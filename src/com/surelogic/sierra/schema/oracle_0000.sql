
CREATE TABLE SIERRA_USER (
  ID         NUMBER       NOT NULL  PRIMARY KEY, 
  USER_NAME  VARCHAR(255) UNIQUE NOT NULL
)
<<>>

CREATE SEQUENCE SIERRA_USER_SEQ
START WITH 1
INCREMENT BY 1
NOMAXVALUE
<<>>

CREATE TRIGGER SIERRA_USER_INC
BEFORE INSERT ON SIERRA_USER FOR EACH ROW
BEGIN
  SELECT SIERRA_USER_SEQ.NEXTVAL
  INTO :NEW.ID
  FROM DUAL;
END;

<<>>
CREATE TABLE TOOL (
  ID       NUMBER       NOT NULL  PRIMARY KEY,
  NAME     VARCHAR(255) NOT NULL,
  VERSION  VARCHAR(255) NOT NULL,
  CONSTRAINT TOOL_CN UNIQUE (NAME,VERSION)
)
<<>>

CREATE SEQUENCE TOOL_SEQ
START WITH 1
INCREMENT BY 1
NOMAXVALUE
<<>>

CREATE TRIGGER TOOL_INC
BEFORE INSERT ON TOOL FOR EACH ROW
BEGIN
  SELECT TOOL_SEQ.NEXTVAL
  INTO :NEW.ID
  FROM DUAL;
END;
<<>>
CREATE TABLE PROJECT (
  ID                 NUMBER       NOT NULL  PRIMARY KEY, 
  NAME               VARCHAR(255) UNIQUE NOT NULL,
  SERVER_UUID        CHAR(36),
  SETTINGS_REVISION  NUMBER       DEFAULT 0
)
<<>>

CREATE SEQUENCE PROJECT_SEQ
START WITH 1
INCREMENT BY 1
NOMAXVALUE
<<>>

CREATE TRIGGER PROJECT_INC
BEFORE INSERT ON PROJECT FOR EACH ROW
BEGIN
  SELECT PROJECT_SEQ.NEXTVAL
  INTO :NEW.ID
  FROM DUAL;
END;
<<>>
CREATE TABLE SCAN (
  ID              NUMBER          NOT NULL  PRIMARY KEY, 
  USER_ID         NUMBER          CONSTRAINT SCAN_SPSUSER_FK REFERENCES SIERRA_USER(ID),
  PROJECT_ID      NUMBER          NOT NULL CONSTRAINT SCAN_PROJECT_FK REFERENCES PROJECT(ID),
  UUID            CHAR(36)        UNIQUE NOT NULL,
  JAVA_VERSION    VARCHAR(2000),
  JAVA_VENDOR     VARCHAR(2000),
  SCAN_DATE_TIME  TIMESTAMP       NOT NULL,
  STATUS          VARCHAR(10)     NOT NULL CONSTRAINT SCAN_STATUS_CN CHECK (STATUS IN ('LOADING', 'FINISHED'))
)
<<>>

CREATE SEQUENCE SCAN_SEQ
START WITH 1
INCREMENT BY 1
NOMAXVALUE
<<>>

CREATE TRIGGER SCAN_INC
BEFORE INSERT ON SCAN FOR EACH ROW
BEGIN
  SELECT SCAN_SEQ.NEXTVAL
  INTO :NEW.ID
  FROM DUAL;
END;
<<>>
CREATE TABLE SCAN_ERROR (
  ID       NUMBER         NOT NULL  PRIMARY KEY, 
  SCAN_ID  NUMBER         NOT NULL CONSTRAINT ERROR_SCAN_FK REFERENCES SCAN(ID) ON DELETE CASCADE,
  TOOL_ID  NUMBER         NOT NULL CONSTRAINT ERROR_TOOL_FK REFERENCES TOOL(ID),
  MESSAGE  VARCHAR(2000) NOT NULL
)
<<>>

CREATE SEQUENCE SCAN_ERROR_SEQ
START WITH 1
INCREMENT BY 1
NOMAXVALUE
<<>>

CREATE TRIGGER SCAN_ERROR_INC
BEFORE INSERT ON SCAN_ERROR FOR EACH ROW
BEGIN
  SELECT SCAN_ERROR_SEQ.NEXTVAL
  INTO :NEW.ID
  FROM DUAL;
END;
<<>>
CREATE TABLE FINDING (
  ID                    NUMBER    NOT NULL  PRIMARY KEY,
  PROJECT_ID            NUMBER    NOT NULL CONSTRAINT FINDING_PROJECT_FK REFERENCES PROJECT (ID),
  OBSOLETED_BY_ID       NUMBER    CONSTRAINT FINDING_OBSOLETED_FINDING_FK REFERENCES FINDING (ID),
  UUID                  CHAR(36),
  IS_READ               CHAR(1)   DEFAULT 'N' CONSTRAINT FINDING_READ_CN CHECK (IS_READ IN ('Y','N')),
  LAST_CHANGED          TIMESTAMP,
  IMPORTANCE            INTEGER,
  SUMMARY               VARCHAR(2000),
  OBSOLETED_BY_REVISION NUMBER
)
<<>>

CREATE SEQUENCE FINDING_SEQ
START WITH 1
INCREMENT BY 1
NOMAXVALUE
<<>>

CREATE TRIGGER FINDING_INC
BEFORE INSERT ON FINDING FOR EACH ROW
BEGIN
  SELECT FINDING_SEQ.NEXTVAL
  INTO :NEW.ID
  FROM DUAL;
END;
<<>>
CREATE TABLE SIERRA_AUDIT (
  ID          NUMBER          NOT NULL  PRIMARY KEY, 
  FINDING_ID  NUMBER          NOT NULL CONSTRAINT AUDIT_FINDING_FK REFERENCES FINDING (ID) ON DELETE CASCADE,
  EVENT       VARCHAR(10)     NOT NULL CONSTRAINT EVENT_CN CHECK (EVENT IN ('COMMENT','IMPORTANCE','READ','SUMMARY')),
  USER_ID     NUMBER          CONSTRAINT AUDIT_SPSUSER_FK REFERENCES SIERRA_USER (ID),
  DATE_TIME   TIMESTAMP       NOT NULL,
  VALUE       VARCHAR(2000),
  REVISION    NUMBER
)
<<>>

CREATE SEQUENCE AUDIT_SEQ
START WITH 1
INCREMENT BY 1
NOMAXVALUE
<<>>

CREATE TRIGGER AUDIT_INC
BEFORE INSERT ON SIERRA_AUDIT FOR EACH ROW
BEGIN
  SELECT AUDIT_SEQ.NEXTVAL
  INTO :NEW.ID
  FROM DUAL;
END;
<<>>
CREATE INDEX AUDIT_EVENT_INDEX ON SIERRA_AUDIT(EVENT)
<<>>

CREATE TABLE ARTIFACT_TYPE (
  ID                    NUMBER        NOT NULL  PRIMARY KEY,
  TOOL_ID               NUMBER        NOT NULL CONSTRAINT ARTIFACT_TYPE_TOOL_FK REFERENCES TOOL (ID),
  MNEMONIC              VARCHAR(255)  NOT NULL,
  MNEMONIC_DISPLAY      VARCHAR(255)  NOT NULL,
  CATEGORY              VARCHAR(2000),
  LINK                  VARCHAR(2000),
  INFO                  VARCHAR(2000),
  CONSTRAINT ARTIFACT_TYPE_CN UNIQUE (TOOL_ID, MNEMONIC)
)
<<>>

CREATE SEQUENCE ARTIFACT_TYPE_SEQ
START WITH 1
INCREMENT BY 1
NOMAXVALUE
<<>>

CREATE TRIGGER ARTIFACT_TYPE_INC
BEFORE INSERT ON ARTIFACT_TYPE FOR EACH ROW
BEGIN
  SELECT ARTIFACT_TYPE_SEQ.NEXTVAL
  INTO :NEW.ID
  FROM DUAL;
END;
<<>>
CREATE TABLE COMPILATION_UNIT (
  ID            NUMBER         NOT NULL  PRIMARY KEY,
  PACKAGE_NAME  VARCHAR(2000) NOT NULL,
  CLASS_NAME    VARCHAR(2000) NOT NULL,
  CONSTRAINT COMPILATION_UNIT_CN UNIQUE (PACKAGE_NAME, CLASS_NAME)
)
<<>>

CREATE SEQUENCE COMPILATION_UNIT_SEQ
START WITH 1
INCREMENT BY 1
NOMAXVALUE
<<>>

CREATE TRIGGER COMPILATION_UNIT_INC
BEFORE INSERT ON COMPILATION_UNIT FOR EACH ROW
BEGIN
  SELECT COMPILATION_UNIT_SEQ.NEXTVAL
  INTO :NEW.ID
  FROM DUAL;
END;
<<>>
CREATE TABLE SOURCE_LOCATION (
  ID                   NUMBER         NOT NULL  PRIMARY KEY,
  COMPILATION_UNIT_ID  NUMBER         NOT NULL CONSTRAINT SL_CU_FK REFERENCES COMPILATION_UNIT (ID),
  HASH                 NUMBER,
  LINE_OF_CODE         INTEGER            NOT NULL, -- no value represented by 0 instead of null
  END_LINE_OF_CODE     INTEGER            NOT NULL, -- no value represented by 0 instead of null
  LOCATION_TYPE        VARCHAR(6)     CONSTRAINT FIELD_TYPE_CN CHECK (LOCATION_TYPE IN ('METHOD', 'CLASS', 'FIELD')),
  IDENTIFIER           VARCHAR(2000)
)
<<>>
CREATE INDEX SOURCE_LOCATION_HASH_INDEX ON SOURCE_LOCATION(HASH)
<<>>

CREATE SEQUENCE SOURCE_LOCATION_SEQ
START WITH 1
INCREMENT BY 1
NOMAXVALUE
<<>>

CREATE TRIGGER SOURCE_LOCATION_INC
BEFORE INSERT ON SOURCE_LOCATION FOR EACH ROW
BEGIN
  SELECT SOURCE_LOCATION_SEQ.NEXTVAL
  INTO :NEW.ID
  FROM DUAL;
END;
<<>>
CREATE TABLE METRIC_CU (
  SCAN_ID              NUMBER NOT NULL CONSTRAINT METRIC_CU_SCAN_FK REFERENCES SCAN (ID) ON DELETE CASCADE,
  COMPILATION_UNIT_ID  NUMBER NOT NULL CONSTRAINT METRIC_CU_COMPILATION_UNIT_FK REFERENCES COMPILATION_UNIT (ID),
  LINES_OF_CODE        INTEGER,
  PRIMARY KEY (SCAN_ID,COMPILATION_UNIT_ID)
)
<<>>

<<>>
CREATE TABLE ARTIFACT (
  ID                          NUMBER         NOT NULL  PRIMARY KEY, 
  SCAN_ID                     NUMBER         NOT NULL CONSTRAINT ARTIFACT_SCAN_FK REFERENCES SCAN (ID) ON DELETE CASCADE,
  ARTIFACT_TYPE_ID            NUMBER         NOT NULL CONSTRAINT A_A_T_FK REFERENCES ARTIFACT_TYPE (ID),
  PRIMARY_SOURCE_LOCATION_ID  NUMBER         NOT NULL CONSTRAINT A_P_S_L_FK REFERENCES SOURCE_LOCATION (ID),
  PRIORITY                    INTEGER,
  SEVERITY                    INTEGER,
  MESSAGE                     VARCHAR(2000)
)
<<>>

CREATE SEQUENCE ARTIFACT_SEQ
START WITH 1
INCREMENT BY 1
NOMAXVALUE
<<>>

CREATE TRIGGER ARTIFACT_INC
BEFORE INSERT ON ARTIFACT FOR EACH ROW
BEGIN
  SELECT ARTIFACT_SEQ.NEXTVAL
  INTO :NEW.ID
  FROM DUAL;
END;
<<>>
CREATE TABLE ARTIFACT_FINDING_RELTN (
  ARTIFACT_ID  NUMBER NOT NULL CONSTRAINT AFR_ARTIFACT_FK REFERENCES ARTIFACT(ID) ON DELETE CASCADE,
  FINDING_ID   NUMBER NOT NULL CONSTRAINT AFR_FINDING_FK REFERENCES FINDING(ID) ON DELETE CASCADE,
  PRIMARY KEY (ARTIFACT_ID, FINDING_ID)
)
<<>>

CREATE TABLE ARTIFACT_SOURCE_LOCATION_RELTN (
  ARTIFACT_ID        NUMBER NOT NULL CONSTRAINT ASLR_ARTIFACT_FK REFERENCES ARTIFACT(ID) ON DELETE CASCADE,
  SOURCE_LOCATION_ID NUMBER NOT NULL CONSTRAINT ASLR_SOURCE_LOCATION_FK REFERENCES SOURCE_LOCATION(ID),
  PRIMARY KEY (ARTIFACT_ID, SOURCE_LOCATION_ID)
)
<<>>

CREATE TABLE FINDING_CATEGORY (
  ID          NUMBER         NOT NULL  PRIMARY KEY,
  UUID        VARCHAR(2000) UNIQUE NOT NULL,
  NAME        VARCHAR(2000) UNIQUE NOT NULL,
  DESCRIPTION VARCHAR(2000)
)
<<>>

CREATE SEQUENCE FINDING_CATEGORY_SEQ
START WITH 1
INCREMENT BY 1
NOMAXVALUE
<<>>

CREATE TRIGGER FINDING_CATEGORY_INC
BEFORE INSERT ON FINDING_CATEGORY FOR EACH ROW
BEGIN
  SELECT FINDING_CATEGORY_SEQ.NEXTVAL
  INTO :NEW.ID
  FROM DUAL;
END;
<<>>
CREATE TABLE FINDING_TYPE (
  ID            NUMBER         NOT NULL  PRIMARY KEY,
  UUID          VARCHAR(2000)  UNIQUE NOT NULL,
  NAME          VARCHAR(2000) NOT NULL,
  SHORT_MESSAGE VARCHAR(2000),
  INFO          VARCHAR(2000)
)
<<>>

CREATE SEQUENCE FINDING_TYPE_SEQ
START WITH 1
INCREMENT BY 1
NOMAXVALUE
<<>>

CREATE TRIGGER FINDING_TYPE_INC
BEFORE INSERT ON FINDING_TYPE FOR EACH ROW
BEGIN
  SELECT FINDING_TYPE_SEQ.NEXTVAL
  INTO :NEW.ID
  FROM DUAL;
END;
<<>>
CREATE TABLE ART_TYPE_FIN_TYPE_RELTN (
  ARTIFACT_TYPE_ID NUMBER UNIQUE NOT NULL CONSTRAINT ATFTR_ARTIFACT_TYPE_FK REFERENCES ARTIFACT_TYPE (ID),
  FINDING_TYPE_ID  NUMBER NOT NULL CONSTRAINT ATFTR_FINDING_TYPE_FK REFERENCES FINDING_TYPE (ID),
  PRIMARY KEY (ARTIFACT_TYPE_ID,FINDING_TYPE_ID)
)
<<>>

CREATE TABLE CATEGORY_FINDING_TYPE_RELTN (
  CATEGORY_ID     NUMBER NOT NULL CONSTRAINT CFTR_CATEGORY_FK REFERENCES FINDING_CATEGORY (ID),
  FINDING_TYPE_ID NUMBER NOT NULL CONSTRAINT CFTR_FINDING_TYPE_FK REFERENCES FINDING_TYPE (ID),
  PRIMARY KEY (CATEGORY_ID,FINDING_TYPE_ID)
)
<<>>

CREATE TABLE PROJECT_FILTERS (
  PROJECT_ID      NUMBER  NOT NULL CONSTRAINT SETTINGS_PROJECT_FK REFERENCES PROJECT (ID) ON DELETE CASCADE,
  FINDING_TYPE_ID NUMBER  NOT NULL CONSTRAINT SETTINGS_FINDING_TYPE_FK REFERENCES FINDING_TYPE (ID),
  DELTA           INTEGER,
  IMPORTANCE      INTEGER,
  FILTERED        CHAR(1) CONSTRAINT SETTINGS_FILTERED_FK CHECK (FILTERED IS NULL OR FILTERED IN ('Y')),
  PRIMARY KEY (PROJECT_ID,FINDING_TYPE_ID)
)
<<>>

CREATE TABLE LOCATION_MATCH (
  PROJECT_ID       NUMBER         NOT NULL CONSTRAINT MATCH_PROJECT_FK REFERENCES PROJECT (ID),
  HASH             NUMBER         NOT NULL,
  PACKAGE_NAME     VARCHAR(2000) NOT NULL,
  CLASS_NAME       VARCHAR(2000) NOT NULL,
  FINDING_TYPE_ID  NUMBER         NOT NULL CONSTRAINT MATCH_FINDING_TYPE_FK REFERENCES FINDING_TYPE (ID),
  FINDING_ID       NUMBER         NOT NULL CONSTRAINT MATCH_FINDING_FK REFERENCES FINDING (ID),
  REVISION         NUMBER,
  PRIMARY KEY (PROJECT_ID,HASH, PACKAGE_NAME, CLASS_NAME, FINDING_TYPE_ID)
)
<<>>
CREATE INDEX MATCH_HASH_INDEX ON LOCATION_MATCH (HASH)
<<>>
