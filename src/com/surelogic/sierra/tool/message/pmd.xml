<?xml version="1.0" encoding="UTF-8"?>
<findingTypes>
	<findingType>
		<id>AvoidNonConstructorMethodsWithClassName</id>
		<artifact tool="PMD"
			mnemonic="AvoidNonConstructorMethodsWithClassName">
		</artifact>
		<shortMessage>
			It is very easy to confuse methods having the same name as
			their class with constructors. It is preferable to choose a
			different name for these methods.
		</shortMessage>
		<info>
			It is very easy to confuse methods having the same name as
			their class with constructors. It is preferable to choose a
			different name for these methods.
		</info>
		<name>Avoid Non-Constructor Methods With Class Name</name>
	</findingType>
	<findingType>
		<id>EmptyCatchBlock</id>
		<artifact tool="PMD" mnemonic="EmptyCatchBlock"></artifact>
		<shortMessage>
			Empty Catch Block finds instances where an exception is
			caught, but nothing is done. In most circumstances, this
			swallows an exception which should either be acted on or
			reported.
		</shortMessage>
		<info>
			Empty Catch Block finds instances where an exception is
			caught, but nothing is done. In most circumstances, this
			swallows an exception which should either be acted on or
			reported.
		</info>
		<name>Empty Catch Block</name>
	</findingType>
	<findingType>
		<id>EmptyIfStmt</id>
		<artifact tool="PMD" mnemonic="EmptyIfStmt"></artifact>
		<shortMessage>
			Empty If Statement finds instances where a condition is
			checked but nothing is done about it.
		</shortMessage>
		<info>
			Empty If Statement finds instances where a condition is
			checked but nothing is done about it.
		</info>
		<name>Empty If Statement</name>
	</findingType>
	<findingType>
		<id>EmptyWhileStmt</id>
		<artifact tool="PMD" mnemonic="EmptyWhileStmt"></artifact>
		<shortMessage>
			Empty While Statement finds all instances where a while
			statement does nothing. If it is a timing loop, then you
			should use Thread.sleep() for it; if it's a while loop that
			does a lot in the exit expression, rewrite it to make it
			clearer.
		</shortMessage>
		<info>
			Empty While Statement finds all instances where a while
			statement does nothing. If it is a timing loop, then you
			should use Thread.sleep() for it; if it's a while loop that
			does a lot in the exit expression, rewrite it to make it
			clearer.
		</info>
		<name>Empty While Statement</name>
	</findingType>
	<findingType>
		<id>EmptyTryBlock</id>
		<artifact tool="PMD" mnemonic="EmptyTryBlock"></artifact>
		<shortMessage>
			Avoid empty try blocks - what's the point?
		</shortMessage>
		<info>Avoid empty try blocks - what's the point?</info>
		<name>Empty Try Block</name>
	</findingType>
	<findingType>
		<id>EmptyFinallyBlock</id>
		<artifact tool="PMD" mnemonic="EmptyFinallyBlock"></artifact>
		<shortMessage>
			Avoid empty finally blocks - these can be deleted.
		</shortMessage>
		<info>Avoid empty finally blocks - these can be deleted.</info>
		<name>Empty Finally Block</name>
	</findingType>
	<findingType>
		<id>EmptySwitchStatements</id>
		<artifact tool="PMD" mnemonic="EmptySwitchStatements">
		</artifact>
		<shortMessage>Avoid empty switch statements.</shortMessage>
		<info>Avoid empty switch statements.</info>
		<name>Empty Switch Statements</name>
	</findingType>
	<findingType>
		<id>JumbledIncrementer</id>
		<artifact tool="PMD" mnemonic="JumbledIncrementer"></artifact>
		<shortMessage>
			Avoid jumbled loop incrementers - it's usually a mistake,
			and it's confusing even if it's what's intended.
		</shortMessage>
		<info>
			Avoid jumbled loop incrementers - it's usually a mistake,
			and it's confusing even if it's what's intended.
		</info>
		<name>Jumbled Incrementer</name>
	</findingType>
	<findingType>
		<id>ForLoopShouldBeWhileLoop</id>
		<artifact tool="PMD" mnemonic="ForLoopShouldBeWhileLoop">
		</artifact>
		<shortMessage>
			Some for loops can be simplified to while loops - this makes
			them more concise.
		</shortMessage>
		<info>
			Some for loops can be simplified to while loops - this makes
			them more concise.
		</info>
		<name>For Loop Should Be While Loop</name>
	</findingType>
	<findingType>
		<id>UnnecessaryConversionTemporary</id>
		<artifact tool="PMD"
			mnemonic="UnnecessaryConversionTemporary">
		</artifact>
		<shortMessage>
			Avoid unnecessary temporaries when converting primitives to
			Strings
		</shortMessage>
		<info>
			Avoid unnecessary temporaries when converting primitives to
			Strings
		</info>
		<name>Unnecessary Conversion Temporary</name>
	</findingType>

	<findingType>
		<id>DoubleCheckedLocking</id>
		<shortMessage>
			Partially created objects can be returned by the Double
			Checked Locking pattern when used in Java. An optimizing JRE
			may assign a reference to the baz variable before it creates
			the object the reference is intended to point to. For more
			details see
			http://www.javaworld.com/javaworld/jw-02-2001/jw-0209-double.html.
		</shortMessage>
		<info>
			Partially created objects can be returned by the Double
			Checked Locking pattern when used in Java. An optimizing JRE
			may assign a reference to the baz variable before it creates
			the object the reference is intended to point to. For more
			details see
			http://www.javaworld.com/javaworld/jw-02-2001/jw-0209-double.html.
		</info>
		<name>Double Checked Locking</name>
	</findingType>
	
	<findingType>
		<id>ReturnFromFinallyBlock</id>
		<artifact tool="PMD" mnemonic="ReturnFromFinallyBlock">
		</artifact>
		<shortMessage>
			Avoid returning from a finally block - this can discard
			exceptions.
		</shortMessage>
		<info>
			Avoid returning from a finally block - this can discard
			exceptions.
		</info>
		<name>Return From Finally Block</name>
	</findingType>

	<findingType>
		<id>UnnecessaryReturn</id>
		<artifact tool="PMD" mnemonic="UnnecessaryReturn"></artifact>
		<shortMessage>Avoid unnecessary return statements</shortMessage>
		<info>Avoid unnecessary return statements</info>
		<name>Unnecessary Return</name>
	</findingType>
	<findingType>
		<id>EmptyStaticInitializer</id>
		<artifact tool="PMD" mnemonic="EmptyStaticInitializer">
		</artifact>
		<shortMessage>
			An empty static initializer was found.
		</shortMessage>
		<info>An empty static initializer was found.</info>
		<name>Empty Static Initializer</name>
	</findingType>
	<findingType>
		<id>UnconditionalIfStatement</id>
		<artifact tool="PMD" mnemonic="UnconditionalIfStatement">
		</artifact>
		<shortMessage>
			Do not use &quot;if&quot; statements that are always true or
			always false.
		</shortMessage>
		<info>
			Do not use &quot;if&quot; statements that are always true or
			always false.
		</info>
		<name>Unconditional If Statement</name>
	</findingType>
	<findingType>
		<id>EmptyStatementNotInLoop</id>
		<artifact tool="PMD" mnemonic="EmptyStatementNotInLoop">
		</artifact>
		<shortMessage>
			An empty statement (aka a semicolon by itself) that is not
			used as the sole body of a for loop or while loop is
			probably a bug. It could also be a double semicolon, which
			is useless and should be removed.
		</shortMessage>
		<info>
			An empty statement (aka a semicolon by itself) that is not
			used as the sole body of a for loop or while loop is
			probably a bug. It could also be a double semicolon, which
			is useless and should be removed.
		</info>
		<name>Empty Statement Not In Loop</name>
	</findingType>
	<findingType>
		<id>BooleanInstantiation</id>
		<artifact tool="PMD" mnemonic="BooleanInstantiation"></artifact>
		<shortMessage>
			Avoid instantiating Boolean objects; you can reference
			Boolean.TRUE, Boolean.FALSE, or call Boolean.valueOf()
			instead.
		</shortMessage>
		<info>
			Avoid instantiating Boolean objects; you can reference
			Boolean.TRUE, Boolean.FALSE, or call Boolean.valueOf()
			instead.
		</info>
		<name>Boolean Instantiation</name>
	</findingType>
	<findingType>
		<id>UnnecessaryFinalModifier</id>
		<artifact tool="PMD" mnemonic="UnnecessaryFinalModifier">
		</artifact>
		<shortMessage>
			When a class has the final modifier, all the methods are
			automatically final.
		</shortMessage>
		<info>
			When a class has the final modifier, all the methods are
			automatically final.
		</info>
		<name>Unnecessary Final Modifier</name>
	</findingType>
	<findingType>
		<id>CollapsibleIfStatements</id>
		<artifact tool="PMD" mnemonic="CollapsibleIfStatements">
		</artifact>
		<shortMessage>
			Sometimes two 'if' statements can be consolidated by
			separating their conditions with a boolean short-circuit
			operator.
		</shortMessage>
		<info>
			Sometimes two 'if' statements can be consolidated by
			separating their conditions with a boolean short-circuit
			operator.
		</info>
		<name>Collapsible If Statements</name>
	</findingType>
	<findingType>
		<id>UselessOverridingMethod</id>
		<artifact tool="PMD" mnemonic="UselessOverridingMethod">
		</artifact>
		<shortMessage>
			The overriding method merely calls the same method defined
			in a superclass
		</shortMessage>
		<info>
			The overriding method merely calls the same method defined
			in a superclass
		</info>
		<name>Useless Overriding Method</name>
	</findingType>
	<findingType>
		<id>ClassCastExceptionWithToArray</id>
		<artifact tool="PMD" mnemonic="ClassCastExceptionWithToArray">
		</artifact>
		<shortMessage>
			if you need to get an array of a class from your Collection,
			you should pass an array of the desidered class as the
			parameter of the toArray method. Otherwise you will get a
			ClassCastException.
		</shortMessage>
		<info>
			if you need to get an array of a class from your Collection,
			you should pass an array of the desidered class as the
			parameter of the toArray method. Otherwise you will get a
			ClassCastException.
		</info>
		<name>Class Cast Exception With To Array</name>
	</findingType>
	<findingType>
		<id>AvoidDecimalLiteralsInBigDecimalConstructor</id>
		<artifact tool="PMD"
			mnemonic="AvoidDecimalLiteralsInBigDecimalConstructor">
		</artifact>
		<shortMessage>
			One might assume that &quot;new BigDecimal(.1)&quot; is
			exactly equal to .1, but it is actually equal to
			.1000000000000000055511151231257827021181583404541015625.
			This is so because .1 cannot be represented exactly as a
			double (or, for that matter, as a binary fraction of any
			finite length). Thus, the long value that is being passed in
			to the constructor is not exactly equal to .1, appearances
			notwithstanding.

			The (String) constructor, on the other hand, is perfectly
			predictable: 'new BigDecimal(&quot;.1&quot;)' is exactly
			equal to .1, as one would expect. Therefore, it is generally
			recommended that the (String) constructor be used in
			preference to this one.
		</shortMessage>
		<info>
			One might assume that &quot;new BigDecimal(.1)&quot; is
			exactly equal to .1, but it is actually equal to
			.1000000000000000055511151231257827021181583404541015625.
			This is so because .1 cannot be represented exactly as a
			double (or, for that matter, as a binary fraction of any
			finite length). Thus, the long value that is being passed in
			to the constructor is not exactly equal to .1, appearances
			notwithstanding.

			The (String) constructor, on the other hand, is perfectly
			predictable: 'new BigDecimal(&quot;.1&quot;)' is exactly
			equal to .1, as one would expect. Therefore, it is generally
			recommended that the (String) constructor be used in
			preference to this one.
		</info>
		<name>Avoid Decimal Literals In Big Decimal Constructor</name>
	</findingType>
	<findingType>
		<id>UselessOperationOnImmutable</id>
		<artifact tool="PMD" mnemonic="UselessOperationOnImmutable">
		</artifact>
		<shortMessage>
			An operation on an Immutable object (BigDecimal or
			BigInteger) won't change the object itself. The result of
			the operation is a new object. Therefore, ignoring the
			operation result is an error.
		</shortMessage>
		<info>
			An operation on an Immutable object (BigDecimal or
			BigInteger) won't change the object itself. The result of
			the operation is a new object. Therefore, ignoring the
			operation result is an error.
		</info>
		<name>Useless Operation On Immutable</name>
	</findingType>

	<findingType>
		<id>UnusedNullCheckInEquals</id>
		<artifact tool="PMD" mnemonic="UnusedNullCheckInEquals">
		</artifact>
		<shortMessage>
			After checking an object reference for null, you should
			invoke equals() on that object rather than passing it to
			another object's equals() method.
		</shortMessage>
		<info>
			After checking an object reference for null, you should
			invoke equals() on that object rather than passing it to
			another object's equals() method.
		</info>
		<name>Unused Null Check In Equals</name>
	</findingType>
	<findingType>
		<id>AvoidThreadGroup</id>
		<artifact tool="PMD" mnemonic="AvoidThreadGroup"></artifact>
		<shortMessage>
			Avoid using ThreadGroup; although it is intended to be used
			in a threaded environment it contains methods that are not
			thread safe.
		</shortMessage>
		<info>
			Avoid using ThreadGroup; although it is intended to be used
			in a threaded environment it contains methods that are not
			thread safe.
		</info>
		<name>Avoid Thread Group</name>
	</findingType>
	<findingType>
		<id>BrokenNullCheck</id>
		<artifact tool="PMD" mnemonic="BrokenNullCheck"></artifact>
		<shortMessage>
			The null check is broken since it will throw a
			NullPointerException itself. It is likely that you used ||
			instead of &amp;&amp; or vice versa.
		</shortMessage>
		<info>
			The null check is broken since it will throw a
			NullPointerException itself. It is likely that you used ||
			instead of &amp;&amp; or vice versa.
		</info>
		<name>Broken Null Check</name>
	</findingType>
	<findingType>
		<id>BigIntegerInstantiation</id>
		<artifact tool="PMD" mnemonic="BigIntegerInstantiation">
		</artifact>
		<shortMessage>
			Don't create instances of already existing BigInteger
			(BigInteger.ZERO, BigInteger.ONE) and for 1.5 on,
			BigInteger.TEN and BigDecimal (BigDecimal.ZERO,
			BigDecimal.ONE, BigDecimal.TEN)
		</shortMessage>
		<info>
			Don't create instances of already existing BigInteger
			(BigInteger.ZERO, BigInteger.ONE) and for 1.5 on,
			BigInteger.TEN and BigDecimal (BigDecimal.ZERO,
			BigDecimal.ONE, BigDecimal.TEN)
		</info>
		<name>Big Integer Instantiation</name>
	</findingType>
	<findingType>
		<id>AvoidUsingOctalValues</id>
		<artifact tool="PMD" mnemonic="AvoidUsingOctalValues">
		</artifact>
		<shortMessage>
			Integer literals should not start with zero. Zero means that
			the rest of literal will be interpreted as an octal value.
		</shortMessage>
		<info>
			Integer literals should not start with zero. Zero means that
			the rest of literal will be interpreted as an octal value.
		</info>
		<name>Avoid Using Octal Values</name>
	</findingType>
	<findingType>
		<id>IfStmtsMustUseBraces</id>
		<artifact tool="PMD" mnemonic="IfStmtsMustUseBraces"></artifact>
		<shortMessage>
			Avoid using if statements without using curly braces.
		</shortMessage>
		<info>
			Avoid using if statements without using curly braces.
		</info>
		<name>If Statements Must Use Braces</name>
	</findingType>
	<findingType>
		<id>WhileLoopsMustUseBraces</id>
		<artifact tool="PMD" mnemonic="WhileLoopsMustUseBraces">
		</artifact>
		<shortMessage>
			Avoid using 'while' statements without using curly braces.
		</shortMessage>
		<info>
			Avoid using 'while' statements without using curly braces.
		</info>
		<name>While Loops Must Use Braces</name>
	</findingType>
	<findingType>
		<id>IfElseStmtsMustUseBraces</id>
		<artifact tool="PMD" mnemonic="IfElseStmtsMustUseBraces">
		</artifact>
		<shortMessage>
			Avoid using if..else statements without using curly braces.
		</shortMessage>
		<info>
			Avoid using if..else statements without using curly braces.
		</info>
		<name>If Else Statements Must Use Braces</name>
	</findingType>
	<findingType>
		<id>ForLoopsMustUseBraces</id>
		<artifact tool="PMD" mnemonic="ForLoopsMustUseBraces">
		</artifact>
		<shortMessage>
			Avoid using 'for' statements without using curly braces.
		</shortMessage>
		<info>
			Avoid using 'for' statements without using curly braces.
		</info>
		<name>For Loops Must Use Braces</name>
	</findingType>

	<findingType>
		<id>CloneThrowsCloneNotSupportedException</id>
		<artifact tool="PMD"
			mnemonic="CloneThrowsCloneNotSupportedException">
		</artifact>
		<shortMessage>
			The method clone() should throw a
			CloneNotSupportedException.
		</shortMessage>
		<info>
			The method clone() should throw a
			CloneNotSupportedException.
		</info>
		<name>Clone Throws Clone Not Supported Exception</name>
	</findingType>

	<findingType>
		<id>NPathComplexity</id>
		<artifact tool="PMD" mnemonic="NPathComplexity"></artifact>
		<shortMessage>
			The NPath complexity of a method is the number of acyclic
			execution paths through that method. A threshold of 200 is
			generally considered the point where measures should be
			taken to reduce complexity.
		</shortMessage>
		<info>
			The NPath complexity of a method is the number of acyclic
			execution paths through that method. A threshold of 200 is
			generally considered the point where measures should be
			taken to reduce complexity.
		</info>
		<name>NPath Complexity</name>
	</findingType>
	<findingType>
		<id>ExcessiveMethodLength</id>
		<artifact tool="PMD" mnemonic="ExcessiveMethodLength">
		</artifact>
		<shortMessage>
			Violations of this rule usually indicate that the method is
			doing too much. Try to reduce the method size by creating
			helper methods and removing any copy/pasted code.
		</shortMessage>
		<info>
			Violations of this rule usually indicate that the method is
			doing too much. Try to reduce the method size by creating
			helper methods and removing any copy/pasted code.
		</info>
		<name>Excessive Method Length</name>
	</findingType>
	<findingType>
		<id>ExcessiveParameterList</id>
		<artifact tool="PMD" mnemonic="ExcessiveParameterList">
		</artifact>
		<shortMessage>
			Long parameter lists can indicate that a new object should
			be created to wrap the numerous parameters. Basically, try
			to group the parameters together.
		</shortMessage>
		<info>
			Long parameter lists can indicate that a new object should
			be created to wrap the numerous parameters. Basically, try
			to group the parameters together.
		</info>
		<name>Excessive Parameter List</name>
	</findingType>
	<findingType>
		<id>ExcessiveClassLength</id>
		<artifact tool="PMD" mnemonic="ExcessiveClassLength"></artifact>
		<shortMessage>
			Long Class files are indications that the class may be
			trying to do too much. Try to break it down, and reduce the
			size to something manageable.
		</shortMessage>
		<info>
			Long Class files are indications that the class may be
			trying to do too much. Try to break it down, and reduce the
			size to something manageable.
		</info>
		<name>Excessive Class Length</name>
	</findingType>
	<findingType>
		<id>CyclomaticComplexity</id>
		<artifact tool="PMD" mnemonic="CyclomaticComplexity"></artifact>
		<shortMessage>
			Complexity is determined by the number of decision points in
			a method plus one for the method entry. The decision points
			are 'if', 'while', 'for', and 'case labels'. Generally, 1-4
			is low complexity, 5-7 indicates moderate complexity, 8-10
			is high complexity, and 11+ is very high complexity.
		</shortMessage>
		<info>
			Complexity is determined by the number of decision points in
			a method plus one for the method entry. The decision points
			are 'if', 'while', 'for', and 'case labels'. Generally, 1-4
			is low complexity, 5-7 indicates moderate complexity, 8-10
			is high complexity, and 11+ is very high complexity.
		</info>
		<name>Cyclomatic Complexity</name>
	</findingType>
	<findingType>
		<id>ExcessivePublicCount</id>
		<artifact tool="PMD" mnemonic="ExcessivePublicCount"></artifact>
		<shortMessage>
			A large number of public methods and attributes declared in
			a class can indicate the class may need to be broken up as
			increased effort will be required to thoroughly test it.
		</shortMessage>
		<info>
			A large number of public methods and attributes declared in
			a class can indicate the class may need to be broken up as
			increased effort will be required to thoroughly test it.
		</info>
		<name>Excessive Public Count</name>
	</findingType>
	<findingType>
		<id>TooManyFields</id>
		<artifact tool="PMD" mnemonic="TooManyFields"></artifact>
		<shortMessage>
			Classes that have too many fields could be redesigned to
			have fewer fields, possibly through some nested object
			grouping of some of the information. For example, a class
			with city/state/zip fields could instead have one Address
			field.
		</shortMessage>
		<info>
			Classes that have too many fields could be redesigned to
			have fewer fields, possibly through some nested object
			grouping of some of the information. For example, a class
			with city/state/zip fields could instead have one Address
			field.
		</info>
		<name>Too Many Fields</name>
	</findingType>
	<findingType>
		<id>NcssMethodCount</id>
		<artifact tool="PMD" mnemonic="NcssMethodCount"></artifact>
		<shortMessage>
			This rule uses the NCSS (Non Commenting Source Statements)
			algorithm to determine the number of lines of code for a
			given method. NCSS ignores comments, and counts actual
			statements. Using this algorithm, lines of code that are
			split are counted as one.
		</shortMessage>
		<info>
			This rule uses the NCSS (Non Commenting Source Statements)
			algorithm to determine the number of lines of code for a
			given method. NCSS ignores comments, and counts actual
			statements. Using this algorithm, lines of code that are
			split are counted as one.
		</info>
		<name>NCSS Method Count</name>
	</findingType>
	<findingType>
		<id>NcssTypeCount</id>
		<artifact tool="PMD" mnemonic="NcssTypeCount"></artifact>
		<shortMessage>
			This rule uses the NCSS (Non Commenting Source Statements)
			algorithm to determine the number of lines of code for a
			given type. NCSS ignores comments, and counts actual
			statements. Using this algorithm, lines of code that are
			split are counted as one.
		</shortMessage>
		<info>
			This rule uses the NCSS (Non Commenting Source Statements)
			algorithm to determine the number of lines of code for a
			given type. NCSS ignores comments, and counts actual
			statements. Using this algorithm, lines of code that are
			split are counted as one.
		</info>
		<name>NCSS Type Count</name>
	</findingType>
	<findingType>
		<id>NcssConstructorCount</id>
		<artifact tool="PMD" mnemonic="NcssConstructorCount"></artifact>
		<shortMessage>
			This rule uses the NCSS (Non Commenting Source Statements)
			algorithm to determine the number of lines of code for a
			given constructor. NCSS ignores comments, and counts actual
			statements. Using this algorithm, lines of code that are
			split are counted as one.
		</shortMessage>
		<info>
			This rule uses the NCSS (Non Commenting Source Statements)
			algorithm to determine the number of lines of code for a
			given constructor. NCSS ignores comments, and counts actual
			statements. Using this algorithm, lines of code that are
			split are counted as one.
		</info>
		<name>NCSS Constructor Count</name>
	</findingType>
	<findingType>
		<id>UnnecessaryConstructor</id>
		<artifact tool="PMD" mnemonic="UnnecessaryConstructor">
		</artifact>
		<shortMessage>
			This rule detects when a constructor is not necessary; i.e.,
			when there's only one constructor, it's public, has an empty
			body, and takes no arguments.
		</shortMessage>
		<info>
			This rule detects when a constructor is not necessary; i.e.,
			when there's only one constructor, it's public, has an empty
			body, and takes no arguments.
		</info>
		<name>Unnecessary Constructor</name>
	</findingType>
	<findingType>
		<id>NullAssignment</id>
		<artifact tool="PMD" mnemonic="NullAssignment"></artifact>
		<shortMessage>
			Assigning a &quot;null&quot; to a variable (outside of its
			declaration) is usually bad form. Some times, the assignment
			is an indication that the programmer doesn't completely
			understand what is going on in the code. NOTE: This sort of
			assignment may in rare cases be useful to encourage garbage
			collection. If that's what you're using it for, by all
			means, disregard this rule :-)
		</shortMessage>
		<info>
			Assigning a &quot;null&quot; to a variable (outside of its
			declaration) is usually bad form. Some times, the assignment
			is an indication that the programmer doesn't completely
			understand what is going on in the code. NOTE: This sort of
			assignment may in rare cases be useful to encourage garbage
			collection. If that's what you're using it for, by all
			means, disregard this rule :-)
		</info>
		<name>Null Assignment</name>
	</findingType>
	<findingType>
		<id>OnlyOneReturn</id>
		<artifact tool="PMD" mnemonic="OnlyOneReturn"></artifact>
		<shortMessage>
			A method should have only one exit point, and that should be
			the last statement in the method.
		</shortMessage>
		<info>
			A method should have only one exit point, and that should be
			the last statement in the method.
		</info>
		<name>Only One Return</name>
	</findingType>
	<findingType>
		<id>UnusedModifier</id>
		<artifact tool="PMD" mnemonic="UnusedModifier"></artifact>
		<shortMessage>
			Fields in interfaces are automatically public static final,
			and methods are public abstract. Classes or interfaces
			nested in an interface are automatically public and static
			(all nested interfaces are automatically static). For
			historical reasons, modifiers which are implied by the
			context are accepted by the compiler, but are superfluous.
		</shortMessage>
		<info>
			Fields in interfaces are automatically public static final,
			and methods are public abstract. Classes or interfaces
			nested in an interface are automatically public and static
			(all nested interfaces are automatically static). For
			historical reasons, modifiers which are implied by the
			context are accepted by the compiler, but are superfluous.
		</info>
		<name>Unused Modifier</name>
	</findingType>
	<findingType>
		<id>AssignmentInOperand</id>
		<artifact tool="PMD" mnemonic="AssignmentInOperand"></artifact>
		<shortMessage>
			Avoid assignments in operands; this can make code more
			complicated and harder to read.
		</shortMessage>
		<info>
			Avoid assignments in operands; this can make code more
			complicated and harder to read.
		</info>
		<name>Assignment In Operand</name>
	</findingType>
	<findingType>
		<id>AtLeastOneConstructor</id>
		<artifact tool="PMD" mnemonic="AtLeastOneConstructor">
		</artifact>
		<shortMessage>
			Each class should declare at least one constructor.
		</shortMessage>
		<info>Each class should declare at least one constructor.</info>
		<name>At Least One Constructor</name>
	</findingType>
	<findingType>
		<id>DontImportSun</id>
		<artifact tool="PMD" mnemonic="DontImportSun"></artifact>
		<shortMessage>
			Avoid importing anything from the 'sun.*' packages. These
			packages are not portable and are likely to change.
		</shortMessage>
		<info>
			Avoid importing anything from the 'sun.*' packages. These
			packages are not portable and are likely to change.
		</info>
		<name>Don't Import sun.* Packages</name>
	</findingType>
	<findingType>
		<id>SuspiciousOctalEscape</id>
		<artifact tool="PMD" mnemonic="SuspiciousOctalEscape">
		</artifact>
		<shortMessage>
			A suspicious octal escape sequence was found inside a String
			literal. The Java language specification (section 3.10.6)
			says an octal escape sequence inside a literal String shall
			consist of a backslash followed by:

			OctalDigit | OctalDigit OctalDigit | ZeroToThree OctalDigit
			OctalDigit

			Any octal escape sequence followed by non-octal digits can
			be confusing, e.g. &quot;\038&quot; is interpreted as the
			octal escape sequence &quot;\03&quot; followed by the
			literal character &quot;8&quot;.
		</shortMessage>
		<info>
			A suspicious octal escape sequence was found inside a String
			literal. The Java language specification (section 3.10.6)
			says an octal escape sequence inside a literal String shall
			consist of a backslash followed by:

			OctalDigit | OctalDigit OctalDigit | ZeroToThree OctalDigit
			OctalDigit

			Any octal escape sequence followed by non-octal digits can
			be confusing, e.g. &quot;\038&quot; is interpreted as the
			octal escape sequence &quot;\03&quot; followed by the
			literal character &quot;8&quot;.
		</info>
		<name>Suspicious Octal Escape</name>
	</findingType>
	<findingType>
		<id>CallSuperInConstructor</id>
		<artifact tool="PMD" mnemonic="CallSuperInConstructor">
		</artifact>
		<shortMessage>
			It is a good practice to call super() in a constructor. If
			super() is not called but another constructor (such as an
			overloaded constructor) is called, this rule will not report
			it.
		</shortMessage>
		<info>
			It is a good practice to call super() in a constructor. If
			super() is not called but another constructor (such as an
			overloaded constructor) is called, this rule will not report
			it.
		</info>
		<name>Call Super In Constructor</name>
	</findingType>
	<findingType>
		<id>UnnecessaryParentheses</id>
		<artifact tool="PMD" mnemonic="UnnecessaryParentheses">
		</artifact>
		<shortMessage>
			Sometimes expressions are wrapped in unnecessary
			parentheses, making them look like a function call.
		</shortMessage>
		<info>
			Sometimes expressions are wrapped in unnecessary
			parentheses, making them look like a function call.
		</info>
		<name>Unnecessary Parentheses</name>
	</findingType>
	<findingType>
		<id>SingularField</id>
		<artifact tool="PMD" mnemonic="SingularField"></artifact>
		<shortMessage>
			A field that's only used by one method could perhaps be
			replaced by a local variable.
		</shortMessage>
		<info>
			A field that's only used by one method could perhaps be
			replaced by a local variable.
		</info>
		<name>Singular Field</name>
	</findingType>
	<findingType>
		<id>DefaultPackage</id>
		<artifact tool="PMD" mnemonic="DefaultPackage"></artifact>
		<shortMessage>
			Use explicit scoping instead of the default package private
			level.
		</shortMessage>
		<info>
			Use explicit scoping instead of the default package private
			level.
		</info>
		<name>Default Package</name>
	</findingType>
	<findingType>
		<id>BooleanInversion</id>
		<artifact tool="PMD" mnemonic="BooleanInversion"></artifact>
		<shortMessage>
			3



			//ClassOrInterfaceDeclaration[@Interface='false']
			/ClassOrInterfaceBody /ClassOrInterfaceBodyDeclaration [
			FieldDeclaration[@PackagePrivate='true'] or
			MethodDeclaration[@PackagePrivate='true'] ]







			Use bitwise inversion to invert boolean values - it's the
			fastest way to do this. See
			http://www.javaspecialists.co.za/archive/newsletter.do?issue=042&amp;locale=en_US
			for specific details
		</shortMessage>
		<info>
			3



			//ClassOrInterfaceDeclaration[@Interface='false']
			/ClassOrInterfaceBody /ClassOrInterfaceBodyDeclaration [
			FieldDeclaration[@PackagePrivate='true'] or
			MethodDeclaration[@PackagePrivate='true'] ]







			Use bitwise inversion to invert boolean values - it's the
			fastest way to do this. See
			http://www.javaspecialists.co.za/archive/newsletter.do?issue=042&amp;locale=en_US
			for specific details
		</info>
		<name>Boolean Inversion</name>
	</findingType>
	<findingType>
		<id>DataflowAnomalyAnalysis</id>
		<artifact tool="PMD" mnemonic="DataflowAnomalyAnalysis">
		</artifact>
		<shortMessage>
			The dataflow analysis tracks local definitions,
			undefinitions and references to variables on different paths
			on the data flow. From those informations there can be found
			various problems.

			1. UR - Anomaly: There is a reference to a variable that was
			not defined before. This is a bug and leads to an error. 2.
			DU - Anomaly: A recently defined variable is undefined.
			These anomalies may appear in normal source text. 3. DD -
			Anomaly: A recently defined variable is redefined. This is
			ominous but don't have to be a bug.
		</shortMessage>
		<info>
			The dataflow analysis tracks local definitions,
			undefinitions and references to variables on different paths
			on the data flow. From those informations there can be found
			various problems.

			1. UR - Anomaly: There is a reference to a variable that was
			not defined before. This is a bug and leads to an error. 2.
			DU - Anomaly: A recently defined variable is undefined.
			These anomalies may appear in normal source text. 3. DD -
			Anomaly: A recently defined variable is redefined. This is
			ominous but don't have to be a bug.
		</info>
		<name>Dataflow Anomaly Analysis</name>
	</findingType>
	<findingType>
		<id>CouplingBetweenObjects</id>
		<artifact tool="PMD" mnemonic="CouplingBetweenObjects">
		</artifact>
		<shortMessage>
			This rule counts unique attributes, local variables and
			return types within an object. A number higher than
			specified threshold can indicate a high degree of coupling.
		</shortMessage>
		<info>
			This rule counts unique attributes, local variables and
			return types within an object. A number higher than
			specified threshold can indicate a high degree of coupling.
		</info>
		<name>Coupling Between Objects</name>
	</findingType>
	<findingType>
		<id>ExcessiveImports</id>
		<artifact tool="PMD" mnemonic="ExcessiveImports"></artifact>
		<shortMessage>
			A high number of imports can indicate a high degree of
			coupling within an object. Rule counts the number of unique
			imports and reports a violation if the count is above the
			user defined threshold.
		</shortMessage>
		<info>
			A high number of imports can indicate a high degree of
			coupling within an object. Rule counts the number of unique
			imports and reports a violation if the count is above the
			user defined threshold.
		</info>
		<name>Excessive Imports</name>
	</findingType>
	<findingType>
		<id>LooseCoupling</id>
		<artifact tool="PMD" mnemonic="LooseCoupling"></artifact>
		<shortMessage>
			Avoid using implementation types (i.e., HashSet); use the
			interface (i.e, Set) instead
		</shortMessage>
		<info>
			Avoid using implementation types (i.e., HashSet); use the
			interface (i.e, Set) instead
		</info>
		<name>Loose Coupling</name>
	</findingType>
	<findingType>
		<id>UseSingleton</id>
		<artifact tool="PMD" mnemonic="UseSingleton"></artifact>
		<shortMessage>
			If you have a class that has nothing but static methods,
			consider making it a Singleton. Note that this doesn't apply
			to abstract classes, since their subclasses may well include
			non-static methods. Also, if you want this class to be a
			Singleton, remember to add a private constructor to prevent
			instantiation.
		</shortMessage>
		<info>
			If you have a class that has nothing but static methods,
			consider making it a Singleton. Note that this doesn't apply
			to abstract classes, since their subclasses may well include
			non-static methods. Also, if you want this class to be a
			Singleton, remember to add a private constructor to prevent
			instantiation.
		</info>
		<name>Use Singleton</name>
	</findingType>
	<findingType>
		<id>SimplifyBooleanReturns</id>
		<artifact tool="PMD" mnemonic="SimplifyBooleanReturns">
		</artifact>
		<shortMessage>
			Avoid unnecessary if..then..else statements when returning a
			boolean.
		</shortMessage>
		<info>
			Avoid unnecessary if..then..else statements when returning a
			boolean.
		</info>
		<name>Simplify Boolean Returns</name>
	</findingType>
	<findingType>
		<id>SimplifyBooleanExpressions</id>
		<artifact tool="PMD" mnemonic="SimplifyBooleanExpressions">
		</artifact>
		<shortMessage>
			Avoid unnecessary comparisons in boolean expressions - this
			complicates simple code.
		</shortMessage>
		<info>
			Avoid unnecessary comparisons in boolean expressions - this
			complicates simple code.
		</info>
		<name>Simplify Boolean Expressions</name>
	</findingType>
	<findingType>
		<id>SwitchStmtsShouldHaveDefault</id>
		<artifact tool="PMD" mnemonic="SwitchStmtsShouldHaveDefault">
		</artifact>
		<shortMessage>
			Switch statements should have a default label.
		</shortMessage>
		<info>Switch statements should have a default label.</info>
		<name>Switch Statements Should Have Default</name>
	</findingType>
	<findingType>
		<id>AvoidDeeplyNestedIfStmts</id>
		<artifact tool="PMD" mnemonic="AvoidDeeplyNestedIfStmts">
		</artifact>
		<shortMessage>
			Deeply nested if..then statements are hard to read.
		</shortMessage>
		<info>Deeply nested if..then statements are hard to read.</info>
		<name>Avoid Deeply Nested If Statements</name>
	</findingType>
	<findingType>
		<id>AvoidReassigningParameters</id>
		<artifact tool="PMD" mnemonic="AvoidReassigningParameters">
		</artifact>
		<shortMessage>
			Reassigning values to parameters is a questionable practice.
			Use a temporary local variable instead.
		</shortMessage>
		<info>
			Reassigning values to parameters is a questionable practice.
			Use a temporary local variable instead.
		</info>
		<name>Avoid Reassigning Parameters</name>
	</findingType>
	<findingType>
		<id>SwitchDensity</id>
		<artifact tool="PMD" mnemonic="SwitchDensity"></artifact>
		<shortMessage>
			A high ratio of statements to labels in a switch statement
			implies that the switch statement is doing too much work.
			Consider moving the statements into new methods, or creating
			subclasses based on the switch variable.
		</shortMessage>
		<info>
			A high ratio of statements to labels in a switch statement
			implies that the switch statement is doing too much work.
			Consider moving the statements into new methods, or creating
			subclasses based on the switch variable.
		</info>
		<name>Switch Density</name>
	</findingType>
	<findingType>
		<id>ConstructorCallsOverridableMethod</id>
		<artifact tool="PMD"
			mnemonic="ConstructorCallsOverridableMethod">
		</artifact>
		<shortMessage>
			Calling overridable methods during construction poses a risk
			of invoking methods on an incompletely constructed object
			and can be difficult to discern. It may leave the sub-class
			unable to construct its superclass or forced to replicate
			the construction process completely within itself, losing
			the ability to call super(). If the default constructor
			contains a call to an overridable method, the subclass may
			be completely uninstantiable. Note that this includes method
			calls throughout the control flow graph - i.e., if a
			constructor Foo() calls a private method bar() that calls a
			public method buz(), this denotes a problem.
		</shortMessage>
		<info>
			Calling overridable methods during construction poses a risk
			of invoking methods on an incompletely constructed object
			and can be difficult to discern. It may leave the sub-class
			unable to construct its superclass or forced to replicate
			the construction process completely within itself, losing
			the ability to call super(). If the default constructor
			contains a call to an overridable method, the subclass may
			be completely uninstantiable. Note that this includes method
			calls throughout the control flow graph - i.e., if a
			constructor Foo() calls a private method bar() that calls a
			public method buz(), this denotes a problem.
		</info>
		<name>Constructor Calls Overridable Method</name>
	</findingType>
	<findingType>
		<id>AccessorClassGeneration</id>
		<artifact tool="PMD" mnemonic="AccessorClassGeneration">
		</artifact>
		<shortMessage>
			Instantiation by way of private constructors from outside of
			the constructor's class often causes the generation of an
			accessor. A factory method, or non-privitization of the
			constructor can eliminate this situation. The generated
			class file is actually an interface. It gives the accessing
			class the ability to invoke a new hidden package scope
			constructor that takes the interface as a supplementary
			parameter. This turns a private constructor effectively into
			one with package scope, and is challenging to discern.
		</shortMessage>
		<info>
			Instantiation by way of private constructors from outside of
			the constructor's class often causes the generation of an
			accessor. A factory method, or non-privitization of the
			constructor can eliminate this situation. The generated
			class file is actually an interface. It gives the accessing
			class the ability to invoke a new hidden package scope
			constructor that takes the interface as a supplementary
			parameter. This turns a private constructor effectively into
			one with package scope, and is challenging to discern.
		</info>
		<name>Accessor Class Generation</name>
	</findingType>
	<findingType>
		<id>FinalFieldCouldBeStatic</id>
		<artifact tool="PMD" mnemonic="FinalFieldCouldBeStatic">
		</artifact>
		<shortMessage>
			If a final field is assigned to a compile-time constant, it
			could be made static, thus saving overhead in each object at
			runtime.
		</shortMessage>
		<info>
			If a final field is assigned to a compile-time constant, it
			could be made static, thus saving overhead in each object at
			runtime.
		</info>
		<name>Final Field Could Be Static</name>
	</findingType>
	<findingType>
		<id>CloseResource</id>
		<artifact tool="PMD" mnemonic="CloseResource"></artifact>
		<shortMessage>
			Ensure that resources (like Connection, Statement, and
			ResultSet objects) are always closed after use.
		</shortMessage>
		<info>
			Ensure that resources (like Connection, Statement, and
			ResultSet objects) are always closed after use.
		</info>
		<name>Close Resource</name>
	</findingType>
	<findingType>
		<id>NonStaticInitializer</id>
		<artifact tool="PMD" mnemonic="NonStaticInitializer"></artifact>
		<shortMessage>
			A nonstatic initializer block will be called any time a
			constructor is invoked (just prior to invoking the
			constructor). While this is a valid language construct, it
			is rarely used and is confusing.
		</shortMessage>
		<info>
			A nonstatic initializer block will be called any time a
			constructor is invoked (just prior to invoking the
			constructor). While this is a valid language construct, it
			is rarely used and is confusing.
		</info>
		<name>Non Static Initializer</name>
	</findingType>
	<findingType>
		<id>DefaultLabelNotLastInSwitchStmt</id>
		<artifact tool="PMD"
			mnemonic="DefaultLabelNotLastInSwitchStmt">
		</artifact>
		<shortMessage>
			By convention, the default label should be the last label in
			a switch statement.
		</shortMessage>
		<info>
			By convention, the default label should be the last label in
			a switch statement.
		</info>
		<name>Default Label Not Last In Switch Statements</name>
	</findingType>
	<findingType>
		<id>NonCaseLabelInSwitchStatement</id>
		<artifact tool="PMD" mnemonic="NonCaseLabelInSwitchStatement">
		</artifact>
		<shortMessage>
			A non-case label (e.g. a named break/continue label) was
			present in a switch statement. This legal, but confusing. It
			is easy to mix up the case labels and the non-case labels.
		</shortMessage>
		<info>
			A non-case label (e.g. a named break/continue label) was
			present in a switch statement. This legal, but confusing. It
			is easy to mix up the case labels and the non-case labels.
		</info>
		<name>Non Case Label In Switch Statement</name>
	</findingType>
	<findingType>
		<id>OptimizableToArrayCall</id>
		<artifact tool="PMD" mnemonic="OptimizableToArrayCall">
		</artifact>
		<shortMessage>
			A call to Collection.toArray can use the Collection's size
			vs an empty Array of the desired type.
		</shortMessage>
		<info>
			A call to Collection.toArray can use the Collection's size
			vs an empty Array of the desired type.
		</info>
		<name>Optimizable To Array Call</name>
	</findingType>
	<findingType>
		<id>BadComparison</id>
		<artifact tool="PMD" mnemonic="BadComparison"></artifact>
		<shortMessage>
			Avoid equality comparisons with Double.NaN - these are
			likely to be logic errors.
		</shortMessage>
		<info>
			Avoid equality comparisons with Double.NaN - these are
			likely to be logic errors.
		</info>
		<name>Bad Comparison</name>
	</findingType>

	<findingType>
		<id>ConfusingTernary</id>
		<artifact tool="PMD" mnemonic="ConfusingTernary"></artifact>
		<shortMessage>
			In an &quot;if&quot; expression with an &quot;else&quot;
			clause, avoid negation in the test. For example, rephrase:
			if (x != y) diff(); else same(); as: if (x == y) same();
			else diff(); Most &quot;if (x != y)&quot; cases without an
			&quot;else&quot; are often return cases, so consistent use
			of this rule makes the code easier to read. Also, this
			resolves trivial ordering problems, such as &quot;does the
			error case go first?&quot; or &quot;does the common case go
			first?&quot;.
		</shortMessage>
		<info>
			In an &quot;if&quot; expression with an &quot;else&quot;
			clause, avoid negation in the test. For example, rephrase:
			if (x != y) diff(); else same(); as: if (x == y) same();
			else diff(); Most &quot;if (x != y)&quot; cases without an
			&quot;else&quot; are often return cases, so consistent use
			of this rule makes the code easier to read. Also, this
			resolves trivial ordering problems, such as &quot;does the
			error case go first?&quot; or &quot;does the common case go
			first?&quot;.
		</info>
		<name>Confusing Ternary</name>
	</findingType>
	<findingType>
		<id>InstantiationToGetClass</id>
		<artifact tool="PMD" mnemonic="InstantiationToGetClass">
		</artifact>
		<shortMessage>
			Avoid instantiating an object just to call getClass() on it;
			use the .class public member instead.
		</shortMessage>
		<info>
			Avoid instantiating an object just to call getClass() on it;
			use the .class public member instead.
		</info>
		<name>Instantiation To Get Class</name>
	</findingType>
	<findingType>
		<id>IdempotentOperations</id>
		<artifact tool="PMD" mnemonic="IdempotentOperations"></artifact>
		<shortMessage>
			Avoid idempotent operations - they are have no effect.
		</shortMessage>
		<info>
			Avoid idempotent operations - they are have no effect.
		</info>
		<name>Idempotent Operations</name>
	</findingType>
	<findingType>
		<id>SimpleDateFormatNeedsLocale</id>
		<artifact tool="PMD" mnemonic="SimpleDateFormatNeedsLocale">
		</artifact>
		<shortMessage>
			Be sure to specify a Locale when creating a new instance of
			SimpleDateFormat.
		</shortMessage>
		<info>
			Be sure to specify a Locale when creating a new instance of
			SimpleDateFormat.
		</info>
		<name>Simple Date Format Needs Locale</name>
	</findingType>
	<findingType>
		<id>ImmutableField</id>
		<artifact tool="PMD" mnemonic="ImmutableField"></artifact>
		<shortMessage>
			Identifies private fields whose values never change once
			they are initialized either in the declaration of the field
			or by a constructor. This aids in converting existing
			classes to immutable classes.
		</shortMessage>
		<info>
			Identifies private fields whose values never change once
			they are initialized either in the declaration of the field
			or by a constructor. This aids in converting existing
			classes to immutable classes.
		</info>
		<name>Immutable Field</name>
	</findingType>
	<findingType>
		<id>UseLocaleWithCaseConversions</id>
		<artifact tool="PMD" mnemonic="UseLocaleWithCaseConversions">
		</artifact>
		<shortMessage>
			When doing a String.toLowerCase()/toUpperCase() call, use a
			Locale. This avoids problems with certain locales, i.e.
			Turkish.
		</shortMessage>
		<info>
			When doing a String.toLowerCase()/toUpperCase() call, use a
			Locale. This avoids problems with certain locales, i.e.
			Turkish.
		</info>
		<name>Use Locale With Case Conversions</name>
	</findingType>
	<findingType>
		<id>AvoidProtectedFieldInFinalClass</id>
		<artifact tool="PMD"
			mnemonic="AvoidProtectedFieldInFinalClass">
		</artifact>
		<shortMessage>
			Do not use protected fields in final classes since they
			cannot be subclassed. Clarify your intent by using private
			or package access modifiers instead.
		</shortMessage>
		<info>
			Do not use protected fields in final classes since they
			cannot be subclassed. Clarify your intent by using private
			or package access modifiers instead.
		</info>
		<name>Avoid Protected Field In Final Class</name>
	</findingType>
	<findingType>
		<id>AssignmentToNonFinalStatic</id>
		<artifact tool="PMD" mnemonic="AssignmentToNonFinalStatic">
		</artifact>
		<shortMessage>
			Identifies a possible unsafe usage of a static field.
		</shortMessage>
		<info>
			Identifies a possible unsafe usage of a static field.
		</info>
		<name>Assignment To Non Final Static</name>
	</findingType>
	<findingType>
		<id>MissingStaticMethodInNonInstantiatableClass</id>
		<artifact tool="PMD"
			mnemonic="MissingStaticMethodInNonInstantiatableClass">
		</artifact>
		<shortMessage>
			A class that has private constructors and does not have any
			static methods or fields cannot be used.
		</shortMessage>
		<info>
			A class that has private constructors and does not have any
			static methods or fields cannot be used.
		</info>
		<name>Missing Static Method In Non Instantiatable Class</name>
	</findingType>
	<findingType>
		<id>AvoidSynchronizedAtMethodLevel</id>
		<artifact tool="PMD"
			mnemonic="AvoidSynchronizedAtMethodLevel">
		</artifact>
		<shortMessage>
			Method level synchronization can backfire when new code is
			added to the method. Block-level synchronization helps to
			ensure that only the code that needs synchronization gets
			it.
		</shortMessage>
		<info>
			Method level synchronization can backfire when new code is
			added to the method. Block-level synchronization helps to
			ensure that only the code that needs synchronization gets
			it.
		</info>
		<name>Avoid Synchronized At Method Level</name>
	</findingType>
	<findingType>
		<id>MissingBreakInSwitch</id>
		<artifact tool="PMD" mnemonic="MissingBreakInSwitch"></artifact>
		<shortMessage>
			A switch statement without an enclosed break statement may
			be a bug.
		</shortMessage>
		<info>
			A switch statement without an enclosed break statement may
			be a bug.
		</info>
		<name>Missing Break In Switch</name>
	</findingType>

	<findingType>
		<id>AvoidInstanceofChecksInCatchClause</id>
		<artifact tool="PMD"
			mnemonic="AvoidInstanceofChecksInCatchClause">
		</artifact>
		<shortMessage>
			Each caught exception type should be handled in its own
			catch clause.
		</shortMessage>
		<info>
			Each caught exception type should be handled in its own
			catch clause.
		</info>
		<name>Avoid instanceof Checks In Catch Clause</name>
	</findingType>
	<findingType>
		<id>AbstractClassWithoutAbstractMethod</id>
		<artifact tool="PMD"
			mnemonic="AbstractClassWithoutAbstractMethod">
		</artifact>
		<shortMessage>
			The abstract class does not contain any abstract methods. An
			abstract class suggests an incomplete implementation, which
			is to be completed by subclasses implementing the abstract
			methods. If the class is intended to be used as a base class
			only (not to be instantiated direcly) a protected
			constructor can be provided prevent direct instantiation.
		</shortMessage>
		<info>
			The abstract class does not contain any abstract methods. An
			abstract class suggests an incomplete implementation, which
			is to be completed by subclasses implementing the abstract
			methods. If the class is intended to be used as a base class
			only (not to be instantiated direcly) a protected
			constructor can be provided prevent direct instantiation.
		</info>
		<name>Abstract Class Without Abstract Method</name>
	</findingType>
	<findingType>
		<id>SimplifyConditional</id>
		<artifact tool="PMD" mnemonic="SimplifyConditional"></artifact>
		<shortMessage>
			No need to check for null before an instanceof; the
			instanceof keyword returns false when given a null argument.
		</shortMessage>
		<info>
			No need to check for null before an instanceof; the
			instanceof keyword returns false when given a null argument.
		</info>
		<name>Simplify Conditional</name>
	</findingType>
	<findingType>
		<id>CompareObjectsWithEquals</id>
		<artifact tool="PMD" mnemonic="CompareObjectsWithEquals">
		</artifact>
		<shortMessage>
			Use equals() to compare object references; avoid comparing
			them with ==.
		</shortMessage>
		<info>
			Use equals() to compare object references; avoid comparing
			them with ==.
		</info>
		<name>Compare Objects With Equals</name>
	</findingType>
	<findingType>
		<id>PositionLiteralsFirstInComparisons</id>
		<artifact tool="PMD"
			mnemonic="PositionLiteralsFirstInComparisons">
		</artifact>
		<shortMessage>
			Position literals first in String comparisons - that way if
			the String is null you won't get a NullPointerException,
			it'll just return false.
		</shortMessage>
		<info>
			Position literals first in String comparisons - that way if
			the String is null you won't get a NullPointerException,
			it'll just return false.
		</info>
		<name>Position Literals First In Comparisons</name>
	</findingType>
	<findingType>
		<id>UnnecessaryLocalBeforeReturn</id>
		<artifact tool="PMD" mnemonic="UnnecessaryLocalBeforeReturn">
		</artifact>
		<shortMessage>
			Avoid unnecessarily creating local variables
		</shortMessage>
		<info>Avoid unnecessarily creating local variables</info>
		<name>Unnecessary Local Before Return</name>
	</findingType>
	<findingType>
		<id>NonThreadSafeSingleton</id>
		<artifact tool="PMD" mnemonic="NonThreadSafeSingleton">
		</artifact>
		<shortMessage>
			Non-thread safe singletons can result in bad state changes.
			Eliminate static singletons if possible by instantiating the
			object directly. Static singletons are usually not needed as
			only a single instance exists anyway. Other possible fixes
			are to synchronize the entire method or to use an
			initialize-on-demand holder class (do not use the
			double-check idiom).

			See Effective Java, item 48.
		</shortMessage>
		<info>
			Non-thread safe singletons can result in bad state changes.
			Eliminate static singletons if possible by instantiating the
			object directly. Static singletons are usually not needed as
			only a single instance exists anyway. Other possible fixes
			are to synchronize the entire method or to use an
			initialize-on-demand holder class (do not use the
			double-check idiom).

			See Effective Java, item 48.
		</info>
		<name>Non Thread Safe Singleton</name>
	</findingType>
	<findingType>
		<id>UncommentedEmptyMethod</id>
		<artifact tool="PMD" mnemonic="UncommentedEmptyMethod">
		</artifact>
		<shortMessage>
			Uncommented Empty Method finds instances where a method does
			not contain statements, but there is no comment. By
			explicitly commenting empty methods it is easier to
			distinguish between intentional (commented) and
			unintentional empty methods.
		</shortMessage>
		<info>
			Uncommented Empty Method finds instances where a method does
			not contain statements, but there is no comment. By
			explicitly commenting empty methods it is easier to
			distinguish between intentional (commented) and
			unintentional empty methods.
		</info>
		<name>Uncommented Empty Method</name>
	</findingType>
	<findingType>
		<id>UncommentedEmptyConstructor</id>
		<artifact tool="PMD" mnemonic="UncommentedEmptyConstructor">
		</artifact>
		<shortMessage>
			Uncommented Empty Constructor finds instances where a
			constructor does not contain statements, but there is no
			comment. By explicitly commenting empty constructors it is
			easier to distinguish between intentional (commented) and
			unintentional empty constructors.
		</shortMessage>
		<info>
			Uncommented Empty Constructor finds instances where a
			constructor does not contain statements, but there is no
			comment. By explicitly commenting empty constructors it is
			easier to distinguish between intentional (commented) and
			unintentional empty constructors.
		</info>
		<name>Uncommented Empty Constructor</name>
	</findingType>
	<findingType>
		<id>AvoidConstantsInterface</id>
		<artifact tool="PMD" mnemonic="AvoidConstantsInterface">
		</artifact>
		<shortMessage>
			An interface should be used only to model a behaviour of a
			class: using an interface as a container of constants is a
			poor usage pattern.
		</shortMessage>
		<info>
			An interface should be used only to model a behaviour of a
			class: using an interface as a container of constants is a
			poor usage pattern.
		</info>
		<name>Avoid Constants Interface</name>
	</findingType>
	<findingType>
		<id>UnsynchronizedStaticDateFormatter</id>
		<artifact tool="PMD"
			mnemonic="UnsynchronizedStaticDateFormatter">
		</artifact>
		<shortMessage>
			SimpleDateFormat is not synchronized. Sun recomends separate
			format instances for each thread. If multiple threads must
			access a static formatter, the formatter must be
			synchronized either on method or block level.
		</shortMessage>
		<info>
			SimpleDateFormat is not synchronized. Sun recomends separate
			format instances for each thread. If multiple threads must
			access a static formatter, the formatter must be
			synchronized either on method or block level.
		</info>
		<name>Unsynchronized Static Date Formatter</name>
	</findingType>
	<findingType>
		<id>PreserveStackTrace</id>
		<artifact tool="PMD" mnemonic="PreserveStackTrace"></artifact>
		<shortMessage>
			Throwing a new exception from a catch block without passing
			the original exception into the new Exception will cause the
			true stack trace to be lost, and can make it difficult to
			debug effectively.
		</shortMessage>
		<info>
			Throwing a new exception from a catch block without passing
			the original exception into the new Exception will cause the
			true stack trace to be lost, and can make it difficult to
			debug effectively.
		</info>
		<name>Preserve Stack Trace</name>
	</findingType>
	<findingType>
		<id>UseCollectionIsEmpty</id>
		<artifact tool="PMD" mnemonic="UseCollectionIsEmpty"></artifact>
		<shortMessage>
			The isEmpty() method on java.util.Collection is provided to
			see if a collection has any elements. Comparing the value of
			size() to 0 merely duplicates existing behavior.
		</shortMessage>
		<info>
			The isEmpty() method on java.util.Collection is provided to
			see if a collection has any elements. Comparing the value of
			size() to 0 merely duplicates existing behavior.
		</info>
		<name>Use Collection Is Empty</name>
	</findingType>


	<findingType>
		<id>FinalizeOverloaded</id>
		<artifact tool="PMD" mnemonic="FinalizeOverloaded"></artifact>
		<shortMessage>
			Methods named finalize() should not have parameters. It is
			confusing and probably a bug to overload finalize(). It will
			not be called by the VM.
		</shortMessage>
		<info>
			Methods named finalize() should not have parameters. It is
			confusing and probably a bug to overload finalize(). It will
			not be called by the VM.
		</info>
		<name>Finalize Overloaded</name>
	</findingType>

	<findingType>
		<id>DuplicateImports</id>
		<artifact tool="PMD" mnemonic="DuplicateImports"></artifact>
		<shortMessage>Avoid duplicate import statements.</shortMessage>
		<info>Avoid duplicate import statements.</info>
		<name>Duplicate Imports</name>
	</findingType>
	<findingType>
		<id>DontImportJavaLang</id>
		<artifact tool="PMD" mnemonic="DontImportJavaLang"></artifact>
		<shortMessage>
			Avoid importing anything from the package 'java.lang'. These
			classes are automatically imported (JLS 7.5.3).
		</shortMessage>
		<info>
			Avoid importing anything from the package 'java.lang'. These
			classes are automatically imported (JLS 7.5.3).
		</info>
		<name>Don't Import java.lang</name>
	</findingType>
	<findingType>
		<id>UnusedImports</id>
		<artifact tool="PMD" mnemonic="UnusedImports"></artifact>
		<shortMessage>Avoid unused import statements.</shortMessage>
		<info>Avoid unused import statements.</info>
		<name>Unused Imports</name>
	</findingType>
	<findingType>
		<id>ImportFromSamePackage</id>
		<artifact tool="PMD" mnemonic="ImportFromSamePackage">
		</artifact>
		<shortMessage>
			No need to import a type that lives in the same package.
		</shortMessage>
		<info>
			No need to import a type that lives in the same package.
		</info>
		<name>Import From Same Package</name>
	</findingType>
	<findingType>
		<id>UseProperClassLoader</id>
		<artifact tool="PMD" mnemonic="UseProperClassLoader"></artifact>
		<shortMessage>
			In J2EE getClassLoader() might not work as expected. Use
			Thread.currentThread().getContextClassLoader() instead.
		</shortMessage>
		<info>
			In J2EE getClassLoader() might not work as expected. Use
			Thread.currentThread().getContextClassLoader() instead.
		</info>
		<name>Use Proper Class Loader</name>
	</findingType>
	<findingType>
		<id>MDBAndSessionBeanNamingConvention</id>
		<artifact tool="PMD"
			mnemonic="MDBAndSessionBeanNamingConvention">
		</artifact>
		<shortMessage>
			The EJB Specification state that any MessageDrivenBean or
			SessionBean should be suffixed by Bean.
		</shortMessage>
		<info>
			The EJB Specification state that any MessageDrivenBean or
			SessionBean should be suffixed by Bean.
		</info>
		<name>MDB And Session Bean Naming Convention</name>
	</findingType>
	<findingType>
		<id>RemoteSessionInterfaceNamingConvention</id>
		<artifact tool="PMD"
			mnemonic="RemoteSessionInterfaceNamingConvention">
		</artifact>
		<shortMessage>
			Remote Home interface of a Session EJB should be suffixed by
			'Home'.
		</shortMessage>
		<info>
			Remote Home interface of a Session EJB should be suffixed by
			'Home'.
		</info>
		<name>Remote Session Interface Naming Convention</name>
	</findingType>
	<findingType>
		<id>LocalInterfaceSessionNamingConvention</id>
		<artifact tool="PMD"
			mnemonic="LocalInterfaceSessionNamingConvention">
		</artifact>
		<shortMessage>
			The Local Interface of a Session EJB should be suffixed by
			'Local'.
		</shortMessage>
		<info>
			The Local Interface of a Session EJB should be suffixed by
			'Local'.
		</info>
		<name>Local Interface Session Naming Convention</name>
	</findingType>
	<findingType>
		<id>LocalHomeNamingConvention</id>
		<artifact tool="PMD" mnemonic="LocalHomeNamingConvention">
		</artifact>
		<shortMessage>
			The Local Home interface of a Session EJB should be suffixed
			by 'LocalHome'.
		</shortMessage>
		<info>
			The Local Home interface of a Session EJB should be suffixed
			by 'LocalHome'.
		</info>
		<name>Local Home Naming Convention</name>
	</findingType>
	<findingType>
		<id>RemoteInterfaceNamingConvention</id>
		<artifact tool="PMD"
			mnemonic="RemoteInterfaceNamingConvention">
		</artifact>
		<shortMessage>
			Remote Interface of a Session EJB should NOT be suffixed.
		</shortMessage>
		<info>
			Remote Interface of a Session EJB should NOT be suffixed.
		</info>
		<name>Remote Interface Naming Convention</name>
	</findingType>
	<findingType>
		<id>BeanMembersShouldSerialize</id>
		<artifact tool="PMD" mnemonic="BeanMembersShouldSerialize">
		</artifact>
		<shortMessage>
			If a class is a bean, or is referenced by a bean directly or
			indirectly it needs to be serializable. Member variables
			need to be marked as transient, static, or have accessor
			methods in the class. Marking variables as transient is the
			safest and easiest modification. Accessor methods should
			follow the Java naming conventions, i.e.if you have a
			variable foo, you should provide getFoo and setFoo methods.
		</shortMessage>
		<info>
			If a class is a bean, or is referenced by a bean directly or
			indirectly it needs to be serializable. Member variables
			need to be marked as transient, static, or have accessor
			methods in the class. Marking variables as transient is the
			safest and easiest modification. Accessor methods should
			follow the Java naming conventions, i.e.if you have a
			variable foo, you should provide getFoo and setFoo methods.
		</info>
		<name>Bean Members Should Serialize</name>
	</findingType>
	<findingType>
		<id>MissingSerialVersionUID</id>
		<artifact tool="PMD" mnemonic="MissingSerialVersionUID">
		</artifact>
		<shortMessage>
			Classes that are serializable should provide a
			serialVersionUID field.
		</shortMessage>
		<info>
			Classes that are serializable should provide a
			serialVersionUID field.
		</info>
		<name>Missing Serial Version UID</name>
	</findingType>
	<findingType>
		<id>JUnitStaticSuite</id>
		<artifact tool="PMD" mnemonic="JUnitStaticSuite"></artifact>
		<shortMessage>
			The suite() method in a JUnit test needs to be both public
			and static.
		</shortMessage>
		<info>
			The suite() method in a JUnit test needs to be both public
			and static.
		</info>
		<name>JUnit Static Suite</name>
	</findingType>
	<findingType>
		<id>JUnitSpelling</id>
		<artifact tool="PMD" mnemonic="JUnitSpelling"></artifact>
		<shortMessage>
			Some JUnit framework methods are easy to misspell.
		</shortMessage>
		<info>Some JUnit framework methods are easy to misspell.</info>
		<name>JUnit Spelling</name>
	</findingType>
	<findingType>
		<id>JUnitAssertionsShouldIncludeMessage</id>
		<artifact tool="PMD"
			mnemonic="JUnitAssertionsShouldIncludeMessage">
		</artifact>
		<shortMessage>
			JUnit assertions should include a message - i.e., use the
			three argument version of assertEquals(), not the two
			argument version.
		</shortMessage>
		<info>
			JUnit assertions should include a message - i.e., use the
			three argument version of assertEquals(), not the two
			argument version.
		</info>
		<name>JUnit Assertions Should Include Message</name>
	</findingType>
	<findingType>
		<id>JUnitTestsShouldIncludeAssert</id>
		<artifact tool="PMD" mnemonic="JUnitTestsShouldIncludeAssert">
		</artifact>
		<shortMessage>
			JUnit tests should include at least one assertion. This
			makes the tests more robust, and using assert with messages
			provide the developer a clearer idea of what the test does.
		</shortMessage>
		<info>
			JUnit tests should include at least one assertion. This
			makes the tests more robust, and using assert with messages
			provide the developer a clearer idea of what the test does.
		</info>
		<name>JUnit Tests Should Include Assert</name>
	</findingType>
	<findingType>
		<id>TestClassWithoutTestCases</id>
		<artifact tool="PMD" mnemonic="TestClassWithoutTestCases">
		</artifact>
		<shortMessage>
			Test classes end with the suffix Test. Having a non-test
			class with that name is not a good practice, since most
			people will assume it is a test case. Test classes have test
			methods named testXXX.
		</shortMessage>
		<info>
			Test classes end with the suffix Test. Having a non-test
			class with that name is not a good practice, since most
			people will assume it is a test case. Test classes have test
			methods named testXXX.
		</info>
		<name>Test Class Without Test Cases</name>
	</findingType>
	<findingType>
		<id>UnnecessaryBooleanAssertion</id>
		<artifact tool="PMD" mnemonic="UnnecessaryBooleanAssertion">
		</artifact>
		<shortMessage>
			A JUnit test assertion with a boolean literal is unnecessary
			since it always will eval to the same thing. Consider using
			flow control (in case of assertTrue(false) or similar) or
			simply removing statements like assertTrue(true) and
			assertFalse(false). If you just want a test to halt, use the
			fail method.
		</shortMessage>
		<info>
			A JUnit test assertion with a boolean literal is unnecessary
			since it always will eval to the same thing. Consider using
			flow control (in case of assertTrue(false) or similar) or
			simply removing statements like assertTrue(true) and
			assertFalse(false). If you just want a test to halt, use the
			fail method.
		</info>
		<name>Unnecessary Boolean Assertion</name>
	</findingType>
	<findingType>
		<id>UseAssertEqualsInsteadOfAssertTrue</id>
		<artifact tool="PMD"
			mnemonic="UseAssertEqualsInsteadOfAssertTrue">
		</artifact>
		<shortMessage>
			This rule detects JUnit assertions in object equality. These
			assertions should be made by more specific methods, like
			assertEquals.
		</shortMessage>
		<info>
			This rule detects JUnit assertions in object equality. These
			assertions should be made by more specific methods, like
			assertEquals.
		</info>
		<name>Use Assert Equals Instead Of Assert True</name>
	</findingType>
	<findingType>
		<id>UseAssertSameInsteadOfAssertTrue</id>
		<artifact tool="PMD"
			mnemonic="UseAssertSameInsteadOfAssertTrue">
		</artifact>
		<shortMessage>
			This rule detects JUnit assertions in object references
			equality. These assertions should be made by more specific
			methods, like assertSame, assertNotSame.
		</shortMessage>
		<info>
			This rule detects JUnit assertions in object references
			equality. These assertions should be made by more specific
			methods, like assertSame, assertNotSame.
		</info>
		<name>Use Assert Same Instead Of Assert True</name>
	</findingType>
	<findingType>
		<id>UseAssertNullInsteadOfAssertTrue</id>
		<artifact tool="PMD"
			mnemonic="UseAssertNullInsteadOfAssertTrue">
		</artifact>
		<shortMessage>
			This rule detects JUnit assertions in object references
			equality. These assertions should be made by more specific
			methods, like assertNull, assertNotNull.
		</shortMessage>
		<info>
			This rule detects JUnit assertions in object references
			equality. These assertions should be made by more specific
			methods, like assertNull, assertNotNull.
		</info>
		<name>Use Assert Null Instead Of Assert True</name>
	</findingType>
	<findingType>
		<id>SimplifyBooleanAssertion</id>
		<artifact tool="PMD" mnemonic="SimplifyBooleanAssertion">
		</artifact>
		<shortMessage>
			Avoid negation in an assertTrue or assertFalse test. For
			example, rephrase: assertTrue(!expr); as: assertFalse(expr);
		</shortMessage>
		<info>
			Avoid negation in an assertTrue or assertFalse test. For
			example, rephrase: assertTrue(!expr); as: assertFalse(expr);
		</info>
		<name>Simplify Boolean Assertion</name>
	</findingType>
	<findingType>
		<id>UseCorrectExceptionLogging</id>
		<artifact tool="PMD" mnemonic="UseCorrectExceptionLogging">
		</artifact>
		<shortMessage>
			To make sure the full stacktrace is printed out, use the
			logging statement with 2 arguments: a String and a
			Throwable.
		</shortMessage>
		<info>
			To make sure the full stacktrace is printed out, use the
			logging statement with 2 arguments: a String and a
			Throwable.
		</info>
		<name>Use Correct Exception Logging</name>
	</findingType>
	<findingType>
		<id>ProperLogger</id>
		<artifact tool="PMD" mnemonic="ProperLogger"></artifact>
		<shortMessage>
			A logger should normally be defined private static final and
			have the correct class. Private final Log log; is also
			allowed for rare cases where loggers need to be passed
			around, with the restriction that the logger needs to be
			passed into the constructor.
		</shortMessage>
		<info>
			A logger should normally be defined private static final and
			have the correct class. Private final Log log; is also
			allowed for rare cases where loggers need to be passed
			around, with the restriction that the logger needs to be
			passed into the constructor.
		</info>
		<name>Proper Logger</name>
	</findingType>
	<findingType>
		<id>MoreThanOneLogger</id>
		<artifact tool="PMD" mnemonic="MoreThanOneLogger"></artifact>
		<shortMessage>
			Normally only one logger is used in each class.
		</shortMessage>
		<info>Normally only one logger is used in each class.</info>
		<name>More Than One Logger</name>
	</findingType>
	<findingType>
		<id>LoggerIsNotStaticFinal</id>
		<artifact tool="PMD" mnemonic="LoggerIsNotStaticFinal">
		</artifact>
		<shortMessage>
			In most cases, the Logger can be declared static and final.
		</shortMessage>
		<info>
			In most cases, the Logger can be declared static and final.
		</info>
		<name>Logger Is Not Static Final</name>
	</findingType>
	<findingType>
		<id>SystemPrintln</id>
		<artifact tool="PMD" mnemonic="SystemPrintln"></artifact>
		<shortMessage>
			System.(out|err).print is used, consider using a logger.
		</shortMessage>
		<info>
			System.(out|err).print is used, consider using a logger.
		</info>
		<name>Use of System Println</name>
	</findingType>
	<findingType>
		<id>AvoidPrintStackTrace</id>
		<artifact tool="PMD" mnemonic="AvoidPrintStackTrace"></artifact>
		<shortMessage>
			Avoid printStackTrace(); use a logger call instead.
		</shortMessage>
		<info>Avoid printStackTrace(); use a logger call instead.</info>
		<name>Avoid Print Stack Trace</name>
	</findingType>
	<findingType>
		<id>ReplaceVectorWithList</id>
		<artifact tool="PMD" mnemonic="ReplaceVectorWithList">
		</artifact>
		<shortMessage>
			Consider replacing Vector usages with the newer
			java.util.ArrayList if expensive threadsafe operation is not
			required.
		</shortMessage>
		<info>
			Consider replacing Vector usages with the newer
			java.util.ArrayList if expensive threadsafe operation is not
			required.
		</info>
		<name>Replace Vector With List</name>
	</findingType>
	<findingType>
		<id>ReplaceHashtableWithMap</id>
		<artifact tool="PMD" mnemonic="ReplaceHashtableWithMap">
		</artifact>
		<shortMessage>
			Consider replacing this Hashtable with the newer
			java.util.Map
		</shortMessage>
		<info>
			Consider replacing this Hashtable with the newer
			java.util.Map
		</info>
		<name>Replace Hashtable With Map</name>
	</findingType>
	<findingType>
		<id>ReplaceEnumerationWithIterator</id>
		<artifact tool="PMD"
			mnemonic="ReplaceEnumerationWithIterator">
		</artifact>
		<shortMessage>
			Consider replacing this Enumeration with the newer
			java.util.Iterator
		</shortMessage>
		<info>
			Consider replacing this Enumeration with the newer
			java.util.Iterator
		</info>
		<name>Replace Enumeration With Iterator</name>
	</findingType>
	<findingType>
		<id>AvoidEnumAsIdentifier</id>
		<artifact tool="PMD" mnemonic="AvoidEnumAsIdentifier">
		</artifact>
		<shortMessage>
			Finds all places where 'enum' is used as an identifier.
		</shortMessage>
		<info>
			Finds all places where 'enum' is used as an identifier.
		</info>
		<name>Avoid Enum As Identifier</name>
	</findingType>
	<findingType>
		<id>AvoidAssertAsIdentifier</id>
		<artifact tool="PMD" mnemonic="AvoidAssertAsIdentifier">
		</artifact>
		<shortMessage>
			Finds all places where 'assert' is used as an identifier.
		</shortMessage>
		<info>
			Finds all places where 'assert' is used as an identifier.
		</info>
		<name>Avoid Assert As Identifier</name>
	</findingType>

	<findingType>
		<id>ByteInstantiation</id>
		<artifact tool="PMD" mnemonic="ByteInstantiation"></artifact>
		<shortMessage>
			In JDK 1.5, calling new Byte() causes memory allocation.
			Byte.valueOf() is more memory friendly.
		</shortMessage>
		<info>
			In JDK 1.5, calling new Byte() causes memory allocation.
			Byte.valueOf() is more memory friendly.
		</info>
		<name>Byte Instantiation</name>
	</findingType>
	<findingType>
		<id>ShortInstantiation</id>
		<artifact tool="PMD" mnemonic="ShortInstantiation"></artifact>
		<shortMessage>
			In JDK 1.5, calling new Short() causes memory allocation.
			Short.valueOf() is more memory friendly.
		</shortMessage>
		<info>
			In JDK 1.5, calling new Short() causes memory allocation.
			Short.valueOf() is more memory friendly.
		</info>
		<name>Short Instantiation</name>
	</findingType>
	<findingType>
		<id>LongInstantiation</id>
		<artifact tool="PMD" mnemonic="LongInstantiation"></artifact>
		<shortMessage>
			In JDK 1.5, calling new Long() causes memory allocation.
			Long.valueOf() is more memory friendly.
		</shortMessage>
		<info>
			In JDK 1.5, calling new Long() causes memory allocation.
			Long.valueOf() is more memory friendly.
		</info>
		<name>Long Instantiation</name>
	</findingType>
	<findingType>
		<id>JUnit4TestShouldUseBeforeAnnotation</id>
		<artifact tool="PMD"
			mnemonic="JUnit4TestShouldUseBeforeAnnotation">
		</artifact>
		<shortMessage>
			In JUnit 3, the setUp method was used to set up all data
			entities required in running tests. JUnit 4 skips the setUp
			method and executes all methods annotated with @Before
			before all tests
		</shortMessage>
		<info>
			In JUnit 3, the setUp method was used to set up all data
			entities required in running tests. JUnit 4 skips the setUp
			method and executes all methods annotated with @Before
			before all tests
		</info>
		<name>JUnit4Test Should Use Before Annotation</name>
	</findingType>
	<findingType>
		<id>JUnit4TestShouldUseAfterAnnotation</id>
		<artifact tool="PMD"
			mnemonic="JUnit4TestShouldUseAfterAnnotation">
		</artifact>
		<shortMessage>
			In JUnit 3, the tearDown method was used to clean up all
			data entities required in running tests. JUnit 4 skips the
			tearDown method and executes all methods annotated with
			@After after running each test
		</shortMessage>
		<info>
			In JUnit 3, the tearDown method was used to clean up all
			data entities required in running tests. JUnit 4 skips the
			tearDown method and executes all methods annotated with
			@After after running each test
		</info>
		<name>JUnit4Test Should Use After Annotation</name>
	</findingType>
	<findingType>
		<id>JUnit4TestShouldUseTestAnnotation</id>
		<artifact tool="PMD"
			mnemonic="JUnit4TestShouldUseTestAnnotation">
		</artifact>
		<shortMessage>
			In JUnit 3, the framework executed all methods which started
			with the word test as a unit test. In JUnit 4, only methods
			annotated with the @Test annotation are executed.
		</shortMessage>
		<info>
			In JUnit 3, the framework executed all methods which started
			with the word test as a unit test. In JUnit 4, only methods
			annotated with the @Test annotation are executed.
		</info>
		<name>JUnit4Test Should Use Test Annotation</name>
	</findingType>
	<findingType>
		<id>JUnit4SuitesShouldUseSuiteAnnotation</id>
		<artifact tool="PMD"
			mnemonic="JUnit4SuitesShouldUseSuiteAnnotation">
		</artifact>
		<shortMessage>
			In JUnit 3, test suites are indicated by the suite() method.
			In JUnit 4, suites are indicated through the
			@RunWith(Suite.class) annotation.
		</shortMessage>
		<info>
			In JUnit 3, test suites are indicated by the suite() method.
			In JUnit 4, suites are indicated through the
			@RunWith(Suite.class) annotation.
		</info>
		<name>JUnit4Suites Should Use Suite Annotation</name>
	</findingType>
	<findingType>
		<id>JUnitUseExpected</id>
		<artifact tool="PMD" mnemonic="JUnitUseExpected"></artifact>
		<shortMessage></shortMessage>
		<info></info>
		<name>JUnit Use Expected</name>
	</findingType>
	<findingType>
		<id>ShortVariable</id>
		<artifact tool="PMD" mnemonic="ShortVariable"></artifact>
		<shortMessage>
			Detects when a field, local, or parameter has a very short
			name.
		</shortMessage>
		<info>
			Detects when a field, local, or parameter has a very short
			name.
		</info>
		<name>Short Variable</name>
	</findingType>
	<findingType>
		<id>LongVariable</id>
		<artifact tool="PMD" mnemonic="LongVariable"></artifact>
		<shortMessage>
			Detects when a field, formal or local variable is declared
			with a long name.
		</shortMessage>
		<info>
			Detects when a field, formal or local variable is declared
			with a long name.
		</info>
		<name>Long Variable</name>
	</findingType>
	<findingType>
		<id>ShortMethodName</id>
		<artifact tool="PMD" mnemonic="ShortMethodName"></artifact>
		<shortMessage>
			Detects when very short method names are used.
		</shortMessage>
		<info>Detects when very short method names are used.</info>
		<name>Short Method Name</name>
	</findingType>
	<findingType>
		<id>AbstractNaming</id>
		<artifact tool="PMD" mnemonic="AbstractNaming"></artifact>
		<shortMessage>
			Abstract classes should be named 'AbstractXXX'.
		</shortMessage>
		<info>Abstract classes should be named 'AbstractXXX'.</info>
		<name>Abstract Naming</name>
	</findingType>
	<findingType>
		<id>AvoidDollarSigns</id>
		<artifact tool="PMD" mnemonic="AvoidDollarSigns"></artifact>
		<shortMessage>
			Avoid using dollar signs in variable/method/class/interface
			names.
		</shortMessage>
		<info>
			Avoid using dollar signs in variable/method/class/interface
			names.
		</info>
		<name>Avoid Dollar Signs</name>
	</findingType>
	<findingType>
		<id>MethodWithSameNameAsEnclosingClass</id>
		<artifact tool="PMD"
			mnemonic="MethodWithSameNameAsEnclosingClass">
		</artifact>
		<shortMessage>
			Non-constructor methods should not have the same name as the
			enclosing class.
		</shortMessage>
		<info>
			Non-constructor methods should not have the same name as the
			enclosing class.
		</info>
		<name>Method With Same Name As Enclosing Class</name>
	</findingType>

	<findingType>
		<id>SuspiciousConstantFieldName</id>
		<artifact tool="PMD" mnemonic="SuspiciousConstantFieldName">
		</artifact>
		<shortMessage>
			A field name is all in uppercase characters, which in Sun's
			Java naming conventions indicate a constant. However, the
			field is not final.
		</shortMessage>
		<info>
			A field name is all in uppercase characters, which in Sun's
			Java naming conventions indicate a constant. However, the
			field is not final.
		</info>
		<name>Suspicious Constant Field Name</name>
	</findingType>

	<findingType>
		<id>AvoidFieldNameMatchingTypeName</id>
		<artifact tool="PMD"
			mnemonic="AvoidFieldNameMatchingTypeName">
		</artifact>
		<shortMessage>
			It is somewhat confusing to have a field name matching the
			declaring class name. This probably means that type and or
			field names could be more precise.
		</shortMessage>
		<info>
			It is somewhat confusing to have a field name matching the
			declaring class name. This probably means that type and or
			field names could be more precise.
		</info>
		<name>Avoid Field Name Matching Type Name</name>
	</findingType>
	<findingType>
		<id>AvoidFieldNameMatchingMethodName</id>
		<artifact tool="PMD"
			mnemonic="AvoidFieldNameMatchingMethodName">
		</artifact>
		<shortMessage>
			It is somewhat confusing to have a field name with the same
			name as a method. While this is totally legal, having
			information (field) and actions (method) is not clear
			naming.
		</shortMessage>
		<info>
			It is somewhat confusing to have a field name with the same
			name as a method. While this is totally legal, having
			information (field) and actions (method) is not clear
			naming.
		</info>
		<name>Avoid Field Name Matching Method Name</name>
	</findingType>
	<findingType>
		<id>NoPackage</id>
		<artifact tool="PMD" mnemonic="NoPackage"></artifact>
		<shortMessage>
			Detects when a class or interface does not have a package
			definition.
		</shortMessage>
		<info>
			Detects when a class or interface does not have a package
			definition.
		</info>
		<name>No Package</name>
	</findingType>
	<findingType>
		<id>PackageCase</id>
		<artifact tool="PMD" mnemonic="PackageCase"></artifact>
		<shortMessage>
			Detects when a package definition contains upper case
			characters.
		</shortMessage>
		<info>
			Detects when a package definition contains upper case
			characters.
		</info>
		<name>Package Case</name>
	</findingType>
	<findingType>
		<id>MisleadingVariableName</id>
		<artifact tool="PMD" mnemonic="MisleadingVariableName">
		</artifact>
		<shortMessage>
			Detects when a non-field has a name starting with 'm_'. This
			usually indicates a field and thus is confusing.
		</shortMessage>
		<info>
			Detects when a non-field has a name starting with 'm_'. This
			usually indicates a field and thus is confusing.
		</info>
		<name>Misleading Variable Name</name>
	</findingType>
	<findingType>
		<id>BooleanGetMethodName</id>
		<artifact tool="PMD" mnemonic="BooleanGetMethodName"></artifact>
		<shortMessage>
			Looks for methods named 'getX()' with 'boolean' as the
			return type. The convention is to name these methods
			'isX()'.
		</shortMessage>
		<info>
			Looks for methods named 'getX()' with 'boolean' as the
			return type. The convention is to name these methods
			'isX()'.
		</info>
		<name>Boolean Get Method Name</name>
	</findingType>
	<findingType>
		<id>LocalVariableCouldBeFinal</id>
		<artifact tool="PMD" mnemonic="LocalVariableCouldBeFinal">
		</artifact>
		<shortMessage>
			A local variable assigned only once can be declared final.
		</shortMessage>
		<info>
			A local variable assigned only once can be declared final.
		</info>
		<name>Local Variable Could Be Final</name>
	</findingType>
	<findingType>
		<id>MethodArgumentCouldBeFinal</id>
		<artifact tool="PMD" mnemonic="MethodArgumentCouldBeFinal">
		</artifact>
		<shortMessage>
			A method argument that is never assigned can be declared
			final.
		</shortMessage>
		<info>
			A method argument that is never assigned can be declared
			final.
		</info>
		<name>Method Argument Could Be Final</name>
	</findingType>
	<findingType>
		<id>AvoidInstantiatingObjectsInLoops</id>
		<artifact tool="PMD"
			mnemonic="AvoidInstantiatingObjectsInLoops">
		</artifact>
		<shortMessage>
			Detects when a new object is created inside a loop
		</shortMessage>
		<info>Detects when a new object is created inside a loop</info>
		<name>Avoid Instantiating Objects In Loops</name>
	</findingType>
	<findingType>
		<id>UseArrayListInsteadOfVector</id>
		<artifact tool="PMD" mnemonic="UseArrayListInsteadOfVector">
		</artifact>
		<shortMessage>
			ArrayList is a much better Collection implementation than
			Vector.
		</shortMessage>
		<info>
			ArrayList is a much better Collection implementation than
			Vector.
		</info>
		<name>Use Array List Instead Of Vector</name>
	</findingType>
	<findingType>
		<id>SimplifyStartsWith</id>
		<artifact tool="PMD" mnemonic="SimplifyStartsWith"></artifact>
		<shortMessage>
			Since it passes in a literal of length 1, this call to
			String.startsWith can be rewritten using String.charAt(0) to
			save some time.
		</shortMessage>
		<info>
			Since it passes in a literal of length 1, this call to
			String.startsWith can be rewritten using String.charAt(0) to
			save some time.
		</info>
		<name>Simplify Starts With</name>
	</findingType>

	<findingType>
		<id>UseArraysAsList</id>
		<artifact tool="PMD" mnemonic="UseArraysAsList"></artifact>
		<shortMessage>
			The class java.util.Arrays has a &quot;asList&quot; method
			that should be use when you want to create a new List from
			an array of objects. It is faster than executing a loop to
			cpy all the elements of the array one by one
		</shortMessage>
		<info>
			The class java.util.Arrays has a &quot;asList&quot; method
			that should be use when you want to create a new List from
			an array of objects. It is faster than executing a loop to
			cpy all the elements of the array one by one
		</info>
		<name>Use Arrays As List</name>
	</findingType>
	<findingType>
		<id>AvoidArrayLoops</id>
		<artifact tool="PMD" mnemonic="AvoidArrayLoops"></artifact>
		<shortMessage>
			Instead of copying data between two arrays, use
			System.arraycopy method
		</shortMessage>
		<info>
			Instead of copying data between two arrays, use
			System.arraycopy method
		</info>
		<name>Avoid Array Loops</name>
	</findingType>
	<findingType>
		<id>UnnecessaryWrapperObjectCreation</id>
		<artifact tool="PMD"
			mnemonic="UnnecessaryWrapperObjectCreation">
		</artifact>
		<shortMessage>
			Parsing method should be called directy instead.
		</shortMessage>
		<info>Parsing method should be called directy instead.</info>
		<name>Unnecessary Wrapper Object Creation</name>
	</findingType>
	<findingType>
		<id>AddEmptyString</id>
		<artifact tool="PMD" mnemonic="AddEmptyString"></artifact>
		<shortMessage>
			Finds empty string literals which are being added. This is
			an inefficient way to convert any type to a String.
		</shortMessage>
		<info>
			Finds empty string literals which are being added. This is
			an inefficient way to convert any type to a String.
		</info>
		<name>Add Empty String</name>
	</findingType>
	<findingType>
		<id>AvoidCatchingThrowable</id>
		<artifact tool="PMD" mnemonic="AvoidCatchingThrowable">
		</artifact>
		<shortMessage>
			This is dangerous because it casts too wide a net; it can
			catch things like OutOfMemoryError.
		</shortMessage>
		<info>
			This is dangerous because it casts too wide a net; it can
			catch things like OutOfMemoryError.
		</info>
		<name>Avoid Catching Throwable</name>
	</findingType>
	<findingType>
		<id>SignatureDeclareThrowsException</id>
		<artifact tool="PMD"
			mnemonic="SignatureDeclareThrowsException">
		</artifact>
		<shortMessage>
			It is unclear which exceptions that can be thrown from the
			methods. It might be difficult to document and understand
			the vague interfaces. Use either a class derived from
			RuntimeException or a checked exception.
		</shortMessage>
		<info>
			It is unclear which exceptions that can be thrown from the
			methods. It might be difficult to document and understand
			the vague interfaces. Use either a class derived from
			RuntimeException or a checked exception.
		</info>
		<name>Signature Declare Throws Exception</name>
	</findingType>
	<findingType>
		<id>ExceptionAsFlowControl</id>
		<artifact tool="PMD" mnemonic="ExceptionAsFlowControl">
		</artifact>
		<shortMessage>
			Using Exceptions as flow control leads to GOTOish code and
			obscures true exceptions when debugging.
		</shortMessage>
		<info>
			Using Exceptions as flow control leads to GOTOish code and
			obscures true exceptions when debugging.
		</info>
		<name>Exception As Flow Control</name>
	</findingType>
	<findingType>
		<id>AvoidCatchingNPE</id>
		<artifact tool="PMD" mnemonic="AvoidCatchingNPE"></artifact>
		<shortMessage>
			Code should never throw NPE under normal circumstances. A
			catch block may hide the original error, causing other more
			subtle errors in its wake.
		</shortMessage>
		<info>
			Code should never throw NPE under normal circumstances. A
			catch block may hide the original error, causing other more
			subtle errors in its wake.
		</info>
		<name>Avoid Catching NullPointerException</name>
	</findingType>
	<findingType>
		<id>AvoidThrowingRawExceptionTypes</id>
		<artifact tool="PMD"
			mnemonic="AvoidThrowingRawExceptionTypes">
		</artifact>
		<shortMessage>
			Avoid throwing certain exception types. Rather than throw a
			raw RuntimeException, Throwable, Exception, or Error, use a
			subclassed exception or error instead.
		</shortMessage>
		<info>
			Avoid throwing certain exception types. Rather than throw a
			raw RuntimeException, Throwable, Exception, or Error, use a
			subclassed exception or error instead.
		</info>
		<name>Avoid Throwing Raw Exception Types</name>
	</findingType>
	<findingType>
		<id>AvoidThrowingNullPointerException</id>
		<artifact tool="PMD"
			mnemonic="AvoidThrowingNullPointerException">
		</artifact>
		<shortMessage>
			Avoid throwing a NullPointerException - it's confusing
			because most people will assume that the virtual machine
			threw it. Consider using an IllegalArgumentException
			instead; this will be clearly seen as a programmer-initiated
			exception.
		</shortMessage>
		<info>
			Avoid throwing a NullPointerException - it's confusing
			because most people will assume that the virtual machine
			threw it. Consider using an IllegalArgumentException
			instead; this will be clearly seen as a programmer-initiated
			exception.
		</info>
		<name>Avoid Throwing NullPointerException</name>
	</findingType>
	<findingType>
		<id>AvoidRethrowingException</id>
		<artifact tool="PMD" mnemonic="AvoidRethrowingException">
		</artifact>
		<shortMessage>
			Catch blocks that merely rethrow a caught exception only add
			to code size and runtime complexity.
		</shortMessage>
		<info>
			Catch blocks that merely rethrow a caught exception only add
			to code size and runtime complexity.
		</info>
		<name>Avoid Rethrowing Exception</name>
	</findingType>
	<findingType>
		<id>DoNotExtendJavaLangError</id>
		<artifact tool="PMD" mnemonic="DoNotExtendJavaLangError">
		</artifact>
		<shortMessage>
			Errors are system exceptions. Do not extend them.
		</shortMessage>
		<info>Errors are system exceptions. Do not extend them.</info>
		<name>Do Not Extend java.lang.Error</name>
	</findingType>
	<findingType>
		<id>AvoidDuplicateLiterals</id>
		<artifact tool="PMD" mnemonic="AvoidDuplicateLiterals">
		</artifact>
		<shortMessage>
			Code containing duplicate String literals can usually be
			improved by declaring the String as a constant field.
		</shortMessage>
		<info>
			Code containing duplicate String literals can usually be
			improved by declaring the String as a constant field.
		</info>
		<name>Avoid Duplicate Literals</name>
	</findingType>

	<findingType>
		<id>StringToString</id>
		<artifact tool="PMD" mnemonic="StringToString"></artifact>
		<shortMessage>
			Avoid calling toString() on String objects; this is
			unnecessary.
		</shortMessage>
		<info>
			Avoid calling toString() on String objects; this is
			unnecessary.
		</info>
		<name>Call to toString() on a String</name>
	</findingType>
	<findingType>
		<id>InefficientStringBuffering</id>
		<artifact tool="PMD" mnemonic="InefficientStringBuffering">
		</artifact>
		<shortMessage>
			Avoid concatenating non literals in a StringBuffer
			constructor or append().
		</shortMessage>
		<info>
			Avoid concatenating non literals in a StringBuffer
			constructor or append().
		</info>
		<name>Inefficient String Buffering</name>
	</findingType>
	<findingType>
		<id>UnnecessaryCaseChange</id>
		<artifact tool="PMD" mnemonic="UnnecessaryCaseChange">
		</artifact>
		<shortMessage>
			Using equalsIgnoreCase() is faster than using
			toUpperCase/toLowerCase().equals()
		</shortMessage>
		<info>
			Using equalsIgnoreCase() is faster than using
			toUpperCase/toLowerCase().equals()
		</info>
		<name>Unnecessary Case Change</name>
	</findingType>
	<findingType>
		<id>UseStringBufferLength</id>
		<artifact tool="PMD" mnemonic="UseStringBufferLength">
		</artifact>
		<shortMessage>
			Use StringBuffer.length() to determine StringBuffer length
			rather than using
			StringBuffer.toString().equals(&quot;&quot;) or
			StringBuffer.toString().length() ==.
		</shortMessage>
		<info>
			Use StringBuffer.length() to determine StringBuffer length
			rather than using
			StringBuffer.toString().equals(&quot;&quot;) or
			StringBuffer.toString().length() ==.
		</info>
		<name>Use String Buffer Length</name>
	</findingType>
	<findingType>
		<id>AppendCharacterWithChar</id>
		<artifact tool="PMD" mnemonic="AppendCharacterWithChar">
		</artifact>
		<shortMessage>
			Avoid concatenating characters as strings in
			StringBuffer.append.
		</shortMessage>
		<info>
			Avoid concatenating characters as strings in
			StringBuffer.append.
		</info>
		<name>Append Character With Char</name>
	</findingType>
	<findingType>
		<id>ConsecutiveLiteralAppends</id>
		<artifact tool="PMD" mnemonic="ConsecutiveLiteralAppends">
		</artifact>
		<shortMessage>
			Consecutively calling StringBuffer.append with String
			literals
		</shortMessage>
		<info>
			Consecutively calling StringBuffer.append with String
			literals
		</info>
		<name>Consecutive Literal Appends</name>
	</findingType>
	<findingType>
		<id>UseIndexOfChar</id>
		<artifact tool="PMD" mnemonic="UseIndexOfChar"></artifact>
		<shortMessage>
			Use String.indexOf(char) when checking for the index of a
			single character; it executes faster.
		</shortMessage>
		<info>
			Use String.indexOf(char) when checking for the index of a
			single character; it executes faster.
		</info>
		<name>Use Index Of Char</name>
	</findingType>
	<findingType>
		<id>InefficientEmptyStringCheck</id>
		<artifact tool="PMD" mnemonic="InefficientEmptyStringCheck">
		</artifact>
		<shortMessage>
			String.trim().length() is an inefficient way to check if a
			String is really empty, as it creates a new String object
			just to check its size. Consider creating a static function
			that loops through a string, checking
			Character.isWhitespace() on each character and returning
			false if a non-whitespace character is found.
		</shortMessage>
		<info>
			String.trim().length() is an inefficient way to check if a
			String is really empty, as it creates a new String object
			just to check its size. Consider creating a static function
			that loops through a string, checking
			Character.isWhitespace() on each character and returning
			false if a non-whitespace character is found.
		</info>
		<name>Inefficient Empty String Check</name>
	</findingType>
	<findingType>
		<id>InsufficientStringBufferDeclaration</id>
		<artifact tool="PMD"
			mnemonic="InsufficientStringBufferDeclaration">
		</artifact>
		<shortMessage>
			Failing to pre-size a StringBuffer properly could cause it
			to re-size many times during runtime. This rule checks the
			characters that are actually passed into
			StringBuffer.append(), but represents a best guess
			&quot;worst case&quot; scenario. An empty StringBuffer
			constructor initializes the object to 16 characters. This
			default is assumed if the length of the constructor can not
			be determined.
		</shortMessage>
		<info>
			Failing to pre-size a StringBuffer properly could cause it
			to re-size many times during runtime. This rule checks the
			characters that are actually passed into
			StringBuffer.append(), but represents a best guess
			&quot;worst case&quot; scenario. An empty StringBuffer
			constructor initializes the object to 16 characters. This
			default is assumed if the length of the constructor can not
			be determined.
		</info>
		<name>Insufficient String Buffer Declaration</name>
	</findingType>
	<findingType>
		<id>UselessStringValueOf</id>
		<artifact tool="PMD" mnemonic="UselessStringValueOf"></artifact>
		<shortMessage>
			No need to call String.valueOf to append to a string; just
			use the valueOf() argument directly.
		</shortMessage>
		<info>
			No need to call String.valueOf to append to a string; just
			use the valueOf() argument directly.
		</info>
		<name>Useless String.valueOf</name>
	</findingType>
	<findingType>
		<id>StringBufferInstantiationWithChar</id>
		<artifact tool="PMD"
			mnemonic="StringBufferInstantiationWithChar">
		</artifact>
		<shortMessage>
			StringBuffer sb = new StringBuffer('c'); The char will be
			converted into int to intialize StringBuffer size.
		</shortMessage>
		<info>
			StringBuffer sb = new StringBuffer('c'); The char will be
			converted into int to intialize StringBuffer size.
		</info>
		<name>String Buffer Instantiation With Char</name>
	</findingType>
	<findingType>
		<id>MethodReturnsInternalArray</id>
		<artifact tool="PMD" mnemonic="MethodReturnsInternalArray">
		</artifact>
		<shortMessage>
			Exposing internal arrays directly allows the user to modify
			some code that could be critical. It is safer to return a
			copy of the array.
		</shortMessage>
		<info>
			Exposing internal arrays directly allows the user to modify
			some code that could be critical. It is safer to return a
			copy of the array.
		</info>
		<name>Method Returns Internal Array</name>
	</findingType>
	<findingType>
		<id>ArrayIsStoredDirectly</id>
		<artifact tool="PMD" mnemonic="ArrayIsStoredDirectly">
		</artifact>
		<shortMessage>
			Constructors and methods receiving arrays should clone
			objects and store the copy. This prevents that future
			changes from the user affect the internal functionality.
		</shortMessage>
		<info>
			Constructors and methods receiving arrays should clone
			objects and store the copy. This prevents that future
			changes from the user affect the internal functionality.
		</info>
		<name>Array Is Stored Directly</name>
	</findingType>

	<findingType>
		<id>UnusedLocalVariable</id>
		<artifact tool="PMD" mnemonic="UnusedLocalVariable"></artifact>
		<shortMessage>
			Detects when a local variable is declared and/or assigned,
			but not used.
		</shortMessage>
		<info>
			Detects when a local variable is declared and/or assigned,
			but not used.
		</info>
		<name>Unused Local Variable</name>
	</findingType>
	<findingType>
		<id>UnusedPrivateMethod</id>
		<artifact tool="PMD" mnemonic="UnusedPrivateMethod"></artifact>
		<shortMessage>
			Unused Private Method detects when a private method is
			declared but is unused.
		</shortMessage>
		<info>
			Unused Private Method detects when a private method is
			declared but is unused.
		</info>
		<name>Unused Private Method</name>
	</findingType>
	<findingType>
		<id>UnusedFormalParameter</id>
		<artifact tool="PMD" mnemonic="UnusedFormalParameter">
		</artifact>
		<shortMessage>
			Avoid passing parameters to methods or constructors and then
			not using those parameters.
		</shortMessage>
		<info>
			Avoid passing parameters to methods or constructors and then
			not using those parameters.
		</info>
		<name>Unused Formal Parameter</name>
	</findingType>

	<findingType>
		<id>OverrideBothEqualsAndHashcode</id>
		<artifact tool="PMD" mnemonic="OverrideBothEqualsAndHashcode">
		</artifact>
		<shortMessage>
			Override both public boolean Object.equals(Object other),
			and public int Object.hashCode(), or override neither. Even
			if you are inheriting a hashCode() from a parent class,
			consider implementing hashCode and explicitly delegating to
			your superclass.
		</shortMessage>
		<info>
			Override both public boolean Object.equals(Object other),
			and public int Object.hashCode(), or override neither. Even
			if you are inheriting a hashCode() from a parent class,
			consider implementing hashCode and explicitly delegating to
			your superclass.
		</info>
		<name>Override Both Equals And Hashcode</name>
	</findingType>
	<!-- This finding type is no longer in use -->
	<findingType>
		<id>StringInstantiation</id>
		<shortMessage>
			Avoid instantiating String objects; this is usually
			unnecessary.
		</shortMessage>
		<info>
			Avoid instantiating String objects; this is usually
			unnecessary.
		</info>
		<name>String Instantiation</name>
	</findingType>
	<!-- Duplicate
		<findingType>
		<id>UseNotifyAllInsteadOfNotify</id>
		<artifact tool="PMD" mnemonic="UseNotifyAllInsteadOfNotify">
		</artifact>
		<shortMessage>
		Thread.notify() awakens a thread monitoring the object. If
		more than one thread is monitoring, then only one is chosen.
		The thread chosen is arbitrary; thus it's usually safer to
		call notifyAll() instead.
		</shortMessage>
		<info>
		Thread.notify() awakens a thread monitoring the object. If
		more than one thread is monitoring, then only one is chosen.
		The thread chosen is arbitrary; thus it's usually safer to
		call notifyAll() instead.
		</info>
		<name>Use Notify All Instead Of Notify</name>
		</findingType>
		
		<findingType>
		<id>StringInstantiation</id>
		<artifact tool="PMD" mnemonic="StringInstantiation"></artifact>
		<shortMessage>
		Avoid instantiating String objects; this is usually
		unnecessary.
		</shortMessage>
		<info>
		Avoid instantiating String objects; this is usually
		unnecessary.
		</info>
		<name>String Instantiation</name>
		</findingType>
		<findingType>
		<id>AvoidCallingFinalize</id>
		<artifact tool="PMD" mnemonic="AvoidCallingFinalize"></artifact>
		<shortMessage>
		Object.finalize() is called by the garbage collector on an
		object when garbage collection determines that there are no
		more references to the object.
		</shortMessage>
		<info>
		Object.finalize() is called by the garbage collector on an
		object when garbage collection determines that there are no
		more references to the object.
		</info>
		<name>Avoid Calling Finalize</name>
		</findingType>
		
		<findingType>
		<id>UnusedPrivateField</id>
		<artifact tool="PMD" mnemonic="UnusedPrivateField"></artifact>
		<shortMessage>
		Detects when a private field is declared and/or assigned a
		value, but not used.
		</shortMessage>
		<info>
		Detects when a private field is declared and/or assigned a
		value, but not used.
		</info>
		<name>Unused Private Field</name>
		</findingType>
		
		<findingType>
		<id>UseStringBufferForStringAppends</id>
		<artifact tool="PMD"
		mnemonic="UseStringBufferForStringAppends">
		</artifact>
		<shortMessage>
		Finds usages of += for appending strings.
		</shortMessage>
		<info>Finds usages of += for appending strings.</info>
		<name>Use String Buffer For String Appends</name>
		</findingType>
		
		<findingType>
		<id>IntegerInstantiation</id>
		<artifact tool="PMD" mnemonic="IntegerInstantiation"></artifact>
		<shortMessage>
		In JDK 1.5, calling new Integer() causes memory allocation.
		Integer.valueOf() is more memory friendly.
		</shortMessage>
		<info>
		In JDK 1.5, calling new Integer() causes memory allocation.
		Integer.valueOf() is more memory friendly.
		</info>
		<name>Integer Instantiation</name>
		</findingType>
		
		<findingType>
		<id>SuspiciousHashcodeMethodName</id>
		<artifact tool="PMD" mnemonic="SuspiciousHashcodeMethodName">
		</artifact>
		<shortMessage>
		The method name and return type are suspiciously close to
		hashCode(), which may mean you are intending to override the
		hashCode() method.
		</shortMessage>
		<info>
		The method name and return type are suspiciously close to
		hashCode(), which may mean you are intending to override the
		hashCode() method.
		</info>
		<name>Suspicious Hashcode Method Name</name>
		</findingType>
		
		<findingType>
		<id>SuspiciousEqualsMethodName</id>
		<artifact tool="PMD" mnemonic="SuspiciousEqualsMethodName">
		</artifact>
		<shortMessage>
		The method name and parameter number are suspiciously close
		to equals(Object), which may mean you are intending to
		override the equals(Object) method.
		</shortMessage>
		<info>
		The method name and parameter number are suspiciously close
		to equals(Object), which may mean you are intending to
		override the equals(Object) method.
		</info>
		<name>Suspicious Equals Method Name</name>
		</findingType>
		
		<findingType>
		<id>MethodNamingConventions</id>
		<artifact tool="PMD" mnemonic="MethodNamingConventions">
		</artifact>
		<shortMessage>
		Method names should always begin with a lower case
		character, and should not contain underscores.
		</shortMessage>
		<info>
		Method names should always begin with a lower case
		character, and should not contain underscores.
		</info>
		<name>Method Naming Conventions</name>
		</findingType>
		
		<findingType>
		<id>VariableNamingConventions</id>
		<artifact tool="PMD" mnemonic="VariableNamingConventions">
		</artifact>
		<shortMessage>
		A variable naming conventions rule - customize this to your
		liking. Currently, it checks for final variables that should
		be fully capitalized and non-final variables that should not
		include underscores.
		</shortMessage>
		<info>
		A variable naming conventions rule - customize this to your
		liking. Currently, it checks for final variables that should
		be fully capitalized and non-final variables that should not
		include underscores.
		</info>
		<name>Variable Naming Conventions</name>
		</findingType>
		
		<findingType>
		<id>ClassNamingConventions</id>
		<artifact tool="PMD" mnemonic="ClassNamingConventions">
		</artifact>
		<shortMessage>
		Class names should always begin with an upper case
		character.
		</shortMessage>
		<info>
		Class names should always begin with an upper case
		character.
		</info>
		<name>Class Naming Conventions</name>
		</findingType>
		
		<findingType>
		<id>FinalizeShouldBeProtected</id>
		<artifact tool="PMD" mnemonic="FinalizeShouldBeProtected">
		</artifact>
		<shortMessage>
		If you override finalize(), make it protected. If you make
		it public, other classes may call it.
		</shortMessage>
		<info>
		If you override finalize(), make it protected. If you make
		it public, other classes may call it.
		</info>
		<name>Finalize Should Be Protected</name>
		</findingType>
		<findingType>
		<id>ProperCloneImplementation</id>
		<artifact tool="PMD" mnemonic="ProperCloneImplementation">
		</artifact>
		<shortMessage>
		Object clone() should be implemented with super.clone().
		</shortMessage>
		<info>
		Object clone() should be implemented with super.clone().
		</info>
		<name>Proper Clone Implementation</name>
		</findingType>
		
		<findingType>
		<id>CloneMethodMustImplementCloneable</id>
		<artifact tool="PMD"
		mnemonic="CloneMethodMustImplementCloneable">
		</artifact>
		<shortMessage>
		The method clone() should only be implemented if the class
		implements the Cloneable interface with the exception of a
		final method that only throws CloneNotSupportedException.
		</shortMessage>
		<info>
		The method clone() should only be implemented if the class
		implements the Cloneable interface with the exception of a
		final method that only throws CloneNotSupportedException.
		</info>
		<name>Clone Method Must Implement Cloneable</name>
		</findingType>
		
		<findingType>
		<id>MisplacedNullCheck</id>
		<artifact tool="PMD" mnemonic="MisplacedNullCheck"></artifact>
		<shortMessage>
		The null check here is misplaced. if the variable is null
		you'll get a NullPointerException. Either the check is
		useless (the variable will never be &quot;null&quot;) or
		it's incorrect.
		</shortMessage>
		<info>
		The null check here is misplaced. if the variable is null
		you'll get a NullPointerException. Either the check is
		useless (the variable will never be &quot;null&quot;) or
		it's incorrect.
		</info>
		<name>Misplaced Null Check</name>
		</findingType>
		
		<findingType>
		<id>EqualsNull</id>
		<artifact tool="PMD" mnemonic="EqualsNull"></artifact>
		<shortMessage>
		Inexperienced programmers sometimes confuse comparison
		concepts and use equals() to compare to null.
		</shortMessage>
		<info>
		Inexperienced programmers sometimes confuse comparison
		concepts and use equals() to compare to null.
		</info>
		<name>Equals Null</name>
		</findingType>
		
		<findingType>
		<id>EmptyFinalizer</id>
		<artifact tool="PMD" mnemonic="EmptyFinalizer"></artifact>
		<shortMessage>
		If the finalize() method is empty, then it does not need to
		exist.
		</shortMessage>
		<info>
		If the finalize() method is empty, then it does not need to
		exist.
		</info>
		<name>Empty Finalizer</name>
		</findingType>
		
		<findingType>
		<id>FinalizeOnlyCallsSuperFinalize</id>
		<artifact tool="PMD"
		mnemonic="FinalizeOnlyCallsSuperFinalize">
		</artifact>
		<shortMessage>
		If the finalize() is implemented, it should do something
		besides just calling super.finalize().
		</shortMessage>
		<info>
		If the finalize() is implemented, it should do something
		besides just calling super.finalize().
		</info>
		<name>Finalize Only Calls Super Finalize</name>
		</findingType>
		
		<findingType>
		<id>FinalizeDoesNotCallSuperFinalize</id>
		<artifact tool="PMD"
		mnemonic="FinalizeDoesNotCallSuperFinalize">
		</artifact>
		<shortMessage>
		If the finalize() is implemented, its last action should be
		to call super.finalize.
		</shortMessage>
		<info>
		If the finalize() is implemented, its last action should be
		to call super.finalize.
		</info>
		<name>Finalize Does Not Call Super Finalize</name>
		</findingType>
		
		<findingType>
		<id>EmptySynchronizedBlock</id>
		<artifact tool="PMD" mnemonic="EmptySynchronizedBlock">
		</artifact>
		<shortMessage>
		Avoid empty synchronized blocks - they're useless.
		</shortMessage>
		<info>Avoid empty synchronized blocks - they're useless.</info>
		<name>Empty Synchronized Block</name>
		</findingType>
	-->
	
	<!-- For PMD 4.1 -->
	<findingType>
		<id>AvoidUsingHardCodedIP</id>
		<artifact tool="PMD"
			mnemonic="AvoidUsingHardCodedIP">
		</artifact>
		<shortMessage>Avoid using hard-coded IP address</shortMessage>
		<info>

			&lt;p&gt; An application with hard coded IP may become impossible to deploy in some cases. 
			It never hurts to externalize IP addresses. &lt;/p&gt;
			
			&lt;p&gt; . &lt;/p&gt;

		</info>
		<name>Avoid Using Hardcoded IP Addresses</name>
	</findingType>	
	<findingType>
		<id>CheckResultSet</id>
		<artifact tool="PMD"
			mnemonic="CheckResultSet">
		</artifact>
		<shortMessage>Check the return values from methods on ResultSet</shortMessage>
		<info> &lt;p&gt; Always check the return value from calling 
		       ResultSet.{next,previous,first,last}.  If the return value is 'false', 
		       the developer should deal with it. &lt;/p&gt;
		</info>
		<name>Check Return Values from ResultSet Methods</name>
	</findingType>		
	<findingType>
		<id>AvoidFinalLocalVariable</id>
		<artifact tool="PMD"
			mnemonic="AvoidFinalLocalVariable">
		</artifact>
		<shortMessage>
			Avoid using final local variables 
		</shortMessage>
		<info>

			&lt;p&gt; Instead, use fields. &lt;/p&gt;

		</info>
		<name>Avoid Final Local Variables</name>
	</findingType>	
	<findingType>
		<id>AvoidUsingShortType</id>
		<artifact tool="PMD"
			mnemonic="AvoidUsingShortType">
		</artifact>
		<shortMessage>
			Avoid using the "short" type
		</shortMessage>
		<info>

			&lt;p&gt; Java uses the short type to reduce memory usage, not to optimize
			calculation. On the contrary, the JVM does not has any arithmetic capabilities
			with the "short" type, so it must convert the short into int, then do the proper 
			calculation and then convert int back to short. Therefore, use of the "short" type
			may actually take more time
			&lt;/p&gt;

		</info>
		<name>Avoid Using Short Type</name>
	</findingType>	
	<findingType>
		<id>AvoidUsingVolatile</id>
		<artifact tool="PMD"
			mnemonic="AvoidUsingVolatile">
		</artifact>
		<shortMessage>
			Avoid using "volatile" fields
		</shortMessage>
		<info>

			&lt;p&gt; The 'volatile' keyword is generally used to fine tune a concurrent Java 
			application, and therefore, requires a expert knowledge of the Java Memory Model. 
			Moreover, it is often misused. Therefore, the 'volatile'	keyword should not be used
			for maintenance purposes and portability. 
			&lt;/p&gt;

		</info>
		<name>Avoid Using Volatile Fields</name>
	</findingType>	
	<findingType>
		<id>AvoidUsingNativeCode</id>
		<artifact tool="PMD"
			mnemonic="AvoidUsingNativeCode">
		</artifact>
		<shortMessage>
			Avoid using native code
		</shortMessage>
		<info>

			&lt;p&gt; 
			The JVM and Java language allows for a wide range of functionality, so it should be
      very rare to have to rely on non-Java code, and in particular, on the 
      Java Native Interface (JNI).  Since the use of JNI often makes an application 
      less portable, and harder to maintain, it is not recommended. &lt;/p&gt;

		</info>
		<name>Avoid Using Native Code</name>
	</findingType>	
	<findingType>
		<id>AvoidAccessibilityAlteration</id>
		<artifact tool="PMD"
			mnemonic="AvoidAccessibilityAlteration">
		</artifact>
		<shortMessage>
			Avoid changing class/method accessibility at runtime
		</shortMessage>
		<info>

			&lt;p&gt; 		
			Methods in java.lang.reflect, such as getDeclaredConstructors(), 
			getDeclaredConstructor(Class[]) and setAccessible(), allow someone to alter, 
			at runtime, the accessibility of fields, classes, or methods, even if they 
			are private. &lt;/p&gt;

		</info>
		<name>Avoid Changing Class/Method Accessibility At Runtime</name>
	</findingType>	
	<findingType>
		<id>ClassWithOnlyPrivateConstructorsShouldBeFinal</id>
		<artifact tool="PMD"
			mnemonic="ClassWithOnlyPrivateConstructorsShouldBeFinal">
		</artifact>
		<shortMessage>
			A class which only has private constructors should be final
		</shortMessage>
		<info>

			&lt;p&gt; A class with only private constructors should be final, 
			unless the private constructor is called by a inner class. &lt;/p&gt;

		</info>
		<name>Class With Only Private Constructors Should Be Final</name>
	</findingType>	
	<findingType>
		<id>EmptyMethodInAbstractClassShouldBeAbstract</id>
		<artifact tool="PMD"
			mnemonic="EmptyMethodInAbstractClassShouldBeAbstract">
		</artifact>
		<shortMessage>
			An empty method in an abstract class should instead be abstract
		</shortMessage>
		<info>

			&lt;p&gt; An empty method in an abstract class should instead be abstract,
			as developer may rely on this empty implementation, rather than code an 
			appropriate one. 
			&lt;/p&gt;

		</info>
		<name>Empty Method In Abstract Class Should Be Abstract</name>
	</findingType>	
	<findingType>
		<id>TooManyStaticImports</id>
		<artifact tool="PMD"
			mnemonic="TooManyStaticImports">
		</artifact>
		<shortMessage>
			Too many static imports may lead to messy code
		</shortMessage>
		<info>

			&lt;p&gt; If you overuse the static import feature, it can make your program
			unreadable and unmaintainable, polluting its namespace with all the static 
			members you import.  Readers of your code (including you, a few months after
			you wrote it) will not know which class a static member comes from (Sun 1.5 
			Language Guide). 
			&lt;/p&gt;

		</info>
		<name>Too Many Static Imports</name>
	</findingType>	
	<findingType>
		<id>DoNotCallSystemExit</id>
		<artifact tool="PMD"
			mnemonic="DoNotCallSystemExit">
		</artifact>
		<shortMessage>
			System.exit() should not be used in J2EE/JEE apps
		</shortMessage>
		<info>

			&lt;p&gt; Web applications should not call System.exit(), 
			since only the web container or the application server should stop the JVM. &lt;/p&gt;

		</info>
		<name>Do Not Call System.exit()</name>
	</findingType>	
	<findingType>
		<id>StaticEJBFieldShouldBeFinal</id>
		<artifact tool="PMD"
			mnemonic="StaticEJBFieldShouldBeFinal">
		</artifact>
		<shortMessage>
			EJB's shouldn't have non-final static fields
		</shortMessage>
		<info>

			&lt;p&gt; According to the J2EE specification (p.494), an EJB should not have
			any static fields with write access. However, static read-only fields are allowed. 
			This ensures proper behavior, especially when instances are distributed by the 
			container on several JREs.. &lt;/p&gt;

		</info>
		<name>Static EJB Fields Should Be Final</name>
	</findingType>	
	<findingType>
		<id>DoNotUseThreads</id>
		<artifact tool="PMD"
			mnemonic="DoNotUseThreads">
		</artifact>
		<shortMessage>
			To be J2EE-compliant, a web app should not use any threads
		</shortMessage>
		<info>

			&lt;p&gt; The J2EE specification explicitly forbid use of threads. &lt;/p&gt;

		</info>
		<name>Do Not Use Threads</name>
	</findingType>	

	<category>
		<id>Basic Rules</id>
		<findingType>EmptyCatchBlock</findingType>
		<findingType>EmptyIfStmt</findingType>
		<findingType>EmptyWhileStmt</findingType>
		<findingType>EmptyTryBlock</findingType>
		<findingType>EmptyFinallyBlock</findingType>
		<findingType>EmptySwitchStatements</findingType>
		<findingType>JumbledIncrementer</findingType>
		<findingType>ForLoopShouldBeWhileLoop</findingType>
		<findingType>UnnecessaryConversionTemporary</findingType>
		<findingType>OverrideBothEqualsAndHashcode</findingType>
		<findingType>DoubleCheckedLocking</findingType>
		<findingType>ReturnFromFinallyBlock</findingType>
		<!-- DUP <findingType>EmptySynchronizedBlock</findingType> -->
		<findingType>UnnecessaryReturn</findingType>
		<findingType>EmptyStaticInitializer</findingType>
		<findingType>UnconditionalIfStatement</findingType>
		<findingType>EmptyStatementNotInLoop</findingType>
		<findingType>BooleanInstantiation</findingType>
		<findingType>UnnecessaryFinalModifier</findingType>
		<findingType>CollapsibleIfStatements</findingType>
		<findingType>UselessOverridingMethod</findingType>
		<findingType>ClassCastExceptionWithToArray</findingType>
		<findingType>
			AvoidDecimalLiteralsInBigDecimalConstructor
		</findingType>
		<findingType>UselessOperationOnImmutable</findingType>
		<!--  DUP <findingType>MisplacedNullCheck</findingType> -->
		<findingType>UnusedNullCheckInEquals</findingType>
		<findingType>AvoidThreadGroup</findingType>
		<findingType>BrokenNullCheck</findingType>
		<findingType>BigIntegerInstantiation</findingType>
		<findingType>AvoidUsingOctalValues</findingType>
		<findingType>AvoidUsingHardCodedIP</findingType>
		<findingType>CheckResultSet</findingType>
		<name>Basic Rules</name>
		<description>
			The Basic Ruleset contains a collection of good practices
			which everyone should follow.
		</description>
	</category>
	<category>
		<id>Braces Rules</id>
		<findingType>IfStmtsMustUseBraces</findingType>
		<findingType>WhileLoopsMustUseBraces</findingType>
		<findingType>IfElseStmtsMustUseBraces</findingType>
		<findingType>ForLoopsMustUseBraces</findingType>
		<name>Braces Rules</name>
		<description>
			The Braces Ruleset contains a collection of braces rules.
		</description>
	</category>
	<category>
		<id>Clone Implementation Rules</id>
		<!-- DUP <findingType>ProperCloneImplementation<
		/findingType> -->
		<findingType>CloneThrowsCloneNotSupportedException</findingType>
		<!-- DUP <findingType>CloneMethodMustImplementCloneable</findingType>-->
		<name>Clone Implementation Rules</name>
		<description>
			The Clone Implementation ruleset contains a collection of
			rules that find questionable usages of the clone() method.
		</description>
	</category>
	<category>
		<id>Code Size Rules</id>
		<findingType>NPathComplexity</findingType>
		<findingType>ExcessiveMethodLength</findingType>
		<findingType>ExcessiveParameterList</findingType>
		<findingType>ExcessiveClassLength</findingType>
		<findingType>CyclomaticComplexity</findingType>
		<findingType>ExcessivePublicCount</findingType>
		<findingType>TooManyFields</findingType>
		<findingType>NcssMethodCount</findingType>
		<findingType>NcssTypeCount</findingType>
		<findingType>NcssConstructorCount</findingType>
		<name>Code Size Rules</name>
		<description>
			The Code Size Ruleset contains a collection of rules that
			find code size related problems.
		</description>
	</category>
	<category>
		<id>Controversial Rules</id>
		<findingType>UnnecessaryConstructor</findingType>
		<findingType>NullAssignment</findingType>
		<findingType>OnlyOneReturn</findingType>
		<findingType>UnusedModifier</findingType>
		<findingType>AssignmentInOperand</findingType>
		<findingType>AtLeastOneConstructor</findingType>
		<findingType>DontImportSun</findingType>
		<findingType>SuspiciousOctalEscape</findingType>
		<findingType>CallSuperInConstructor</findingType>
		<findingType>UnnecessaryParentheses</findingType>
		<findingType>SingularField</findingType>
		<findingType>DefaultPackage</findingType>
		<findingType>BooleanInversion</findingType>
		<findingType>DataflowAnomalyAnalysis</findingType>
		<findingType>AvoidAccessibilityAlteration</findingType>
		<findingType>AvoidFinalLocalVariable</findingType>
		<findingType>AvoidUsingNativeCode</findingType>
		<findingType>AvoidUsingShortType</findingType>
		<findingType>AvoidUsingVolatile</findingType>
		<name>Controversial Rules</name>
		<description>
			The Controversial Ruleset contains rules that, for whatever
			reason, are considered controversial. They are separated out
			here to allow people to include as they see fit via custom
			rulesets. This ruleset was initially created in response to
			discussions over UnnecessaryConstructorRule which Tom likes
			but most people really dislike :-)
		</description>
	</category>
	<category>
		<id>Coupling Rules</id>
		<findingType>CouplingBetweenObjects</findingType>
		<findingType>ExcessiveImports</findingType>
		<findingType>LooseCoupling</findingType>
		<name>Coupling Rules</name>
		<description>
			These are rules which find instances of high or
			inappropriate coupling between objects and packages.
		</description>
	</category>
	<category>
		<id>Design Rules</id>
		<findingType>UseSingleton</findingType>
		<findingType>SimplifyBooleanReturns</findingType>
		<findingType>SimplifyBooleanExpressions</findingType>
		<findingType>SwitchStmtsShouldHaveDefault</findingType>
		<findingType>AvoidDeeplyNestedIfStmts</findingType>
		<findingType>AvoidReassigningParameters</findingType>
		<findingType>SwitchDensity</findingType>
		<findingType>ConstructorCallsOverridableMethod</findingType>
		<findingType>AccessorClassGeneration</findingType>
		<findingType>FinalFieldCouldBeStatic</findingType>
		<findingType>CloseResource</findingType>
		<findingType>NonStaticInitializer</findingType>
		<findingType>DefaultLabelNotLastInSwitchStmt</findingType>
		<findingType>NonCaseLabelInSwitchStatement</findingType>
		<findingType>OptimizableToArrayCall</findingType>
		<findingType>BadComparison</findingType>
		<!--  DUP <findingType>EqualsNull</findingType> -->
		<findingType>ConfusingTernary</findingType>
		<findingType>InstantiationToGetClass</findingType>
		<findingType>IdempotentOperations</findingType>
		<findingType>SimpleDateFormatNeedsLocale</findingType>
		<findingType>ImmutableField</findingType>
		<findingType>UseLocaleWithCaseConversions</findingType>
		<findingType>AvoidProtectedFieldInFinalClass</findingType>
		<findingType>AssignmentToNonFinalStatic</findingType>
		<findingType>
			MissingStaticMethodInNonInstantiatableClass
		</findingType>
		<findingType>AvoidSynchronizedAtMethodLevel</findingType>
		<findingType>MissingBreakInSwitch</findingType>
		<!-- DUP <findingType>UseNotifyAllInsteadOfNotify</findingType> -->
		<findingType>AvoidInstanceofChecksInCatchClause</findingType>
		<findingType>AbstractClassWithoutAbstractMethod</findingType>
		<findingType>SimplifyConditional</findingType>
		<findingType>CompareObjectsWithEquals</findingType>
		<findingType>PositionLiteralsFirstInComparisons</findingType>
		<findingType>UnnecessaryLocalBeforeReturn</findingType>
		<findingType>NonThreadSafeSingleton</findingType>
		<findingType>UncommentedEmptyMethod</findingType>
		<findingType>UncommentedEmptyConstructor</findingType>
		<findingType>AvoidConstantsInterface</findingType>
		<findingType>UnsynchronizedStaticDateFormatter</findingType>
		<findingType>PreserveStackTrace</findingType>
		<findingType>UseCollectionIsEmpty</findingType>
		<findingType>ClassWithOnlyPrivateConstructorsShouldBeFinal</findingType>
		<findingType>EmptyMethodInAbstractClassShouldBeAbstract</findingType>
		<name>Design Rules</name>
		<description>
			The Design Ruleset contains a collection of rules that find
			questionable designs.
		</description>
	</category>
	<category>
		<id>Finalizer Rules</id>
		<!-- DUP <findingType>EmptyFinalizer</findingType> -->
		<!-- DUP <findingType>FinalizeOnlyCallsSuperFinalize</findingType> -->
		<findingType>FinalizeOverloaded</findingType>
		<!-- DUP <findingType>FinalizeDoesNotCallSuperFinalize</findingType> -->
		<!-- DUP <findingType>FinalizeShouldBeProtected</findingType> -->
		<!-- DUP <findingType>AvoidCallingFinalize</findingType> -->
		<name>Finalizer Rules</name>
		<description>
			These rules deal with different problems that can occur with
			finalizers.
		</description>
	</category>
	<category>
		<id>Import Statement Rules</id>
		<findingType>DuplicateImports</findingType>
		<findingType>DontImportJavaLang</findingType>
		<findingType>UnusedImports</findingType>
		<findingType>ImportFromSamePackage</findingType>
		<findingType>TooManyStaticImports</findingType>
		<name>Import Statement Rules</name>
		<description>
			These rules deal with different problems that can occur with
			a class' import statements.
		</description>
	</category>
	<category>
		<id>J2EE Rules</id>
		<findingType>UseProperClassLoader</findingType>
		<findingType>MDBAndSessionBeanNamingConvention</findingType>
		<findingType>
			RemoteSessionInterfaceNamingConvention
		</findingType>
		<findingType>LocalInterfaceSessionNamingConvention</findingType>
		<findingType>LocalHomeNamingConvention</findingType>
		<findingType>RemoteInterfaceNamingConvention</findingType>
		<findingType>DoNotCallSystemExit</findingType>
		<findingType>DoNotUseThreads</findingType>
		<findingType>StaticEJBFieldShouldBeFinal</findingType>
		<name>J2EE Rules</name>
		<description>These are rules for J2EE</description>
	</category>
	<category>
		<id>JavaBean Rules</id>
		<findingType>BeanMembersShouldSerialize</findingType>
		<findingType>MissingSerialVersionUID</findingType>
		<name>JavaBean Rules</name>
		<description>
			The JavaBeans Ruleset catches instances of bean rules not
			being followed.
		</description>
	</category>
	<category>
		<id>JUnit Rules</id>
		<findingType>JUnitStaticSuite</findingType>
		<findingType>JUnitSpelling</findingType>
		<findingType>JUnitAssertionsShouldIncludeMessage</findingType>
		<findingType>JUnitTestsShouldIncludeAssert</findingType>
		<findingType>TestClassWithoutTestCases</findingType>
		<findingType>UnnecessaryBooleanAssertion</findingType>
		<findingType>UseAssertEqualsInsteadOfAssertTrue</findingType>
		<findingType>UseAssertSameInsteadOfAssertTrue</findingType>
		<findingType>UseAssertNullInsteadOfAssertTrue</findingType>
		<findingType>SimplifyBooleanAssertion</findingType>
		<name>JUnit Rules</name>
		<description>
			These rules deal with different problems that can occur with
			JUnit tests.
		</description>
	</category>
	<category>
		<id>Jakarta Commons Logging Rules</id>
		<findingType>UseCorrectExceptionLogging</findingType>
		<findingType>ProperLogger</findingType>
		<name>Jakarta Commons Logging Rules</name>
		<description>
			The Jakarta Commons Logging ruleset contains a collection of
			rules that find questionable usages of that framework.
		</description>
	</category>
	<category>
		<id>Java Logging Rules</id>
		<findingType>MoreThanOneLogger</findingType>
		<findingType>LoggerIsNotStaticFinal</findingType>
		<findingType>SystemPrintln</findingType>
		<findingType>AvoidPrintStackTrace</findingType>
		<name>Java Logging Rules</name>
		<description>
			The Java Logging ruleset contains a collection of rules that
			find questionable usages of the logger.
		</description>
	</category>
	<category>
		<id>Migration Rules</id>
		<findingType>ReplaceVectorWithList</findingType>
		<findingType>ReplaceHashtableWithMap</findingType>
		<findingType>ReplaceEnumerationWithIterator</findingType>
		<findingType>AvoidEnumAsIdentifier</findingType>
		<findingType>AvoidAssertAsIdentifier</findingType>
		<!-- DUP <findingType>IntegerInstantiation</findingType> -->
		<findingType>ByteInstantiation</findingType>
		<findingType>ShortInstantiation</findingType>
		<findingType>LongInstantiation</findingType>
		<findingType>JUnit4TestShouldUseBeforeAnnotation</findingType>
		<findingType>JUnit4TestShouldUseAfterAnnotation</findingType>
		<findingType>JUnit4TestShouldUseTestAnnotation</findingType>
		<findingType>JUnit4SuitesShouldUseSuiteAnnotation</findingType>
		<findingType>JUnitUseExpected</findingType>
		<name>Migration Rules</name>
		<description>
			Contains rules about migrating from one JDK version to
			another. Don't use these rules directly, rather, use a
			wrapper ruleset such as migrating_to_13.xml.
		</description>
	</category>
	<category>
		<id>Naming Rules</id>
		<findingType>ShortVariable</findingType>
		<findingType>LongVariable</findingType>
		<findingType>ShortMethodName</findingType>
		<!-- DUP <findingType>VariableNamingConventions</findingType> -->
		<!-- DUP <findingType>MethodNamingConventions</findingType> -->
		<!-- DUP <findingType>ClassNamingConventions</findingType> -->
		<findingType>AbstractNaming</findingType>
		<findingType>AvoidDollarSigns</findingType>
		<findingType>MethodWithSameNameAsEnclosingClass</findingType>
		<!-- DUP <findingType>SuspiciousHashcodeMethodName</findingType> -->
		<findingType>SuspiciousConstantFieldName</findingType>
		<!-- DUP <findingType>SuspiciousEqualsMethodName</findingType> -->
		<findingType>AvoidFieldNameMatchingTypeName</findingType>
		<findingType>AvoidFieldNameMatchingMethodName</findingType>
		<findingType>NoPackage</findingType>
		<findingType>PackageCase</findingType>
		<findingType>MisleadingVariableName</findingType>
		<findingType>BooleanGetMethodName</findingType>
		<findingType>
			AvoidNonConstructorMethodsWithClassName
		</findingType>
		<name>Naming Rules</name>
		<description>
			The Naming Ruleset contains a collection of rules about
			names - too long, too short, and so forth.
		</description>
	</category>
	<category>
		<id>Optimization Rules</id>
		<findingType>LocalVariableCouldBeFinal</findingType>
		<findingType>MethodArgumentCouldBeFinal</findingType>
		<findingType>AvoidInstantiatingObjectsInLoops</findingType>
		<findingType>UseArrayListInsteadOfVector</findingType>
		<findingType>SimplifyStartsWith</findingType>
		<!--  DUP <findingType>UseStringBufferForStringAppends</findingType> -->
		<findingType>UseArraysAsList</findingType>
		<findingType>AvoidArrayLoops</findingType>
		<findingType>UnnecessaryWrapperObjectCreation</findingType>
		<findingType>AddEmptyString</findingType>
		<name>Optimization Rules</name>
		<description>
			These rules deal with different optimizations that generally
			apply to performance best practices.
		</description>
	</category>
	<category>
		<id>Strict Exception Rules</id>
		<findingType>AvoidCatchingThrowable</findingType>
		<findingType>SignatureDeclareThrowsException</findingType>
		<findingType>ExceptionAsFlowControl</findingType>
		<findingType>AvoidCatchingNPE</findingType>
		<findingType>AvoidThrowingRawExceptionTypes</findingType>
		<findingType>AvoidThrowingNullPointerException</findingType>
		<findingType>AvoidRethrowingException</findingType>
		<findingType>DoNotExtendJavaLangError</findingType>
		<name>Strict Exception Rules</name>
		<description>
			These rules provide some strict guidelines about throwing
			and catching exceptions.
		</description>
	</category>
	<category>
		<id>String and StringBuffer Rules</id>
		<findingType>AvoidDuplicateLiterals</findingType>
		<findingType>StringInstantiation</findingType>
		<findingType>StringToString</findingType>
		<findingType>InefficientStringBuffering</findingType>
		<findingType>UnnecessaryCaseChange</findingType>
		<findingType>UseStringBufferLength</findingType>
		<findingType>AppendCharacterWithChar</findingType>
		<findingType>ConsecutiveLiteralAppends</findingType>
		<findingType>UseIndexOfChar</findingType>
		<findingType>InefficientEmptyStringCheck</findingType>
		<findingType>InsufficientStringBufferDeclaration</findingType>
		<findingType>UselessStringValueOf</findingType>
		<findingType>StringBufferInstantiationWithChar</findingType>
		<name>String and StringBuffer Rules</name>
		<description>
			These rules deal with different problems that can occur with
			manipulation of the class String or StringBuffer.
		</description>
	</category>
	<category>
		<id>Security Code Guidelines</id>
		<findingType>MethodReturnsInternalArray</findingType>
		<findingType>ArrayIsStoredDirectly</findingType>
		<name>Security Code Guidelines</name>
		<description>
			These rules check the security guidelines from Sun,
			published at
			http://java.sun.com/security/seccodeguide.html#gcg
		</description>
	</category>
	<category>
		<id>Unused Code Rules</id>
		<!-- DUP <findingType>UnusedPrivateField</findingType> -->
		<findingType>UnusedLocalVariable</findingType>
		<findingType>UnusedPrivateMethod</findingType>
		<findingType>UnusedFormalParameter</findingType>
		<name>Unused Code Rules</name>
		<description>
			The Unused Code Ruleset contains a collection of rules that
			find unused code.
		</description>
	</category>
</findingTypes>
