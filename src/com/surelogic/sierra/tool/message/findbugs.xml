<?xml version="1.0" encoding="UTF-8"?>
<tns:findingTypes xmlns:tns="http://www.surelogic.com/sierra/1.0"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.surelogic.com/sierra/1.0 sierra.xsd ">
	<findingType>
		<id>SW_SWING_METHODS_INVOKED_IN_SWING_THREAD</id>
		<artifact tool="FindBugs"
			mnemonic="Swing Methods Invoked In Swing Thread">
		</artifact>
		<shortMessage>
			Certain swing methods needs to be invoked in Swing thread
		</shortMessage>
		<info>

			&lt;p&gt;(&lt;a
			href=&quot;http://java.sun.com/developer/JDCTechTips/2003/tt1208.html#1&quot;&gt;From
			JDC Tech Tip&lt;/a&gt;): The Swing methods show(),
			setVisible(), and pack() will create the associated peer for
			the frame. With the creation of the peer, the system creates
			the event dispatch thread. This makes things problematic
			because the event dispatch thread could be notifying
			listeners while pack and validate are still processing. This
			situation could result in two threads going through the
			Swing component-based GUI -- it's a serious flaw that could
			result in deadlocks or other related threading issues. A
			pack call causes components to be realized. As they are
			being realized (that is, not necessarily visible), they
			could trigger listener notification on the event dispatch
			thread.&lt;/p&gt;


		</info>
		<name>Swing Methods Invoked In Swing Thread</name>
	</findingType>
	<findingType>
		<id>IL_INFINITE_LOOP</id>
		<artifact tool="FindBugs" mnemonic="Infinite Loop"></artifact>
		<shortMessage>An apparent infinite loop</shortMessage>
		<info>

			&lt;p&gt;This loop doesn't seem to have a way to terminate
			(other than by perhaps throwing an exception).&lt;/p&gt;

		</info>
		<name>Infinite Loop</name>
	</findingType>
	<findingType>
		<id>IL_INFINITE_RECURSIVE_LOOP</id>
		<artifact tool="FindBugs" mnemonic="Infinite Recursive Loop">
		</artifact>
		<shortMessage>An apparent infinite recursive loop</shortMessage>
		<info>

			&lt;p&gt;This method unconditionally invokes itself. This
			would seem to indicate an infinite recursive loop that will
			result in a stack overflow.&lt;/p&gt;

		</info>
		<name>Infinite Recursive Loop</name>
	</findingType>
	<findingType>
		<id>IL_CONTAINER_ADDED_TO_ITSELF</id>
		<artifact tool="FindBugs"
			mnemonic="Container Added To Itself">
		</artifact>
		<shortMessage>A container is added to itself</shortMessage>
		<info>

			&lt;p&gt;A container is added to itself. As a result,
			computing the hashCode of this set will throw a
			StackOverflowException. &lt;/p&gt;

		</info>
		<name>Container Added To Itself</name>
	</findingType>
	<findingType>
		<id>VO_VOLATILE_REFERENCE_TO_ARRAY</id>
		<artifact tool="FindBugs"
			mnemonic="Volatile Reference To Array">
		</artifact>
		<shortMessage>
			A volatile reference to an array doesn't treat the array
			elements as volatile
		</shortMessage>
		<info>

			&lt;p&gt;This declares a volatile reference to an array,
			which might not be what you want. With a volatile reference
			to an array, reads and writes of the reference to the array
			are treated as volatile, but the array elements are
			non-volatile. To get volatile array elements, you will need
			to use one of the atomic array classes in
			java.util.concurrent (provided in Java 5.0).&lt;/p&gt;

		</info>
		<name>Volatile Reference To Array</name>
	</findingType>
	<findingType>
		<id>UI_INHERITANCE_UNSAFE_GETRESOURCE</id>
		<artifact tool="FindBugs"
			mnemonic="Inheritance Unsafe Getresource">
		</artifact>
		<shortMessage>
			Usage of GetResource may be unsafe if class is extended
		</shortMessage>
		<info>

			&lt;p&gt;Calling
			&lt;code&gt;this.getClass().getResource(...)&lt;/code&gt;
			could give results other than expected if this class is
			extended by a class in another package.&lt;/p&gt;

		</info>
		<name>Inheritance Unsafe Getresource</name>
	</findingType>
	<findingType>
		<id>NP_SYNC_AND_NULL_CHECK_FIELD</id>
		<artifact tool="FindBugs"
			mnemonic="Sync And Null Check Field">
		</artifact>
		<shortMessage>
			Synchronize and null check on the same field.
		</shortMessage>
		<info>

			&lt;p&gt;Since field is synchronized on, it seems not likely
			to be null. If it is null and then synchronized on a
			NullPointerException will be thrown and the check would be
			pointless. Better to synchronize on another field.&lt;/p&gt;


		</info>
		<name>Sync And Null Check Field</name>
	</findingType>
	<findingType>
		<id>TESTING</id>
		<artifact tool="FindBugs" mnemonic="Testing"></artifact>
		<shortMessage>Testing</shortMessage>
		<info>

			&lt;p&gt;This bug pattern is only generated by new,
			incompletely implemented bug detectors.&lt;/p&gt;

		</info>
		<name>Testing</name>
	</findingType>
	<findingType>
		<id>UNKNOWN</id>
		<artifact tool="FindBugs" mnemonic="Unknown"></artifact>
		<shortMessage>Unknown bug pattern</shortMessage>
		<info>

			&lt;p&gt;A warning was recorded, but findbugs can't find the
			description of this bug pattern and so can't describe it.
			This should occur only in cases of a bug in FindBugs or its
			configuration, or perhaps if an analysis was generated using
			a plugin, but that plugin is not currently loaded.
			.&lt;/p&gt;

		</info>
		<name>Unknown</name>
	</findingType>
	<findingType>
		<id>AM_CREATES_EMPTY_ZIP_FILE_ENTRY</id>
		<artifact tool="FindBugs"
			mnemonic="Creates Empty Zip File Entry">
		</artifact>
		<shortMessage>Creates an empty zip file entry</shortMessage>
		<info>

			&lt;p&gt;The code calls
			&lt;code&gt;putNextEntry()&lt;/code&gt;, immediately
			followed by a call to &lt;code&gt;closeEntry()&lt;/code&gt;.
			This results in an empty ZipFile entry. The contents of the
			entry should be written to the ZipFile between the calls to
			&lt;code&gt;putNextEntry()&lt;/code&gt; and
			&lt;code&gt;closeEntry()&lt;/code&gt;.&lt;/p&gt;

		</info>
		<name>Creates Empty Zip File Entry</name>
	</findingType>
	<findingType>
		<id>AM_CREATES_EMPTY_JAR_FILE_ENTRY</id>
		<artifact tool="FindBugs"
			mnemonic="Creates Empty Jar File Entry">
		</artifact>
		<shortMessage>Creates an empty jar file entry</shortMessage>
		<info>

			&lt;p&gt;The code calls
			&lt;code&gt;putNextEntry()&lt;/code&gt;, immediately
			followed by a call to &lt;code&gt;closeEntry()&lt;/code&gt;.
			This results in an empty JarFile entry. The contents of the
			entry should be written to the JarFile between the calls to
			&lt;code&gt;putNextEntry()&lt;/code&gt; and
			&lt;code&gt;closeEntry()&lt;/code&gt;.&lt;/p&gt;

		</info>
		<name>Creates Empty Jar File Entry</name>
	</findingType>
	<findingType>
		<id>IMSE_DONT_CATCH_IMSE</id>
		<artifact tool="FindBugs" mnemonic="Dont Catch Imse"></artifact>
		<shortMessage>
			Dubious catching of IllegalMonitorStateException
		</shortMessage>
		<info>

			&lt;p&gt;IllegalMonitorStateException is generally only
			thrown in case of a design flaw in your code (calling wait
			or notify on an object you do not hold a lock on).&lt;/p&gt;

		</info>
		<name>Dont Catch Imse</name>
	</findingType>
	<findingType>
		<id>FL_MATH_USING_FLOAT_PRECISION</id>
		<artifact tool="FindBugs"
			mnemonic="Math Using Float Precision">
		</artifact>
		<shortMessage>
			Method performs math using floating point precision
		</shortMessage>
		<info>

			&lt;p&gt; The method performs math operations using floating
			point precision. Floating point precision is very imprecise.
			For example, 16777216.0f + 1.0f = 16777216.0f. Consider
			using double math instead.&lt;/p&gt;

		</info>
		<name>Math Using Float Precision</name>
	</findingType>
	<findingType>
		<id>CN_IDIOM</id>
		<artifact tool="FindBugs" mnemonic="Idiom"></artifact>
		<shortMessage>
			Class implements Cloneable but does not define or use clone
			method
		</shortMessage>
		<info>

			&lt;p&gt; Class implements Cloneable but does not define or
			use the clone method.&lt;/p&gt;

		</info>
		<name>Idiom</name>
	</findingType>
	<findingType>
		<id>CN_IDIOM_NO_SUPER_CALL</id>
		<artifact tool="FindBugs" mnemonic="Idiom No Super Call">
		</artifact>
		<shortMessage>
			clone method does not call super.clone()
		</shortMessage>
		<info>

			&lt;p&gt; This non-final class defines a clone() method that
			does not call super.clone(). If this class
			(&quot;&lt;i&gt;A&lt;/i&gt;&quot;) is extended by a subclass
			(&quot;&lt;i&gt;B&lt;/i&gt;&quot;), and the subclass
			&lt;i&gt;B&lt;/i&gt; calls super.clone(), then it is likely
			that &lt;i&gt;B&lt;/i&gt;'s clone() method will return an
			object of type &lt;i&gt;A&lt;/i&gt;, which violates the
			standard contract for clone().&lt;/p&gt;

			&lt;p&gt; If all clone() methods call super.clone(), then
			they are guaranteed to use Object.clone(), which always
			returns an object of the correct type.&lt;/p&gt;

		</info>
		<name>Idiom No Super Call</name>
	</findingType>
	<findingType>
		<id>NM_FUTURE_KEYWORD_USED_AS_IDENTIFIER</id>
		<artifact tool="FindBugs"
			mnemonic="Future Keyword Used As Identifier">
		</artifact>
		<shortMessage>
			Use of identifier that is a keyword in later versions of
			Java
		</shortMessage>
		<info>

			&lt;p&gt;The identifier is a word that is reserversed as a
			keyword in later versions of Java, and your code will need
			to be changed in order to compile it in later versions of
			Java.&lt;/p&gt;


		</info>
		<name>Future Keyword Used As Identifier</name>
	</findingType>
	<findingType>
		<id>NM_FUTURE_KEYWORD_USED_AS_MEMBER_IDENTIFIER</id>
		<artifact tool="FindBugs"
			mnemonic="Future Keyword Used As Member Identifier">
		</artifact>
		<shortMessage>
			Use of identifier that is a keyword in later versions of
			Java
		</shortMessage>
		<info>

			&lt;p&gt;This identifier is used as a keyword in later
			versions of Java. This code, and any code that references
			this API, will need to be changed in order to compile it in
			later versions of Java.&lt;/p&gt;


		</info>
		<name>Future Keyword Used As Member Identifier</name>
	</findingType>
	<findingType>
		<id>DE_MIGHT_DROP</id>
		<artifact tool="FindBugs" mnemonic="Might Drop"></artifact>
		<shortMessage>Method might drop exception</shortMessage>
		<info>

			&lt;p&gt; This method might drop an exception.&amp;nbsp; In
			general, exceptions should be handled or reported in some
			way, or they should be thrown out of the method.&lt;/p&gt;

		</info>
		<name>Might Drop</name>
	</findingType>
	<findingType>
		<id>DE_MIGHT_IGNORE</id>
		<artifact tool="FindBugs" mnemonic="Might Ignore"></artifact>
		<shortMessage>Method might ignore exception</shortMessage>
		<info>

			&lt;p&gt; This method might ignore an exception.&amp;nbsp;
			In general, exceptions should be handled or reported in some
			way, or they should be thrown out of the method.&lt;/p&gt;

		</info>
		<name>Might Ignore</name>
	</findingType>
	<findingType>
		<id>DP_DO_INSIDE_DO_PRIVILEGED</id>
		<artifact tool="FindBugs" mnemonic="Do Inside Do Privileged">
		</artifact>
		<shortMessage>
			Method invoked that should be only be invoked inside a
			doPrivileged block
		</shortMessage>
		<info>

			&lt;p&gt; This code invokes a method that requires a
			security permission check. If this code will be granted
			security permissions, but might be invoked by code that does
			not have security permissions, then the invocation needs to
			occur inside a doPrivileged block.&lt;/p&gt;

		</info>
		<name>Do Inside Do Privileged</name>
	</findingType>
	<findingType>
		<id>DP_DO_INSIDE_DO_PRIVILEDGED</id>
		<artifact tool="FindBugs" mnemonic="Do Inside Do Priviledged">
		</artifact>
		<shortMessage>
			Method invoked that should be only be invoked inside a
			doPrivileged block
		</shortMessage>
		<info>

			&lt;p&gt; This code invokes a method that requires a
			security permission check. If this code will be granted
			security permissions, but might be invoked by code that does
			not have security permissions, then the invocation needs to
			occur inside a doPrivileged block.&lt;/p&gt;

		</info>
		<name>Do Inside Do Priviledged</name>
	</findingType>
	<findingType>
		<id>DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED</id>
		<artifact tool="FindBugs"
			mnemonic="Create Classloader Inside Do Privileged">
		</artifact>
		<shortMessage>
			Classloaders should only be created inside doPrivileged
			block
		</shortMessage>
		<info>

			&lt;p&gt; This code creates a classloader, which requires a
			security manager. If this code will be granted security
			permissions, but might be invoked by code that does not have
			security permissions, then the classloader creation needs to
			occur inside a doPrivileged block.&lt;/p&gt;

		</info>
		<name>Create Classloader Inside Do Privileged</name>
	</findingType>
	<findingType>
		<id>DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEDGED</id>
		<artifact tool="FindBugs"
			mnemonic="Create Classloader Inside Do Priviledged">
		</artifact>
		<shortMessage>
			Classloaders should only be created inside doPrivileged
			block
		</shortMessage>
		<info>

			&lt;p&gt; This code creates a classloader, which requires a
			security manager. If this code will be granted security
			permissions, but might be invoked by code that does not have
			security permissions, then the classloader creation needs to
			occur inside a doPrivileged block.&lt;/p&gt;

		</info>
		<name>Create Classloader Inside Do Priviledged</name>
	</findingType>
	<findingType>
		<id>JCIP_FIELD_ISNT_FINAL_IN_IMMUTABLE_CLASS</id>
		<artifact tool="FindBugs"
			mnemonic="Field Isnt Final In Immutable Class">
		</artifact>
		<shortMessage>
			Fields of immutable classes should be final
		</shortMessage>
		<info>

			&lt;p&gt; The class is annotated with
			net.jcip.annotations.Immutable, and the rules for that
			annotation require that all fields are final. .&lt;/p&gt;

		</info>
		<name>Field Isnt Final In Immutable Class</name>
	</findingType>
	<findingType>
		<id>DMI_THREAD_PASSED_WHERE_RUNNABLE_EXPECTED</id>
		<artifact tool="FindBugs"
			mnemonic="Thread Passed Where Runnable Expected">
		</artifact>
		<shortMessage>
			Thread passed where Runnable expected
		</shortMessage>
		<info>

			&lt;p&gt; A Thread object is passed as a parameter to a
			method where a Runnable is expected. This is rather unusual,
			and may indicate a logic error or cause unexpected behavior.
			&lt;/p&gt;

		</info>
		<name>Thread Passed Where Runnable Expected</name>
	</findingType>
	<findingType>
		<id>DMI_COLLECTION_OF_URLS</id>
		<artifact tool="FindBugs" mnemonic="Collection Of Urls">
		</artifact>
		<shortMessage>
			Maps and sets of URLs can be performance hogs
		</shortMessage>
		<info>

			&lt;p&gt; This method or field is or uses a Map or Set of
			URLs. Since both the equals and hashCode method of URL
			perform domain name resolution, this can result in a big
			performance hit. See &lt;a
			href=&quot;http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html&quot;&gt;http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html&lt;/a&gt;
			for more information. Consider using
			&lt;code&gt;java.net.URI&lt;/code&gt; instead. &lt;/p&gt;

		</info>
		<name>Collection Of Urls</name>
	</findingType>
	<findingType>
		<id>DMI_BLOCKING_METHODS_ON_URL</id>
		<artifact tool="FindBugs" mnemonic="Blocking Methods On Url">
		</artifact>
		<shortMessage>
			The equals and hashCode methods of URL are blocking
		</shortMessage>
		<info>

			&lt;p&gt; The equals and hashCode method of URL perform
			domain name resolution, this can result in a big performance
			hit. See &lt;a
			href=&quot;http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html&quot;&gt;http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html&lt;/a&gt;
			for more information. Consider using
			&lt;code&gt;java.net.URI&lt;/code&gt; instead. &lt;/p&gt;

		</info>
		<name>Blocking Methods On Url</name>
	</findingType>
	<findingType>
		<id>DMI_ANNOTATION_IS_NOT_VISIBLE_TO_REFLECTION</id>
		<artifact tool="FindBugs"
			mnemonic="Annotation Is Not Visible To Reflection">
		</artifact>
		<shortMessage>
			Can't use reflection to check for presence of annotation
			with default retention
		</shortMessage>
		<info>

			&lt;p&gt; Unless an annotation has itself been annotated
			with a @Retention other than the default of source-only
			retention, the annotation isn't retained in the classfile
			and can't be observed using reflection (e.g., by using the
			isAnnotationPresent method). .&lt;/p&gt;

		</info>
		<name>Annotation Is Not Visible To Reflection</name>
	</findingType>
	<findingType>
		<id>DM_EXIT</id>
		<artifact tool="FindBugs" mnemonic="Exit"></artifact>
		<shortMessage>Method invokes System.exit(...)</shortMessage>
		<info>

			&lt;p&gt; Invoking System.exit shuts down the entire Java
			virtual machine. This should only been done when it is
			appropriate. Such calls make it hard or impossible for your
			code to be invoked by other code. Consider throwing a
			RuntimeException instead.&lt;/p&gt;

		</info>
		<name>Exit</name>
	</findingType>
	<findingType>
		<id>DM_RUN_FINALIZERS_ON_EXIT</id>
		<artifact tool="FindBugs" mnemonic="Run Finalizers On Exit">
		</artifact>
		<shortMessage>
			Method invokes dangerous method runFinalizersOnExit
		</shortMessage>
		<info>

			&lt;p&gt; &lt;em&gt;Never call System.runFinalizersOnExit or
			Runtime.runFinalizersOnExit for any reason: they are among
			the most dangerous methods in the Java libraries.&lt;/em&gt;
			-- Joshua Bloch&lt;/p&gt;

		</info>
		<name>Run Finalizers On Exit</name>
	</findingType>
	<findingType>
		<id>DM_STRING_CTOR</id>
		<artifact tool="FindBugs" mnemonic="String Ctor"></artifact>
		<shortMessage>
			Method invokes inefficient new String(String) constructor
		</shortMessage>
		<info>

			&lt;p&gt; Using the
			&lt;code&gt;java.lang.String(String)&lt;/code&gt;
			constructor wastes memory because the object so constructed
			will be functionally indistinguishable from the
			&lt;code&gt;String&lt;/code&gt; passed as a
			parameter.&amp;nbsp; Just use the argument
			&lt;code&gt;String&lt;/code&gt; directly.&lt;/p&gt;

		</info>
		<name>String Ctor</name>
	</findingType>
	<findingType>
		<id>DM_STRING_VOID_CTOR</id>
		<artifact tool="FindBugs" mnemonic="String Void Ctor">
		</artifact>
		<shortMessage>
			Method invokes inefficient new String() constructor
		</shortMessage>
		<info>

			&lt;p&gt; Creating a new
			&lt;code&gt;java.lang.String&lt;/code&gt; object using the
			no-argument constructor wastes memory because the object so
			created will be functionally indistinguishable from the
			empty string constant
			&lt;code&gt;&quot;&quot;&lt;/code&gt;.&amp;nbsp; Java
			guarantees that identical string constants will be
			represented by the same &lt;code&gt;String&lt;/code&gt;
			object.&amp;nbsp; Therefore, you should just use the empty
			string constant directly.&lt;/p&gt;

		</info>
		<name>String Void Ctor</name>
	</findingType>
	<findingType>
		<id>DM_STRING_TOSTRING</id>
		<artifact tool="FindBugs" mnemonic="String Tostring"></artifact>
		<shortMessage>
			Method invokes toString() method on a String
		</shortMessage>
		<info>

			&lt;p&gt; Calling &lt;code&gt;String.toString()&lt;/code&gt;
			is just a redundant operation. Just use the
			String.&lt;/p&gt;

		</info>
		<name>String Tostring</name>
	</findingType>
	<findingType>
		<id>DM_GC</id>
		<artifact tool="FindBugs" mnemonic="Gc"></artifact>
		<shortMessage>
			Explicit garbage collection; extremely dubious except in
			benchmarking code
		</shortMessage>
		<info>

			&lt;p&gt; Code explicitly invokes garbage collection. Except
			for specific use in benchmarking, this is very
			dubious.&lt;/p&gt; &lt;p&gt;In the past, situations where
			people have explicitly invoked the garbage collector in
			routines such as close or finalize methods has led to huge
			performance black holes. Garbage collection can be
			expensive. Any situation that forces hundreds or thousands
			of garbage collections will bring the machine to a
			crawl.&lt;/p&gt;

		</info>
		<name>Gc</name>
	</findingType>
	<findingType>
		<id>DM_BOOLEAN_CTOR</id>
		<artifact tool="FindBugs" mnemonic="Boolean Ctor"></artifact>
		<shortMessage>
			Method invokes inefficient Boolean constructor; use
			Boolean.valueOf(...) instead
		</shortMessage>
		<info>

			&lt;p&gt; Creating new instances of
			&lt;code&gt;java.lang.Boolean&lt;/code&gt; wastes memory,
			since &lt;code&gt;Boolean&lt;/code&gt; objects are immutable
			and there are only two useful values of this type.&amp;nbsp;
			Use the &lt;code&gt;Boolean.valueOf()&lt;/code&gt; method
			(or Java 1.5 autoboxing) to create
			&lt;code&gt;Boolean&lt;/code&gt; objects instead.&lt;/p&gt;

		</info>
		<name>Boolean Ctor</name>
	</findingType>
	<findingType>
		<id>DM_NUMBER_CTOR</id>
		<artifact tool="FindBugs" mnemonic="Number Ctor"></artifact>
		<shortMessage>
			Method invokes inefficient Number constructor; use static
			valueOf instead
		</shortMessage>
		<info>

			&lt;p&gt; Using &lt;code&gt;new Integer(int)&lt;/code&gt; is
			guaranteed to always result in a new object whereas
			&lt;code&gt;Integer.valueOf(int)&lt;/code&gt; allows caching
			of values to be done by the compiler, class library, or JVM.
			Using of cached values avoids object allocation and the code
			will be faster. &lt;/p&gt; &lt;p&gt; Values between -128 and
			127 are guaranteed to have corresponding cached instances
			and using &lt;code&gt;valueOf&lt;/code&gt; is approximately
			3.5 times faster than using constructor. For values outside
			the constant range the performance of both styles is the
			same. &lt;/p&gt; &lt;p&gt; Unless the class must be
			compatible with JVMs predating Java 1.5, use either
			autoboxing or the &lt;code&gt;valueOf()&lt;/code&gt; method
			when creating instances of &lt;code&gt;Long&lt;/code&gt;,
			&lt;code&gt;Integer&lt;/code&gt;,
			&lt;code&gt;Short&lt;/code&gt;,
			&lt;code&gt;Character&lt;/code&gt;, and
			&lt;code&gt;Byte&lt;/code&gt;. &lt;/p&gt;

		</info>
		<name>Number Ctor</name>
	</findingType>
	<findingType>
		<id>DM_FP_NUMBER_CTOR</id>
		<artifact tool="FindBugs" mnemonic="Fp Number Ctor"></artifact>
		<shortMessage>
			Method invokes inefficient floating-point Number
			constructor; use static valueOf instead
		</shortMessage>
		<info>

			&lt;p&gt; Using &lt;code&gt;new Double(double)&lt;/code&gt;
			is guaranteed to always result in a new object whereas
			&lt;code&gt;Double.valueOf(double)&lt;/code&gt; allows
			caching of values to be done by the compiler, class library,
			or JVM. Using of cached values avoids object allocation and
			the code will be faster. &lt;/p&gt; &lt;p&gt; Unless the
			class must be compatible with JVMs predating Java 1.5, use
			either autoboxing or the &lt;code&gt;valueOf()&lt;/code&gt;
			method when creating instances of
			&lt;code&gt;Double&lt;/code&gt; and
			&lt;code&gt;Float&lt;/code&gt;. &lt;/p&gt;

		</info>
		<name>Fp Number Ctor</name>
	</findingType>
	<findingType>
		<id>DM_STRING_EMPTY_EQUALS</id>
		<artifact tool="FindBugs" mnemonic="String Empty Equals">
		</artifact>
		<shortMessage>
			Method invokes inefficient String.equals(&quot;&quot;); use
			String.length() == 0 instead
		</shortMessage>
		<info>

			&lt;p&gt; An object is compared to the empty String object
			using the equals() method here. Checking that the String
			object's length is zero may be faster, and removes String
			constants from the class file.&lt;/p&gt;

		</info>
		<name>String Empty Equals</name>
	</findingType>
	<findingType>
		<id>DM_CONVERT_CASE</id>
		<artifact tool="FindBugs" mnemonic="Convert Case"></artifact>
		<shortMessage>
			Consider using Locale parameterized version of invoked
			method
		</shortMessage>
		<info>

			&lt;p&gt; A String is being converted to upper or lowercase,
			using the platform's default encoding. This may result in
			improper conversions when used with international
			characters. Use the &lt;/p&gt;
			&lt;table&gt;&lt;tr&gt;&lt;td&gt;String.toUpperCase( Locale
			l
			)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;String.toLowerCase(
			Locale l )&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
			&lt;p&gt;versions instead.&lt;/p&gt;

		</info>
		<name>Convert Case</name>
	</findingType>
	<findingType>
		<id>BX_UNBOXED_AND_COERCED_FOR_TERNARY_OPERATOR</id>
		<artifact tool="FindBugs"
			mnemonic="Unboxed And Coerced For Ternary Operator">
		</artifact>
		<shortMessage>
			Primitive value is unboxed and coerced for ternary operator
		</shortMessage>
		<info>

			&lt;p&gt;A wrapped primative value is unboxed and converted
			to another primative type as part of the evaluation of a
			conditional ternary operator (the &lt;code&gt; b ? e1 :
			e2&lt;/code&gt; operator). The semantics of Java mandate
			that if &lt;code&gt;e1&lt;/code&gt; and
			&lt;code&gt;e2&lt;/code&gt; are wrapped numeric values, the
			values are unboxed and converted/coerced to their common
			type (e.g, if &lt;code&gt;e1&lt;/code&gt; is of type
			&lt;code&gt;Integer&lt;/code&gt; and
			&lt;code&gt;e2&lt;/code&gt; is of type
			&lt;code&gt;Float&lt;/code&gt;, then
			&lt;code&gt;e1&lt;/code&gt; is unboxed, converted to a
			floating point value, and boxed. See JLS Section 15.25.
			&lt;/p&gt;

		</info>
		<name>Unboxed And Coerced For Ternary Operator</name>
	</findingType>
	<findingType>
		<id>BX_BOXING_IMMEDIATELY_UNBOXED</id>
		<artifact tool="FindBugs"
			mnemonic="Boxing Immediately Unboxed">
		</artifact>
		<shortMessage>
			Primitive value is boxed and then immediately unboxed
		</shortMessage>
		<info>

			&lt;p&gt;A primitive is boxed, and then immediately unboxed.
			This probably is due to a manual boxing in a place where an
			unboxed value is required, thus forcing the compiler to
			immediately undue the work of the boxing. &lt;/p&gt;

		</info>
		<name>Boxing Immediately Unboxed</name>
	</findingType>
	<findingType>
		<id>BX_BOXING_IMMEDIATELY_UNBOXED_TO_PERFORM_COERCION</id>
		<artifact tool="FindBugs"
			mnemonic="Boxing Immediately Unboxed To Perform Coercion">
		</artifact>
		<shortMessage>
			Primitive value is boxed then unboxed to perform primative
			coercion
		</shortMessage>
		<info>

			&lt;p&gt;A primitive boxed value constructed and then
			immediately converted into a different primitive type (e.g.,
			&lt;code&gt;new Double(d).intValue()&lt;/code&gt;). Just
			perform direct primitive coercion (e.g., &lt;code&gt;(int)
			d&lt;/code&gt;).&lt;/p&gt;

		</info>
		<name>Boxing Immediately Unboxed To Perform Coercion</name>
	</findingType>
	<findingType>
		<id>DM_BOXED_PRIMITIVE_TOSTRING</id>
		<artifact tool="FindBugs" mnemonic="Boxed Primitive Tostring">
		</artifact>
		<shortMessage>
			Method allocates a boxed primitive just to call toString
		</shortMessage>
		<info>

			&lt;p&gt;A boxed primitive is allocated just to call
			toString(). It is more effective to just use the static form
			of toString which takes the primitive value. So,&lt;/p&gt;
			&lt;table&gt;
			&lt;tr&gt;&lt;th&gt;Replace...&lt;/th&gt;&lt;th&gt;With
			this...&lt;/th&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;new
			Integer(1).toString()&lt;/td&gt;&lt;td&gt;Integer.toString(1)&lt;/td&gt;&lt;/tr&gt;
			&lt;tr&gt;&lt;td&gt;new
			Long(1).toString()&lt;/td&gt;&lt;td&gt;Long.toString(1)&lt;/td&gt;&lt;/tr&gt;
			&lt;tr&gt;&lt;td&gt;new
			Float(1.0).toString()&lt;/td&gt;&lt;td&gt;Float.toString(1.0)&lt;/td&gt;&lt;/tr&gt;
			&lt;tr&gt;&lt;td&gt;new
			Double(1.0).toString()&lt;/td&gt;&lt;td&gt;Double.toString(1.0)&lt;/td&gt;&lt;/tr&gt;
			&lt;tr&gt;&lt;td&gt;new
			Byte(1).toString()&lt;/td&gt;&lt;td&gt;Byte.toString(1)&lt;/td&gt;&lt;/tr&gt;
			&lt;tr&gt;&lt;td&gt;new
			Short(1).toString()&lt;/td&gt;&lt;td&gt;Short.toString(1)&lt;/td&gt;&lt;/tr&gt;
			&lt;tr&gt;&lt;td&gt;new
			Boolean(true).toString()&lt;/td&gt;&lt;td&gt;Boolean.toString(true)&lt;/td&gt;&lt;/tr&gt;
			&lt;/table&gt;

		</info>
		<name>Boxed Primitive Tostring</name>
	</findingType>
	<findingType>
		<id>DM_NEW_FOR_GETCLASS</id>
		<artifact tool="FindBugs" mnemonic="New For Getclass">
		</artifact>
		<shortMessage>
			Method allocates an object, only to get the class object
		</shortMessage>
		<info>

			&lt;p&gt;This method allocates an object just to call
			getClass() on it, in order to retrieve the Class object for
			it. It is simpler to just access the .class property of the
			class.&lt;/p&gt;

		</info>
		<name>New For Getclass</name>
	</findingType>
	<findingType>
		<id>DM_MONITOR_WAIT_ON_CONDITION</id>
		<artifact tool="FindBugs"
			mnemonic="Monitor Wait On Condition">
		</artifact>
		<shortMessage>Monitor wait() called on Condition</shortMessage>
		<info>

			&lt;p&gt; This method calls &lt;code&gt;wait()&lt;/code&gt;
			on a
			&lt;code&gt;java.util.concurrent.locks.Condition&lt;/code&gt;
			object.&amp;nbsp; Waiting for a
			&lt;code&gt;Condition&lt;/code&gt; should be done using one
			of the &lt;code&gt;await()&lt;/code&gt; methods defined by
			the &lt;code&gt;Condition&lt;/code&gt; interface. &lt;/p&gt;

		</info>
		<name>Monitor Wait On Condition</name>
	</findingType>
	<findingType>
		<id>RV_01_TO_INT</id>
		<artifact tool="FindBugs" mnemonic="01 To Int"></artifact>
		<shortMessage>
			Random value from 0 to 1 is coerced to the integer 0
		</shortMessage>
		<info>

			&lt;p&gt;A random value from 0 to 1 is being coerced to the
			integer value 0. You probably want to multiple the random
			value by something else before coercing it to an integer, or
			use the Random.nextInt(n) method. &lt;/p&gt;

		</info>
		<name>01 To Int</name>
	</findingType>
	<findingType>
		<id>DM_NEXTINT_VIA_NEXTDOUBLE</id>
		<artifact tool="FindBugs" mnemonic="Nextint Via Nextdouble">
		</artifact>
		<shortMessage>
			Use the nextInt method of Random rather than nextDouble to
			generate a random integer
		</shortMessage>
		<info>

			&lt;p&gt;If r is a java.util.Random, you can generate a
			random number from 0 to n-1 using r.nextInt(n) Rather than
			using (int)(r.nextDouble() * n). &lt;/p&gt;

		</info>
		<name>Nextint Via Nextdouble</name>
	</findingType>
	<findingType>
		<id>SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE</id>
		<artifact tool="FindBugs"
			mnemonic="Nonconstant String Passed To Execute">
		</artifact>
		<shortMessage>
			Nonconstant string passed to execute method on an SQL
			statement
		</shortMessage>
		<info>

			&lt;p&gt;The method invokes the execute method on an SQL
			statement with a String that seems to be dynamically
			generated. Consider using a prepared statement instead. It
			is more efficient and less vulnerable to SQL injection
			attacks. &lt;/p&gt;

		</info>
		<name>Nonconstant String Passed To Execute</name>
	</findingType>
	<findingType>
		<id>
			SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING
		</id>
		<artifact tool="FindBugs"
			mnemonic="Prepared Statement Generated From Nonconstant String">
		</artifact>
		<shortMessage>
			A prepared statement is generated from a nonconstant String
		</shortMessage>
		<info>

			&lt;p&gt;The code creates an SQL prepared statement from a
			nonconstant String. If unchecked, tainted data from a user
			is used in building this String, SQL injection could be used
			to make the prepared statement do something unexpected and
			undesirable. &lt;/p&gt;

		</info>
		<name>
			Prepared Statement Generated From Nonconstant String
		</name>
	</findingType>
	<findingType>
		<id>DM_USELESS_THREAD</id>
		<artifact tool="FindBugs" mnemonic="Useless Thread"></artifact>
		<shortMessage>
			A thread was created using the default empty run method
		</shortMessage>
		<info>

			&lt;p&gt;This method creates a thread without specifying a
			run method either by deriving from the Thread class, or by
			passing a Runnable object. This thread, then, does nothing
			but waste time. &lt;/p&gt;

		</info>
		<name>Useless Thread</name>
	</findingType>
	<findingType>
		<id>DC_DOUBLECHECK</id>
		<artifact tool="FindBugs" mnemonic="Doublecheck"></artifact>
		<shortMessage>Possible double check of field</shortMessage>
		<info>

			&lt;p&gt; This method may contain an instance of
			double-checked locking.&amp;nbsp; This idiom is not correct
			according to the semantics of the Java memory
			model.&amp;nbsp; For more information, see the web page
			&lt;a
			href=&quot;http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html&quot;
			&gt;http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html&lt;/a&gt;.&lt;/p&gt;

		</info>
		<name>Doublecheck</name>
	</findingType>
	<findingType>
		<id>FI_FINALIZER_NULLS_FIELDS</id>
		<artifact tool="FindBugs" mnemonic="Finalizer Nulls Fields">
		</artifact>
		<shortMessage>Finalizer nulls fields</shortMessage>
		<info>

			&lt;p&gt; This finalizer nulls out fields. This is usually
			an error, as it does not aid garbage collection, and the
			object is going to be garbage collected anyway.

		</info>
		<name>Finalizer Nulls Fields</name>
	</findingType>
	<findingType>
		<id>FI_FINALIZER_ONLY_NULLS_FIELDS</id>
		<artifact tool="FindBugs"
			mnemonic="Finalizer Only Nulls Fields">
		</artifact>
		<shortMessage>Finalizer only nulls fields</shortMessage>
		<info>

			&lt;p&gt; This finalizer does nothing except null out
			fields. This is completely pointless, and requires that the
			object be garbage collected, finalized, and then garbage
			collected again. You should just remove the finalize method.

		</info>
		<name>Finalizer Only Nulls Fields</name>
	</findingType>
	<findingType>
		<id>FI_PUBLIC_SHOULD_BE_PROTECTED</id>
		<artifact tool="FindBugs"
			mnemonic="Public Should Be Protected">
		</artifact>
		<shortMessage>
			Finalizer should be protected, not public
		</shortMessage>
		<info>

			&lt;p&gt; A class's &lt;code&gt;finalize()&lt;/code&gt;
			method should have protected access, not public.&lt;/p&gt;

		</info>
		<name>Public Should Be Protected</name>
	</findingType>
	<findingType>
		<id>FI_EMPTY</id>
		<artifact tool="FindBugs" mnemonic="Empty"></artifact>
		<shortMessage>Empty finalizer should be deleted</shortMessage>
		<info>

			&lt;p&gt; Empty &lt;code&gt;finalize()&lt;/code&gt; methods
			are useless, so they should be deleted.&lt;/p&gt;

		</info>
		<name>Empty</name>
	</findingType>
	<findingType>
		<id>FI_NULLIFY_SUPER</id>
		<artifact tool="FindBugs" mnemonic="Nullify Super"></artifact>
		<shortMessage>
			Finalizer nullifies superclass finalizer
		</shortMessage>
		<info>

			&lt;p&gt; This empty &lt;code&gt;finalize()&lt;/code&gt;
			method explicitly negates the effect of any finalizer
			defined by its superclass.&amp;nbsp; Any finalizer actions
			defined for the superclass will not be performed.&amp;nbsp;
			Unless this is intended, delete this method.&lt;/p&gt;

		</info>
		<name>Nullify Super</name>
	</findingType>
	<findingType>
		<id>FI_USELESS</id>
		<artifact tool="FindBugs" mnemonic="Useless"></artifact>
		<shortMessage>
			Finalizer does nothing but call superclass finalizer
		</shortMessage>
		<info>

			&lt;p&gt; The only thing this
			&lt;code&gt;finalize()&lt;/code&gt; method does is call the
			superclass's &lt;code&gt;finalize()&lt;/code&gt; method,
			making it redundant.&amp;nbsp; Delete it.&lt;/p&gt;

		</info>
		<name>Useless</name>
	</findingType>
	<findingType>
		<id>FI_MISSING_SUPER_CALL</id>
		<artifact tool="FindBugs" mnemonic="Missing Super Call">
		</artifact>
		<shortMessage>
			Finalizer does not call superclass finalizer
		</shortMessage>
		<info>

			&lt;p&gt; This &lt;code&gt;finalize()&lt;/code&gt; method
			does not make a call to its superclass's
			&lt;code&gt;finalize()&lt;/code&gt; method.&amp;nbsp; So,
			any finalizer actions defined for the superclass will not be
			performed.&amp;nbsp; Add a call to
			&lt;code&gt;super.finalize()&lt;/code&gt;.&lt;/p&gt;

		</info>
		<name>Missing Super Call</name>
	</findingType>
	<findingType>
		<id>FI_EXPLICIT_INVOCATION</id>
		<artifact tool="FindBugs" mnemonic="Explicit Invocation">
		</artifact>
		<shortMessage>Explicit invocation of finalizer</shortMessage>
		<info>

			&lt;p&gt; This method contains an explicit invocation of the
			&lt;code&gt;finalize()&lt;/code&gt; method on an
			object.&amp;nbsp; Because finalizer methods are supposed to
			be executed once, and only by the VM, this is a bad
			idea.&lt;/p&gt; &lt;p&gt;If a connected set of objects
			beings finalizable, then the VM will invoke the finalize
			method on all the finalizable object, possibly at the same
			time in different threads. Thus, it is a particularly bad
			idea, in the finalize method for a class X, invoke finalize
			on objects referenced by X, because they may already be
			getting finalized in a separate thread.

		</info>
		<name>Explicit Invocation</name>
	</findingType>
	<findingType>
		<id>EQ_DONT_DEFINE_EQUALS_FOR_ENUM</id>
		<artifact tool="FindBugs"
			mnemonic="Dont Define Equals For Enum">
		</artifact>
		<shortMessage>
			Covariant equals() method defined for enum
		</shortMessage>
		<info>

			&lt;p&gt; This class defines an enumeration, and equality on
			enumerations are defined using object identity. Definine a
			covariant equals method for an enumeration value is
			exceptionally bad practice, since it would likely result in
			having two different enumeration values that compare as
			equals using the covariant enum method, and as not equal
			when compared normally. Don't do it. &lt;/p&gt;

		</info>
		<name>Dont Define Equals For Enum</name>
	</findingType>
	<findingType>
		<id>EQ_SELF_USE_OBJECT</id>
		<artifact tool="FindBugs" mnemonic="Self Use Object"></artifact>
		<shortMessage>
			Covariant equals() method defined, Object.equals(Object)
			inherited
		</shortMessage>
		<info>

			&lt;p&gt; This class defines a covariant version of the
			&lt;code&gt;equals()&lt;/code&gt; method, but inherits the
			normal &lt;code&gt;equals(Object)&lt;/code&gt; method
			defined in the base
			&lt;code&gt;java.lang.Object&lt;/code&gt; class.&amp;nbsp;
			The class should probably define a non-covariant version of
			&lt;code&gt;equals()&lt;/code&gt;.&amp;nbsp; (I.e., a method
			with the signature &lt;code&gt;boolean
			equals(java.lang.Object)&lt;/code&gt;.&lt;/p&gt;

		</info>
		<name>Self Use Object</name>
	</findingType>
	<findingType>
		<id>EQ_SELF_NO_OBJECT</id>
		<artifact tool="FindBugs" mnemonic="Self No Object"></artifact>
		<shortMessage>Covariant equals() method defined</shortMessage>
		<info>

			&lt;p&gt; This class defines a covariant version of
			&lt;code&gt;equals()&lt;/code&gt;.&amp;nbsp; To correctly
			override the &lt;code&gt;equals()&lt;/code&gt; method in
			&lt;code&gt;java.lang.Object&lt;/code&gt;, the parameter of
			&lt;code&gt;equals()&lt;/code&gt; must have type
			&lt;code&gt;java.lang.Object&lt;/code&gt;.&lt;/p&gt;

		</info>
		<name>Self No Object</name>
	</findingType>
	<findingType>
		<id>EQ_OVERRIDING_EQUALS_NOT_SYMMETRIC</id>
		<artifact tool="FindBugs"
			mnemonic="Overriding Equals Not Symmetric">
		</artifact>
		<shortMessage>
			equals method overrides equals in superclass and may not be
			symmetric
		</shortMessage>
		<info>

			&lt;p&gt; This class defines an equals method that overrides
			an equals method in a superclass. Both equals methods
			methods use &lt;code&gt;instanceof&lt;/code&gt; in the
			determination of whether two objects are equals. This is
			fraught with peril, since it is important that the equals
			method is symetrical (in other words,
			&lt;code&gt;a.equals(b) == b.equals(a)&lt;/code&gt;). If B
			is a subtype of A, and A's equals method checks that the
			argument is an instanceof A, and B's equals method checks
			that the argument is an instanceof B, it is quite likely
			that the equivalence relation defined by these methods is
			not symmetric.

		</info>
		<name>Overriding Equals Not Symmetric</name>
	</findingType>
	<findingType>
		<id>HSC_HUGE_SHARED_STRING_CONSTANT</id>
		<artifact tool="FindBugs"
			mnemonic="Huge Shared String Constant">
		</artifact>
		<shortMessage>
			Huge string constants is duplicated across multiple class
			files
		</shortMessage>
		<info>

			&lt;p&gt; A large String constant is duplicated across
			multiple class files. This is likely because a final field
			is initialized to a String constant, and the Java language
			mandates that all references to a final field from other
			classes be inlined into that classfile. See &lt;a
			href=&quot;http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6447475&quot;&gt;JDK
			bug 6447475&lt;/a&gt; for a description of an occurrence of
			this bug in the JDK and how resolving it reduced the size of
			the JDK by 1 megabyte. &lt;/p&gt;

		</info>
		<name>Huge Shared String Constant</name>
	</findingType>
	<findingType>
		<id>NP_ARGUMENT_MIGHT_BE_NULL</id>
		<artifact tool="FindBugs" mnemonic="Argument Might Be Null">
		</artifact>
		<shortMessage>
			Method does not check for null argument
		</shortMessage>
		<info>

			&lt;p&gt; A parameter to this method has been identified as
			a value that should always be checked to see whether or not
			it is null, but it is being dereferenced without a preceding
			null check. &lt;/p&gt;

		</info>
		<name>Argument Might Be Null</name>
	</findingType>
	<findingType>
		<id>NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT</id>
		<artifact tool="FindBugs"
			mnemonic="Equals Should Handle Null Argument">
		</artifact>
		<shortMessage>
			equals() method does not check for null argument
		</shortMessage>
		<info>

			&lt;p&gt; This implementation of equals(Object) violates the
			contract defined by java.lang.Object.equals() because it
			does not check for null being passed as the argument. All
			equals() methods should return false if passed a null value.
			&lt;/p&gt;

		</info>
		<name>Equals Should Handle Null Argument</name>
	</findingType>
	<findingType>
		<id>NP_DOES_NOT_HANDLE_NULL</id>
		<artifact tool="FindBugs" mnemonic="Does Not Handle Null">
		</artifact>
		<shortMessage>
			equals() method does not check for null parameter
		</shortMessage>
		<info>

			&lt;p&gt; This implementation of equals(Object) violates the
			contract defined by java.lang.Object.equals() because it
			does not check for null being passed as the parameter. All
			equals() methods should return false if passed a null value.
			&lt;/p&gt;

		</info>
		<name>Does Not Handle Null</name>
	</findingType>
	<findingType>
		<id>CO_SELF_NO_OBJECT</id>
		<artifact tool="FindBugs" mnemonic="Self No Object"></artifact>
		<shortMessage>
			Covariant compareTo() method defined
		</shortMessage>
		<info>

			&lt;p&gt; This class defines a covariant version of
			&lt;code&gt;compareTo()&lt;/code&gt;.&amp;nbsp; To correctly
			override the &lt;code&gt;compareTo()&lt;/code&gt; method in
			the &lt;code&gt;Comparable&lt;/code&gt; interface, the
			parameter of &lt;code&gt;compareTo()&lt;/code&gt; must have
			type &lt;code&gt;java.lang.Object&lt;/code&gt;.&lt;/p&gt;

		</info>
		<name>Self No Object</name>
	</findingType>
	<findingType>
		<id>HE_USE_OF_UNHASHABLE_CLASS</id>
		<artifact tool="FindBugs" mnemonic="Use Of Unhashable Class">
		</artifact>
		<shortMessage>
			Use of class without a hashCode() method in a hashed data
			structure
		</shortMessage>
		<info>

			&lt;p&gt; A class defines an equals(Object) method but not a
			hashCode() method, and thus doesn't fulfill the requirement
			that equal Objects have equal hashCodes. An instance of this
			class is used in a hash data structure, making the need to
			fix this problem of highest importance.

		</info>
		<name>Use Of Unhashable Class</name>
	</findingType>
	<findingType>
		<id>HE_HASHCODE_USE_OBJECT_EQUALS</id>
		<artifact tool="FindBugs"
			mnemonic="Hashcode Use Object Equals">
		</artifact>
		<shortMessage>
			Class defines hashCode() and uses Object.equals()
		</shortMessage>
		<info>

			&lt;p&gt; This class defines a
			&lt;code&gt;hashCode()&lt;/code&gt; method but inherits its
			&lt;code&gt;equals()&lt;/code&gt; method from
			&lt;code&gt;java.lang.Object&lt;/code&gt; (which defines
			equality by comparing object references).&amp;nbsp; Although
			this will probably satisfy the contract that equal objects
			must have equal hashcodes, it is probably not what was
			intended by overriding the
			&lt;code&gt;hashCode()&lt;/code&gt; method.&amp;nbsp;
			(Overriding &lt;code&gt;hashCode()&lt;/code&gt; implies that
			the object's identity is based on criteria more complicated
			than simple reference equality.)&lt;/p&gt; &lt;p&gt;If you
			don't think instances of this class will ever be inserted
			into a HashMap/HashTable, the recommended
			&lt;code&gt;hashCode&lt;/code&gt; implementation to use
			is:&lt;/p&gt; &lt;p&gt;&lt;pre&gt;public int hashCode() {
			assert false : &quot;hashCode not designed&quot;; return 42;
			// any arbitrary constant will do }&lt;/pre&gt;&lt;/p&gt;

		</info>
		<name>Hashcode Use Object Equals</name>
	</findingType>
	<findingType>
		<id>EQ_COMPARETO_USE_OBJECT_EQUALS</id>
		<artifact tool="FindBugs"
			mnemonic="Compareto Use Object Equals">
		</artifact>
		<shortMessage>
			Class defines compareTo(...) and uses Object.equals()
		</shortMessage>
		<info>

			&lt;p&gt; This class defines a
			&lt;code&gt;compareTo(...)&lt;/code&gt; method but inherits
			its &lt;code&gt;equals()&lt;/code&gt; method from
			&lt;code&gt;java.lang.Object&lt;/code&gt;. Generally, the
			value of compareTo should return zero if and only if equals
			returns true. If this is violated, weird and unpredictable
			failures will occur in classes such as PriorityQueue. In
			Java 5 the PriorityQueue.remove method uses the compareTo
			method, while in Java 6 it uses the equals method.

			&lt;p&gt;From the JavaDoc for the compareTo method in the
			Comparable interface: &lt;blockquote&gt; It is strongly
			recommended, but not strictly required that
			&lt;code&gt;(x.compareTo(y)==0) ==
			(x.equals(y))&lt;/code&gt;. Generally speaking, any class
			that implements the Comparable interface and violates this
			condition should clearly indicate this fact. The recommended
			language is &quot;Note: this class has a natural ordering
			that is inconsistent with equals.&quot; &lt;/blockquote&gt;

		</info>
		<name>Compareto Use Object Equals</name>
	</findingType>
	<findingType>
		<id>HE_HASHCODE_NO_EQUALS</id>
		<artifact tool="FindBugs" mnemonic="Hashcode No Equals">
		</artifact>
		<shortMessage>
			Class defines hashCode() but not equals()
		</shortMessage>
		<info>

			&lt;p&gt; This class defines a
			&lt;code&gt;hashCode()&lt;/code&gt; method but not an
			&lt;code&gt;equals()&lt;/code&gt; method.&amp;nbsp;
			Therefore, the class may violate the invariant that equal
			objects must have equal hashcodes.&lt;/p&gt;

		</info>
		<name>Hashcode No Equals</name>
	</findingType>
	<findingType>
		<id>HE_EQUALS_USE_HASHCODE</id>
		<artifact tool="FindBugs" mnemonic="Equals Use Hashcode">
		</artifact>
		<shortMessage>
			Class defines equals() and uses Object.hashCode()
		</shortMessage>
		<info>

			&lt;p&gt; This class overrides
			&lt;code&gt;equals(Object)&lt;/code&gt;, but does not
			override &lt;code&gt;hashCode()&lt;/code&gt;, and inherits
			the implementation of &lt;code&gt;hashCode()&lt;/code&gt;
			from &lt;code&gt;java.lang.Object&lt;/code&gt; (which
			returns the identity hash code, an arbitrary value assigned
			to the object by the VM).&amp;nbsp; Therefore, the class is
			very likely to violate the invariant that equal objects must
			have equal hashcodes.&lt;/p&gt;

			&lt;p&gt;If you don't think instances of this class will
			ever be inserted into a HashMap/HashTable, the recommended
			&lt;code&gt;hashCode&lt;/code&gt; implementation to use
			is:&lt;/p&gt; &lt;pre&gt;public int hashCode() { assert
			false : &quot;hashCode not designed&quot;; return 42; // any
			arbitrary constant will do }&lt;/pre&gt;

		</info>
		<name>Equals Use Hashcode</name>
	</findingType>
	<findingType>
		<id>HE_INHERITS_EQUALS_USE_HASHCODE</id>
		<artifact tool="FindBugs"
			mnemonic="Inherits Equals Use Hashcode">
		</artifact>
		<shortMessage>
			Class inherits equals() and uses Object.hashCode()
		</shortMessage>
		<info>

			&lt;p&gt; This class inherits
			&lt;code&gt;equals(Object)&lt;/code&gt; from an abstract
			superclass, and &lt;code&gt;hashCode()&lt;/code&gt; from
			&lt;code&gt;java.lang.Object&lt;/code&gt; (which returns the
			identity hash code, an arbitrary value assigned to the
			object by the VM).&amp;nbsp; Therefore, the class is very
			likely to violate the invariant that equal objects must have
			equal hashcodes.&lt;/p&gt;

			&lt;p&gt;If you don't want to define a hashCode method,
			and/or don't believe the object will ever be put into a
			HashMap/Hashtable, define the
			&lt;code&gt;hashCode()&lt;/code&gt; method to throw
			&lt;code&gt;UnsupportedOperationException&lt;/code&gt;.&lt;/p&gt;

		</info>
		<name>Inherits Equals Use Hashcode</name>
	</findingType>
	<findingType>
		<id>HE_EQUALS_NO_HASHCODE</id>
		<artifact tool="FindBugs" mnemonic="Equals No Hashcode">
		</artifact>
		<shortMessage>
			Class defines equals() but not hashCode()
		</shortMessage>
		<info>

			&lt;p&gt; This class overrides
			&lt;code&gt;equals(Object)&lt;/code&gt;, but does not
			override &lt;code&gt;hashCode()&lt;/code&gt;.&amp;nbsp;
			Therefore, the class may violate the invariant that equal
			objects must have equal hashcodes.&lt;/p&gt;

		</info>
		<name>Equals No Hashcode</name>
	</findingType>
	<findingType>
		<id>EQ_ABSTRACT_SELF</id>
		<artifact tool="FindBugs" mnemonic="Abstract Self"></artifact>
		<shortMessage>
			Abstract class defines covariant equals() method
		</shortMessage>
		<info>

			&lt;p&gt; This class defines a covariant version of
			&lt;code&gt;equals()&lt;/code&gt;.&amp;nbsp; To correctly
			override the &lt;code&gt;equals()&lt;/code&gt; method in
			&lt;code&gt;java.lang.Object&lt;/code&gt;, the parameter of
			&lt;code&gt;equals()&lt;/code&gt; must have type
			&lt;code&gt;java.lang.Object&lt;/code&gt;.&lt;/p&gt;

		</info>
		<name>Abstract Self</name>
	</findingType>
	<findingType>
		<id>ES_COMPARING_STRINGS_WITH_EQ</id>
		<artifact tool="FindBugs"
			mnemonic="Comparing Strings With Eq">
		</artifact>
		<shortMessage>
			Comparison of String objects using == or !=
		</shortMessage>
		<info>

			&lt;p&gt;This code compares
			&lt;code&gt;java.lang.String&lt;/code&gt; objects for
			reference equality using the == or != operators. Unless both
			strings are either constants in a source file, or have been
			interned using the &lt;code&gt;String.intern()&lt;/code&gt;
			method, the same string value may be represented by two
			different String objects. Consider using the
			&lt;code&gt;equals(Object)&lt;/code&gt; method
			instead.&lt;/p&gt;

		</info>
		<name>Comparing Strings With Eq</name>
	</findingType>
	<findingType>
		<id>ES_COMPARING_PARAMETER_STRING_WITH_EQ</id>
		<artifact tool="FindBugs"
			mnemonic="Comparing Parameter String With Eq">
		</artifact>
		<shortMessage>
			Comparison of String parameter using == or !=
		</shortMessage>
		<info>

			&lt;p&gt;This code compares a
			&lt;code&gt;java.lang.String&lt;/code&gt; parameter for
			reference equality using the == or != operators. Requiring
			callers to pass only String constants or interned strings to
			a method is unnecessarily fragile, and rarely leads to
			measurable performance gains. Consider using the
			&lt;code&gt;equals(Object)&lt;/code&gt; method
			instead.&lt;/p&gt;

		</info>
		<name>Comparing Parameter String With Eq</name>
	</findingType>
	<findingType>
		<id>CO_ABSTRACT_SELF</id>
		<artifact tool="FindBugs" mnemonic="Abstract Self"></artifact>
		<shortMessage>
			Abstract class defines covariant compareTo() method
		</shortMessage>
		<info>

			&lt;p&gt; This class defines a covariant version of
			&lt;code&gt;compareTo()&lt;/code&gt;.&amp;nbsp; To correctly
			override the &lt;code&gt;compareTo()&lt;/code&gt; method in
			the &lt;code&gt;Comparable&lt;/code&gt; interface, the
			parameter of &lt;code&gt;compareTo()&lt;/code&gt; must have
			type &lt;code&gt;java.lang.Object&lt;/code&gt;.&lt;/p&gt;

		</info>
		<name>Abstract Self</name>
	</findingType>
	<findingType>
		<id>IS_FIELD_NOT_GUARDED</id>
		<artifact tool="FindBugs" mnemonic="Field Not Guarded">
		</artifact>
		<shortMessage>
			Field not guarded against concurrent access
		</shortMessage>
		<info>

			&lt;p&gt; This field is annotated with
			net.jcip.annotations.GuardedBy, but can be accessed in a way
			that seems to violate the annotation.&lt;/p&gt;

		</info>
		<name>Field Not Guarded</name>
	</findingType>
	<findingType>
		<id>IS2_INCONSISTENT_SYNC</id>
		<artifact tool="FindBugs" mnemonic="Inconsistent Sync">
		</artifact>
		<shortMessage>Inconsistent synchronization</shortMessage>
		<info>

			&lt;p&gt; The fields of this class appear to be accessed
			inconsistently with respect to synchronization.&amp;nbsp;
			This bug report indicates that the bug pattern detector
			judged that &lt;/p&gt; &lt;ol&gt; &lt;li&gt; The class
			contains a mix of locked and unlocked accesses,&lt;/li&gt;
			&lt;li&gt; At least one locked access was performed by one
			of the class's own methods, and&lt;/li&gt; &lt;li&gt; The
			number of unsynchronized field accesses (reads and writes)
			was no more than one third of all accesses, with writes
			being weighed twice as high as reads&lt;/li&gt; &lt;/ol&gt;

			&lt;p&gt; A typical bug matching this bug pattern is
			forgetting to synchronize one of the methods in a class that
			is intended to be thread-safe.&lt;/p&gt;

			&lt;p&gt; You can select the nodes labeled
			&quot;Unsynchronized access&quot; to show the code locations
			where the detector believed that a field was accessed
			without synchronization.&lt;/p&gt;

			&lt;p&gt; Note that there are various sources of inaccuracy
			in this detector; for example, the detector cannot
			statically detect all situations in which a lock is
			held.&amp;nbsp; Also, even when the detector is accurate in
			distinguishing locked vs. unlocked accesses, the code in
			question may still be correct.&lt;/p&gt;

			&lt;p&gt; This description refers to the &quot;IS2&quot;
			version of the pattern detector, which has more accurate
			ways of detecting locked vs. unlocked accesses than the
			older &quot;IS&quot; detector.&lt;/p&gt;

		</info>
		<name>Inconsistent Sync</name>
	</findingType>
	<findingType>
		<id>NN_NAKED_NOTIFY</id>
		<artifact tool="FindBugs" mnemonic="Naked Notify"></artifact>
		<shortMessage>Naked notify</shortMessage>
		<info>

			&lt;p&gt; A call to &lt;code&gt;notify()&lt;/code&gt; or
			&lt;code&gt;notifyAll()&lt;/code&gt; was made without any
			(apparent) accompanying modification to mutable object
			state.&amp;nbsp; In general, calling a notify method on a
			monitor is done because some condition another thread is
			waiting for has become true.&amp;nbsp; However, for the
			condition to be meaningful, it must involve a heap object
			that is visible to both threads.&lt;/p&gt;

			&lt;p&gt; This bug does not necessarily indicate an error,
			since the change to mutable object state may have taken
			place in a method which then called the method containing
			the notification.&lt;/p&gt;

		</info>
		<name>Naked Notify</name>
	</findingType>
	<findingType>
		<id>MS_EXPOSE_REP</id>
		<artifact tool="FindBugs" mnemonic="Expose Rep"></artifact>
		<shortMessage>
			Public static method may expose internal representation by
			returning array
		</shortMessage>
		<info>

			&lt;p&gt; A public static method returns a reference to an
			array that is part of the static state of the class. Any
			code that calls this method can freely modify the underlying
			array. One fix is to return a copy of the array.&lt;/p&gt;

		</info>
		<name>Expose Rep</name>
	</findingType>
	<findingType>
		<id>EI_EXPOSE_REP</id>
		<artifact tool="FindBugs" mnemonic="Expose Rep"></artifact>
		<shortMessage>
			May expose internal representation by returning reference to
			mutable object
		</shortMessage>
		<info>

			&lt;p&gt; Returning a reference to a mutable object value
			stored in one of the object's fields exposes the internal
			representation of the object.&amp;nbsp; If instances are
			accessed by untrusted code, and unchecked changes to the
			mutable object would compromise security or other important
			properties, you will need to do something different.
			Returning a new copy of the object is better approach in
			many situations.&lt;/p&gt;

		</info>
		<name>Expose Rep</name>
	</findingType>
	<findingType>
		<id>EI_EXPOSE_REP2</id>
		<artifact tool="FindBugs" mnemonic="Expose REP2"></artifact>
		<shortMessage>
			May expose internal representation by incorporating
			reference to mutable object
		</shortMessage>
		<info>

			&lt;p&gt; This code stores a reference to an externally
			mutable object into the internal representation of the
			object.&amp;nbsp; If instances are accessed by untrusted
			code, and unchecked changes to the mutable object would
			compromise security or other important properties, you will
			need to do something different. Storing a copy of the object
			is better approach in many situations.&lt;/p&gt;

		</info>
		<name>Expose REP2</name>
	</findingType>
	<findingType>
		<id>EI_EXPOSE_STATIC_REP2</id>
		<artifact tool="FindBugs" mnemonic="Expose Static REP2">
		</artifact>
		<shortMessage>
			May expose internal static state by storing a mutable object
			into a static field
		</shortMessage>
		<info>

			&lt;p&gt; This code stores a reference to an externally
			mutable object into a static field. If unchecked changes to
			the mutable object would compromise security or other
			important properties, you will need to do something
			different. Storing a copy of the object is better approach
			in many situations.&lt;/p&gt;

		</info>
		<name>Expose Static REP2</name>
	</findingType>
	<findingType>
		<id>RU_INVOKE_RUN</id>
		<artifact tool="FindBugs" mnemonic="Invoke Run"></artifact>
		<shortMessage>
			Invokes run on a thread (did you mean to start it instead?)
		</shortMessage>
		<info>

			&lt;p&gt; This method explicitly invokes
			&lt;code&gt;run()&lt;/code&gt; on an object.&amp;nbsp; In
			general, classes implement the
			&lt;code&gt;Runnable&lt;/code&gt; interface because they are
			going to have their &lt;code&gt;run()&lt;/code&gt; method
			invoked in a new thread, in which case
			&lt;code&gt;Thread.start()&lt;/code&gt; is the right method
			to call.&lt;/p&gt;

		</info>
		<name>Invoke Run</name>
	</findingType>
	<findingType>
		<id>SP_SPIN_ON_FIELD</id>
		<artifact tool="FindBugs" mnemonic="Spin On Field"></artifact>
		<shortMessage>Method spins on field</shortMessage>
		<info>

			&lt;p&gt; This method spins in a loop which reads a
			field.&amp;nbsp; The compiler may legally hoist the read out
			of the loop, turning the code into an infinite
			loop.&amp;nbsp; The class should be changed so it uses
			proper synchronization (including wait and notify
			calls).&lt;/p&gt;

		</info>
		<name>Spin On Field</name>
	</findingType>
	<findingType>
		<id>NS_DANGEROUS_NON_SHORT_CIRCUIT</id>
		<artifact tool="FindBugs"
			mnemonic="Dangerous Non Short Circuit">
		</artifact>
		<shortMessage>
			Potentially dangerous use of non-short-circuit logic
		</shortMessage>
		<info>

			&lt;p&gt; This code seems to be using non-short-circuit
			logic (e.g., &amp;amp; or |) rather than short-circuit logic
			(&amp;amp;&amp;amp; or ||). In addition, it seem possible
			that, depending on the value of the left hand side, you
			might not want to evaluate the right hand side (because it
			would have side effects, could cause an exception or could
			be expensive.&lt;/p&gt; &lt;p&gt; Non-short-circuit logic
			causes both sides of the expression to be evaluated even
			when the result can be inferred from knowing the left-hand
			side. This can be less efficient and can result in errors if
			the left-hand side guards cases when evaluating the
			right-hand side can generate an error. &lt;/p&gt;

			&lt;p&gt;See &lt;a
			href=&quot;http://java.sun.com/docs/books/jls/third_edition/html/expressions.html#15.22.2&quot;&gt;the
			Java Language Specification&lt;/a&gt; for details

			&lt;/p&gt;

		</info>
		<name>Dangerous Non Short Circuit</name>
	</findingType>
	<findingType>
		<id>NS_NON_SHORT_CIRCUIT</id>
		<artifact tool="FindBugs" mnemonic="Non Short Circuit">
		</artifact>
		<shortMessage>
			Questionable use of non-short-circuit logic
		</shortMessage>
		<info>

			&lt;p&gt; This code seems to be using non-short-circuit
			logic (e.g., &amp;amp; or |) rather than short-circuit logic
			(&amp;amp;&amp;amp; or ||). Non-short-circuit logic causes
			both sides of the expression to be evaluated even when the
			result can be inferred from knowing the left-hand side. This
			can be less efficient and can result in errors if the
			left-hand side guards cases when evaluating the right-hand
			side can generate an error.

			&lt;p&gt;See &lt;a
			href=&quot;http://java.sun.com/docs/books/jls/third_edition/html/expressions.html#15.22.2&quot;&gt;the
			Java Language Specification&lt;/a&gt; for details

			&lt;/p&gt;

		</info>
		<name>Non Short Circuit</name>
	</findingType>
	<findingType>
		<id>TLW_TWO_LOCK_WAIT</id>
		<artifact tool="FindBugs" mnemonic="Two Lock Wait"></artifact>
		<shortMessage>Wait with two locks held</shortMessage>
		<info>

			&lt;p&gt; Waiting on a monitor while two locks are held may
			cause deadlock. &amp;nbsp; Performing a wait only releases
			the lock on the object being waited on, not any other locks.
			&amp;nbsp; This not necessarily a bug, but is worth
			examining closely.&lt;/p&gt;

		</info>
		<name>Two Lock Wait</name>
	</findingType>
	<findingType>
		<id>TLW_TWO_LOCK_NOTIFY</id>
		<artifact tool="FindBugs" mnemonic="Two Lock Notify"></artifact>
		<shortMessage>Notify with two locks held</shortMessage>
		<info>

			&lt;p&gt; The code calls notify() or notifyAll() while two
			locks are held. If this notification is intended to wake up
			a wait() that is holding the same locks, it may deadlock,
			since the wait will only give up one lock and the notify
			will be unable to get both locks, and thus the notify will
			not succeed. &amp;nbsp; If there is also a warning about a
			two lock wait, the probably of a bug is quite high.
			&lt;/p&gt;

		</info>
		<name>Two Lock Notify</name>
	</findingType>
	<findingType>
		<id>UW_UNCOND_WAIT</id>
		<artifact tool="FindBugs" mnemonic="Uncond Wait"></artifact>
		<shortMessage>Unconditional wait</shortMessage>
		<info>

			&lt;p&gt; This method contains a call to
			&lt;code&gt;java.lang.Object.wait()&lt;/code&gt; which is
			not guarded by conditional control flow.&amp;nbsp; The code
			should verify that condition it intends to wait for is not
			already satisfied before calling wait; any previous
			notifications will be ignored. &lt;/p&gt;

		</info>
		<name>Uncond Wait</name>
	</findingType>
	<findingType>
		<id>UR_UNINIT_READ</id>
		<artifact tool="FindBugs" mnemonic="Uninit Read"></artifact>
		<shortMessage>
			Uninitialized read of field in constructor
		</shortMessage>
		<info>

			&lt;p&gt; This constructor reads a field which has not yet
			been assigned a value.&amp;nbsp; This is often caused when
			the programmer mistakenly uses the field instead of one of
			the constructor's parameters.&lt;/p&gt;

		</info>
		<name>Uninit Read</name>
	</findingType>
	<findingType>
		<id>UG_SYNC_SET_UNSYNC_GET</id>
		<artifact tool="FindBugs" mnemonic="Sync Set Unsync Get">
		</artifact>
		<shortMessage>
			Unsynchronized get method, synchronized set method
		</shortMessage>
		<info>

			&lt;p&gt; This class contains similarly-named get and set
			methods where the set method is synchronized and the get
			method is not.&amp;nbsp; This may result in incorrect
			behavior at runtime, as callers of the get method will not
			necessarily see a consistent state for the object.&amp;nbsp;
			The get method should be made synchronized.&lt;/p&gt;

		</info>
		<name>Sync Set Unsync Get</name>
	</findingType>
	<findingType>
		<id>IC_INIT_CIRCULARITY</id>
		<artifact tool="FindBugs" mnemonic="Init Circularity">
		</artifact>
		<shortMessage>Initialization circularity</shortMessage>
		<info>

			&lt;p&gt; A circularity was detected in the static
			initializers of the two classes referenced by the bug
			instance.&amp;nbsp; Many kinds of unexpected behavior may
			arise from such circularity.&lt;/p&gt;

		</info>
		<name>Init Circularity</name>
	</findingType>
	<findingType>
		<id>IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION</id>
		<artifact tool="FindBugs"
			mnemonic="Superclass Uses Subclass During Initialization">
		</artifact>
		<shortMessage>
			Superclass uses subclass during initialization
		</shortMessage>
		<info>

			&lt;p&gt; During the initialization of a class, the class
			makes an active use of a subclass. That subclass will not
			yet be initialized at the time of this use. For example, in
			the following code, &lt;code&gt;foo&lt;/code&gt; will be
			null.&lt;/p&gt;

			&lt;pre&gt; public class CircularClassInitialization {
			static class InnerClassSingleton extends
			CircularClassInitialization { static InnerClassSingleton
			singleton = new InnerClassSingleton(); }

			static CircularClassInitialization foo =
			InnerClassSingleton.singleton; } &lt;/pre&gt;


		</info>
		<name>Superclass Uses Subclass During Initialization</name>
	</findingType>
	<findingType>
		<id>IT_NO_SUCH_ELEMENT</id>
		<artifact tool="FindBugs" mnemonic="No Such Element"></artifact>
		<shortMessage>
			Iterator next() method can't throw NoSuchElement exception
		</shortMessage>
		<info>

			&lt;p&gt; This class implements the
			&lt;code&gt;java.util.Iterator&lt;/code&gt;
			interface.&amp;nbsp; However, its
			&lt;code&gt;next()&lt;/code&gt; method is not capable of
			throwing
			&lt;code&gt;java.util.NoSuchElementException&lt;/code&gt;.&amp;nbsp;
			The &lt;code&gt;next()&lt;/code&gt; method should be changed
			so it throws &lt;code&gt;NoSuchElementException&lt;/code&gt;
			if is called when there are no more elements to
			return.&lt;/p&gt;

		</info>
		<name>No Such Element</name>
	</findingType>
	<findingType>
		<id>DL_SYNCHRONIZATION_ON_SHARED_CONSTANT</id>
		<artifact tool="FindBugs"
			mnemonic="Synchronization On Shared Constant">
		</artifact>
		<shortMessage>
			Synchronization on shared constant could lead to deadlock
		</shortMessage>
		<info>

			&lt;p&gt; The code synchronizes on a shared primative
			constant, such as an interned String. &lt;pre&gt; private
			static String LOCK = &quot;LOCK&quot;; ...
			synchronized(LOCK) { ...} ... &lt;/pre&gt; &lt;/p&gt;
			&lt;p&gt;Such constants an interned and shared across all
			other classes loaded by the JVM. Thus, this could is locking
			on something that other code might also be locking. This
			could result in very strange and hard to diagnose blocking
			and deadlock behavior. See &lt;a
			href=&quot;http://www.javalobby.org/java/forums/t96352.html&quot;&gt;http://www.javalobby.org/java/forums/t96352.html&lt;/a&gt;
			and &lt;a
			href=&quot;http://jira.codehaus.org/browse/JETTY-352&quot;&gt;http://jira.codehaus.org/browse/JETTY-352&lt;/a&gt;.
			&lt;/p&gt;

		</info>
		<name>Synchronization On Shared Constant</name>
	</findingType>
	<findingType>
		<id>ESync_EMPTY_SYNC</id>
		<artifact tool="FindBugs" mnemonic="Empty Sync"></artifact>
		<shortMessage>Empty synchronized block</shortMessage>
		<info>

			&lt;p&gt; The code contains an empty synchronized
			block:&lt;/p&gt; &lt;pre&gt; synchronized() {} &lt;/pre&gt;
			&lt;p&gt;Empty synchronized blocks are far more subtle and
			hard to use correctly than most people recognize, and empty
			synchronized blocks are almost never a better solution than
			less contrived solutions. &lt;/p&gt;

		</info>
		<name>Empty Sync</name>
	</findingType>
	<findingType>
		<id>IS_INCONSISTENT_SYNC</id>
		<artifact tool="FindBugs" mnemonic="Inconsistent Sync">
		</artifact>
		<shortMessage>Inconsistent synchronization</shortMessage>
		<info>

			&lt;p&gt; The fields of this class appear to be accessed
			inconsistently with respect to synchronization.&amp;nbsp;
			This bug report indicates that the bug pattern detector
			judged that &lt;/p&gt; &lt;ol&gt; &lt;li&gt; The class
			contains a mix of locked and unlocked accesses,&lt;/li&gt;
			&lt;li&gt; At least one locked access was performed by one
			of the class's own methods, and&lt;/li&gt; &lt;li&gt; The
			number of unsynchronized field accesses (reads and writes)
			was no more than one third of all accesses, with writes
			being weighed twice as high as reads&lt;/li&gt; &lt;/ol&gt;

			&lt;p&gt; A typical bug matching this bug pattern is
			forgetting to synchronize one of the methods in a class that
			is intended to be thread-safe.&lt;/p&gt;

			&lt;p&gt; Note that there are various sources of inaccuracy
			in this detector; for example, the detector cannot
			statically detect all situations in which a lock is
			held.&amp;nbsp; Also, even when the detector is accurate in
			distinguishing locked vs. unlocked accesses, the code in
			question may still be correct.&lt;/p&gt;

		</info>
		<name>Inconsistent Sync</name>
	</findingType>
	<findingType>
		<id>ML_SYNC_ON_UPDATED_FIELD</id>
		<artifact tool="FindBugs" mnemonic="Sync On Updated Field">
		</artifact>
		<shortMessage>
			Method synchronizes on an updated field
		</shortMessage>
		<info>

			&lt;p&gt; This method synchronizes on an object references
			from a mutable field. This is unlikely to have useful
			semantics, since different threads may be synchronizing on
			different objects.&lt;/p&gt;

		</info>
		<name>Sync On Updated Field</name>
	</findingType>
	<findingType>
		<id>MS_OOI_PKGPROTECT</id>
		<artifact tool="FindBugs" mnemonic="Ooi Pkgprotect"></artifact>
		<shortMessage>
			Field should be moved out of an interface and made package
			protected
		</shortMessage>
		<info>

			&lt;p&gt; A final static field that is defined in an
			interface references a mutable object such as an array or
			hashtable. This mutable object could be changed by malicious
			code or by accident from another package. To solve this, the
			field needs to be moved to a class and made package
			protected to avoid this vulnerability.&lt;/p&gt;

		</info>
		<name>Ooi Pkgprotect</name>
	</findingType>
	<findingType>
		<id>MS_FINAL_PKGPROTECT</id>
		<artifact tool="FindBugs" mnemonic="Final Pkgprotect">
		</artifact>
		<shortMessage>
			Field should be both final and package protected
		</shortMessage>
		<info>

			&lt;p&gt; A mutable static field could be changed by
			malicious code or by accident from another package. The
			field could be made package protected and/or made final to
			avoid this vulnerability.&lt;/p&gt;

		</info>
		<name>Final Pkgprotect</name>
	</findingType>
	<findingType>
		<id>MS_SHOULD_BE_FINAL</id>
		<artifact tool="FindBugs" mnemonic="Should Be Final"></artifact>
		<shortMessage>Field isn't final but should be</shortMessage>
		<info>

			&lt;p&gt; A mutable static field could be changed by
			malicious code or by accident from another package. The
			field could be made final to avoid this
			vulnerability.&lt;/p&gt;

		</info>
		<name>Should Be Final</name>
	</findingType>
	<findingType>
		<id>MS_PKGPROTECT</id>
		<artifact tool="FindBugs" mnemonic="Pkgprotect"></artifact>
		<shortMessage>Field should be package protected</shortMessage>
		<info>

			&lt;p&gt; A mutable static field could be changed by
			malicious code or by accident. The field could be made
			package protected to avoid this vulnerability.&lt;/p&gt;

		</info>
		<name>Pkgprotect</name>
	</findingType>
	<findingType>
		<id>MS_MUTABLE_HASHTABLE</id>
		<artifact tool="FindBugs" mnemonic="Mutable Hashtable">
		</artifact>
		<shortMessage>Field is a mutable Hashtable</shortMessage>
		<info>

			&lt;p&gt;A final static field references a Hashtable and can
			be accessed by malicious code or by accident from another
			package. This code can freely modify the contents of the
			Hashtable.&lt;/p&gt;

		</info>
		<name>Mutable Hashtable</name>
	</findingType>
	<findingType>
		<id>MS_MUTABLE_ARRAY</id>
		<artifact tool="FindBugs" mnemonic="Mutable Array"></artifact>
		<shortMessage>Field is a mutable array</shortMessage>
		<info>

			&lt;p&gt; A final static field references an array and can
			be accessed by malicious code or by accident from another
			package. This code can freely modify the contents of the
			array.&lt;/p&gt;

		</info>
		<name>Mutable Array</name>
	</findingType>
	<findingType>
		<id>MS_CANNOT_BE_FINAL</id>
		<artifact tool="FindBugs" mnemonic="Cannot Be Final"></artifact>
		<shortMessage>
			Field isn't final and can't be protected from malicious code
		</shortMessage>
		<info>

			&lt;p&gt; A mutable static field could be changed by
			malicious code or by accident from another package.
			Unfortunately, the way the field is used doesn't allow any
			easy fix to this problem.&lt;/p&gt;

		</info>
		<name>Cannot Be Final</name>
	</findingType>
	<findingType>
		<id>IA_AMBIGUOUS_INVOCATION_OF_INHERITED_OR_OUTER_METHOD</id>
		<artifact tool="FindBugs"
			mnemonic="Ambiguous Invocation Of Inherited Or Outer Method">
		</artifact>
		<shortMessage>
			Ambiguous invocation of either an inherited or outer method
		</shortMessage>
		<info>

			&lt;p&gt; An inner class is invoking a method that could be
			resolved to either a inherited method or a method defined in
			an outer class. By the Java semantics, it will be resolved
			to invoke the inherited method, but this may not be want you
			intend. If you really intend to invoke the inherited method,
			invoke it by invoking the method on super (e.g., invoke
			super.foo(17)), and thus it will be clear to other readers
			of your code and to FindBugs that you want to invoke the
			inherited method, not the method in the outer class.
			&lt;/p&gt;

		</info>
		<name>Ambiguous Invocation Of Inherited Or Outer Method</name>
	</findingType>
	<findingType>
		<id>NM_CLASS_NAMING_CONVENTION</id>
		<artifact tool="FindBugs" mnemonic="Class Naming Convention">
		</artifact>
		<shortMessage>
			Class names should start with an upper case letter
		</shortMessage>
		<info>

			&lt;p&gt; Class names should be nouns, in mixed case with
			the first letter of each internal word capitalized. Try to
			keep your class names simple and descriptive. Use whole
			words-avoid acronyms and abbreviations (unless the
			abbreviation is much more widely used than the long form,
			such as URL or HTML). &lt;/p&gt;

		</info>
		<name>Class Naming Convention</name>
	</findingType>
	<findingType>
		<id>NM_METHOD_NAMING_CONVENTION</id>
		<artifact tool="FindBugs" mnemonic="Method Naming Convention">
		</artifact>
		<shortMessage>
			Method names should start with an lower case letter
		</shortMessage>
		<info>

			&lt;p&gt; Methods should be verbs, in mixed case with the
			first letter lowercase, with the first letter of each
			internal word capitalized. &lt;/p&gt;

		</info>
		<name>Method Naming Convention</name>
	</findingType>
	<findingType>
		<id>NM_FIELD_NAMING_CONVENTION</id>
		<artifact tool="FindBugs" mnemonic="Field Naming Convention">
		</artifact>
		<shortMessage>
			Field names should start with an lower case letter
		</shortMessage>
		<info>

			&lt;p&gt; Names of fields that are not final should be in
			mixed case with a lowercase first letter and the first
			letters of subsequent words capitalized. &lt;/p&gt;

		</info>
		<name>Field Naming Convention</name>
	</findingType>
	<findingType>
		<id>NM_VERY_CONFUSING</id>
		<artifact tool="FindBugs" mnemonic="Very Confusing"></artifact>
		<shortMessage>Very confusing method names</shortMessage>
		<info>

			&lt;p&gt; The referenced methods have names that differ only
			by capitalization or the packages of their parameters. This
			is very confusing because if the capitalization and
			parameter package names were identical then one of the
			methods would override the other. &lt;/p&gt;

		</info>
		<name>Very Confusing</name>
	</findingType>
	<findingType>
		<id>NM_VERY_CONFUSING_INTENTIONAL</id>
		<artifact tool="FindBugs"
			mnemonic="Very Confusing Intentional">
		</artifact>
		<shortMessage>
			Very confusing method names (but intentional)
		</shortMessage>
		<info>

			&lt;p&gt; The referenced methods have names that differ only
			by capitalization or the packages of their parameters. This
			is very confusing because if the capitalization were
			identical then one of the methods would override the other.
			From the existence of other methods, it seems that the
			existence of both of these methods is intentional, but is
			sure is confusing. You should try hard to eliminate one of
			them, unless you are forced to have both due to frozen APIs.
			&lt;/p&gt;

		</info>
		<name>Very Confusing Intentional</name>
	</findingType>
	<findingType>
		<id>NM_CONFUSING</id>
		<artifact tool="FindBugs" mnemonic="Confusing"></artifact>
		<shortMessage>Confusing method names</shortMessage>
		<info>

			&lt;p&gt; The referenced methods have names that differ only
			by capitalization.&lt;/p&gt;

		</info>
		<name>Confusing</name>
	</findingType>
	<findingType>
		<id>NM_METHOD_CONSTRUCTOR_CONFUSION</id>
		<artifact tool="FindBugs"
			mnemonic="Method Constructor Confusion">
		</artifact>
		<shortMessage>
			Apparent method/constructor confusion
		</shortMessage>
		<info>

			&lt;p&gt; This regular method has the same name as the class
			it is defined in. It is likely that this was intended to be
			a constructor. If it was intended to be a constructor,
			remove the declaration of a void return value. If you had
			accidently defined this method, realized the mistake,
			defined a proper constructor but can't get rid of this
			method due to backwards compatibility, deprecate the method.
			&lt;/p&gt;

		</info>
		<name>Method Constructor Confusion</name>
	</findingType>
	<findingType>
		<id>NM_LCASE_HASHCODE</id>
		<artifact tool="FindBugs" mnemonic="Lcase Hashcode"></artifact>
		<shortMessage>
			Class defines hashcode(); should it be hashCode()?
		</shortMessage>
		<info>

			&lt;p&gt; This class defines a method called
			&lt;code&gt;hashcode()&lt;/code&gt;.&amp;nbsp; This method
			does not override the &lt;code&gt;hashCode()&lt;/code&gt;
			method in &lt;code&gt;java.lang.Object&lt;/code&gt;, which
			is probably what was intended.&lt;/p&gt;

		</info>
		<name>Lcase Hashcode</name>
	</findingType>
	<findingType>
		<id>NM_LCASE_TOSTRING</id>
		<artifact tool="FindBugs" mnemonic="Lcase Tostring"></artifact>
		<shortMessage>
			Class defines tostring(); should it be toString()?
		</shortMessage>
		<info>

			&lt;p&gt; This class defines a method called
			&lt;code&gt;tostring()&lt;/code&gt;.&amp;nbsp; This method
			does not override the &lt;code&gt;toString()&lt;/code&gt;
			method in &lt;code&gt;java.lang.Object&lt;/code&gt;, which
			is probably what was intended.&lt;/p&gt;

		</info>
		<name>Lcase Tostring</name>
	</findingType>
	<findingType>
		<id>NM_BAD_EQUAL</id>
		<artifact tool="FindBugs" mnemonic="Bad Equal"></artifact>
		<shortMessage>
			Class defines equal(); should it be equals()?
		</shortMessage>
		<info>

			&lt;p&gt; This class defines a method
			&lt;code&gt;equal(Object)&lt;/code&gt;.&amp;nbsp; This
			method does not override the
			&lt;code&gt;equals(Object)&lt;/code&gt; method in
			&lt;code&gt;java.lang.Object&lt;/code&gt;, which is probably
			what was intended.&lt;/p&gt;

		</info>
		<name>Bad Equal</name>
	</findingType>
	<findingType>
		<id>NM_CLASS_NOT_EXCEPTION</id>
		<artifact tool="FindBugs" mnemonic="Class Not Exception">
		</artifact>
		<shortMessage>
			Class is not derived from an Exception, even though it is
			named as such
		</shortMessage>
		<info>

			&lt;p&gt; This class is not derived from another exception,
			but ends with 'Exception'. This will be confusing to users
			of this class.&lt;/p&gt;

		</info>
		<name>Class Not Exception</name>
	</findingType>
	<findingType>
		<id>RR_NOT_CHECKED</id>
		<artifact tool="FindBugs" mnemonic="Not Checked"></artifact>
		<shortMessage>
			Method ignores results of InputStream.read()
		</shortMessage>
		<info>

			&lt;p&gt; This method ignores the return value of one of the
			variants of
			&lt;code&gt;java.io.InputStream.read()&lt;/code&gt; which
			can return multiple bytes.&amp;nbsp; If the return value is
			not checked, the caller will not be able to correctly handle
			the case where fewer bytes were read than the caller
			requested.&amp;nbsp; This is a particularly insidious kind
			of bug, because in many programs, reads from input streams
			usually do read the full amount of data requested, causing
			the program to fail only sporadically.&lt;/p&gt;

		</info>
		<name>Not Checked</name>
	</findingType>
	<findingType>
		<id>SR_NOT_CHECKED</id>
		<artifact tool="FindBugs" mnemonic="Not Checked"></artifact>
		<shortMessage>
			Method ignores results of InputStream.skip()
		</shortMessage>
		<info>

			&lt;p&gt; This method ignores the return value of
			&lt;code&gt;java.io.InputStream.skip()&lt;/code&gt; which
			can skip multiple bytes.&amp;nbsp; If the return value is
			not checked, the caller will not be able to correctly handle
			the case where fewer bytes were skipped than the caller
			requested.&amp;nbsp; This is a particularly insidious kind
			of bug, because in many programs, skips from input streams
			usually do skip the full amount of data requested, causing
			the program to fail only sporadically. With Buffered
			streams, however, skip() will only skip data in the buffer,
			and will routinely fail to skip the requested number of
			bytes.&lt;/p&gt;

		</info>
		<name>Not Checked</name>
	</findingType>
	<findingType>
		<id>SE_READ_RESOLVE_MUST_RETURN_OBJECT</id>
		<artifact tool="FindBugs"
			mnemonic="Read Resolve Must Return Object">
		</artifact>
		<shortMessage>
			The readResolve method must be declared with a return type
			of Object.
		</shortMessage>
		<info>

			&lt;p&gt; In order for the readResolve method to be
			recognized by the serialization mechanism. &lt;/p&gt;

		</info>
		<name>Read Resolve Must Return Object</name>
	</findingType>
	<findingType>
		<id>SE_TRANSIENT_FIELD_OF_NONSERIALIZABLE_CLASS</id>
		<artifact tool="FindBugs"
			mnemonic="Transient Field Of Nonserializable Class">
		</artifact>
		<shortMessage>
			Transient field of class that isn't Serializable.
		</shortMessage>
		<info>

			&lt;p&gt; The field is marked as transient, but the class
			isn't Serializable, so marking it as transient has
			absolutely no effect. This may be leftover marking from a
			previous version of the code in which the class was
			transient, or it may indicate a misunderstanding of how
			serialization works. &lt;/p&gt;

		</info>
		<name>Transient Field Of Nonserializable Class</name>
	</findingType>
	<findingType>
		<id>SE_TRANSIENT_FIELD_NOT_RESTORED</id>
		<artifact tool="FindBugs"
			mnemonic="Transient Field Not Restored">
		</artifact>
		<shortMessage>
			Transient field that isn't set by deserialization.
		</shortMessage>
		<info>

			&lt;p&gt; This class contains a field that is updated at
			multiple places in the class, thus it seems to be part of
			the state of the class. However, since the field is marked
			as transient and not set in readObject or readResolve, it
			will contain the default value in any deserialized instance
			of the class. &lt;/p&gt;

		</info>
		<name>Transient Field Not Restored</name>
	</findingType>
	<findingType>
		<id>SE_METHOD_MUST_BE_PRIVATE</id>
		<artifact tool="FindBugs" mnemonic="Method Must Be Private">
		</artifact>
		<shortMessage>
			Method must be private in order for serialization to work
		</shortMessage>
		<info>

			&lt;p&gt; This class implements the
			&lt;code&gt;Serializable&lt;/code&gt; interface, and defines
			a method for custom serialization/deserialization. But since
			that method isn't declared private, it will be silently
			ignored by the serialization/deserialization API.&lt;/p&gt;

		</info>
		<name>Method Must Be Private</name>
	</findingType>
	<findingType>
		<id>SE_NO_SUITABLE_CONSTRUCTOR_FOR_EXTERNALIZATION</id>
		<artifact tool="FindBugs"
			mnemonic="No Suitable Constructor For Externalization">
		</artifact>
		<shortMessage>
			Class is Externalizable but doesn't define a void
			constructor
		</shortMessage>
		<info>

			&lt;p&gt; This class implements the
			&lt;code&gt;Externalizable&lt;/code&gt; interface, but does
			not define a void constructor. When Externalizable objects
			are deserialized, they first need to be constructed by
			invoking the void constructor. Since this class does not
			have one, serialization and deserialization will fail at
			runtime.&lt;/p&gt;

		</info>
		<name>No Suitable Constructor For Externalization</name>
	</findingType>
	<findingType>
		<id>SE_NO_SUITABLE_CONSTRUCTOR</id>
		<artifact tool="FindBugs" mnemonic="No Suitable Constructor">
		</artifact>
		<shortMessage>
			Class is Serializable but its superclass doesn't define a
			void constructor
		</shortMessage>
		<info>

			&lt;p&gt; This class implements the
			&lt;code&gt;Serializable&lt;/code&gt; interface and its
			superclass does not. When such an object is deserialized,
			the fields of the superclass need to be initialized by
			invoking the void constructor of the superclass. Since the
			superclass does not have one, serialization and
			deserialization will fail at runtime.&lt;/p&gt;

		</info>
		<name>No Suitable Constructor</name>
	</findingType>
	<findingType>
		<id>SE_NO_SERIALVERSIONID</id>
		<artifact tool="FindBugs" mnemonic="No Serialversionid">
		</artifact>
		<shortMessage>
			Class is Serializable, but doesn't define serialVersionUID
		</shortMessage>
		<info>

			&lt;p&gt; This class implements the
			&lt;code&gt;Serializable&lt;/code&gt; interface, but does
			not define a &lt;code&gt;serialVersionUID&lt;/code&gt;
			field.&amp;nbsp; A change as simple as adding a reference to
			a .class object will add synthetic fields to the class,
			which will unfortunately change the implicit
			serialVersionUID (e.g., adding a reference to
			&lt;code&gt;String.class&lt;/code&gt; will generate a static
			field &lt;code&gt;class$java$lang$String&lt;/code&gt;).
			Also, different source code to bytecode compilers may use
			different naming conventions for synthetic variables
			generated for references to class objects or inner classes.
			To ensure interoperability of Serializable across versions,
			consider adding an explicit serialVersionUID.&lt;/p&gt;

		</info>
		<name>No Serialversionid</name>
	</findingType>
	<findingType>
		<id>SE_COMPARATOR_SHOULD_BE_SERIALIZABLE</id>
		<artifact tool="FindBugs"
			mnemonic="Comparator Should Be Serializable">
		</artifact>
		<shortMessage>
			Comparator doesn't implement Serializable
		</shortMessage>
		<info>

			&lt;p&gt; This class implements the
			&lt;code&gt;Comparator&lt;/code&gt; interface. You should
			consider whether or not it should also implement the
			&lt;code&gt;Serializable&lt;/code&gt; interface. If a
			comparator is used to construct an ordered collection such
			as a &lt;code&gt;TreeMap&lt;/code&gt;, then the
			&lt;code&gt;TreeMap&lt;/code&gt; will be serializable only
			if the comparator is also serializable. As most comparators
			have little or no state, making them serializable is
			generally easy and good defensive programming. &lt;/p&gt;

		</info>
		<name>Comparator Should Be Serializable</name>
	</findingType>
	<findingType>
		<id>SF_SWITCH_FALLTHROUGH</id>
		<artifact tool="FindBugs" mnemonic="Switch Fallthrough">
		</artifact>
		<shortMessage>
			Switch statement found where one case falls through to the
			next case
		</shortMessage>
		<info>

			&lt;p&gt; This method contains a switch statement where one
			case branch will fall through to the next case. Usually you
			need to end this case with a break or return.&lt;/p&gt;

		</info>
		<name>Switch Fallthrough</name>
	</findingType>
	<findingType>
		<id>SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH</id>
		<artifact tool="FindBugs"
			mnemonic="Dead Store Due To Switch Fallthrough">
		</artifact>
		<shortMessage>
			Dead store due to switch statement fall through
		</shortMessage>
		<info>

			&lt;p&gt; A value stored in the previous switch case is
			overwritten here due to a switch fall through. It is likely
			that you forgot to put a break or return at the end of the
			previous case. &lt;/p&gt;

		</info>
		<name>Dead Store Due To Switch Fallthrough</name>
	</findingType>
	<findingType>
		<id>WS_WRITEOBJECT_SYNC</id>
		<artifact tool="FindBugs" mnemonic="Writeobject Sync">
		</artifact>
		<shortMessage>
			Class's writeObject() method is synchronized but nothing
			else is
		</shortMessage>
		<info>

			&lt;p&gt; This class has a
			&lt;code&gt;writeObject()&lt;/code&gt; method which is
			synchronized; however, no other method of the class is
			synchronized.&lt;/p&gt;

		</info>
		<name>Writeobject Sync</name>
	</findingType>
	<findingType>
		<id>RS_READOBJECT_SYNC</id>
		<artifact tool="FindBugs" mnemonic="Readobject Sync"></artifact>
		<shortMessage>
			Class's readObject() method is synchronized
		</shortMessage>
		<info>

			&lt;p&gt; This serializable class defines a
			&lt;code&gt;readObject()&lt;/code&gt; which is
			synchronized.&amp;nbsp; By definition, an object created by
			deserialization is only reachable by one thread, and thus
			there is no need for &lt;code&gt;readObject()&lt;/code&gt;
			to be synchronized.&amp;nbsp; If the
			&lt;code&gt;readObject()&lt;/code&gt; method itself is
			causing the object to become visible to another thread, that
			is an example of very dubious coding style.&lt;/p&gt;

		</info>
		<name>Readobject Sync</name>
	</findingType>
	<findingType>
		<id>SE_NONSTATIC_SERIALVERSIONID</id>
		<artifact tool="FindBugs"
			mnemonic="Nonstatic Serialversionid">
		</artifact>
		<shortMessage>serialVersionUID isn't static</shortMessage>
		<info>

			&lt;p&gt; This class defines a
			&lt;code&gt;serialVersionUID&lt;/code&gt; field that is not
			static.&amp;nbsp; The field should be made static if it is
			intended to specify the version UID for purposes of
			serialization.&lt;/p&gt;

		</info>
		<name>Nonstatic Serialversionid</name>
	</findingType>
	<findingType>
		<id>SE_NONFINAL_SERIALVERSIONID</id>
		<artifact tool="FindBugs" mnemonic="Nonfinal Serialversionid">
		</artifact>
		<shortMessage>serialVersionUID isn't final</shortMessage>
		<info>

			&lt;p&gt; This class defines a
			&lt;code&gt;serialVersionUID&lt;/code&gt; field that is not
			final.&amp;nbsp; The field should be made final if it is
			intended to specify the version UID for purposes of
			serialization.&lt;/p&gt;

		</info>
		<name>Nonfinal Serialversionid</name>
	</findingType>
	<findingType>
		<id>SE_NONLONG_SERIALVERSIONID</id>
		<artifact tool="FindBugs" mnemonic="Nonlong Serialversionid">
		</artifact>
		<shortMessage>serialVersionUID isn't long</shortMessage>
		<info>

			&lt;p&gt; This class defines a
			&lt;code&gt;serialVersionUID&lt;/code&gt; field that is not
			long.&amp;nbsp; The field should be made long if it is
			intended to specify the version UID for purposes of
			serialization.&lt;/p&gt;

		</info>
		<name>Nonlong Serialversionid</name>
	</findingType>
	<findingType>
		<id>SE_BAD_FIELD</id>
		<artifact tool="FindBugs" mnemonic="Bad Field"></artifact>
		<shortMessage>
			Non-transient non-serializable instance field in
			serializable class
		</shortMessage>
		<info>

			&lt;p&gt; This Serializable class defines a non-primitive
			instance field which is neither transient, Serializable, or
			&lt;code&gt;java.lang.Object&lt;/code&gt;, and does not
			appear to implement the
			&lt;code&gt;Externalizable&lt;/code&gt; interface or the
			&lt;code&gt;readObject()&lt;/code&gt; and
			&lt;code&gt;writeObject()&lt;/code&gt; methods.&amp;nbsp;
			Objects of this class will not be deserialized correctly if
			a non-Serializable object is stored in this field.&lt;/p&gt;

		</info>
		<name>Bad Field</name>
	</findingType>
	<findingType>
		<id>SE_BAD_FIELD_INNER_CLASS</id>
		<artifact tool="FindBugs" mnemonic="Bad Field Inner Class">
		</artifact>
		<shortMessage>
			Non-serializable class has a serializable inner class
		</shortMessage>
		<info>

			&lt;p&gt; This Serializable class is an inner class of a
			non-serializable class. Thus, attempts to serialize it will
			also attempt to associate instance of the outer class with
			which it is associated, leading to a runtime error.
			&lt;/p&gt; &lt;p&gt;If possible, making the inner class a
			static inner class should solve the problem. Making the
			outer class serializable might also work, but that would
			mean serializing an instance of the inner class would always
			also serialize the instance of the outer class, which it
			often not what you really want.

		</info>
		<name>Bad Field Inner Class</name>
	</findingType>
	<findingType>
		<id>SE_INNER_CLASS</id>
		<artifact tool="FindBugs" mnemonic="Inner Class"></artifact>
		<shortMessage>Serializable inner class</shortMessage>
		<info>

			&lt;p&gt; This Serializable class is an inner class. Any
			attempt to serialize it will also serialize the associated
			outer instance. The outer instance is serializable, so this
			won't fail, but it might serialize a lot more data than
			intended. If possible, making the inner class a static inner
			class (also known as a nested class) should solve the
			problem.

		</info>
		<name>Inner Class</name>
	</findingType>
	<findingType>
		<id>SE_BAD_FIELD_STORE</id>
		<artifact tool="FindBugs" mnemonic="Bad Field Store"></artifact>
		<shortMessage>
			Non-serializable value stored into instance field of a
			serializable class
		</shortMessage>
		<info>

			&lt;p&gt; A non-serializable value is stored into a
			non-transient field of a serializable class.&lt;/p&gt;

		</info>
		<name>Bad Field Store</name>
	</findingType>
	<findingType>
		<id>SC_START_IN_CTOR</id>
		<artifact tool="FindBugs" mnemonic="Start In Ctor"></artifact>
		<shortMessage>Constructor invokes Thread.start()</shortMessage>
		<info>

			&lt;p&gt; The constructor starts a thread. This is likely to
			be wrong if the class is ever extended/subclassed, since the
			thread will be started before the subclass constructor is
			started.&lt;/p&gt;

		</info>
		<name>Start In Ctor</name>
	</findingType>
	<findingType>
		<id>SS_SHOULD_BE_STATIC</id>
		<artifact tool="FindBugs" mnemonic="Should Be Static">
		</artifact>
		<shortMessage>
			Unread field: should this field be static?
		</shortMessage>
		<info>

			&lt;p&gt; This class contains an instance final field that
			is initialized to a compile-time static value. Consider
			making the field static.&lt;/p&gt;

		</info>
		<name>Should Be Static</name>
	</findingType>
	<findingType>
		<id>UUF_UNUSED_FIELD</id>
		<artifact tool="FindBugs" mnemonic="Unused Field"></artifact>
		<shortMessage>Unused field</shortMessage>
		<info>

			&lt;p&gt; This field is never used.&amp;nbsp; Consider
			removing it from the class.&lt;/p&gt;

		</info>
		<name>Unused Field</name>
	</findingType>
	<findingType>
		<id>URF_UNREAD_FIELD</id>
		<artifact tool="FindBugs" mnemonic="Unread Field"></artifact>
		<shortMessage>Unread field</shortMessage>
		<info>

			&lt;p&gt; This field is never read.&amp;nbsp; Consider
			removing it from the class.&lt;/p&gt;

		</info>
		<name>Unread Field</name>
	</findingType>
	<findingType>
		<id>QF_QUESTIONABLE_FOR_LOOP</id>
		<artifact tool="FindBugs" mnemonic="Questionable For Loop">
		</artifact>
		<shortMessage>
			Complicated, subtle or wrong increment in for-loop
		</shortMessage>
		<info>

			&lt;p&gt;Are you sure this for loop is incrementing the
			correct variable? It appears that another variable is being
			initialized and checked by the for loop. &lt;/p&gt;

		</info>
		<name>Questionable For Loop</name>
	</findingType>
	<findingType>
		<id>UWF_NULL_FIELD</id>
		<artifact tool="FindBugs" mnemonic="Null Field"></artifact>
		<shortMessage>Field only ever set to null</shortMessage>
		<info>

			&lt;p&gt; All writes to this field are of the constant value
			null, and thus all reads of the field will return null.
			Check for errors, or remove it if it is useless.&lt;/p&gt;

		</info>
		<name>Null Field</name>
	</findingType>
	<findingType>
		<id>UWF_UNWRITTEN_FIELD</id>
		<artifact tool="FindBugs" mnemonic="Unwritten Field"></artifact>
		<shortMessage>Unwritten field</shortMessage>
		<info>

			&lt;p&gt; This field is never written.&amp;nbsp; All reads
			of it will return the default value. Check for errors
			(should it have been initialized?), or remove it if it is
			useless.&lt;/p&gt;

		</info>
		<name>Unwritten Field</name>
	</findingType>
	<findingType>
		<id>ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD</id>
		<artifact tool="FindBugs"
			mnemonic="Write To Static From Instance Method">
		</artifact>
		<shortMessage>
			Write to static field from instance method
		</shortMessage>
		<info>

			&lt;p&gt; This instance method writes to a static field.
			This is tricky to get correct if multiple instances are
			being manipulated, and generally bad practice. &lt;/p&gt;

		</info>
		<name>Write To Static From Instance Method</name>
	</findingType>
	<findingType>
		<id>NP_LOAD_OF_KNOWN_NULL_VALUE</id>
		<artifact tool="FindBugs" mnemonic="Load Of Known Null Value">
		</artifact>
		<shortMessage>Load of known null value</shortMessage>
		<info>

			&lt;p&gt; The variable referenced at this point is known to
			be null due to an earlier check against null. Although this
			is valid, it might be a mistake (perhaps you intended to
			refer to a different variable, or perhaps the earlier check
			to see if the variable is null should have been a check to
			see if it was nonnull. &lt;/p&gt;

		</info>
		<name>Load Of Known Null Value</name>
	</findingType>
	<findingType>
		<id>NP_IMMEDIATE_DEREFERENCE_OF_READLINE</id>
		<artifact tool="FindBugs"
			mnemonic="Immediate Dereference Of Readline">
		</artifact>
		<shortMessage>
			Immediate dereference of the result of readLine()
		</shortMessage>
		<info>

			&lt;p&gt; The result of invoking readLine() is immediately
			dereferenced. If there are no more lines of text to read,
			readLine() will return null and dereferencing that will
			generate a null pointer exception. &lt;/p&gt;

		</info>
		<name>Immediate Dereference Of Readline</name>
	</findingType>
	<findingType>
		<id>NP_UNWRITTEN_FIELD</id>
		<artifact tool="FindBugs" mnemonic="Unwritten Field"></artifact>
		<shortMessage>Read of unwritten field</shortMessage>
		<info>

			&lt;p&gt; The program is dereferencing a field that does not
			seem to ever have a non-null value written to it.
			Dereferencing this value will generate a null pointer
			exception. &lt;/p&gt;

		</info>
		<name>Unwritten Field</name>
	</findingType>
	<findingType>
		<id>SIC_INNER_SHOULD_BE_STATIC</id>
		<artifact tool="FindBugs" mnemonic="Inner Should Be Static">
		</artifact>
		<shortMessage>Should be a static inner class</shortMessage>
		<info>

			&lt;p&gt; This class is an inner class, but does not use its
			embedded reference to the object which created it.&amp;nbsp;
			This reference makes the instances of the class larger, and
			may keep the reference to the creator object alive longer
			than necessary.&amp;nbsp; If possible, the class should be
			made static. &lt;/p&gt;

		</info>
		<name>Inner Should Be Static</name>
	</findingType>
	<findingType>
		<id>NP_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR</id>
		<artifact tool="FindBugs"
			mnemonic="Field Not Initialized In Constructor">
		</artifact>
		<shortMessage>
			Read of field not initialized in constructor
		</shortMessage>
		<info>

			&lt;p&gt; This is a read of a field is never initialized
			within any constructor, and is therefore could be null after
			the object is initialized. This might be a coding error, or
			else the class containing the field is written in a way that
			depends upon methods being called in some specific order (a
			little bit dodgy, but not necessarily wrong). &lt;/p&gt;

		</info>
		<name>Field Not Initialized In Constructor</name>
	</findingType>
	<findingType>
		<id>UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR</id>
		<artifact tool="FindBugs"
			mnemonic="Field Not Initialized In Constructor">
		</artifact>
		<shortMessage>
			Field not initialized in constructor
		</shortMessage>
		<info>

			&lt;p&gt; This field is never initialized within any
			constructor, and is therefore could be null after the object
			is constructed. This could be a either an error or a
			questionable design, since it means a null pointer exception
			will be generated if that field is dereferenced before being
			initialized. &lt;/p&gt;

		</info>
		<name>Field Not Initialized In Constructor</name>
	</findingType>
	<findingType>
		<id>SIC_INNER_SHOULD_BE_STATIC_ANON</id>
		<artifact tool="FindBugs"
			mnemonic="Inner Should Be Static Anon">
		</artifact>
		<shortMessage>
			Could be refactored into a named static inner class
		</shortMessage>
		<info>

			&lt;p&gt; This class is an inner class, but does not use its
			embedded reference to the object which created it.&amp;nbsp;
			This reference makes the instances of the class larger, and
			may keep the reference to the creator object alive longer
			than necessary.&amp;nbsp; If possible, the class should be
			made into a &lt;em&gt;static&lt;/em&gt; inner class. Since
			anonymous inner classes cannot be marked as static, doing
			this will requiring refactoring the inner class so that it
			is a named inner class.&lt;/p&gt;

		</info>
		<name>Inner Should Be Static Anon</name>
	</findingType>
	<findingType>
		<id>SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS</id>
		<artifact tool="FindBugs"
			mnemonic="Inner Should Be Static Needs This">
		</artifact>
		<shortMessage>
			Could be refactored into a static inner class
		</shortMessage>
		<info>

			&lt;p&gt; This class is an inner class, but does not use its
			embedded reference to the object which created it except
			during construction of the inner object.&amp;nbsp; This
			reference makes the instances of the class larger, and may
			keep the reference to the creator object alive longer than
			necessary.&amp;nbsp; If possible, the class should be made
			into a &lt;em&gt;static&lt;/em&gt; inner class. Since the
			reference to the outer object is required during
			construction of the inner instance, the inner class will
			need to be refactored so as to pass a reference to the outer
			instance to the constructor for the inner class.&lt;/p&gt;

		</info>
		<name>Inner Should Be Static Needs This</name>
	</findingType>
	<findingType>
		<id>WA_NOT_IN_LOOP</id>
		<artifact tool="FindBugs" mnemonic="Not In Loop"></artifact>
		<shortMessage>Wait not in loop</shortMessage>
		<info>

			&lt;p&gt; This method contains a call to
			&lt;code&gt;java.lang.Object.wait()&lt;/code&gt; which is
			not in a loop.&amp;nbsp; If the monitor is used for multiple
			conditions, the condition the caller intended to wait for
			might not be the one that actually occurred.&lt;/p&gt;

		</info>
		<name>Not In Loop</name>
	</findingType>
	<findingType>
		<id>WA_AWAIT_NOT_IN_LOOP</id>
		<artifact tool="FindBugs" mnemonic="Await Not In Loop">
		</artifact>
		<shortMessage>Condition.await() not in loop</shortMessage>
		<info>

			&lt;p&gt; This method contains a call to
			&lt;code&gt;java.util.concurrent.await()&lt;/code&gt; (or
			variants) which is not in a loop.&amp;nbsp; If the object is
			used for multiple conditions, the condition the caller
			intended to wait for might not be the one that actually
			occurred.&lt;/p&gt;

		</info>
		<name>Await Not In Loop</name>
	</findingType>
	<findingType>
		<id>NO_NOTIFY_NOT_NOTIFYALL</id>
		<artifact tool="FindBugs" mnemonic="Notify Not Notifyall">
		</artifact>
		<shortMessage>
			Using notify() rather than notifyAll()
		</shortMessage>
		<info>

			&lt;p&gt; This method calls
			&lt;code&gt;notify()&lt;/code&gt; rather than
			&lt;code&gt;notifyAll()&lt;/code&gt;.&amp;nbsp; Java
			monitors are often used for multiple conditions.&amp;nbsp;
			Calling &lt;code&gt;notify()&lt;/code&gt; only wakes up one
			thread, meaning that the thread woken up might not be the
			one waiting for the condition that the caller just
			satisfied.&lt;/p&gt;

		</info>
		<name>Notify Not Notifyall</name>
	</findingType>
	<findingType>
		<id>RV_CHECK_FOR_POSITIVE_INDEXOF</id>
		<artifact tool="FindBugs"
			mnemonic="Check For Positive Indexof">
		</artifact>
		<shortMessage>
			Method checks to see if result of String.indexOf is positive
		</shortMessage>
		<info>

			&lt;p&gt; The method invokes String.indexOf and checks to
			see if the result is positive or non-positive. It is much
			more typical to check to see if the result is negative or
			non-negative. It is positive only if the substring checked
			for occurs at some place other than at the beginning of the
			String.&lt;/p&gt;

		</info>
		<name>Check For Positive Indexof</name>
	</findingType>
	<findingType>
		<id>RV_DONT_JUST_NULL_CHECK_READLINE</id>
		<artifact tool="FindBugs"
			mnemonic="Dont Just Null Check Readline">
		</artifact>
		<shortMessage>
			Method discards result of readLine after checking if it is
			nonnull
		</shortMessage>
		<info>

			&lt;p&gt; The value returned by readLine is discarded after
			checking to see if the return value is non-null. In almost
			all situations, if the result is non-null, you will want to
			use that non-null value. Calling readLine again will give
			you a different line.&lt;/p&gt;

		</info>
		<name>Dont Just Null Check Readline</name>
	</findingType>
	<findingType>
		<id>RV_RETURN_VALUE_IGNORED</id>
		<artifact tool="FindBugs" mnemonic="Return Value Ignored">
		</artifact>
		<shortMessage>Method ignores return value</shortMessage>
		<info>

			&lt;p&gt; The return value of this method should be checked.
			One common cause of this warning is to invoke a method on an
			immutable object, thinking that it updates the object. For
			example, in the following code fragment,&lt;/p&gt;
			&lt;blockquote&gt; &lt;pre&gt; String dateString =
			getHeaderField(name); dateString.trim(); &lt;/pre&gt;
			&lt;/blockquote&gt; &lt;p&gt;the programmer seems to be
			thinking that the trim() method will update the String
			referenced by dateString. But since Strings are immutable,
			the trim() function returns a new String value, which is
			being ignored here. The code should be corrected to:
			&lt;/p&gt; &lt;blockquote&gt; &lt;pre&gt; String dateString
			= getHeaderField(name); dateString = dateString.trim();
			&lt;/pre&gt; &lt;/blockquote&gt;

		</info>
		<name>Return Value Ignored</name>
	</findingType>
	<findingType>
		<id>RV_RETURN_VALUE_IGNORED2</id>
		<artifact tool="FindBugs" mnemonic="Return Value IGNORED2">
		</artifact>
		<shortMessage>Method ignores return value</shortMessage>
		<info>

			&lt;p&gt; The return value of this method should be checked.
			One common cause of this warning is to invoke a method on an
			immutable object, thinking that it updates the object. For
			example, in the following code fragment,&lt;/p&gt;
			&lt;blockquote&gt; &lt;pre&gt; String dateString =
			getHeaderField(name); dateString.trim(); &lt;/pre&gt;
			&lt;/blockquote&gt; &lt;p&gt;the programmer seems to be
			thinking that the trim() method will update the String
			referenced by dateString. But since Strings are immutable,
			the trim() function returns a new String value, which is
			being ignored here. The code should be corrected to:
			&lt;/p&gt; &lt;blockquote&gt; &lt;pre&gt; String dateString
			= getHeaderField(name); dateString = dateString.trim();
			&lt;/pre&gt; &lt;/blockquote&gt;

		</info>
		<name>Return Value IGNORED2</name>
	</findingType>
	<findingType>
		<id>NP_ALWAYS_NULL</id>
		<artifact tool="FindBugs" mnemonic="Always Null"></artifact>
		<shortMessage>Null pointer dereference</shortMessage>
		<info>

			&lt;p&gt; A null pointer is dereferenced here.&amp;nbsp;
			This will lead to a
			&lt;code&gt;NullPointerException&lt;/code&gt; when the code
			is executed.&lt;/p&gt;

		</info>
		<name>Always Null</name>
	</findingType>
	<findingType>
		<id>NP_STORE_INTO_NONNULL_FIELD</id>
		<artifact tool="FindBugs" mnemonic="Store Into Nonnull Field">
		</artifact>
		<shortMessage>
			Store of null value into field annotated NonNull
		</shortMessage>
		<info>

			&lt;p&gt; A value that could be null is stored into a field
			that has been annotated as NonNull. &lt;/p&gt;

		</info>
		<name>Store Into Nonnull Field</name>
	</findingType>
	<findingType>
		<id>NP_ALWAYS_NULL_EXCEPTION</id>
		<artifact tool="FindBugs" mnemonic="Always Null Exception">
		</artifact>
		<shortMessage>
			Null pointer dereference in method on exception path
		</shortMessage>
		<info>

			&lt;p&gt; A pointer which is null on an exception path is
			dereferenced here.&amp;nbsp; This will lead to a
			&lt;code&gt;NullPointerException&lt;/code&gt; when the code
			is executed.&amp;nbsp; Note that because FindBugs currently
			does not prune infeasible exception paths, this may be a
			false warning.&lt;/p&gt;

			&lt;p&gt; Also note that FindBugs considers the default case
			of a switch statement to be an exception path, since the
			default case is often infeasible.&lt;/p&gt;

		</info>
		<name>Always Null Exception</name>
	</findingType>
	<findingType>
		<id>NP_NULL_ON_SOME_PATH</id>
		<artifact tool="FindBugs" mnemonic="Null On Some Path">
		</artifact>
		<shortMessage>Possible null pointer dereference</shortMessage>
		<info>

			&lt;p&gt; A reference value dereferenced here might be null
			at runtime.&amp;nbsp; This may lead to a
			&lt;code&gt;NullPointerException&lt;/code&gt; when the code
			is executed.&lt;/p&gt;

		</info>
		<name>Null On Some Path</name>
	</findingType>
	<findingType>
		<id>NP_NULL_ON_SOME_PATH_EXCEPTION</id>
		<artifact tool="FindBugs"
			mnemonic="Null On Some Path Exception">
		</artifact>
		<shortMessage>
			Possible null pointer dereference in method on exception
			path
		</shortMessage>
		<info>

			&lt;p&gt; A reference value which is null on some exception
			control path is dereferenced here.&amp;nbsp; This may lead
			to a &lt;code&gt;NullPointerException&lt;/code&gt; when the
			code is executed.&amp;nbsp; Note that because FindBugs
			currently does not prune infeasible exception paths, this
			may be a false warning.&lt;/p&gt;

			&lt;p&gt; Also note that FindBugs considers the default case
			of a switch statement to be an exception path, since the
			default case is often infeasible.&lt;/p&gt;

		</info>
		<name>Null On Some Path Exception</name>
	</findingType>
	<findingType>
		<id>NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE</id>
		<artifact tool="FindBugs"
			mnemonic="Null On Some Path From Return Value">
		</artifact>
		<shortMessage>
			Possible null pointer dereference due to return value of
			called method
		</shortMessage>
		<info>

			&lt;p&gt; A reference value which is null on some exception
			control path is dereferenced here.&amp;nbsp; This may lead
			to a &lt;code&gt;NullPointerException&lt;/code&gt; when the
			code is executed.&amp;nbsp; The value may be null because it
			was return from a method which is known to return
			possibly-null values.&lt;/p&gt;

		</info>
		<name>Null On Some Path From Return Value</name>
	</findingType>
	<findingType>
		<id>NP_NULL_PARAM_DEREF_NONVIRTUAL</id>
		<artifact tool="FindBugs"
			mnemonic="Null Param Deref Nonvirtual">
		</artifact>
		<shortMessage>
			Non-virtual method call passes null for unconditionally
			dereferenced parameter
		</shortMessage>
		<info>

			&lt;p&gt; A possibly-null value is passed to a method which
			unconditionally dereferences it. This will almost certainly
			result in a null pointer exception. &lt;/p&gt;

		</info>
		<name>Null Param Deref Nonvirtual</name>
	</findingType>
	<findingType>
		<id>NP_NULL_PARAM_DEREF_ALL_TARGETS_DANGEROUS</id>
		<artifact tool="FindBugs"
			mnemonic="Null Param Deref All Targets Dangerous">
		</artifact>
		<shortMessage>
			Method call passes null for unconditionally dereferenced
			parameter
		</shortMessage>
		<info>

			&lt;p&gt; A possibly-null value is passed at a call site
			where all known target methods will unconditionally
			dereference it. This is very likely to result in a null
			pointer exception. &lt;/p&gt;

		</info>
		<name>Null Param Deref All Targets Dangerous</name>
	</findingType>
	<findingType>
		<id>NP_NULL_PARAM_DEREF</id>
		<artifact tool="FindBugs" mnemonic="Null Param Deref">
		</artifact>
		<shortMessage>
			Method call passes null for unconditionally dereferenced
			parameter
		</shortMessage>
		<info>

			&lt;p&gt; This method call passes a null value to a method
			which might dereference it unconditionally. &lt;/p&gt;

		</info>
		<name>Null Param Deref</name>
	</findingType>
	<findingType>
		<id>NP_NONNULL_PARAM_VIOLATION</id>
		<artifact tool="FindBugs" mnemonic="Nonnull Param Violation">
		</artifact>
		<shortMessage>
			Method call passes null to a nonnull parameter
		</shortMessage>
		<info>

			&lt;p&gt; This method passes a null value as the parameter
			of a method which must be nonnull. Either this parameter has
			been explicitly marked as @Nonnull, or analysis has
			determined that this parameter is always deferenced.
			&lt;/p&gt;

		</info>
		<name>Nonnull Param Violation</name>
	</findingType>
	<findingType>
		<id>NP_NONNULL_RETURN_VIOLATION</id>
		<artifact tool="FindBugs" mnemonic="Nonnull Return Violation">
		</artifact>
		<shortMessage>
			Method may return null, but is declared @NonNull
		</shortMessage>
		<info>

			&lt;p&gt; This method may return a null value, but the
			method (or a superclass method which it overrides) is
			declared to return @NonNull. &lt;/p&gt;

		</info>
		<name>Nonnull Return Violation</name>
	</findingType>
	<findingType>
		<id>NP_CLONE_COULD_RETURN_NULL</id>
		<artifact tool="FindBugs" mnemonic="Clone Could Return Null">
		</artifact>
		<shortMessage>Clone method may return null</shortMessage>
		<info>

			&lt;p&gt; This clone method seems to return null in some
			circumstances, but clone is never allowed to return a null
			value. If you are convinced this path is unreachable, throw
			an AssertionError instead. &lt;/p&gt;

		</info>
		<name>Clone Could Return Null</name>
	</findingType>
	<findingType>
		<id>NP_TOSTRING_COULD_RETURN_NULL</id>
		<artifact tool="FindBugs"
			mnemonic="Tostring Could Return Null">
		</artifact>
		<shortMessage>toString method may return null</shortMessage>
		<info>

			&lt;p&gt; This toString method seems to return null in some
			circumstances. A liberal reading of the spec could be
			interpreted as allowing this, but it is probably a bad idea
			and could cause other code to break. Return the empty string
			or some other appropriate string rather than null.
			&lt;/p&gt;

		</info>
		<name>Tostring Could Return Null</name>
	</findingType>
	<findingType>
		<id>NP_GUARANTEED_DEREF</id>
		<artifact tool="FindBugs" mnemonic="Guaranteed Deref">
		</artifact>
		<shortMessage>
			Null value is guaranteed to be dereferenced
		</shortMessage>
		<info>

			&lt;p&gt; There is a statement or branch that if executed
			guarantees that a value is null at this point, and that
			value that is guaranteed to be dereferenced (except on
			forward paths involving runtime exceptions). &lt;/p&gt;

		</info>
		<name>Guaranteed Deref</name>
	</findingType>
	<findingType>
		<id>NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH</id>
		<artifact tool="FindBugs"
			mnemonic="Guaranteed Deref On Exception Path">
		</artifact>
		<shortMessage>
			Value is null and guaranteed to be dereferenced on exception
			path
		</shortMessage>
		<info>

			&lt;p&gt; There is a statement or branch on an exception
			path that if executed guarantees that a value is null at
			this point, and that value that is guaranteed to be
			dereferenced (except on forward paths involving runtime
			exceptions). &lt;/p&gt;

		</info>
		<name>Guaranteed Deref On Exception Path</name>
	</findingType>
	<findingType>
		<id>SI_INSTANCE_BEFORE_FINALS_ASSIGNED</id>
		<artifact tool="FindBugs"
			mnemonic="Instance Before Finals Assigned">
		</artifact>
		<shortMessage>
			Static initializer creates instance before all static final
			fields assigned
		</shortMessage>
		<info>

			&lt;p&gt; The class's static initializer creates an instance
			of the class before all of the static final fields are
			assigned.&lt;/p&gt;

		</info>
		<name>Instance Before Finals Assigned</name>
	</findingType>
	<findingType>
		<id>OS_OPEN_STREAM</id>
		<artifact tool="FindBugs" mnemonic="Open Stream"></artifact>
		<shortMessage>Method may fail to close stream</shortMessage>
		<info>

			&lt;p&gt; The method creates an IO stream object, does not
			assign it to any fields, pass it to other methods that might
			close it, or return it, and does not appear to close the
			stream on all paths out of the method.&amp;nbsp; This may
			result in a file descriptor leak.&amp;nbsp; It is generally
			a good idea to use a &lt;code&gt;finally&lt;/code&gt; block
			to ensure that streams are closed.&lt;/p&gt;

		</info>
		<name>Open Stream</name>
	</findingType>
	<findingType>
		<id>OS_OPEN_STREAM_EXCEPTION_PATH</id>
		<artifact tool="FindBugs"
			mnemonic="Open Stream Exception Path">
		</artifact>
		<shortMessage>
			Method may fail to close stream on exception
		</shortMessage>
		<info>

			&lt;p&gt; The method creates an IO stream object, does not
			assign it to any fields, pass it to other methods, or return
			it, and does not appear to close it on all possible
			exception paths out of the method.&amp;nbsp; This may result
			in a file descriptor leak.&amp;nbsp; It is generally a good
			idea to use a &lt;code&gt;finally&lt;/code&gt; block to
			ensure that streams are closed.&lt;/p&gt;

		</info>
		<name>Open Stream Exception Path</name>
	</findingType>
	<findingType>
		<id>PZLA_PREFER_ZERO_LENGTH_ARRAYS</id>
		<artifact tool="FindBugs"
			mnemonic="Prefer Zero Length Arrays">
		</artifact>
		<shortMessage>
			Consider returning a zero length array rather than null
		</shortMessage>
		<info>

			&lt;p&gt; It is often a better design to return a length
			zero array rather than a null reference to indicate that
			there are no results (i.e., an empty list of results). This
			way, no explicit check for null is needed by clients of the
			method.&lt;/p&gt;

			&lt;p&gt;On the other hand, using null to indicate
			&quot;there is no answer to this question&quot;, then it is
			probably appropriate. For example,
			&lt;code&gt;File.listFiles()&lt;/code&gt; returns an empty
			list if given a directory containing no files, and returns
			null if the file is not a directory.&lt;/p&gt;

		</info>
		<name>Prefer Zero Length Arrays</name>
	</findingType>
	<findingType>
		<id>UCF_USELESS_CONTROL_FLOW</id>
		<artifact tool="FindBugs" mnemonic="Useless Control Flow">
		</artifact>
		<shortMessage>Useless control flow</shortMessage>
		<info>

			&lt;p&gt; This method contains a useless control flow
			statement, where control flow continues onto the same place
			regardless of whether or not the branch is taken. For
			example, this is caused by having an empty statement block
			fot an &lt;code&gt;if&lt;/code&gt; statement:&lt;/p&gt;
			&lt;pre&gt; if (argv.length == 0) { // TODO: handle this
			case } &lt;/pre&gt;

		</info>
		<name>Useless Control Flow</name>
	</findingType>
	<findingType>
		<id>UCF_USELESS_CONTROL_FLOW_NEXT_LINE</id>
		<artifact tool="FindBugs"
			mnemonic="Useless Control Flow Next Line">
		</artifact>
		<shortMessage>Useless control flow to next line</shortMessage>
		<info>

			&lt;p&gt; This method contains a useless control flow
			statement in which control flow follows to the same or
			following line regardless of whether or not the branch is
			taken. Often, this is caused by inadvertently using an empty
			statement as the body of an &lt;code&gt;if&lt;/code&gt;
			statement, e.g.:&lt;/p&gt; &lt;pre&gt; if (argv.length ==
			1); System.out.println(&quot;Hello, &quot; + argv[0]);
			&lt;/pre&gt;

		</info>
		<name>Useless Control Flow Next Line</name>
	</findingType>
	<findingType>
		<id>RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE</id>
		<artifact tool="FindBugs"
			mnemonic="Redundant Nullcheck Would Have Been A Npe">
		</artifact>
		<shortMessage>
			Nullcheck of value previously dereferenced
		</shortMessage>
		<info>

			&lt;p&gt; A value is checked here to see whether it is null,
			but this value can't be null because it was previously
			dereferenced and if it were null a null pointer exception
			would have occurred at the earlier dereference. Essentially,
			this code and the previous dereference disagree as to
			whether this value is allowed to be null. Either the check
			is redundant or the previous dereference is
			erroneous.&lt;/p&gt;

		</info>
		<name>Redundant Nullcheck Would Have Been A Npe</name>
	</findingType>
	<findingType>
		<id>RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE</id>
		<artifact tool="FindBugs"
			mnemonic="Redundant Nullcheck Of Null Value">
		</artifact>
		<shortMessage>
			Redundant nullcheck of value known to be null
		</shortMessage>
		<info>

			&lt;p&gt; This method contains a redundant check of a known
			null value against the constant null.&lt;/p&gt;

		</info>
		<name>Redundant Nullcheck Of Null Value</name>
	</findingType>
	<findingType>
		<id>RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE</id>
		<artifact tool="FindBugs"
			mnemonic="Redundant Nullcheck Of Nonnull Value">
		</artifact>
		<shortMessage>
			Redundant nullcheck of value known to be non-null
		</shortMessage>
		<info>

			&lt;p&gt; This method contains a redundant check of a known
			non-null value against the constant null.&lt;/p&gt;

		</info>
		<name>Redundant Nullcheck Of Nonnull Value</name>
	</findingType>
	<findingType>
		<id>RCN_REDUNDANT_COMPARISON_TWO_NULL_VALUES</id>
		<artifact tool="FindBugs"
			mnemonic="Redundant Comparison Two Null Values">
		</artifact>
		<shortMessage>
			Redundant comparison of two null values
		</shortMessage>
		<info>

			&lt;p&gt; This method contains a redundant comparison of two
			references known to both be definitely null.&lt;/p&gt;

		</info>
		<name>Redundant Comparison Two Null Values</name>
	</findingType>
	<findingType>
		<id>RCN_REDUNDANT_COMPARISON_OF_NULL_AND_NONNULL_VALUE</id>
		<artifact tool="FindBugs"
			mnemonic="Redundant Comparison Of Null And Nonnull Value">
		</artifact>
		<shortMessage>
			Redundant comparison of non-null value to null
		</shortMessage>
		<info>

			&lt;p&gt; This method contains a reference known to be
			non-null with another reference known to be null.&lt;/p&gt;

		</info>
		<name>Redundant Comparison Of Null And Nonnull Value</name>
	</findingType>
	<findingType>
		<id>RCN_REDUNDANT_CHECKED_NULL_COMPARISON</id>
		<artifact tool="FindBugs"
			mnemonic="Redundant Checked Null Comparison">
		</artifact>
		<shortMessage>
			Redundant comparison to null of previously checked value
		</shortMessage>
		<info>

			&lt;p&gt; This method contains a redundant comparison of a
			reference value to null. Two types of redundant comparison
			are reported: &lt;/p&gt; &lt;ul&gt; &lt;li&gt; Both values
			compared are definitely null&lt;/li&gt; &lt;li&gt; One value
			is definitely null and the other is definitely not
			null&lt;/li&gt; &lt;/ul&gt;

			&lt;p&gt; This particular warning generally indicates that a
			value known not to be null was checked against null. While
			the check is not necessary, it may simply be a case of
			defensive programming.&lt;/p&gt;

		</info>
		<name>Redundant Checked Null Comparison</name>
	</findingType>
	<findingType>
		<id>UL_UNRELEASED_LOCK</id>
		<artifact tool="FindBugs" mnemonic="Unreleased Lock"></artifact>
		<shortMessage>
			Method does not release lock on all paths
		</shortMessage>
		<info>

			&lt;p&gt; This method acquires a JSR-166
			(&lt;code&gt;java.util.concurrent&lt;/code&gt;) lock, but
			does not release it on all paths out of the method. In
			general, the correct idiom for using a JSR-166 lock is:
			&lt;/p&gt; &lt;pre&gt; Lock l = ...; l.lock(); try { // do
			something } finally { l.unlock(); } &lt;/pre&gt;

		</info>
		<name>Unreleased Lock</name>
	</findingType>
	<findingType>
		<id>UL_UNRELEASED_LOCK_EXCEPTION_PATH</id>
		<artifact tool="FindBugs"
			mnemonic="Unreleased Lock Exception Path">
		</artifact>
		<shortMessage>
			Method does not release lock on all exception paths
		</shortMessage>
		<info>

			&lt;p&gt; This method acquires a JSR-166
			(&lt;code&gt;java.util.concurrent&lt;/code&gt;) lock, but
			does not release it on all exception paths out of the
			method. In general, the correct idiom for using a JSR-166
			lock is: &lt;/p&gt; &lt;pre&gt; Lock l = ...; l.lock(); try
			{ // do something } finally { l.unlock(); } &lt;/pre&gt;

		</info>
		<name>Unreleased Lock Exception Path</name>
	</findingType>
	<findingType>
		<id>RC_REF_COMPARISON</id>
		<artifact tool="FindBugs" mnemonic="Ref Comparison"></artifact>
		<shortMessage>Suspicious reference comparison</shortMessage>
		<info>

			&lt;p&gt; This method compares two reference values using
			the == or != operator, where the correct way to compare
			instances of this type is generally with the equals()
			method. Examples of classes which should generally not be
			compared by reference are java.lang.Integer,
			java.lang.Float, etc.&lt;/p&gt;

		</info>
		<name>Ref Comparison</name>
	</findingType>
	<findingType>
		<id>EC_UNRELATED_TYPES</id>
		<artifact tool="FindBugs" mnemonic="Unrelated Types"></artifact>
		<shortMessage>
			Call to equals() comparing different types
		</shortMessage>
		<info>

			&lt;p&gt; This method calls equals(Object) on two references
			of different class types with no common subclasses.
			Therefore, the objects being compared are unlikely to be
			members of the same class at runtime (unless some
			application classes were not analyzed, or dynamic class
			loading can occur at runtime). According to the contract of
			equals(), objects of different classes should always compare
			as unequal; therefore, according to the contract defined by
			java.lang.Object.equals(Object), the result of this
			comparison will always be false at runtime. &lt;/p&gt;

		</info>
		<name>Unrelated Types</name>
	</findingType>
	<findingType>
		<id>EC_UNRELATED_INTERFACES</id>
		<artifact tool="FindBugs" mnemonic="Unrelated Interfaces">
		</artifact>
		<shortMessage>
			Call to equals() comparing different interface types
		</shortMessage>
		<info>

			&lt;p&gt; This method calls equals(Object) on two references
			of unrelated interface types, where neither is a subtype of
			the other, and there are no known non-abstract classes which
			implement both interfaces. Therefore, the objects being
			compared are unlikely to be members of the same class at
			runtime (unless some application classes were not analyzed,
			or dynamic class loading can occur at runtime). According to
			the contract of equals(), objects of different classes
			should always compare as unequal; therefore, according to
			the contract defined by java.lang.Object.equals(Object), the
			result of this comparison will always be false at runtime.
			&lt;/p&gt;

		</info>
		<name>Unrelated Interfaces</name>
	</findingType>
	<findingType>
		<id>EC_UNRELATED_CLASS_AND_INTERFACE</id>
		<artifact tool="FindBugs"
			mnemonic="Unrelated Class And Interface">
		</artifact>
		<shortMessage>
			Call to equals() comparing unrelated class and interface
		</shortMessage>
		<info>

			&lt;p&gt; This method calls equals(Object) on two
			references, one of which is a class and the other an
			interface, where neither the class nor any of its
			non-abstract subclasses implement the interface. Therefore,
			the objects being compared are unlikely to be members of the
			same class at runtime (unless some application classes were
			not analyzed, or dynamic class loading can occur at
			runtime). According to the contract of equals(), objects of
			different classes should always compare as unequal;
			therefore, according to the contract defined by
			java.lang.Object.equals(Object), the result of this
			comparison will always be false at runtime. &lt;/p&gt;

		</info>
		<name>Unrelated Class And Interface</name>
	</findingType>
	<findingType>
		<id>EC_NULL_ARG</id>
		<artifact tool="FindBugs" mnemonic="Null Arg"></artifact>
		<shortMessage>Call to equals() with null argument</shortMessage>
		<info>

			&lt;p&gt; This method calls equals(Object), passing a null
			value as the argument. According to the contract of the
			equals() method, this call should always return
			&lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;

		</info>
		<name>Null Arg</name>
	</findingType>
	<findingType>
		<id>MWN_MISMATCHED_WAIT</id>
		<artifact tool="FindBugs" mnemonic="Mismatched Wait"></artifact>
		<shortMessage>Mismatched wait()</shortMessage>
		<info>

			&lt;p&gt; This method calls Object.wait() without obviously
			holding a lock on the object.&amp;nbsp; Calling wait()
			without a lock held will result in an
			&lt;code&gt;IllegalMonitorStateException&lt;/code&gt; being
			thrown.&lt;/p&gt;

		</info>
		<name>Mismatched Wait</name>
	</findingType>
	<findingType>
		<id>MWN_MISMATCHED_NOTIFY</id>
		<artifact tool="FindBugs" mnemonic="Mismatched Notify">
		</artifact>
		<shortMessage>Mismatched notify()</shortMessage>
		<info>

			&lt;p&gt; This method calls Object.notify() or
			Object.notifyAll() without obviously holding a lock on the
			object.&amp;nbsp; Calling notify() or notifyAll() without a
			lock held will result in an
			&lt;code&gt;IllegalMonitorStateException&lt;/code&gt; being
			thrown.&lt;/p&gt;

		</info>
		<name>Mismatched Notify</name>
	</findingType>
	<findingType>
		<id>SA_LOCAL_SELF_ASSIGNMENT</id>
		<artifact tool="FindBugs" mnemonic="Local Self Assignment">
		</artifact>
		<shortMessage>Self assignment of local variable</shortMessage>
		<info>

			&lt;p&gt; This method contains a self assignment of a local
			variable; e.g.&lt;/p&gt; &lt;pre&gt; public void foo() { int
			x = 3; x = x; } &lt;/pre&gt; &lt;p&gt; Such assignments are
			useless, and may indicate a logic error or typo. &lt;/p&gt;

		</info>
		<name>Local Self Assignment</name>
	</findingType>
	<findingType>
		<id>SA_FIELD_SELF_ASSIGNMENT</id>
		<artifact tool="FindBugs" mnemonic="Field Self Assignment">
		</artifact>
		<shortMessage>Self assignment of field</shortMessage>
		<info>

			&lt;p&gt; This method contains a self assignment of a field;
			e.g. &lt;/p&gt; &lt;pre&gt; int x; public void foo() { x =
			x; } &lt;/pre&gt; &lt;p&gt;Such assignments are useless, and
			may indicate a logic error or typo.&lt;/p&gt;

		</info>
		<name>Field Self Assignment</name>
	</findingType>
	<findingType>
		<id>SA_FIELD_DOUBLE_ASSIGNMENT</id>
		<artifact tool="FindBugs" mnemonic="Field Double Assignment">
		</artifact>
		<shortMessage>Double assignment of field</shortMessage>
		<info>

			&lt;p&gt; This method contains a double assignment of a
			field; e.g. &lt;/p&gt; &lt;pre&gt; int x,y; public void
			foo() { x = x = 17; } &lt;/pre&gt; &lt;p&gt;Assigning to a
			field twice is useless, and may indicate a logic error or
			typo.&lt;/p&gt;

		</info>
		<name>Field Double Assignment</name>
	</findingType>
	<findingType>
		<id>SA_LOCAL_DOUBLE_ASSIGNMENT</id>
		<artifact tool="FindBugs" mnemonic="Local Double Assignment">
		</artifact>
		<shortMessage>Double assignment of local variable</shortMessage>
		<info>

			&lt;p&gt; This method contains a double assignment of a
			local variable; e.g. &lt;/p&gt; &lt;pre&gt; public void
			foo() { int x,y; x = x = 17; } &lt;/pre&gt;
			&lt;p&gt;Assigning the same value to a variable twice is
			useless, and may indicate a logic error or typo.&lt;/p&gt;

		</info>
		<name>Local Double Assignment</name>
	</findingType>
	<findingType>
		<id>SA_FIELD_SELF_COMPUTATION</id>
		<artifact tool="FindBugs" mnemonic="Field Self Computation">
		</artifact>
		<shortMessage>
			Nonsensical self computation involving a field (e.g., x
			&amp; x)
		</shortMessage>
		<info>

			&lt;p&gt; This method performs a nonsensical computation of
			a field with another reference to the same field (e.g.,
			x&amp;x or x-x). Because of the nature of the computation,
			this operation doesn't seem to make sense, and may indicate
			a typo or a logic error. Double check the computation.
			&lt;/p&gt;

		</info>
		<name>Field Self Computation</name>
	</findingType>
	<findingType>
		<id>SA_LOCAL_SELF_COMPUTATION</id>
		<artifact tool="FindBugs" mnemonic="Local Self Computation">
		</artifact>
		<shortMessage>
			Nonsensical self computation involving a variable (e.g., x
			&amp; x)
		</shortMessage>
		<info>

			&lt;p&gt; This method performs a nonsensical computation of
			a local variable with another reference to the same variable
			(e.g., x&amp;x or x-x). Because of the nature of the
			computation, this operation doesn't seem to make sense, and
			may indicate a typo or a logic error. Double check the
			computation. &lt;/p&gt;

		</info>
		<name>Local Self Computation</name>
	</findingType>
	<findingType>
		<id>SA_FIELD_SELF_COMPARISON</id>
		<artifact tool="FindBugs" mnemonic="Field Self Comparison">
		</artifact>
		<shortMessage>
			Self comparison of field with itself
		</shortMessage>
		<info>

			&lt;p&gt; This method compares a field with itself, and may
			indicate a typo or a logic error. Make sure that you are
			comparing the right things. &lt;/p&gt;

		</info>
		<name>Field Self Comparison</name>
	</findingType>
	<findingType>
		<id>SA_LOCAL_SELF_COMPARISON</id>
		<artifact tool="FindBugs" mnemonic="Local Self Comparison">
		</artifact>
		<shortMessage>
			Self comparison of value with itself
		</shortMessage>
		<info>

			&lt;p&gt; This method compares a local variable with itself,
			and may indicate a typo or a logic error. Make sure that you
			are comparing the right things. &lt;/p&gt;

		</info>
		<name>Local Self Comparison</name>
	</findingType>
	<findingType>
		<id>DMI_LONG_BITS_TO_DOUBLE_INVOKED_ON_INT</id>
		<artifact tool="FindBugs"
			mnemonic="Long Bits To Double Invoked On Int">
		</artifact>
		<shortMessage>
			Double.longBitsToDouble invoked on an int
		</shortMessage>
		<info>

			&lt;p&gt; The Double.longBitsToDouble method is invoked, but
			a 32 bit int value is passed as an argument. This almostly
			certainly is not intended and is unlikely to give the
			intended result. &lt;/p&gt;

		</info>
		<name>Long Bits To Double Invoked On Int</name>
	</findingType>
	<findingType>
		<id>DMI_RANDOM_USED_ONLY_ONCE</id>
		<artifact tool="FindBugs" mnemonic="Random Used Only Once">
		</artifact>
		<shortMessage>
			Random object created and used only once
		</shortMessage>
		<info>

			&lt;p&gt; This code creates a java.util.Random object, uses
			it to generate one random number, and then discards the
			Random object. This produces mediocre quality random numbers
			and is inefficient. If possible, rewrite the code so that
			the Random object is created once and saved, and each time a
			new random number is required invoke a method on the
			existing Random object to obtain it. &lt;/p&gt;

			&lt;p&gt;If it is important that the generated Random
			numbers not be guessable, you &lt;em&gt;must&lt;/em&gt; not
			create a new Random for each random number; the values are
			too easily guessable. You should strongly consider using a
			java.security.SecureRandom instead (and avoid allocating a
			new SecureRandom for each random number needed). &lt;/p&gt;

		</info>
		<name>Random Used Only Once</name>
	</findingType>
	<findingType>
		<id>RV_ABSOLUTE_VALUE_OF_RANDOM_INT</id>
		<artifact tool="FindBugs"
			mnemonic="Absolute Value Of Random Int">
		</artifact>
		<shortMessage>
			Bad attempt to compute absolute value of signed 32-bit
			random integer
		</shortMessage>
		<info>

			&lt;p&gt; This code generates a random signed integer and
			then computes the absolute value of that random integer. If
			the number returned by the random number generator is
			&lt;code&gt;Integer.MIN_VALUE&lt;/code&gt;, then the result
			will be negative as well (since
			&lt;code&gt;Math.abs(Integer.MIN_VALUE) ==
			Integer.MIN_VALUE&lt;/code&gt;). &lt;/p&gt;

		</info>
		<name>Absolute Value Of Random Int</name>
	</findingType>
	<findingType>
		<id>RV_ABSOLUTE_VALUE_OF_HASHCODE</id>
		<artifact tool="FindBugs"
			mnemonic="Absolute Value Of Hashcode">
		</artifact>
		<shortMessage>
			Bad attempt to compute absolute value of signed 32-bit
			hashcode
		</shortMessage>
		<info>

			&lt;p&gt; This code generates a hashcode and then computes
			the absolute value of that hashcode. If the hashcode is
			&lt;code&gt;Integer.MIN_VALUE&lt;/code&gt;, then the result
			will be negative as well (since
			&lt;code&gt;Math.abs(Integer.MIN_VALUE) ==
			Integer.MIN_VALUE&lt;/code&gt;). &lt;/p&gt;

		</info>
		<name>Absolute Value Of Hashcode</name>
	</findingType>
	<findingType>
		<id>RV_REM_OF_RANDOM_INT</id>
		<artifact tool="FindBugs" mnemonic="Rem Of Random Int">
		</artifact>
		<shortMessage>
			Remainder of 32-bit signed random integer
		</shortMessage>
		<info>

			&lt;p&gt; This code generates a random signed integer and
			then computes the remainder of that value modulo another
			value. Since the random number can be negative, the result
			of the remainder operation can also be negative. Be sure
			this is intended, and strongly consider using the
			Random.nextInt(int) method instead. &lt;/p&gt;

		</info>
		<name>Rem Of Random Int</name>
	</findingType>
	<findingType>
		<id>RV_REM_OF_HASHCODE</id>
		<artifact tool="FindBugs" mnemonic="Rem Of Hashcode"></artifact>
		<shortMessage>
			Remainder of hashCode could be negative
		</shortMessage>
		<info>

			&lt;p&gt; This code computes a hashCode, and then computes
			the remainder of that value modulo another value. Since the
			hashCode can be negative, the result of the remainder
			operation can also be negative. &lt;/p&gt; &lt;p&gt;
			Assuming you want to ensure that the result of your
			computation is nonnegative, you may need to change your
			code. If you know the divisor is a power of 2, you can use a
			bitwise and operator instead (i.e., instead of using
			&lt;code&gt;x.hashCode()%n&lt;/code&gt;, use
			&lt;code&gt;x.hashCode()&amp;amp;(n-1)&lt;/code&gt;. This is
			probably faster than computing the remainder as well. If you
			don't know that the divisor is a power of 2, take the
			absolute value of the result of the remainder operation
			(i.e., use &lt;code&gt;Math.abs(x.hashCode()%n)&lt;/code&gt;
			&lt;/p&gt;

		</info>
		<name>Rem Of Hashcode</name>
	</findingType>
	<findingType>
		<id>INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE</id>
		<artifact tool="FindBugs"
			mnemonic="Bad Comparison With Nonnegative Value">
		</artifact>
		<shortMessage>
			Bad comparison of nonnegative value with negative constant
		</shortMessage>
		<info>

			&lt;p&gt; This code compares a value that is guaranteed to
			be non-negative with a negative constant. &lt;/p&gt;

		</info>
		<name>Bad Comparison With Nonnegative Value</name>
	</findingType>
	<findingType>
		<id>INT_BAD_COMPARISON_WITH_SIGNED_BYTE</id>
		<artifact tool="FindBugs"
			mnemonic="Bad Comparison With Signed Byte">
		</artifact>
		<shortMessage>Bad comparison of signed byte</shortMessage>
		<info>

			&lt;p&gt; Signed bytes can only have a value in the range
			-128 to 127. Comparing a signed byte with a value outside
			that range is vacuous and likely to be incorrect. To convert
			a signed byte &lt;code&gt;b&lt;/code&gt; to an unsigned
			value in the range 0..255, use &lt;code&gt;0xff &amp;
			b&lt;/code&gt; &lt;/p&gt;

		</info>
		<name>Bad Comparison With Signed Byte</name>
	</findingType>
	<findingType>
		<id>INT_VACUOUS_COMPARISON</id>
		<artifact tool="FindBugs" mnemonic="Vacuous Comparison">
		</artifact>
		<shortMessage>Vacuous comparison of integer value</shortMessage>
		<info>

			&lt;p&gt; There is an integer comparison that always returns
			the same value (e.g., x &lt;= Integer.MAX_VALUE). &lt;/p&gt;

		</info>
		<name>Vacuous Comparison</name>
	</findingType>
	<findingType>
		<id>INT_BAD_REM_BY_1</id>
		<artifact tool="FindBugs" mnemonic="Bad Rem By 1"></artifact>
		<shortMessage>Integer remainder modulo 1</shortMessage>
		<info>

			&lt;p&gt; Any expression (exp % 1) is guaranteed to always
			return zero. Did you mean (exp &amp; 1) or (exp % 2)
			instead? &lt;/p&gt;

		</info>
		<name>Bad Rem By 1</name>
	</findingType>
	<findingType>
		<id>BIT_IOR_OF_SIGNED_BYTE</id>
		<artifact tool="FindBugs" mnemonic="Ior Of Signed Byte">
		</artifact>
		<shortMessage>Bitwise OR of signed byte value</shortMessage>
		<info>

			&lt;p&gt; Loads a value from a byte array and performs a
			bitwise OR with that value. Values loaded from a byte array
			are sign extended to 32 bits before any any bitwise
			operations are performed on the value. Thus, if
			&lt;code&gt;b[0]&lt;/code&gt; contains the value
			&lt;code&gt;0xff&lt;/code&gt;, and
			&lt;code&gt;x&lt;/code&gt; is initially 0, then the code
			&lt;code&gt;((x &lt;&lt; 8) | b[0])&lt;/code&gt; will sign
			extend &lt;code&gt;0xff&lt;/code&gt; to get
			&lt;code&gt;0xffffffff&lt;/code&gt;, and thus give the value
			&lt;code&gt;0xffffffff&lt;/code&gt; as the result.
			&lt;/p&gt;

			&lt;p&gt;In particular, the following code for packing a
			byte array into an int is badly wrong: &lt;/p&gt;
			&lt;code&gt; int result = 0; for(int i = 0; i &lt; 4; i++)
			result = ((result &lt;&lt; 8) | b[i]); &lt;/code&gt;

			&lt;p&gt;The following idiom will work instead: &lt;/p&gt;
			&lt;code&gt; int result = 0; for(int i = 0; i &lt; 4; i++)
			result = ((result &lt;&lt; 8) | (b[i] &amp;amps; 0xff));
			&lt;/code&gt;


		</info>
		<name>Ior Of Signed Byte</name>
	</findingType>
	<findingType>
		<id>BIT_AND</id>
		<artifact tool="FindBugs" mnemonic="And"></artifact>
		<shortMessage>Incompatible bit masks</shortMessage>
		<info>

			&lt;p&gt; This method compares an expression of the form (a
			&amp;amp; C) to D, which will always compare unequal due to
			the specific values of constants C and D. This may indicate
			a logic error or typo.&lt;/p&gt;

		</info>
		<name>And</name>
	</findingType>
	<findingType>
		<id>BIT_AND_ZZ</id>
		<artifact tool="FindBugs" mnemonic="And Zz"></artifact>
		<shortMessage>
			Check to see if ((...) &amp; 0) == 0
		</shortMessage>
		<info>

			&lt;p&gt; This method compares an expression of the form (a
			&amp;amp; 0) to 0, which will always compare equal. This may
			indicate a logic error or typo.&lt;/p&gt;

		</info>
		<name>And Zz</name>
	</findingType>
	<findingType>
		<id>BIT_IOR</id>
		<artifact tool="FindBugs" mnemonic="Ior"></artifact>
		<shortMessage>Incompatible bit masks</shortMessage>
		<info>

			&lt;p&gt; This method compares an expression of the form (a
			| C) to D. which will always compare unequal due to the
			specific values of constants C and D. This may indicate a
			logic error or typo.&lt;/p&gt;

			&lt;p&gt; Typically, this bug occurs because the code wants
			to perform a membership test in a bit set, but uses the
			bitwise OR operator (&quot;|&quot;) instead of bitwise AND
			(&quot;&amp;amp;&quot;).&lt;/p&gt;

		</info>
		<name>Ior</name>
	</findingType>
	<findingType>
		<id>LI_LAZY_INIT_INSTANCE</id>
		<artifact tool="FindBugs" mnemonic="Lazy Init Instance">
		</artifact>
		<shortMessage>
			Incorrect lazy initialization of instance field
		</shortMessage>
		<info>

			&lt;p&gt; This method contains an unsynchronized lazy
			initialization of a non-volatile field. Because the compiler
			or processor may reorder instructions, threads are not
			guaranteed to see a completely initialized object,
			&lt;em&gt;if the method can be called by multiple
			threads&lt;/em&gt;. You can make the field volatile to
			correct the problem. For more information, see the &lt;a
			href=&quot;http://www.cs.umd.edu/~pugh/java/memoryModel/&quot;&gt;Java
			Memory Model web site&lt;/a&gt;. &lt;/p&gt;

		</info>
		<name>Lazy Init Instance</name>
	</findingType>
	<findingType>
		<id>LI_LAZY_INIT_STATIC</id>
		<artifact tool="FindBugs" mnemonic="Lazy Init Static">
		</artifact>
		<shortMessage>
			Incorrect lazy initialization of static field
		</shortMessage>
		<info>

			&lt;p&gt; This method contains an unsynchronized lazy
			initialization of a non-volatile static field. Because the
			compiler or processor may reorder instructions, threads are
			not guaranteed to see a completely initialized object,
			&lt;em&gt;if the method can be called by multiple
			threads&lt;/em&gt;. You can make the field volatile to
			correct the problem. For more information, see the &lt;a
			href=&quot;http://www.cs.umd.edu/~pugh/java/memoryModel/&quot;&gt;Java
			Memory Model web site&lt;/a&gt;. &lt;/p&gt;

		</info>
		<name>Lazy Init Static</name>
	</findingType>
	<findingType>
		<id>JLM_JSR166_LOCK_MONITORENTER</id>
		<artifact tool="FindBugs" mnemonic="JSR166 Lock Monitorenter">
		</artifact>
		<shortMessage>
			Synchronization performed on java.util.concurrent Lock
		</shortMessage>
		<info>

			&lt;p&gt; This method performs synchronization on an
			implementation of
			&lt;code&gt;java.util.concurrent.locks.Lock&lt;/code&gt;.
			You should use the &lt;code&gt;lock()&lt;/code&gt; and
			&lt;code&gt;unlock()&lt;/code&gt; methods instead.
			&lt;/p&gt;

		</info>
		<name>JSR166 Lock Monitorenter</name>
	</findingType>
	<findingType>
		<id>UPM_UNCALLED_PRIVATE_METHOD</id>
		<artifact tool="FindBugs" mnemonic="Uncalled Private Method">
		</artifact>
		<shortMessage>Private method is never called</shortMessage>
		<info>

			&lt;p&gt; This private method is never called. Although it
			is possible that the method will be invoked through
			reflection, it is more likely that the method is never used,
			and should be removed. &lt;/p&gt;

		</info>
		<name>Uncalled Private Method</name>
	</findingType>
	<findingType>
		<id>UMAC_UNCALLABLE_METHOD_OF_ANONYMOUS_CLASS</id>
		<artifact tool="FindBugs"
			mnemonic="Uncallable Method Of Anonymous Class">
		</artifact>
		<shortMessage>
			Uncallable method defined in anonymous class
		</shortMessage>
		<info>

			&lt;p&gt; This anonymous class defined a method that is not
			directly invoked and does not override a method in a
			superclass. Since methods in other classes cannot directly
			invoke methods declared in an anonymous class, it seems that
			this method is uncallable. The method might simply be dead
			code, but it is also possible that the method is intended to
			override a method declared in a superclass, and due to an
			typo or other error the method does not, in fact, override
			the method it is intended to. &lt;/p&gt;

		</info>
		<name>Uncallable Method Of Anonymous Class</name>
	</findingType>
	<findingType>
		<id>ODR_OPEN_DATABASE_RESOURCE</id>
		<artifact tool="FindBugs" mnemonic="Open Database Resource">
		</artifact>
		<shortMessage>
			Method may fail to close database resource
		</shortMessage>
		<info>

			&lt;p&gt; The method creates a database resource (such as a
			database connection or row set), does not assign it to any
			fields, pass it to other methods, or return it, and does not
			appear to close the object on all paths out of the
			method.&amp;nbsp; Failure to close database resources on all
			paths out of a method may result in poor performance, and
			could cause the application to have problems communicating
			with the database. &lt;/p&gt;

		</info>
		<name>Open Database Resource</name>
	</findingType>
	<findingType>
		<id>ODR_OPEN_DATABASE_RESOURCE_EXCEPTION_PATH</id>
		<artifact tool="FindBugs"
			mnemonic="Open Database Resource Exception Path">
		</artifact>
		<shortMessage>
			Method may fail to close database resource on exception
		</shortMessage>
		<info>

			&lt;p&gt; The method creates a database resource (such as a
			database connection or row set), does not assign it to any
			fields, pass it to other methods, or return it, and does not
			appear to close the object on all exception paths out of the
			method.&amp;nbsp; Failure to close database resources on all
			paths out of a method may result in poor performance, and
			could cause the application to have problems communicating
			with the database.&lt;/p&gt;

		</info>
		<name>Open Database Resource Exception Path</name>
	</findingType>
	<findingType>
		<id>SBSC_USE_STRINGBUFFER_CONCATENATION</id>
		<artifact tool="FindBugs"
			mnemonic="Use Stringbuffer Concatenation">
		</artifact>
		<shortMessage>
			Method concatenates strings using + in a loop
		</shortMessage>
		<info>

			&lt;p&gt; The method seems to be building a String using
			concatenation in a loop. In each iteration, the String is
			converted to a StringBuffer/StringBuilder, appended to, and
			converted back to a String. This can lead to a cost
			quadratic in the number of iterations, as the growing string
			is recopied in each iteration. &lt;/p&gt;

			&lt;p&gt;Better performance can be obtained by using a
			StringBuffer (or StringBuilder in Java 1.5)
			explicitly.&lt;/p&gt;

			&lt;p&gt; For example:&lt;/p&gt; &lt;pre&gt; // This is bad
			String s = &quot;&quot;; for (int i = 0; i &amp;lt;
			field.length; ++i) { s = s + field[i]; }

			// This is better StringBuffer buf = new StringBuffer(); for
			(int i = 0; i &amp;lt; field.length; ++i) {
			buf.append(field[i]); } String s = buf.toString();
			&lt;/pre&gt;

		</info>
		<name>Use Stringbuffer Concatenation</name>
	</findingType>
	<findingType>
		<id>ITA_INEFFICIENT_TO_ARRAY</id>
		<artifact tool="FindBugs" mnemonic="Inefficient To Array">
		</artifact>
		<shortMessage>
			Method uses toArray() with zero-length array argument
		</shortMessage>
		<info>

			&lt;p&gt; This method uses the toArray() method of a
			collection derived class, and passes in a zero-length
			prototype array argument. It is more efficient to use
			&lt;code&gt;myCollection.toArray(new
			Foo[myCollection.size()])&lt;/code&gt; If the array passed
			in is big enough to store all of the elements of the
			collection, then it is populated and returned directly. This
			avoids the need to create a second array (by reflection) to
			return as the result.&lt;/p&gt;

		</info>
		<name>Inefficient To Array</name>
	</findingType>
	<findingType>
		<id>IJU_ASSERT_METHOD_INVOKED_FROM_RUN_METHOD</id>
		<artifact tool="FindBugs"
			mnemonic="Assert Method Invoked From Run Method">
		</artifact>
		<shortMessage>
			JUnit assertion in run method will not be noticed by JUnit
		</shortMessage>
		<info>

			&lt;p&gt; A JUnit assertion is performed in a run method.
			Failed JUnit assertions just result in exceptions being
			thrown. Thus, if this exception occurs in a thread other
			than the thread that invokes the test method, the exception
			will terminate the thread but not result in the test
			failing. &lt;/p&gt;

		</info>
		<name>Assert Method Invoked From Run Method</name>
	</findingType>
	<findingType>
		<id>IJU_SETUP_NO_SUPER</id>
		<artifact tool="FindBugs" mnemonic="Setup No Super"></artifact>
		<shortMessage>
			TestCase implements setUp but doesn't call super.setUp()
		</shortMessage>
		<info>

			&lt;p&gt; Class is a JUnit TestCase and implements the setUp
			method. The setUp method should call super.setUp(), but
			doesn't.&lt;/p&gt;

		</info>
		<name>Setup No Super</name>
	</findingType>
	<findingType>
		<id>IJU_TEARDOWN_NO_SUPER</id>
		<artifact tool="FindBugs" mnemonic="Teardown No Super">
		</artifact>
		<shortMessage>
			TestCase implements tearDown but doesn't call
			super.tearDown()
		</shortMessage>
		<info>

			&lt;p&gt; Class is a JUnit TestCase and implements the
			tearDown method. The tearDown method should call
			super.tearDown(), but doesn't.&lt;/p&gt;

		</info>
		<name>Teardown No Super</name>
	</findingType>
	<findingType>
		<id>IJU_SUITE_NOT_STATIC</id>
		<artifact tool="FindBugs" mnemonic="Suite Not Static">
		</artifact>
		<shortMessage>
			TestCase implements a non-static suite method
		</shortMessage>
		<info>

			&lt;p&gt; Class is a JUnit TestCase and implements the
			suite() method. The suite method should be declared as being
			static, but isn't.&lt;/p&gt;

		</info>
		<name>Suite Not Static</name>
	</findingType>
	<findingType>
		<id>IJU_BAD_SUITE_METHOD</id>
		<artifact tool="FindBugs" mnemonic="Bad Suite Method">
		</artifact>
		<shortMessage>
			TestCase declares a bad suite method
		</shortMessage>
		<info>

			&lt;p&gt; Class is a JUnit TestCase and defines a suite()
			method. However, the suite method needs to be declared as
			either &lt;pre&gt;public static junit.framework.Test
			suite()&lt;/pre&gt; or &lt;pre&gt;public static
			junit.framework.TestSuite suite()&lt;/pre&gt; &lt;/p&gt;

		</info>
		<name>Bad Suite Method</name>
	</findingType>
	<findingType>
		<id>IJU_NO_TESTS</id>
		<artifact tool="FindBugs" mnemonic="No Tests"></artifact>
		<shortMessage>TestCase has no tests</shortMessage>
		<info>

			&lt;p&gt; Class is a JUnit TestCase but has not implemented
			any test methods&lt;/p&gt;

		</info>
		<name>No Tests</name>
	</findingType>
	<findingType>
		<id>BOA_BADLY_OVERRIDDEN_ADAPTER</id>
		<artifact tool="FindBugs" mnemonic="Badly Overridden Adapter">
		</artifact>
		<shortMessage>
			Class overrides a method implemented in super class Adapter
			wrongly
		</shortMessage>
		<info>

			&lt;p&gt; This method overrides a method found in a parent
			class, where that class is an Adapter that implements a
			listener defined in the java.awt.event or javax.swing.event
			package. As a result, this method will not get called when
			the event occurs.&lt;/p&gt;

		</info>
		<name>Badly Overridden Adapter</name>
	</findingType>
	<findingType>
		<id>BRSA_BAD_RESULTSET_ACCESS</id>
		<artifact tool="FindBugs" mnemonic="Bad Resultset Access">
		</artifact>
		<shortMessage>
			Method attempts to access a result set field with index 0
		</shortMessage>
		<info>

			&lt;p&gt; A call to getXXX or updateXXX methods of a result
			set was made where the field index is 0. As ResultSet fields
			start at index 1, this is always a mistake.&lt;/p&gt;

		</info>
		<name>Bad Resultset Access</name>
	</findingType>
	<findingType>
		<id>SQL_BAD_RESULTSET_ACCESS</id>
		<artifact tool="FindBugs" mnemonic="Bad Resultset Access">
		</artifact>
		<shortMessage>
			Method attempts to access a result set field with index 0
		</shortMessage>
		<info>

			&lt;p&gt; A call to getXXX or updateXXX methods of a result
			set was made where the field index is 0. As ResultSet fields
			start at index 1, this is always a mistake.&lt;/p&gt;

		</info>
		<name>Bad Resultset Access</name>
	</findingType>
	<findingType>
		<id>SQL_BAD_PREPARED_STATEMENT_ACCESS</id>
		<artifact tool="FindBugs"
			mnemonic="Bad Prepared Statement Access">
		</artifact>
		<shortMessage>
			Method attempts to access a prepared statement parameter
			with index 0
		</shortMessage>
		<info>

			&lt;p&gt; A call to a setXXX method of a prepared statement
			was made where the parameter index is 0. As parameter
			indexes start at index 1, this is always a
			mistake.&lt;/p&gt;

		</info>
		<name>Bad Prepared Statement Access</name>
	</findingType>
	<findingType>
		<id>SIO_SUPERFLUOUS_INSTANCEOF</id>
		<artifact tool="FindBugs" mnemonic="Superfluous Instanceof">
		</artifact>
		<shortMessage>
			Unnecessary type check done using instanceof operator
		</shortMessage>
		<info>

			&lt;p&gt; Type check performed using the instanceof operator
			where it can be statically determined whether the object is
			of the type requested. &lt;/p&gt;

		</info>
		<name>Superfluous Instanceof</name>
	</findingType>
	<findingType>
		<id>BAC_BAD_APPLET_CONSTRUCTOR</id>
		<artifact tool="FindBugs" mnemonic="Bad Applet Constructor">
		</artifact>
		<shortMessage>
			Bad Applet Constructor relies on uninitialized AppletStub
		</shortMessage>
		<info>

			&lt;p&gt; This constructor calls methods in the parent
			Applet that rely on the AppletStub. Since the AppletStub
			isn't initialized until the init() method of this applet is
			called, these methods will not perform correctly. &lt;/p&gt;

		</info>
		<name>Bad Applet Constructor</name>
	</findingType>
	<findingType>
		<id>EC_ARRAY_AND_NONARRAY</id>
		<artifact tool="FindBugs" mnemonic="Array And Nonarray">
		</artifact>
		<shortMessage>
			equals() used to compare array and nonarray
		</shortMessage>
		<info>

			&lt;p&gt; This method invokes the .equals(Object o) to
			compare an array and a reference that doesn't seem to be an
			array. If things being compared are of different types, they
			are guaranteed to be unequal and the comparison is almost
			certainly an error. Even if they are both arrays, the equals
			method on arrays only determines of the two arrays are the
			same object. To compare the contents of the arrays, use
			java.util.Arrays.equals(Object[], Object[]). &lt;/p&gt;

		</info>
		<name>Array And Nonarray</name>
	</findingType>
	<findingType>
		<id>EC_BAD_ARRAY_COMPARE</id>
		<artifact tool="FindBugs" mnemonic="Bad Array Compare">
		</artifact>
		<shortMessage>
			Invocation of equals() on an array, which is equivalent to
			==
		</shortMessage>
		<info>

			&lt;p&gt; This method invokes the .equals(Object o) method
			on an array. Since arrays do not override the equals method
			of Object, calling equals on an array is the same as
			comparing their addresses. To compare the contents of the
			arrays, use java.util.Arrays.equals(Object[], Object[]).
			&lt;/p&gt;

		</info>
		<name>Bad Array Compare</name>
	</findingType>
	<findingType>
		<id>UOE_USE_OBJECT_EQUALS</id>
		<artifact tool="FindBugs" mnemonic="Use Object Equals">
		</artifact>
		<shortMessage>
			Calls to equals on a final class that doesn't override
			Object's version
		</shortMessage>
		<info>

			&lt;p&gt; This method invokes the .equals(Object o) method
			on a final class that doesn't override the equals method in
			the Object class, effectively making the equals method test
			for sameness, like ==. It is good to use the .equals method,
			but you should consider adding an .equals method in this
			class. &lt;/p&gt; &lt;p&gt;[Bill Pugh]: Sorry, but I
			strongly disagree that this should be a warning, and I think
			your code is just fine. Users of your code shouldn't care
			how you've implemented equals(), and they should never
			depend on == to compare instances, since that bypasses the
			libraries ability to control how objects are compared.
			&lt;/p&gt;

		</info>
		<name>Use Object Equals</name>
	</findingType>
	<findingType>
		<id>STI_INTERRUPTED_ON_CURRENTTHREAD</id>
		<artifact tool="FindBugs"
			mnemonic="Interrupted On Currentthread">
		</artifact>
		<shortMessage>
			Unneeded use of currentThread() call, to call interrupted()
		</shortMessage>
		<info>

			&lt;p&gt; This method invokes the Thread.currentThread()
			call, just to call the interrupted() method. As
			interrupted() is a static method, is more simple and clear
			to use Thread.interrupted(). &lt;/p&gt;

		</info>
		<name>Interrupted On Currentthread</name>
	</findingType>
	<findingType>
		<id>STI_INTERRUPTED_ON_UNKNOWNTHREAD</id>
		<artifact tool="FindBugs"
			mnemonic="Interrupted On Unknownthread">
		</artifact>
		<shortMessage>
			Static Thread.interrupted() method invoked on thread
			instance
		</shortMessage>
		<info>

			&lt;p&gt; This method invokes the Thread.interrupted()
			method on a Thread object that appears to be a Thread object
			that is not the current thread. As the interrupted() method
			is static, the interrupted method will be called on a
			different object than the one the author intended.
			&lt;/p&gt;

		</info>
		<name>Interrupted On Unknownthread</name>
	</findingType>
	<findingType>
		<id>IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN</id>
		<artifact tool="FindBugs"
			mnemonic="Parameter Is Dead But Overwritten">
		</artifact>
		<shortMessage>
			A parameter is dead upon entry to a method but overwritten
		</shortMessage>
		<info>

			&lt;p&gt; The initial value of this parameter is ignored,
			and the parameter is overwritten here. This often indicates
			a mistaken belief that the write to the parameter will be
			conveyed back to the caller. &lt;/p&gt;

		</info>
		<name>Parameter Is Dead But Overwritten</name>
	</findingType>
	<findingType>
		<id>DLS_DEAD_LOCAL_STORE</id>
		<artifact tool="FindBugs" mnemonic="Dead Local Store">
		</artifact>
		<shortMessage>Dead store to local variable</shortMessage>
		<info>

			&lt;p&gt; This instruction assigns a value to a local
			variable, but the value is not read by any subsequent
			instruction. Often, this indicates an error, because the
			value computed is never used. &lt;/p&gt; &lt;p&gt; Note that
			Sun's javac compiler often generates dead stores for final
			local variables. Because FindBugs is a bytecode-based tool,
			there is no easy way to eliminate these false positives.
			&lt;/p&gt;

		</info>
		<name>Dead Local Store</name>
	</findingType>
	<findingType>
		<id>DLS_DEAD_LOCAL_STORE_OF_NULL</id>
		<artifact tool="FindBugs" mnemonic="Dead Local Store Of Null">
		</artifact>
		<shortMessage>
			Dead store of null to local variable
		</shortMessage>
		<info>

			&lt;p&gt;The code stores null into a local variable, and
			stored value is not read. This store may have been
			introduced in assist the garbage collector, but as of Java
			SE 6.0, this is no longer needed or useful. &lt;/p&gt;

		</info>
		<name>Dead Local Store Of Null</name>
	</findingType>
	<findingType>
		<id>MF_METHOD_MASKS_FIELD</id>
		<artifact tool="FindBugs" mnemonic="Method Masks Field">
		</artifact>
		<shortMessage>
			Method defines a variable that obscures a field
		</shortMessage>
		<info>

			&lt;p&gt; This method defines a local variable with the same
			name as a field in this class or a superclass. This may
			cause the method to read an uninitialized value from the
			field, leave the field uninitialized, or both.&lt;/p&gt;

		</info>
		<name>Method Masks Field</name>
	</findingType>
	<findingType>
		<id>MF_CLASS_MASKS_FIELD</id>
		<artifact tool="FindBugs" mnemonic="Class Masks Field">
		</artifact>
		<shortMessage>
			Class defines field that masks a superclass field
		</shortMessage>
		<info>

			&lt;p&gt; This class defines a field with the same name as a
			visible instance field in a superclass. This is confusing,
			and may indicate an error if methods update or access one of
			the fields when they wanted the other.&lt;/p&gt;

		</info>
		<name>Class Masks Field</name>
	</findingType>
	<findingType>
		<id>WMI_WRONG_MAP_ITERATOR</id>
		<artifact tool="FindBugs" mnemonic="Wrong Map Iterator">
		</artifact>
		<shortMessage>
			Inefficient use of keySet iterator instead of entrySet
			iterator
		</shortMessage>
		<info>

			&lt;p&gt; This method accesses the value of a Map entry,
			using a key that was retrieved from a keySet iterator. It is
			more efficient to use an iterator on the entrySet of the
			map, to avoid the Map.get(key) lookup.&lt;/p&gt;

		</info>
		<name>Wrong Map Iterator</name>
	</findingType>
	<findingType>
		<id>ISC_INSTANTIATE_STATIC_CLASS</id>
		<artifact tool="FindBugs" mnemonic="Instantiate Static Class">
		</artifact>
		<shortMessage>
			Needless instantiation of class that only supplies static
			methods
		</shortMessage>
		<info>

			&lt;p&gt; This class allocates an object that is based on a
			class that only supplies static methods. This object does
			not need to be created, just access the static methods
			directly using the class name as a qualifier.&lt;/p&gt;

		</info>
		<name>Instantiate Static Class</name>
	</findingType>
	<findingType>
		<id>REC_CATCH_EXCEPTION</id>
		<artifact tool="FindBugs" mnemonic="Catch Exception"></artifact>
		<shortMessage>
			Exception is caught when Exception is not thrown
		</shortMessage>
		<info>

			&lt;p&gt; This method uses a try-catch block that catches
			Exception objects, but Exception is not thrown within the
			try block, and RuntimeException is not explicitly caught. It
			is a common bug pattern to say try { ... } catch (Exception
			e) { something } as a shorthand for catching a number of
			types of exception each of whose catch blocks is identical,
			but this construct also accidentally catches
			RuntimeException as well, masking potential bugs. &lt;/p&gt;

		</info>
		<name>Catch Exception</name>
	</findingType>
	<findingType>
		<id>FE_TEST_IF_EQUAL_TO_NOT_A_NUMBER</id>
		<artifact tool="FindBugs"
			mnemonic="Test If Equal To Not A Number">
		</artifact>
		<shortMessage>Doomed test for equality to NaN</shortMessage>
		<info>

			&lt;p&gt; This code checks to see if a floating point value
			is equal to the special Not A Number value (e.g.,
			&lt;code&gt;if (x == Double.NaN)&lt;/code&gt;). However,
			because of the special semantics of
			&lt;code&gt;NaN&lt;/code&gt;, no value is equal to
			&lt;code&gt;Nan&lt;/code&gt;, including
			&lt;code&gt;NaN&lt;/code&gt;. Thus, &lt;code&gt;x ==
			Double.NaN&lt;/code&gt; always evaluates to false.

			To check to see if a value contained in
			&lt;code&gt;x&lt;/code&gt; is the special Not A Number
			value, use &lt;code&gt;Double.isNaN(x)&lt;/code&gt; (or
			&lt;code&gt;Float.isNaN(x)&lt;/code&gt; if
			&lt;code&gt;x&lt;/code&gt; is floating point precision).
			&lt;/p&gt;

		</info>
		<name>Test If Equal To Not A Number</name>
	</findingType>
	<findingType>
		<id>FE_FLOATING_POINT_EQUALITY</id>
		<artifact tool="FindBugs" mnemonic="Floating Point Equality">
		</artifact>
		<shortMessage>Test for floating point equality</shortMessage>
		<info>

			&lt;p&gt; This operation compares two floating point values
			for equality. Because floating point calculations may
			involve rounding, calculated float and double values may not
			be accurate. For values that must be precise, such as
			monetary values, consider using a fixed-precision type such
			as BigDecimal. For values that need not be precise, consider
			comparing for equality within some range, for example:
			&lt;code&gt;if ( Math.abs(x - y) &amp;lt; .0000001
			)&lt;/code&gt;. See the Java Language Specification, section
			4.2.4. &lt;/p&gt;

		</info>
		<name>Floating Point Equality</name>
	</findingType>
	<findingType>
		<id>UM_UNNECESSARY_MATH</id>
		<artifact tool="FindBugs" mnemonic="Unnecessary Math">
		</artifact>
		<shortMessage>
			Method calls static Math class method on a constant value
		</shortMessage>
		<info>

			&lt;p&gt; This method uses a static method from
			java.lang.Math on a constant value. This method's result in
			this case, can be determined statically, and is faster and
			sometimes more accurate to just use the constant. Methods
			detected are: &lt;/p&gt; &lt;table&gt; &lt;tr&gt;
			&lt;th&gt;Method&lt;/th&gt; &lt;th&gt;Parameter&lt;/th&gt;
			&lt;/tr&gt; &lt;tr&gt; &lt;td&gt;abs&lt;/td&gt;
			&lt;td&gt;-any-&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;
			&lt;td&gt;acos&lt;/td&gt; &lt;td&gt;0.0 or 1.0&lt;/td&gt;
			&lt;/tr&gt; &lt;tr&gt; &lt;td&gt;asin&lt;/td&gt;
			&lt;td&gt;0.0 or 1.0&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;
			&lt;td&gt;atan&lt;/td&gt; &lt;td&gt;0.0 or 1.0&lt;/td&gt;
			&lt;/tr&gt; &lt;tr&gt; &lt;td&gt;atan2&lt;/td&gt;
			&lt;td&gt;0.0&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;
			&lt;td&gt;cbrt&lt;/td&gt; &lt;td&gt;0.0 or 1.0&lt;/td&gt;
			&lt;/tr&gt; &lt;tr&gt; &lt;td&gt;ceil&lt;/td&gt;
			&lt;td&gt;-any-&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;
			&lt;td&gt;cos&lt;/td&gt; &lt;td&gt;0.0&lt;/td&gt;
			&lt;/tr&gt; &lt;tr&gt; &lt;td&gt;cosh&lt;/td&gt;
			&lt;td&gt;0.0&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;
			&lt;td&gt;exp&lt;/td&gt; &lt;td&gt;0.0 or 1.0&lt;/td&gt;
			&lt;/tr&gt; &lt;tr&gt; &lt;td&gt;expm1&lt;/td&gt;
			&lt;td&gt;0.0&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;
			&lt;td&gt;floor&lt;/td&gt; &lt;td&gt;-any-&lt;/td&gt;
			&lt;/tr&gt; &lt;tr&gt; &lt;td&gt;log&lt;/td&gt;
			&lt;td&gt;0.0 or 1.0&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;
			&lt;td&gt;log10&lt;/td&gt; &lt;td&gt;0.0 or 1.0&lt;/td&gt;
			&lt;/tr&gt; &lt;tr&gt; &lt;td&gt;rint&lt;/td&gt;
			&lt;td&gt;-any-&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;
			&lt;td&gt;round&lt;/td&gt; &lt;td&gt;-any-&lt;/td&gt;
			&lt;/tr&gt; &lt;tr&gt; &lt;td&gt;sin&lt;/td&gt;
			&lt;td&gt;0.0&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;
			&lt;td&gt;sinh&lt;/td&gt; &lt;td&gt;0.0&lt;/td&gt;
			&lt;/tr&gt; &lt;tr&gt; &lt;td&gt;sqrt&lt;/td&gt;
			&lt;td&gt;0.0 or 1.0&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;
			&lt;td&gt;tan&lt;/td&gt; &lt;td&gt;0.0&lt;/td&gt;
			&lt;/tr&gt; &lt;tr&gt; &lt;td&gt;tanh&lt;/td&gt;
			&lt;td&gt;0.0&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;
			&lt;td&gt;toDegrees&lt;/td&gt; &lt;td&gt;0.0 or
			1.0&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;
			&lt;td&gt;toRadians&lt;/td&gt; &lt;td&gt;0.0&lt;/td&gt;
			&lt;/tr&gt; &lt;/table&gt;

		</info>
		<name>Unnecessary Math</name>
	</findingType>
	<findingType>
		<id>CD_CIRCULAR_DEPENDENCY</id>
		<artifact tool="FindBugs" mnemonic="Circular Dependency">
		</artifact>
		<shortMessage>
			Test for circular dependencies among classes
		</shortMessage>
		<info>

			&lt;p&gt; This class has a circular dependency with other
			classes. This makes building these classes difficult, as
			each is dependent on the other to build correctly. Consider
			using interfaces to break the hard dependency. &lt;/p&gt;

		</info>
		<name>Circular Dependency</name>
	</findingType>
	<findingType>
		<id>RI_REDUNDANT_INTERFACES</id>
		<artifact tool="FindBugs" mnemonic="Redundant Interfaces">
		</artifact>
		<shortMessage>
			Class implements same interface as superclass
		</shortMessage>
		<info>

			&lt;p&gt; This class declares that it implements an
			interface that is also implemented by a superclass. This is
			redundant, once a superclass implements an interface, all
			subclasses by default also implement this interface. It may
			point out that the inheritance hierarchy has changed since
			this class was created, and consideration should be taken
			into account for the ownership of the interface's
			implementation. &lt;/p&gt;

		</info>
		<name>Redundant Interfaces</name>
	</findingType>
	<findingType>
		<id>MTIA_SUSPECT_STRUTS_INSTANCE_FIELD</id>
		<artifact tool="FindBugs"
			mnemonic="Suspect Struts Instance Field">
		</artifact>
		<shortMessage>
			Class extends Struts Action class and uses instance
			variables
		</shortMessage>
		<info>

			&lt;p&gt; This class extends from a Struts Action class, and
			uses a instance member variable. Since only one instance of
			a struts Action class is created by the Struts framework,
			and used in a multithreaded way, this paradigm is highly
			discouraged and most likely problematic. Consider only using
			method local variables. &lt;/p&gt;

		</info>
		<name>Suspect Struts Instance Field</name>
	</findingType>
	<findingType>
		<id>MTIA_SUSPECT_SERVLET_INSTANCE_FIELD</id>
		<artifact tool="FindBugs"
			mnemonic="Suspect Servlet Instance Field">
		</artifact>
		<shortMessage>
			Class extends Servlet class and uses instance variables
		</shortMessage>
		<info>

			&lt;p&gt; This class extends from a Servlet class, and uses
			a instance member variable. Since only one instance of a
			Servlet class is created by the J2EE framework, and used in
			a multithreaded way, this paradigm is highly discouraged and
			most likely problematic. Consider only using method local
			variables. &lt;/p&gt;

		</info>
		<name>Suspect Servlet Instance Field</name>
	</findingType>
	<findingType>
		<id>PS_PUBLIC_SEMAPHORES</id>
		<artifact tool="FindBugs" mnemonic="Public Semaphores">
		</artifact>
		<shortMessage>
			Class exposes synchronization and semaphores in its public
			interface
		</shortMessage>
		<info>

			&lt;p&gt; This class uses synchronization along with wait(),
			notify() or notifyAll() on itself (the this reference).
			Client classes that use this class, may, in addition, use an
			instance of this class as a synchronizing object. Because
			two classes are using the same object for synchronization,
			Multithread correctness is suspect. You should not
			synchronize nor call semaphore methods on a public
			reference. Consider using a internal private member variable
			to control synchronization. &lt;/p&gt;

		</info>
		<name>Public Semaphores</name>
	</findingType>
	<findingType>
		<id>ICAST_INTEGER_MULTIPLY_CAST_TO_LONG</id>
		<artifact tool="FindBugs"
			mnemonic="Integer Multiply Cast To Long">
		</artifact>
		<shortMessage>
			Result of integer multiplication cast to long
		</shortMessage>
		<info>

			&lt;p&gt; This code performs integer multiply and then
			converts the result to a long, as in: &lt;code&gt;
			&lt;pre&gt; long convertDaysToMilliseconds(int days) {
			return 1000*3600*24*days; } &lt;/pre&gt;&lt;/code&gt; If the
			multiplication is done using long arithmetic, you can avoid
			the possibility that the result will overflow. For example,
			you could fix the above code to: &lt;code&gt; &lt;pre&gt;
			long convertDaysToMilliseconds(int days) { return
			1000L*3600*24*days; } &lt;/pre&gt;&lt;/code&gt; or
			&lt;code&gt; &lt;pre&gt; static final long
			MILLISECONDS_PER_DAY = 24L*3600*1000; long
			convertDaysToMilliseconds(int days) { return days *
			MILLISECONDS_PER_DAY; } &lt;/pre&gt;&lt;/code&gt; &lt;/p&gt;


		</info>
		<name>Integer Multiply Cast To Long</name>
	</findingType>
	<findingType>
		<id>ICAST_INT_CAST_TO_FLOAT_PASSED_TO_ROUND</id>
		<artifact tool="FindBugs"
			mnemonic="Int Cast To Float Passed To Round">
		</artifact>
		<shortMessage>
			int value cast to float and then passed to Math.round
		</shortMessage>
		<info>

			&lt;p&gt; This code converts an int value to a float
			precision floating point number and then passing the result
			to the Math.round() function, which returns the int/long
			closest to the argument. This operation should always be a
			no-op, since the converting an integer to a float should
			give a number with no fractional part. It is likely that the
			operation that generated the value to be passed to
			Math.round was intended to be performed using floating point
			arithmetic. &lt;/p&gt;


		</info>
		<name>Int Cast To Float Passed To Round</name>
	</findingType>
	<findingType>
		<id>ICAST_INT_CAST_TO_DOUBLE_PASSED_TO_CEIL</id>
		<artifact tool="FindBugs"
			mnemonic="Int Cast To Double Passed To Ceil">
		</artifact>
		<shortMessage>
			int value cast to double and then passed to Math.ceil
		</shortMessage>
		<info>

			&lt;p&gt; This code converts an int value to a double
			precision floating point number and then passing the result
			to the Math.ceil() function, which rounds a double to the
			next higher integer value. This operation should always be a
			no-op, since the converting an integer to a double should
			give a number with no fractional part. It is likely that the
			operation that generated the value to be passed to Math.ceil
			was intended to be performed using double precision floating
			point arithmetic. &lt;/p&gt;


		</info>
		<name>Int Cast To Double Passed To Ceil</name>
	</findingType>
	<findingType>
		<id>ICAST_IDIV_CAST_TO_DOUBLE</id>
		<artifact tool="FindBugs" mnemonic="Idiv Cast To Double">
		</artifact>
		<shortMessage>
			int division result cast to double or float
		</shortMessage>
		<info>

			&lt;p&gt; This code casts the result of an integer division
			operation to double or float. Doing division on integers
			truncates the result to the integer value closest to zero.
			The fact that the result was cast to double suggests that
			this precision should have been retained. What was probably
			meant was to cast one or both of the operands to double
			&lt;em&gt;before&lt;/em&gt; performing the division. Here is
			an example: &lt;/p&gt; &lt;blockquote&gt; &lt;pre&gt; int x
			= 2; int y = 5; // Wrong: yields result 0.0 double value1 =
			x / y;

			// Right: yields result 0.4 double value2 = x / (double) y;
			&lt;/pre&gt; &lt;/blockquote&gt;

		</info>
		<name>Idiv Cast To Double</name>
	</findingType>
	<findingType>
		<id>J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION</id>
		<artifact tool="FindBugs"
			mnemonic="Store Of Non Serializable Object Into Session">
		</artifact>
		<shortMessage>
			Store of non serializable object into HttpSession
		</shortMessage>
		<info>

			&lt;p&gt; This code seems to be storing a non-serializable
			object into an HttpSession. If this session is passivated or
			migrated, an error will result. &lt;/p&gt;

		</info>
		<name>Store Of Non Serializable Object Into Session</name>
	</findingType>
	<findingType>
		<id>DMI_NONSERIALIZABLE_OBJECT_WRITTEN</id>
		<artifact tool="FindBugs"
			mnemonic="Nonserializable Object Written">
		</artifact>
		<shortMessage>
			Non serializable object written to ObjectOutput
		</shortMessage>
		<info>

			&lt;p&gt; This code seems to be passing a non-serializable
			object to the ObjectOutput.writeObject method. If the object
			is, indeed, non-serializable, an error will result.
			&lt;/p&gt;

		</info>
		<name>Nonserializable Object Written</name>
	</findingType>
	<findingType>
		<id>VA_PRIMITIVE_ARRAY_PASSED_TO_OBJECT_VARARG</id>
		<artifact tool="FindBugs"
			mnemonic="Primitive Array Passed To Object Vararg">
		</artifact>
		<shortMessage>
			Primitive array passed to function expecting a variable
			number of object arguments
		</shortMessage>
		<info>

			&lt;p&gt; This code passes a primitive array to a function
			that takes a variable number of object arguments. This
			creates an array of length one to hold the primitive array
			and passes it to the function. &lt;/p&gt;

		</info>
		<name>Primitive Array Passed To Object Vararg</name>
	</findingType>
	<findingType>
		<id>BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS</id>
		<artifact tool="FindBugs"
			mnemonic="Equals Method Should Work For All Objects">
		</artifact>
		<shortMessage>
			Equals method should not assume anything about the type of
			its argument
		</shortMessage>
		<info>

			&lt;p&gt; The &lt;code&gt;equals(Object o)&lt;/code&gt;
			method shouldn't make any assumptions about the type of
			&lt;code&gt;o&lt;/code&gt;. It should simply return false if
			&lt;code&gt;o&lt;/code&gt; is not the same type as
			&lt;code&gt;this&lt;/code&gt;. &lt;/p&gt;

		</info>
		<name>Equals Method Should Work For All Objects</name>
	</findingType>
	<findingType>
		<id>BC_BAD_CAST_TO_ABSTRACT_COLLECTION</id>
		<artifact tool="FindBugs"
			mnemonic="Bad Cast To Abstract Collection">
		</artifact>
		<shortMessage>
			Questionable cast to abstract collection
		</shortMessage>
		<info>

			&lt;p&gt; This code casts a Collection to an abstract
			collection (such as &lt;code&gt;List&lt;/code&gt;,
			&lt;code&gt;Set&lt;/code&gt;, or
			&lt;code&gt;Map&lt;/code&gt;). Ensure that you are
			guaranteed that the object is of the type you are casting
			to. If all you need is to be able to iterate through a
			collection, you don't need to cast it to a Set or List.
			&lt;/p&gt;

		</info>
		<name>Bad Cast To Abstract Collection</name>
	</findingType>
	<findingType>
		<id>BC_IMPOSSIBLE_CAST_PRIMITIVE_ARRAY</id>
		<artifact tool="FindBugs"
			mnemonic="Impossible Cast Primitive Array">
		</artifact>
		<shortMessage>
			Impossible cast involving primitive array
		</shortMessage>
		<info>

			&lt;p&gt; This cast will always throw a ClassCastException.
			&lt;/p&gt;

		</info>
		<name>Impossible Cast Primitive Array</name>
	</findingType>
	<findingType>
		<id>BC_IMPOSSIBLE_CAST</id>
		<artifact tool="FindBugs" mnemonic="Impossible Cast"></artifact>
		<shortMessage>Impossible cast</shortMessage>
		<info>

			&lt;p&gt; This cast will always throw a ClassCastException.
			&lt;/p&gt;

		</info>
		<name>Impossible Cast</name>
	</findingType>
	<findingType>
		<id>NP_NULL_INSTANCEOF</id>
		<artifact tool="FindBugs" mnemonic="Null Instanceof"></artifact>
		<shortMessage>
			A known null value is checked to see if it is an instance of
			a type
		</shortMessage>
		<info>

			&lt;p&gt; This instanceof test will always return false,
			since the value being checked is guaranteed to be null.
			Although this is safe, make sure it isn't an indication of
			some misunderstanding or some other logic error. &lt;/p&gt;

		</info>
		<name>Null Instanceof</name>
	</findingType>
	<findingType>
		<id>BC_NULL_INSTANCEOF</id>
		<artifact tool="FindBugs" mnemonic="Null Instanceof"></artifact>
		<shortMessage>
			A known null value is checked to see if it is an instance of
			a type
		</shortMessage>
		<info>

			&lt;p&gt; This instanceof test will always return false,
			since the value being checked is guaranteed to be null.
			Although this is safe, make sure it isn't an indication of
			some misunderstanding or some other logic error. &lt;/p&gt;

		</info>
		<name>Null Instanceof</name>
	</findingType>
	<findingType>
		<id>BC_IMPOSSIBLE_INSTANCEOF</id>
		<artifact tool="FindBugs" mnemonic="Impossible Instanceof">
		</artifact>
		<shortMessage>instanceof will always return false</shortMessage>
		<info>

			&lt;p&gt; This instanceof test will always return false.
			Although this is safe, make sure it isn't an indication of
			some misunderstanding or some other logic error. &lt;/p&gt;

		</info>
		<name>Impossible Instanceof</name>
	</findingType>
	<findingType>
		<id>BC_VACUOUS_INSTANCEOF</id>
		<artifact tool="FindBugs" mnemonic="Vacuous Instanceof">
		</artifact>
		<shortMessage>instanceof will always return true</shortMessage>
		<info>

			&lt;p&gt; This instanceof test will always return true.
			Although this is safe, make sure it isn't an indication of
			some misunderstanding or some other logic error. &lt;/p&gt;

		</info>
		<name>Vacuous Instanceof</name>
	</findingType>
	<findingType>
		<id>BC_UNCONFIRMED_CAST</id>
		<artifact tool="FindBugs" mnemonic="Unconfirmed Cast">
		</artifact>
		<shortMessage>Unchecked/unconfirmed cast</shortMessage>
		<info>

			&lt;p&gt; This cast is unchecked, and not all instances of
			the type casted from can be cast to the type it is being
			cast to. Ensure that your program logic ensures that this
			cast will not fail. &lt;/p&gt;

		</info>
		<name>Unconfirmed Cast</name>
	</findingType>
	<findingType>
		<id>BC_BAD_CAST_TO_CONCRETE_COLLECTION</id>
		<artifact tool="FindBugs"
			mnemonic="Bad Cast To Concrete Collection">
		</artifact>
		<shortMessage>
			Questionable cast to concrete collection
		</shortMessage>
		<info>

			&lt;p&gt; This code casts an abstract collection (such as a
			Collection, List, or Set) to a specific concrete
			implementation (such as an ArrayList or HashSet). This might
			not be correct, and it may make your code fragile, since it
			makes it harder to switch to other concrete implementations
			at a future point. Unless you have a particular reason to do
			so, just use the abstract collection class. &lt;/p&gt;

		</info>
		<name>Bad Cast To Concrete Collection</name>
	</findingType>
	<findingType>
		<id>RE_POSSIBLE_UNINTENDED_PATTERN</id>
		<artifact tool="FindBugs"
			mnemonic="Possible Unintended Pattern">
		</artifact>
		<shortMessage>
			&quot;.&quot; used for regular expression
		</shortMessage>
		<info>

			&lt;p&gt; A String function is being invoked and
			&quot;.&quot; is being passed to a parameter that takes a
			regular expression as an argument. Is this what you
			intended? For example s.replaceAll(&quot;.&quot;,
			&quot;/&quot;) will return a String in which
			&lt;em&gt;every&lt;/em&gt; character has been replaced by a
			/ character. &lt;/p&gt;

		</info>
		<name>Possible Unintended Pattern</name>
	</findingType>
	<findingType>
		<id>RE_BAD_SYNTAX_FOR_REGULAR_EXPRESSION</id>
		<artifact tool="FindBugs"
			mnemonic="Bad Syntax For Regular Expression">
		</artifact>
		<shortMessage>
			Invalid syntax for regular expression
		</shortMessage>
		<info>

			&lt;p&gt; The code here uses a regular expression that is
			invalid according to the syntax for regular expressions.
			This statement will throw a PatternSyntaxException when
			executed. &lt;/p&gt;

		</info>
		<name>Bad Syntax For Regular Expression</name>
	</findingType>
	<findingType>
		<id>RE_CANT_USE_FILE_SEPARATOR_AS_REGULAR_EXPRESSION</id>
		<artifact tool="FindBugs"
			mnemonic="Cant Use File Separator As Regular Expression">
		</artifact>
		<shortMessage>
			File.separator used for regular expression
		</shortMessage>
		<info>

			&lt;p&gt; The code here uses
			&lt;code&gt;File.separator&lt;/code&gt; where a regular
			expression is required. This will fail on Windows platforms,
			where the &lt;code&gt;File.separator&lt;/code&gt; is a
			backslash, which is interpreted in a regular expression as
			an escape character. Amoung other options, you can just use
			&lt;code&gt;File.separatorChar=='\\' &amp;amp;
			&quot;\\\\&quot; : File.separator&lt;/code&gt; instead of
			&lt;code&gt;File.separator&lt;/code&gt;

			&lt;/p&gt;

		</info>
		<name>Cant Use File Separator As Regular Expression</name>
	</findingType>
	<findingType>
		<id>DLS_OVERWRITTEN_INCREMENT</id>
		<artifact tool="FindBugs" mnemonic="Overwritten Increment">
		</artifact>
		<shortMessage>Overwritten increment</shortMessage>
		<info>

			&lt;p&gt; The code performs an increment operation (e.g.,
			&lt;code&gt;i++&lt;/code&gt;) and then immediately
			overwrites it. For example, &lt;code&gt;i = i++&lt;/code&gt;
			immediately overwrites the incremented value with the
			original value. &lt;/p&gt;

		</info>
		<name>Overwritten Increment</name>
	</findingType>
	<findingType>
		<id>ICAST_QUESTIONABLE_UNSIGNED_RIGHT_SHIFT</id>
		<artifact tool="FindBugs"
			mnemonic="Questionable Unsigned Right Shift">
		</artifact>
		<shortMessage>
			Unsigned right shift cast to short/byte
		</shortMessage>
		<info>

			&lt;p&gt; The code performs an unsigned right shift, whose
			result is then cast to a short or byte, which discards the
			upper bits of the result. Since the upper bits are
			discarded, there may be no difference between a signed and
			unsigned right shift (depending upon the size of the shift).
			&lt;/p&gt;

		</info>
		<name>Questionable Unsigned Right Shift</name>
	</findingType>
	<findingType>
		<id>ICAST_BAD_SHIFT_AMOUNT</id>
		<artifact tool="FindBugs" mnemonic="Bad Shift Amount">
		</artifact>
		<shortMessage>
			Integer shift by an amount not in the range 0..31
		</shortMessage>
		<info>

			&lt;p&gt; The code performs an integer shift by a constant
			amount outside the range 0..31. The effect of this is to use
			the lower 5 bits of the integer value to decide how much to
			shift by. This probably isn't want was expected, and it at
			least confusing. &lt;/p&gt;

		</info>
		<name>Bad Shift Amount</name>
	</findingType>
	<findingType>
		<id>IM_MULTIPLYING_RESULT_OF_IREM</id>
		<artifact tool="FindBugs"
			mnemonic="Multiplying Result Of Irem">
		</artifact>
		<shortMessage>
			Integer multiply of result of integer remainder
		</shortMessage>
		<info>

			&lt;p&gt; The code multiplies the result of an integer
			remaining by an integer constant. Be sure you don't have
			your operator precedence confused. For example i % 60 * 1000
			is (i % 60) * 1000, not i % (60 * 1000). &lt;/p&gt;

		</info>
		<name>Multiplying Result Of Irem</name>
	</findingType>
	<findingType>
		<id>DMI_INVOKING_TOSTRING_ON_ARRAY</id>
		<artifact tool="FindBugs"
			mnemonic="Invoking Tostring On Array">
		</artifact>
		<shortMessage>Invocation of toString on an array</shortMessage>
		<info>

			&lt;p&gt; The code invokes toString on an array, which will
			generate a fairly useless result such as [C@16f0472.
			Consider using Arrays.toString to convert the array into a
			readable String that gives the contents of the array. See
			Programming Puzzlers, chapter 3, puzzle 12. &lt;/p&gt;

		</info>
		<name>Invoking Tostring On Array</name>
	</findingType>
	<findingType>
		<id>IM_AVERAGE_COMPUTATION_COULD_OVERFLOW</id>
		<artifact tool="FindBugs"
			mnemonic="Average Computation Could Overflow">
		</artifact>
		<shortMessage>
			Computation of average could overflow
		</shortMessage>
		<info>

			&lt;p&gt;The code computes the average of two integers using
			either division or signed right shift, and then uses the
			result as the index of an array. If the values being
			averaged are very large, this can overflow (resulting in the
			computation of a negative average). Assuming that the result
			is intended to be nonnegative, you can use an unsigned right
			shift instead. In other words, rather that using
			&lt;code&gt;(low+high)/2&lt;/code&gt;, use
			&lt;code&gt;(low+high) &amp;gt;&amp;gt;&amp;gt;
			1&lt;/code&gt; &lt;/p&gt; &lt;p&gt;This bug exists in many
			earlier implementations of binary search and merge sort.
			Martin Buchholz &lt;a
			href=&quot;http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6412541&quot;&gt;found
			and fixed it&lt;/a&gt; in the JDK libraries, and Joshua
			Bloch &lt;a
			href=&quot;http://googleresearch.blogspot.com/2006/06/extra-extra-read-all-about-it-nearly.html&quot;&gt;widely
			publicized the bug pattern&lt;/a&gt;. &lt;/p&gt;

		</info>
		<name>Average Computation Could Overflow</name>
	</findingType>
	<findingType>
		<id>IM_BAD_CHECK_FOR_ODD</id>
		<artifact tool="FindBugs" mnemonic="Bad Check For Odd">
		</artifact>
		<shortMessage>
			Check for oddness that won't work for negative numbers
		</shortMessage>
		<info>

			&lt;p&gt; The code uses x % 2 == 1 to check to see if a
			value is odd, but this won't work for negative numbers
			(e.g., (-5) % 2 == -1). If this code is intending to check
			for oddness, consider using x &amp; 1 == 1, or x % 2 != 0.
			&lt;/p&gt;

		</info>
		<name>Bad Check For Odd</name>
	</findingType>
	<findingType>
		<id>DMI_HARDCODED_ABSOLUTE_FILENAME</id>
		<artifact tool="FindBugs"
			mnemonic="Hardcoded Absolute Filename">
		</artifact>
		<shortMessage>
			Code contains a hard coded reference to an absolute pathname
		</shortMessage>
		<info>

			&lt;p&gt;This code constructs a File object using a hard
			coded to an absolute pathname (e.g., &lt;code&gt;new
			File(&quot;/home/dannyc/workspace/j2ee/src/share/com/sun/enterprise/deployment&quot;);&lt;/code&gt;
			&lt;/p&gt;

		</info>
		<name>Hardcoded Absolute Filename</name>
	</findingType>
	<findingType>
		<id>DMI_BAD_MONTH</id>
		<artifact tool="FindBugs" mnemonic="Bad Month"></artifact>
		<shortMessage>Bad constant value for month</shortMessage>
		<info>

			&lt;p&gt; This code passes a constant month value outside
			the expected range of 0..11 to a method. &lt;/p&gt;

		</info>
		<name>Bad Month</name>
	</findingType>
	<findingType>
		<id>DMI_USELESS_SUBSTRING</id>
		<artifact tool="FindBugs" mnemonic="Useless Substring">
		</artifact>
		<shortMessage>
			Invocation of substring(0), which returns the original value
		</shortMessage>
		<info>

			&lt;p&gt; This code invokes substring(0) on a String, which
			returns the original value. &lt;/p&gt;

		</info>
		<name>Useless Substring</name>
	</findingType>
	<findingType>
		<id>DMI_CALLING_NEXT_FROM_HASNEXT</id>
		<artifact tool="FindBugs"
			mnemonic="Calling Next From Hasnext">
		</artifact>
		<shortMessage>hasNext method invokes next</shortMessage>
		<info>

			&lt;p&gt; The hasNext() method invokes the next() method.
			This is almost certainly wrong, since the hasNext() method
			is not supposed to change the state of the iterator, and the
			next method is supposed to change the state of the iterator.
			&lt;/p&gt;

		</info>
		<name>Calling Next From Hasnext</name>
	</findingType>
	<findingType>
		<id>SWL_SLEEP_WITH_LOCK_HELD</id>
		<artifact tool="FindBugs" mnemonic="Sleep With Lock Held">
		</artifact>
		<shortMessage>
			Method calls Thread.sleep() with a lock held
		</shortMessage>
		<info>

			&lt;p&gt; This method calls Thread.sleep() with a lock held.
			This may result in very poor performance and scalability, or
			a deadlock, since other threads may be waiting to acquire
			the lock. It is a much better idea to call wait() on the
			lock, which releases the lock and allows other threads to
			run. &lt;/p&gt;

		</info>
		<name>Sleep With Lock Held</name>
	</findingType>
	<findingType>
		<id>DB_DUPLICATE_BRANCHES</id>
		<artifact tool="FindBugs" mnemonic="Duplicate Branches">
		</artifact>
		<shortMessage>
			Method uses the same code for two branches
		</shortMessage>
		<info>

			&lt;p&gt; This method uses the same code to implement two
			branches of a conditional branch. Check to ensure that this
			isn't a coding mistake. &lt;/p&gt;

		</info>
		<name>Duplicate Branches</name>
	</findingType>
	<findingType>
		<id>DB_DUPLICATE_SWITCH_CLAUSES</id>
		<artifact tool="FindBugs" mnemonic="Duplicate Switch Clauses">
		</artifact>
		<shortMessage>
			Method uses the same code for two switch clauses
		</shortMessage>
		<info>

			&lt;p&gt; This method uses the same code to implement two
			clauses of a switch statement. This could be a case of
			duplicate code, but it might also indicate a coding mistake.
			&lt;/p&gt;

		</info>
		<name>Duplicate Switch Clauses</name>
	</findingType>
	<findingType>
		<id>IMA_INEFFICIENT_MEMBER_ACCESS</id>
		<artifact tool="FindBugs"
			mnemonic="Inefficient Member Access">
		</artifact>
		<shortMessage>
			Method accesses a private member variable of owning class
		</shortMessage>
		<info>

			&lt;p&gt; This method of an inner class reads from or writes
			to a private member variable of the owning class, or calls a
			private method of the owning class. The compiler must
			generate a special method to access this private member,
			causing this to be less efficient. Relaxing the protection
			of the member variable or method will allow the compiler to
			treat this as a normal access. &lt;/p&gt;

		</info>
		<name>Inefficient Member Access</name>
	</findingType>
	<findingType>
		<id>XFB_XML_FACTORY_BYPASS</id>
		<artifact tool="FindBugs" mnemonic="Xml Factory Bypass">
		</artifact>
		<shortMessage>
			Method directly allocates a specific implementation of xml
			interfaces
		</shortMessage>
		<info>

			&lt;p&gt; This method allocates a specific implementation of
			an xml interface. It is preferable to use the supplied
			factory classes to create these objects so that the
			implementation can be changed at runtime. See &lt;/p&gt;
			&lt;ul&gt;
			&lt;li&gt;javax.xml.parsers.DocumentBuilderFactory&lt;/li&gt;
			&lt;li&gt;javax.xml.parsers.SAXParserFactory&lt;/li&gt;
			&lt;li&gt;javax.xml.transform.TransformerFactory&lt;/li&gt;
			&lt;li&gt;org.w3c.dom.Document.create&lt;i&gt;XXXX&lt;/i&gt;&lt;/li&gt;
			&lt;/ul&gt; &lt;p&gt;for details.&lt;/p&gt;

		</info>
		<name>Xml Factory Bypass</name>
	</findingType>
	<findingType>
		<id>USM_USELESS_SUBCLASS_METHOD</id>
		<artifact tool="FindBugs" mnemonic="Useless Subclass Method">
		</artifact>
		<shortMessage>
			Method superfluously delegates to parent class method
		</shortMessage>
		<info>

			&lt;p&gt; This derived method merely calls the same
			superclass method passing in the exact parameters received.
			This method can be removed, as it provides no additional
			value. &lt;/p&gt;

		</info>
		<name>Useless Subclass Method</name>
	</findingType>
	<findingType>
		<id>USM_USELESS_ABSTRACT_METHOD</id>
		<artifact tool="FindBugs" mnemonic="Useless Abstract Method">
		</artifact>
		<shortMessage>
			Abstract Method is already defined in implemented interface
		</shortMessage>
		<info>

			&lt;p&gt; This abstract method is already defined in an
			interface that is implemented by this abstract class. This
			method can be removed, as it provides no additional value.
			&lt;/p&gt;

		</info>
		<name>Useless Abstract Method</name>
	</findingType>
	<findingType>
		<id>CI_CONFUSED_INHERITANCE</id>
		<artifact tool="FindBugs" mnemonic="Confused Inheritance">
		</artifact>
		<shortMessage>
			Class is final but declares protected field
		</shortMessage>
		<info>

			&lt;p&gt; This class is declared to be final, but declares
			fields to be protected. Since the class is final, it can not
			be derived from, and the use of protected is confusing. The
			access modifier for the field should be changed to private
			or public to represent the true use for the field.
			&lt;/p&gt;

		</info>
		<name>Confused Inheritance</name>
	</findingType>
	<findingType>
		<id>QBA_QUESTIONABLE_BOOLEAN_ASSIGNMENT</id>
		<artifact tool="FindBugs"
			mnemonic="Questionable Boolean Assignment">
		</artifact>
		<shortMessage>
			Method assigns boolean literal in boolean expression
		</shortMessage>
		<info>

			&lt;p&gt; This method assigns a literal boolean value (true
			or false) to a boolean variable inside an if or while
			expression. Most probably this was supposed to be a boolean
			comparison using ==, not an assignment using =. &lt;/p&gt;

		</info>
		<name>Questionable Boolean Assignment</name>
	</findingType>
	<findingType>
		<id>VR_UNRESOLVABLE_REFERENCE</id>
		<artifact tool="FindBugs" mnemonic="Unresolvable Reference">
		</artifact>
		<shortMessage>
			Class makes reference to unresolvable class or method
		</shortMessage>
		<info>

			&lt;p&gt; This class makes a reference to a class or method
			that can not be resolved using against the libraries it is
			being analyzed with. &lt;/p&gt;

		</info>
		<name>Unresolvable Reference</name>
	</findingType>
	<findingType>
		<id>GC_UNRELATED_TYPES</id>
		<artifact tool="FindBugs" mnemonic="Unrelated Types"></artifact>
		<shortMessage>
			No relationship between generic parameter and method
			argument
		</shortMessage>
		<info>

			&lt;p&gt; This call to a generic container's method contains
			an argument with a different class type from that of the
			container's parameter. Therefore, it is unlikely that the
			container contains any objects with the same type as the
			method argument used here. &lt;/p&gt;

		</info>
		<name>Unrelated Types</name>
	</findingType>
	<findingType>
		<id>STCAL_STATIC_CALENDAR_INSTANCE</id>
		<artifact tool="FindBugs" mnemonic="Static Calendar Instance">
		</artifact>
		<shortMessage>Static Calendar</shortMessage>
		<info>

			&lt;p&gt;Even though the JavaDoc does not contain a hint
			about it, Calendars are inherently unsafe for multihtreaded
			use. Sharing a single instance across thread boundaries
			without proper synchronization will result in erratic
			behavior of the application. Under 1.4 problems seem to
			surface less often than under Java 5 where you will probably
			see random ArrayIndexOutOfBoundsExceptions or
			IndexOutOfBoundsExceptions in
			sun.util.calendar.BaseCalendar.getCalendarDateFromFixedDate().&lt;/p&gt;
			&lt;p&gt;You may also experience serialization
			problems.&lt;/p&gt; &lt;p&gt;Using an instance field is
			recommended.&lt;/p&gt; &lt;p&gt;For more information on this
			see &lt;a
			href=&quot;http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6231579&quot;&gt;Sun
			Bug #6231579&lt;/a&gt; and &lt;a
			href=&quot;http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6178997&quot;&gt;Sun
			Bug #6178997&lt;/a&gt;.&lt;/p&gt;

		</info>
		<name>Static Calendar Instance</name>
	</findingType>
	<findingType>
		<id>STCAL_INVOKE_ON_STATIC_CALENDAR_INSTANCE</id>
		<artifact tool="FindBugs"
			mnemonic="Invoke On Static Calendar Instance">
		</artifact>
		<shortMessage>Call to static Calendar</shortMessage>
		<info>

			&lt;p&gt;Even though the JavaDoc does not contain a hint
			about it, Calendars are inherently unsafe for multihtreaded
			use. The detector has found a call to an instance of
			Calendar that has been obtained via a static field. This
			looks suspicous.&lt;/p&gt; &lt;p&gt;For more information on
			this see &lt;a
			href=&quot;http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6231579&quot;&gt;Sun
			Bug #6231579&lt;/a&gt; and &lt;a
			href=&quot;http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6178997&quot;&gt;Sun
			Bug #6178997&lt;/a&gt;.&lt;/p&gt;

		</info>
		<name>Invoke On Static Calendar Instance</name>
	</findingType>
	<findingType>
		<id>STCAL_STATIC_SIMPLE_DATA_FORMAT_INSTANCE</id>
		<artifact tool="FindBugs"
			mnemonic="Static Simple Data Format Instance">
		</artifact>
		<shortMessage>Static DateFormat</shortMessage>
		<info>

			&lt;p&gt;As the JavaDoc states, DateFormats are inherently
			unsafe for multithreaded use. Sharing a single instance
			across thread boundaries without proper synchronization will
			result in erratic behavior of the application.&lt;/p&gt;
			&lt;p&gt;You may also experience serialization
			problems.&lt;/p&gt; &lt;p&gt;Using an instance field is
			recommended.&lt;/p&gt; &lt;p&gt;For more information on this
			see &lt;a
			href=&quot;http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6231579&quot;&gt;Sun
			Bug #6231579&lt;/a&gt; and &lt;a
			href=&quot;http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6178997&quot;&gt;Sun
			Bug #6178997&lt;/a&gt;.&lt;/p&gt;

		</info>
		<name>Static Simple Data Format Instance</name>
	</findingType>
	<findingType>
		<id>STCAL_INVOKE_ON_STATIC_DATE_FORMAT_INSTANCE</id>
		<artifact tool="FindBugs"
			mnemonic="Invoke On Static Date Format Instance">
		</artifact>
		<shortMessage>Call to static DateFormat</shortMessage>
		<info>

			&lt;p&gt;As the JavaDoc states, DateFormats are inherently
			unsafe for multithreaded use. The detector has found a call
			to an instance of DateFormat that has been obtained via a
			static field. This looks suspicous.&lt;/p&gt; &lt;p&gt;For
			more information on this see &lt;a
			href=&quot;http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6231579&quot;&gt;Sun
			Bug #6231579&lt;/a&gt; and &lt;a
			href=&quot;http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6178997&quot;&gt;Sun
			Bug #6178997&lt;/a&gt;.&lt;/p&gt;

		</info>
		<name>Invoke On Static Date Format Instance</name>
	</findingType>
	<category>
		<findingType>VR_UNRESOLVABLE_REFERENCE</findingType>
		<findingType>IL_INFINITE_LOOP</findingType>
		<findingType>IL_INFINITE_RECURSIVE_LOOP</findingType>
		<findingType>IL_CONTAINER_ADDED_TO_ITSELF</findingType>
		<findingType>TESTING</findingType>
		<findingType>UNKNOWN</findingType>
		<findingType>FL_MATH_USING_FLOAT_PRECISION</findingType>
		<findingType>
			JCIP_FIELD_ISNT_FINAL_IN_IMMUTABLE_CLASS
		</findingType>
		<findingType>
			DMI_ANNOTATION_IS_NOT_VISIBLE_TO_REFLECTION
		</findingType>
		<findingType>
			BX_UNBOXED_AND_COERCED_FOR_TERNARY_OPERATOR
		</findingType>
		<findingType>NP_ARGUMENT_MIGHT_BE_NULL</findingType>
		<findingType>RV_ABSOLUTE_VALUE_OF_RANDOM_INT</findingType>
		<findingType>RV_ABSOLUTE_VALUE_OF_HASHCODE</findingType>
		<findingType>RV_01_TO_INT</findingType>
		<findingType>EQ_OVERRIDING_EQUALS_NOT_SYMMETRIC</findingType>
		<findingType>EQ_DONT_DEFINE_EQUALS_FOR_ENUM</findingType>
		<findingType>HE_USE_OF_UNHASHABLE_CLASS</findingType>
		<findingType>NS_DANGEROUS_NON_SHORT_CIRCUIT</findingType>
		<findingType>UR_UNINIT_READ</findingType>
		<findingType>NM_VERY_CONFUSING</findingType>
		<findingType>NM_METHOD_CONSTRUCTOR_CONFUSION</findingType>
		<findingType>NM_LCASE_HASHCODE</findingType>
		<findingType>NM_LCASE_TOSTRING</findingType>
		<findingType>NM_BAD_EQUAL</findingType>
		<findingType>
			SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH
		</findingType>
		<findingType>NP_UNWRITTEN_FIELD</findingType>
		<findingType>UWF_NULL_FIELD</findingType>
		<findingType>UWF_UNWRITTEN_FIELD</findingType>
		<findingType>RV_RETURN_VALUE_IGNORED</findingType>
		<findingType>RV_RETURN_VALUE_IGNORED2</findingType>
		<findingType>RV_DONT_JUST_NULL_CHECK_READLINE</findingType>
		<findingType>NP_ALWAYS_NULL</findingType>
		<findingType>NP_STORE_INTO_NONNULL_FIELD</findingType>
		<findingType>NP_ALWAYS_NULL_EXCEPTION</findingType>
		<findingType>NP_NULL_ON_SOME_PATH</findingType>
		<findingType>NP_NULL_ON_SOME_PATH_EXCEPTION</findingType>
		<findingType>NP_NULL_PARAM_DEREF</findingType>
		<findingType>NP_NULL_PARAM_DEREF_NONVIRTUAL</findingType>
		<findingType>
			NP_NULL_PARAM_DEREF_ALL_TARGETS_DANGEROUS
		</findingType>
		<findingType>NP_NONNULL_PARAM_VIOLATION</findingType>
		<findingType>NP_NONNULL_RETURN_VIOLATION</findingType>
		<findingType>NP_GUARANTEED_DEREF</findingType>
		<findingType>NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH</findingType>
		<findingType>UCF_USELESS_CONTROL_FLOW_NEXT_LINE</findingType>
		<findingType>
			RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE
		</findingType>
		<findingType>RC_REF_COMPARISON</findingType>
		<findingType>
			VA_PRIMITIVE_ARRAY_PASSED_TO_OBJECT_VARARG
		</findingType>
		<findingType>EC_UNRELATED_TYPES</findingType>
		<findingType>EC_ARRAY_AND_NONARRAY</findingType>
		<findingType>EC_NULL_ARG</findingType>
		<findingType>EC_UNRELATED_INTERFACES</findingType>
		<findingType>EC_UNRELATED_CLASS_AND_INTERFACE</findingType>
		<findingType>INT_BAD_COMPARISON_WITH_SIGNED_BYTE</findingType>
		<findingType>
			INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE
		</findingType>
		<findingType>INT_BAD_REM_BY_1</findingType>
		<findingType>BIT_IOR_OF_SIGNED_BYTE</findingType>
		<findingType>BIT_AND</findingType>
		<findingType>BIT_AND_ZZ</findingType>
		<findingType>BIT_IOR</findingType>
		<findingType>SA_FIELD_SELF_ASSIGNMENT</findingType>
		<findingType>SA_LOCAL_DOUBLE_ASSIGNMENT</findingType>
		<findingType>SA_FIELD_DOUBLE_ASSIGNMENT</findingType>
		<findingType>SA_FIELD_SELF_COMPUTATION</findingType>
		<findingType>SA_LOCAL_SELF_COMPUTATION</findingType>
		<findingType>SA_FIELD_SELF_COMPARISON</findingType>
		<findingType>SA_LOCAL_SELF_COMPARISON</findingType>
		<findingType>
			UMAC_UNCALLABLE_METHOD_OF_ANONYMOUS_CLASS
		</findingType>
		<findingType>
			IJU_ASSERT_METHOD_INVOKED_FROM_RUN_METHOD
		</findingType>
		<findingType>IJU_BAD_SUITE_METHOD</findingType>
		<findingType>IJU_SETUP_NO_SUPER</findingType>
		<findingType>IJU_TEARDOWN_NO_SUPER</findingType>
		<findingType>IJU_SUITE_NOT_STATIC</findingType>
		<findingType>IJU_NO_TESTS</findingType>
		<findingType>BOA_BADLY_OVERRIDDEN_ADAPTER</findingType>
		<findingType>BRSA_BAD_RESULTSET_ACCESS</findingType>
		<findingType>SQL_BAD_RESULTSET_ACCESS</findingType>
		<findingType>SQL_BAD_PREPARED_STATEMENT_ACCESS</findingType>
		<findingType>SIO_SUPERFLUOUS_INSTANCEOF</findingType>
		<findingType>BAC_BAD_APPLET_CONSTRUCTOR</findingType>
		<findingType>EC_BAD_ARRAY_COMPARE</findingType>
		<findingType>STI_INTERRUPTED_ON_CURRENTTHREAD</findingType>
		<findingType>STI_INTERRUPTED_ON_UNKNOWNTHREAD</findingType>
		<findingType>IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN</findingType>
		<findingType>MF_METHOD_MASKS_FIELD</findingType>
		<findingType>MF_CLASS_MASKS_FIELD</findingType>
		<findingType>FE_TEST_IF_EQUAL_TO_NOT_A_NUMBER</findingType>
		<findingType>
			ICAST_INT_CAST_TO_DOUBLE_PASSED_TO_CEIL
		</findingType>
		<findingType>
			ICAST_INT_CAST_TO_FLOAT_PASSED_TO_ROUND
		</findingType>
		<findingType>NP_NULL_INSTANCEOF</findingType>
		<findingType>BC_NULL_INSTANCEOF</findingType>
		<findingType>
			DMI_LONG_BITS_TO_DOUBLE_INVOKED_ON_INT
		</findingType>
		<findingType>BC_IMPOSSIBLE_CAST_PRIMITIVE_ARRAY</findingType>
		<findingType>BC_IMPOSSIBLE_CAST</findingType>
		<findingType>BC_IMPOSSIBLE_INSTANCEOF</findingType>
		<findingType>RE_POSSIBLE_UNINTENDED_PATTERN</findingType>
		<findingType>RE_BAD_SYNTAX_FOR_REGULAR_EXPRESSION</findingType>
		<findingType>
			RE_CANT_USE_FILE_SEPARATOR_AS_REGULAR_EXPRESSION
		</findingType>
		<findingType>DLS_OVERWRITTEN_INCREMENT</findingType>
		<findingType>ICAST_BAD_SHIFT_AMOUNT</findingType>
		<findingType>IM_MULTIPLYING_RESULT_OF_IREM</findingType>
		<findingType>DMI_INVOKING_TOSTRING_ON_ARRAY</findingType>
		<findingType>DMI_BAD_MONTH</findingType>
		<findingType>DMI_CALLING_NEXT_FROM_HASNEXT</findingType>
		<findingType>QBA_QUESTIONABLE_BOOLEAN_ASSIGNMENT</findingType>
		<findingType>GC_UNRELATED_TYPES</findingType>
		<name>Correctness</name>
		<description>
			Probable bug - an apparent coding mistake resulting in code
			that was probably not what the developer intended. We strive
			for a low false positive rate.
		</description>
	</category>
	<category>
		<findingType>
			SW_SWING_METHODS_INVOKED_IN_SWING_THREAD
		</findingType>
		<findingType>FI_FINALIZER_ONLY_NULLS_FIELDS</findingType>
		<findingType>FI_FINALIZER_NULLS_FIELDS</findingType>
		<findingType>UI_INHERITANCE_UNSAFE_GETRESOURCE</findingType>
		<findingType>AM_CREATES_EMPTY_ZIP_FILE_ENTRY</findingType>
		<findingType>AM_CREATES_EMPTY_JAR_FILE_ENTRY</findingType>
		<findingType>DP_DO_INSIDE_DO_PRIVILEGED</findingType>
		<findingType>DP_DO_INSIDE_DO_PRIVILEDGED</findingType>
		<findingType>
			DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED
		</findingType>
		<findingType>
			DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEDGED
		</findingType>
		<findingType>IMSE_DONT_CATCH_IMSE</findingType>
		<findingType>CN_IDIOM</findingType>
		<findingType>CN_IDIOM_NO_SUPER_CALL</findingType>
		<findingType>DE_MIGHT_DROP</findingType>
		<findingType>DE_MIGHT_IGNORE</findingType>
		<findingType>DM_EXIT</findingType>
		<findingType>NM_FUTURE_KEYWORD_USED_AS_IDENTIFIER</findingType>
		<findingType>
			NM_FUTURE_KEYWORD_USED_AS_MEMBER_IDENTIFIER
		</findingType>
		<findingType>DM_RUN_FINALIZERS_ON_EXIT</findingType>
		<findingType>NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT</findingType>
		<findingType>
			SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE
		</findingType>
		<findingType>
			SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING
		</findingType>
		<findingType>FI_EMPTY</findingType>
		<findingType>FI_NULLIFY_SUPER</findingType>
		<findingType>FI_USELESS</findingType>
		<findingType>FI_MISSING_SUPER_CALL</findingType>
		<findingType>FI_EXPLICIT_INVOCATION</findingType>
		<findingType>EQ_SELF_USE_OBJECT</findingType>
		<findingType>EQ_SELF_NO_OBJECT</findingType>
		<findingType>NP_DOES_NOT_HANDLE_NULL</findingType>
		<findingType>CO_SELF_NO_OBJECT</findingType>
		<findingType>ES_COMPARING_STRINGS_WITH_EQ</findingType>
		<findingType>ES_COMPARING_PARAMETER_STRING_WITH_EQ</findingType>
		<findingType>EQ_COMPARETO_USE_OBJECT_EQUALS</findingType>
		<findingType>HE_HASHCODE_USE_OBJECT_EQUALS</findingType>
		<findingType>HE_HASHCODE_NO_EQUALS</findingType>
		<findingType>HE_EQUALS_USE_HASHCODE</findingType>
		<findingType>HE_INHERITS_EQUALS_USE_HASHCODE</findingType>
		<findingType>HE_EQUALS_NO_HASHCODE</findingType>
		<findingType>EQ_ABSTRACT_SELF</findingType>
		<findingType>CO_ABSTRACT_SELF</findingType>
		<findingType>NS_NON_SHORT_CIRCUIT</findingType>
		<findingType>
			IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION
		</findingType>
		<findingType>SI_INSTANCE_BEFORE_FINALS_ASSIGNED</findingType>
		<findingType>IT_NO_SUCH_ELEMENT</findingType>
		<findingType>NM_METHOD_NAMING_CONVENTION</findingType>
		<findingType>NM_FIELD_NAMING_CONVENTION</findingType>
		<findingType>NM_CLASS_NAMING_CONVENTION</findingType>
		<findingType>NM_VERY_CONFUSING_INTENTIONAL</findingType>
		<findingType>NM_CONFUSING</findingType>
		<findingType>NM_CLASS_NOT_EXCEPTION</findingType>
		<findingType>RR_NOT_CHECKED</findingType>
		<findingType>SR_NOT_CHECKED</findingType>
		<findingType>SE_NO_SUITABLE_CONSTRUCTOR</findingType>
		<findingType>
			SE_NO_SUITABLE_CONSTRUCTOR_FOR_EXTERNALIZATION
		</findingType>
		<findingType>SE_COMPARATOR_SHOULD_BE_SERIALIZABLE</findingType>
		<findingType>SE_NO_SERIALVERSIONID</findingType>
		<findingType>SE_READ_RESOLVE_MUST_RETURN_OBJECT</findingType>
		<findingType>SE_TRANSIENT_FIELD_NOT_RESTORED</findingType>
		<findingType>SE_NONFINAL_SERIALVERSIONID</findingType>
		<findingType>SE_NONSTATIC_SERIALVERSIONID</findingType>
		<findingType>SE_NONLONG_SERIALVERSIONID</findingType>
		<findingType>SE_METHOD_MUST_BE_PRIVATE</findingType>
		<findingType>SE_BAD_FIELD</findingType>
		<findingType>SE_INNER_CLASS</findingType>
		<findingType>SE_BAD_FIELD_INNER_CLASS</findingType>
		<findingType>SE_BAD_FIELD_STORE</findingType>
		<findingType>NP_TOSTRING_COULD_RETURN_NULL</findingType>
		<findingType>NP_CLONE_COULD_RETURN_NULL</findingType>
		<findingType>OS_OPEN_STREAM</findingType>
		<findingType>OS_OPEN_STREAM_EXCEPTION_PATH</findingType>
		<findingType>ODR_OPEN_DATABASE_RESOURCE</findingType>
		<findingType>
			ODR_OPEN_DATABASE_RESOURCE_EXCEPTION_PATH
		</findingType>
		<findingType>ISC_INSTANTIATE_STATIC_CLASS</findingType>
		<findingType>DMI_RANDOM_USED_ONLY_ONCE</findingType>
		<findingType>
			BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS
		</findingType>
		<findingType>
			J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION
		</findingType>
		<name>Bad practice</name>
		<description>
			Violations of recommended and essential coding practice.
			Examples include hash code and equals problems, cloneable
			idiom, dropped exceptions, Serializable problems, and misuse
			of finalize. We strive to make this analysis accurate,
			although some groups may not care about some of the bad
			practices.
		</description>
	</category>
	<category>
		<findingType>
			DMI_THREAD_PASSED_WHERE_RUNNABLE_EXPECTED
		</findingType>
		<findingType>NP_IMMEDIATE_DEREFERENCE_OF_READLINE</findingType>
		<findingType>RV_REM_OF_RANDOM_INT</findingType>
		<findingType>RV_REM_OF_HASHCODE</findingType>
		<findingType>IC_INIT_CIRCULARITY</findingType>
		<findingType>
			IA_AMBIGUOUS_INVOCATION_OF_INHERITED_OR_OUTER_METHOD
		</findingType>
		<findingType>
			SE_TRANSIENT_FIELD_OF_NONSERIALIZABLE_CLASS
		</findingType>
		<findingType>SF_SWITCH_FALLTHROUGH</findingType>
		<findingType>QF_QUESTIONABLE_FOR_LOOP</findingType>
		<findingType>
			NP_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR
		</findingType>
		<findingType>
			UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR
		</findingType>
		<findingType>RV_CHECK_FOR_POSITIVE_INDEXOF</findingType>
		<findingType>
			NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE
		</findingType>
		<findingType>NP_LOAD_OF_KNOWN_NULL_VALUE</findingType>
		<findingType>PZLA_PREFER_ZERO_LENGTH_ARRAYS</findingType>
		<findingType>UCF_USELESS_CONTROL_FLOW</findingType>
		<findingType>RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE</findingType>
		<findingType>
			RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
		</findingType>
		<findingType>
			RCN_REDUNDANT_COMPARISON_TWO_NULL_VALUES
		</findingType>
		<findingType>
			RCN_REDUNDANT_COMPARISON_OF_NULL_AND_NONNULL_VALUE
		</findingType>
		<findingType>SA_LOCAL_SELF_ASSIGNMENT</findingType>
		<findingType>INT_VACUOUS_COMPARISON</findingType>
		<findingType>UOE_USE_OBJECT_EQUALS</findingType>
		<findingType>DLS_DEAD_LOCAL_STORE</findingType>
		<findingType>DLS_DEAD_LOCAL_STORE_OF_NULL</findingType>
		<findingType>REC_CATCH_EXCEPTION</findingType>
		<findingType>FE_FLOATING_POINT_EQUALITY</findingType>
		<findingType>CD_CIRCULAR_DEPENDENCY</findingType>
		<findingType>RI_REDUNDANT_INTERFACES</findingType>
		<findingType>MTIA_SUSPECT_STRUTS_INSTANCE_FIELD</findingType>
		<findingType>MTIA_SUSPECT_SERVLET_INSTANCE_FIELD</findingType>
		<findingType>PS_PUBLIC_SEMAPHORES</findingType>
		<findingType>ICAST_INTEGER_MULTIPLY_CAST_TO_LONG</findingType>
		<findingType>ICAST_IDIV_CAST_TO_DOUBLE</findingType>
		<findingType>BC_BAD_CAST_TO_CONCRETE_COLLECTION</findingType>
		<findingType>BC_UNCONFIRMED_CAST</findingType>
		<findingType>BC_VACUOUS_INSTANCEOF</findingType>
		<findingType>BC_BAD_CAST_TO_ABSTRACT_COLLECTION</findingType>
		<findingType>IM_BAD_CHECK_FOR_ODD</findingType>
		<findingType>IM_AVERAGE_COMPUTATION_COULD_OVERFLOW</findingType>
		<findingType>
			ICAST_QUESTIONABLE_UNSIGNED_RIGHT_SHIFT
		</findingType>
		<findingType>DMI_HARDCODED_ABSOLUTE_FILENAME</findingType>
		<findingType>DMI_USELESS_SUBSTRING</findingType>
		<findingType>
			ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD
		</findingType>
		<findingType>DMI_NONSERIALIZABLE_OBJECT_WRITTEN</findingType>
		<findingType>DB_DUPLICATE_BRANCHES</findingType>
		<findingType>DB_DUPLICATE_SWITCH_CLAUSES</findingType>
		<findingType>XFB_XML_FACTORY_BYPASS</findingType>
		<findingType>USM_USELESS_SUBCLASS_METHOD</findingType>
		<findingType>USM_USELESS_ABSTRACT_METHOD</findingType>
		<findingType>CI_CONFUSED_INHERITANCE</findingType>
		<name>Dodgy</name>
		<description>
			code that is confusing, anomalous, or written in a way that
			leads itself to errors. Examples include dead local stores,
			switch fall through, unconfirmed casts, and redundant null
			check of value known to be null. More false positives
			accepted. In previous versions of FindBugs, this category
			was known as Style.
		</description>
	</category>
	<category>
		<findingType>HSC_HUGE_SHARED_STRING_CONSTANT</findingType>
		<findingType>DMI_BLOCKING_METHODS_ON_URL</findingType>
		<findingType>DMI_COLLECTION_OF_URLS</findingType>
		<findingType>DM_STRING_CTOR</findingType>
		<findingType>DM_STRING_VOID_CTOR</findingType>
		<findingType>DM_STRING_TOSTRING</findingType>
		<findingType>DM_GC</findingType>
		<findingType>DM_BOOLEAN_CTOR</findingType>
		<findingType>DM_NUMBER_CTOR</findingType>
		<findingType>DM_FP_NUMBER_CTOR</findingType>
		<findingType>DM_STRING_EMPTY_EQUALS</findingType>
		<findingType>DM_BOXED_PRIMITIVE_TOSTRING</findingType>
		<findingType>BX_BOXING_IMMEDIATELY_UNBOXED</findingType>
		<findingType>
			BX_BOXING_IMMEDIATELY_UNBOXED_TO_PERFORM_COERCION
		</findingType>
		<findingType>DM_NEW_FOR_GETCLASS</findingType>
		<findingType>DM_NEXTINT_VIA_NEXTDOUBLE</findingType>
		<findingType>SS_SHOULD_BE_STATIC</findingType>
		<findingType>UUF_UNUSED_FIELD</findingType>
		<findingType>URF_UNREAD_FIELD</findingType>
		<findingType>SIC_INNER_SHOULD_BE_STATIC</findingType>
		<findingType>SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS</findingType>
		<findingType>SIC_INNER_SHOULD_BE_STATIC_ANON</findingType>
		<findingType>UPM_UNCALLED_PRIVATE_METHOD</findingType>
		<findingType>SBSC_USE_STRINGBUFFER_CONCATENATION</findingType>
		<findingType>ITA_INEFFICIENT_TO_ARRAY</findingType>
		<findingType>WMI_WRONG_MAP_ITERATOR</findingType>
		<findingType>UM_UNNECESSARY_MATH</findingType>
		<findingType>IMA_INEFFICIENT_MEMBER_ACCESS</findingType>
		<name>Performance</name>
		<description>
			code that is not necessarily incorrect but may be
			inefficient
		</description>
	</category>
	<category>
		<findingType>FI_PUBLIC_SHOULD_BE_PROTECTED</findingType>
		<findingType>MS_EXPOSE_REP</findingType>
		<findingType>EI_EXPOSE_REP</findingType>
		<findingType>EI_EXPOSE_REP2</findingType>
		<findingType>EI_EXPOSE_STATIC_REP2</findingType>
		<findingType>MS_OOI_PKGPROTECT</findingType>
		<findingType>MS_FINAL_PKGPROTECT</findingType>
		<findingType>MS_SHOULD_BE_FINAL</findingType>
		<findingType>MS_PKGPROTECT</findingType>
		<findingType>MS_MUTABLE_HASHTABLE</findingType>
		<findingType>MS_MUTABLE_ARRAY</findingType>
		<findingType>MS_CANNOT_BE_FINAL</findingType>
		<name>Malicious code vulnerability</name>
		<description>
			code that is vulnerable to attacks from untrusted code
		</description>
	</category>
	<category>
		<findingType>STCAL_STATIC_CALENDAR_INSTANCE</findingType>
		<findingType>
			STCAL_STATIC_SIMPLE_DATA_FORMAT_INSTANCE
		</findingType>
		<findingType>
			STCAL_INVOKE_ON_STATIC_CALENDAR_INSTANCE
		</findingType>
		<findingType>
			STCAL_INVOKE_ON_STATIC_DATE_FORMAT_INSTANCE
		</findingType>
		<findingType>NP_SYNC_AND_NULL_CHECK_FIELD</findingType>
		<findingType>VO_VOLATILE_REFERENCE_TO_ARRAY</findingType>
		<findingType>DM_MONITOR_WAIT_ON_CONDITION</findingType>
		<findingType>DM_USELESS_THREAD</findingType>
		<findingType>DC_DOUBLECHECK</findingType>
		<findingType>DL_SYNCHRONIZATION_ON_SHARED_CONSTANT</findingType>
		<findingType>ESync_EMPTY_SYNC</findingType>
		<findingType>IS2_INCONSISTENT_SYNC</findingType>
		<findingType>NN_NAKED_NOTIFY</findingType>
		<findingType>RU_INVOKE_RUN</findingType>
		<findingType>SP_SPIN_ON_FIELD</findingType>
		<findingType>TLW_TWO_LOCK_WAIT</findingType>
		<findingType>TLW_TWO_LOCK_NOTIFY</findingType>
		<findingType>UW_UNCOND_WAIT</findingType>
		<findingType>UG_SYNC_SET_UNSYNC_GET</findingType>
		<findingType>IS_INCONSISTENT_SYNC</findingType>
		<findingType>IS_FIELD_NOT_GUARDED</findingType>
		<findingType>ML_SYNC_ON_UPDATED_FIELD</findingType>
		<findingType>WS_WRITEOBJECT_SYNC</findingType>
		<findingType>RS_READOBJECT_SYNC</findingType>
		<findingType>SC_START_IN_CTOR</findingType>
		<findingType>WA_NOT_IN_LOOP</findingType>
		<findingType>WA_AWAIT_NOT_IN_LOOP</findingType>
		<findingType>NO_NOTIFY_NOT_NOTIFYALL</findingType>
		<findingType>UL_UNRELEASED_LOCK</findingType>
		<findingType>UL_UNRELEASED_LOCK_EXCEPTION_PATH</findingType>
		<findingType>MWN_MISMATCHED_WAIT</findingType>
		<findingType>MWN_MISMATCHED_NOTIFY</findingType>
		<findingType>LI_LAZY_INIT_INSTANCE</findingType>
		<findingType>LI_LAZY_INIT_STATIC</findingType>
		<findingType>JLM_JSR166_LOCK_MONITORENTER</findingType>
		<findingType>SWL_SLEEP_WITH_LOCK_HELD</findingType>
		<name>Multithreaded correctness</name>
		<description>
			code flaws having to do with threads, locks, and volatiles
		</description>
	</category>
	<category>
		<findingType>DM_CONVERT_CASE</findingType>
		<name>Internationalization</name>
		<description>
			code flaws having to do with internationalization and locale
		</description>
	</category>
</tns:findingTypes>
