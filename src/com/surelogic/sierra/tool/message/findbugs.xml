<?xml version="1.0" encoding="UTF-8"?>
<findingTypes>
	<findingType>
		<id>SwingMethodsShouldBeInvokedInSwingThread</id>
		<artifact tool="FindBugs"
			mnemonic="SW_SWING_METHODS_INVOKED_IN_SWING_THREAD">
		</artifact>
		<shortMessage>
			Certain Swing methods need to be invoked in the Swing event
			dispatch thread
		</shortMessage>
		<info>
			<![CDATA[<p>(<a href="http://java.sun.com/developer/JDCTechTips/2003/tt1208.html#1">From JDC Tech Tip</a>):
The Swing methods <code>show()</code>,
<code>setVisible()</code>, and <code>pack()</code> will create the associated peer for
the frame. With the creation of the peer, the system creates
the event dispatch thread. This makes things problematic
because the event dispatch thread could be notifying
listeners while pack and validate are still processing. This
situation could result in two threads going through the
Swing component-based GUI&mdash;it's a serious flaw that could
result in deadlocks or other related threading issues. A
pack call causes components to be realized. As they are
being realized (that is, not necessarily visible), they
could trigger listener notification on the event dispatch
thread.</p>]]>
		</info>
		<name>Swing Methods Should Be Invoked In Swing Thread</name>
	</findingType>
	<findingType>
		<id>CaughtInfiniteLoop</id>
		<artifact tool="FindBugs" mnemonic="IL_INFINITE_LOOP">
		</artifact>
		<shortMessage>An apparent infinite loop</shortMessage>
		<info>
			&lt;p&gt;This loop doesn't seem to have a way to terminate
			(other than by perhaps throwing an exception).&lt;/p&gt;
		</info>
		<name>Caught Infinite Loop</name>
	</findingType>
	<findingType>
		<id>CaughtInfiniteRecursiveLoop</id>
		<artifact tool="FindBugs"
			mnemonic="IL_INFINITE_RECURSIVE_LOOP">
		</artifact>
		<shortMessage>An apparent infinite recursive loop</shortMessage>
		<info>
			&lt;p&gt;This method unconditionally invokes itself. This
			would seem to indicate an infinite recursive loop that will
			result in a stack overflow.&lt;/p&gt;
		</info>
		<name>Caught Infinite Recursive Loop</name>
	</findingType>
	<findingType>
		<id>ContainerAddedToItself</id>
		<artifact tool="FindBugs"
			mnemonic="IL_CONTAINER_ADDED_TO_ITSELF">
		</artifact>
		<shortMessage>A container is added to itself</shortMessage>
		<info>
			&lt;p&gt;A container is added to itself. As a result,
			computing the hashCode of this set will throw a
			StackOverflowException. &lt;/p&gt;
		</info>
		<name>Container Added To Itself</name>
	</findingType>
	<findingType>
		<id>VolatileReferenceToArray</id>
		<artifact tool="FindBugs"
			mnemonic="VO_VOLATILE_REFERENCE_TO_ARRAY">
		</artifact>
		<shortMessage>
			A volatile reference to an array doesn't treat the array
			elements as volatile
		</shortMessage>
		<info>
			&lt;p&gt;This declares a volatile reference to an array,
			which might not be what you want. With a volatile reference
			to an array, reads and writes of the reference to the array
			are treated as volatile, but the array elements are
			non-volatile. To get volatile array elements, you will need
			to use one of the atomic array classes in
			java.util.concurrent (provided in Java 5.0).&lt;/p&gt;
		</info>
		<name>Volatile Reference To Array</name>
	</findingType>
	<findingType>
		<id>UnsafeInheritanceOfGetResource</id>
		<artifact tool="FindBugs"
			mnemonic="UI_INHERITANCE_UNSAFE_GETRESOURCE">
		</artifact>
		<shortMessage>
			Usage of GetResource may be unsafe if class is extended
		</shortMessage>
		<info>
			&lt;p&gt;Calling
			&lt;code&gt;this.getClass().getResource(...)&lt;/code&gt;
			could give results other than expected if this class is
			extended by a class in another package.&lt;/p&gt;
		</info>
		<name>Unsafe Inheritance getResource()</name>
	</findingType>
	<findingType>
		<id>SynchronizeAndNullCheckOnSameField</id>
		<artifact tool="FindBugs"
			mnemonic="NP_SYNC_AND_NULL_CHECK_FIELD">
		</artifact>
		<shortMessage>
			Synchronize and null check on the same field
		</shortMessage>
		<info>
			&lt;p&gt;Since field is synchronized on, it seems not likely
			to be null. If it is null and then synchronized on a
			NullPointerException will be thrown and the check would be
			pointless. Better to synchronize on another field.&lt;/p&gt;
		</info>
		<name>Synchronize and Null Check on the Same Field</name>
	</findingType>
	<findingType>
		<id>GeneratedFromIncompleteDetectors</id>
		<artifact tool="FindBugs" mnemonic="TESTING"></artifact>
		<shortMessage>
			This bug pattern is only generated by new, incompletely
			implemented bug detectors in FindBugs
		</shortMessage>
		<info>
			&lt;p&gt;This bug pattern is only generated by new,
			incompletely implemented bug detectors in
			FindBugs.&lt;/p&gt;
		</info>
		<name>Generated From Incomplete Detectors</name>
	</findingType>
	<findingType>
		<id>UnknownBugPattern</id>
		<artifact tool="FindBugs" mnemonic="UNKNOWN"></artifact>
		<shortMessage>Unknown bug pattern in FindBugs</shortMessage>
		<info>
			&lt;p&gt;A warning was recorded, but FindBugs can't find the
			description of this bug pattern and so can't describe it.
			This should occur only in cases of a bug in FindBugs or its
			configuration, or perhaps if an analysis was generated using
			a plugin, but that plugin is not currently loaded.
			.&lt;/p&gt;
		</info>
		<name>Unknown Bug Pattern</name>
	</findingType>
	<findingType>
		<id>CreatesEmptyZipFileEntry</id>
		<artifact tool="FindBugs"
			mnemonic="AM_CREATES_EMPTY_ZIP_FILE_ENTRY">
		</artifact>
		<shortMessage>Creates an empty zip file entry</shortMessage>
		<info>
			&lt;p&gt;The code calls
			&lt;code&gt;putNextEntry()&lt;/code&gt;, immediately
			followed by a call to &lt;code&gt;closeEntry()&lt;/code&gt;.
			This results in an empty ZipFile entry. The contents of the
			entry should be written to the ZipFile between the calls to
			&lt;code&gt;putNextEntry()&lt;/code&gt; and
			&lt;code&gt;closeEntry()&lt;/code&gt;.&lt;/p&gt;
		</info>
		<name>Creates Empty Zip File Entry</name>
	</findingType>
	<findingType>
		<id>CreatesEmptyJarFileEntry</id>
		<artifact tool="FindBugs"
			mnemonic="AM_CREATES_EMPTY_JAR_FILE_ENTRY">
		</artifact>
		<shortMessage>Creates an empty jar file entry</shortMessage>
		<info>
			&lt;p&gt;The code calls
			&lt;code&gt;putNextEntry()&lt;/code&gt;, immediately
			followed by a call to &lt;code&gt;closeEntry()&lt;/code&gt;.
			This results in an empty JarFile entry. The contents of the
			entry should be written to the JarFile between the calls to
			&lt;code&gt;putNextEntry()&lt;/code&gt; and
			&lt;code&gt;closeEntry()&lt;/code&gt;.&lt;/p&gt;
		</info>
		<name>Creates Empty Jar File Entry</name>
	</findingType>
	<findingType>
		<id>AvoidCatchingIllegalStateMonitorException</id>
		<artifact tool="FindBugs" mnemonic="IMSE_DONT_CATCH_IMSE">
		</artifact>
		<shortMessage>
			Dubious catching of IllegalMonitorStateException
		</shortMessage>
		<info>
			&lt;p&gt;IllegalMonitorStateException is generally only
			thrown in case of a design flaw in your code (calling wait
			or notify on an object you do not hold a lock on).&lt;/p&gt;
		</info>
		<name>Avoid Catching IllegalStateMonitorException</name>
	</findingType>
	<findingType>
		<id>AvoidUsingFloatForMathOperations</id>
		<artifact tool="FindBugs"
			mnemonic="FL_MATH_USING_FLOAT_PRECISION">
		</artifact>
		<shortMessage>
			Method performs math using floating point precision
		</shortMessage>
		<info>
			&lt;p&gt; The method performs math operations using floating
			point precision. Floating point precision is very imprecise.
			For example, 16777216.0f + 1.0f = 16777216.0f. Consider
			using double math instead.&lt;/p&gt;
		</info>
		<name>Avoid Using Float For Math Operations</name>
	</findingType>
	<findingType>
		<id>CloneMethodMustImplementCloneable</id>
		<artifact tool="FindBugs" mnemonic="CN_IDIOM"></artifact>
		<artifact tool="PMD"
			mnemonic="CloneMethodMustImplementCloneable">
		</artifact>
		<shortMessage>
			Class implements Cloneable but does not define or use clone
			method
		</shortMessage>
		<info>
			&lt;p&gt; Class implements Cloneable but does not define or
			use the clone method.&lt;/p&gt; &lt;p&gt; The method clone()
			should only be implemented if the class implements the
			Cloneable interface with the exception of a final method
			that only throws CloneNotSupportedException.
		</info>
		<name>Clone Method Must Implement Cloneable</name>
	</findingType>
	<findingType>
		<id>NoSuperCloneCall</id>
		<artifact tool="FindBugs" mnemonic="CN_IDIOM_NO_SUPER_CALL">
		</artifact>
		<artifact tool="PMD" mnemonic="ProperCloneImplementation">
		</artifact>
		<shortMessage>
			clone method does not call super.clone()
		</shortMessage>
		<info>
			&lt;p&gt; This non-final class defines a clone() method that
			does not call super.clone(). If this class
			(&quot;&lt;i&gt;A&lt;/i&gt;&quot;) is extended by a subclass
			(&quot;&lt;i&gt;B&lt;/i&gt;&quot;), and the subclass
			&lt;i&gt;B&lt;/i&gt; calls super.clone(), then it is likely
			that &lt;i&gt;B&lt;/i&gt;'s clone() method will return an
			object of type &lt;i&gt;A&lt;/i&gt;, which violates the
			standard contract for clone().&lt;/p&gt;

			&lt;p&gt; If all clone() methods call super.clone(), then
			they are guaranteed to use Object.clone(), which always
			returns an object of the correct type.&lt;/p&gt;
		</info>
		<name>No Super Clone Call</name>
	</findingType>
	<findingType>
		<id>UseOfFutureKeywordAsIdentifier</id>
		<artifact tool="FindBugs"
			mnemonic="NM_FUTURE_KEYWORD_USED_AS_IDENTIFIER">
		</artifact>
		<shortMessage>
			Use of identifier that is a keyword in later versions of
			Java
		</shortMessage>
		<info>
			&lt;p&gt;The identifier is a word that is reserversed as a
			keyword in later versions of Java, and your code will need
			to be changed in order to compile it in later versions of
			Java.&lt;/p&gt;
		</info>
		<name>Use Of Future Keyword As Identifier</name>
	</findingType>
	<findingType>
		<id>UseOfFutureKeywordAsMemberIdentifier</id>
		<artifact tool="FindBugs"
			mnemonic="NM_FUTURE_KEYWORD_USED_AS_MEMBER_IDENTIFIER">
		</artifact>
		<shortMessage>
			Use of identifier that is a keyword in later versions of
			Java
		</shortMessage>
		<info>
			&lt;p&gt;This identifier is used as a keyword in later
			versions of Java. This code, and any code that references
			this API, will need to be changed in order to compile it in
			later versions of Java.&lt;/p&gt;
		</info>
		<name>Use Of Future Keyword As Member Identifier</name>
	</findingType>
	<findingType>
		<id>MethodMightDropException</id>
		<artifact tool="FindBugs" mnemonic="DE_MIGHT_DROP"></artifact>
		<shortMessage>Method might drop exception</shortMessage>
		<info>
			&lt;p&gt; This method might drop an exception.&amp;nbsp; In
			general, exceptions should be handled or reported in some
			way, or they should be thrown out of the method.&lt;/p&gt;
		</info>
		<name>Method Might Drop Exception</name>
	</findingType>
	<findingType>
		<id>MethodMightIgnoreException</id>
		<artifact tool="FindBugs" mnemonic="DE_MIGHT_IGNORE"></artifact>
		<shortMessage>Method might ignore exception</shortMessage>
		<info>
			&lt;p&gt; This method might ignore an exception.&amp;nbsp;
			In general, exceptions should be handled or reported in some
			way, or they should be thrown out of the method.&lt;/p&gt;
		</info>
		<name>Method Might Ignore Exception</name>
	</findingType>
	<findingType>
		<id>DP_DO_INSIDE_DO_PRIVILEGED</id>
		<artifact tool="FindBugs"
			mnemonic="DP_DO_INSIDE_DO_PRIVILEGED">
		</artifact>
		<shortMessage>
			Method invoked that should be only be invoked inside a
			doPrivileged block
		</shortMessage>
		<info>
			&lt;p&gt; This code invokes a method that requires a
			security permission check. If this code will be granted
			security permissions, but might be invoked by code that does
			not have security permissions, then the invocation needs to
			occur inside a doPrivileged block.&lt;/p&gt;
		</info>
		<name>Method Requires Security Permission Check</name>
	</findingType>
	<findingType>
		<id>MethodRequiresSecurityPermissionCheck</id>
		<artifact tool="FindBugs"
			mnemonic="DP_DO_INSIDE_DO_PRIVILEDGED">
		</artifact>
		<shortMessage>
			Method invoked that should be only be invoked inside a
			doPrivileged block
		</shortMessage>
		<info>
			&lt;p&gt; This code invokes a method that requires a
			security permission check. If this code will be granted
			security permissions, but might be invoked by code that does
			not have security permissions, then the invocation needs to
			occur inside a doPrivileged block.&lt;/p&gt;
		</info>
		<name>Method Requires Security Permission Check</name>
	</findingType>
	<findingType>
		<id>DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED</id>
		<artifact tool="FindBugs"
			mnemonic="DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED">
		</artifact>
		<shortMessage>
			Classloaders should only be created inside doPrivileged
			block
		</shortMessage>
		<info>
			&lt;p&gt; This code creates a classloader, which requires a
			security manager. If this code will be granted security
			permissions, but might be invoked by code that does not have
			security permissions, then the classloader creation needs to
			occur inside a doPrivileged block.&lt;/p&gt;
		</info>
		<name>
			Classloader Creation Requires Security Permission Check
		</name>
	</findingType>
	<findingType>
		<id>ClassloaderCreationRequiresSecurityPermissionCheck</id>
		<artifact tool="FindBugs"
			mnemonic="DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEDGED">
		</artifact>
		<shortMessage>
			Classloaders should only be created inside doPrivileged
			block
		</shortMessage>
		<info>
			&lt;p&gt; This code creates a classloader, which requires a
			security manager. If this code will be granted security
			permissions, but might be invoked by code that does not have
			security permissions, then the classloader creation needs to
			occur inside a doPrivileged block.&lt;/p&gt;
		</info>
		<name>
			Classloader Creation Requires Security Permission Check
		</name>
	</findingType>
	<findingType>
		<id>FieldIsntFinalInImmutableClass</id>
		<artifact tool="FindBugs"
			mnemonic="JCIP_FIELD_ISNT_FINAL_IN_IMMUTABLE_CLASS">
		</artifact>
		<shortMessage>
			Fields of immutable classes should be final
		</shortMessage>
		<info>
			&lt;p&gt; The class is annotated with
			net.jcip.annotations.Immutable, and the rules for that
			annotation require that all fields are final. .&lt;/p&gt;
		</info>
		<name>Field Isn't Final In Immutable Class</name>
	</findingType>
	<findingType>
		<id>ThreadPassedWhereRunnableExpected</id>
		<artifact tool="FindBugs"
			mnemonic="DMI_THREAD_PASSED_WHERE_RUNNABLE_EXPECTED">
		</artifact>
		<shortMessage>
			Thread passed where Runnable expected
		</shortMessage>
		<info>
			&lt;p&gt; A Thread object is passed as a parameter to a
			method where a Runnable is expected. This is rather unusual,
			and may indicate a logic error or cause unexpected behavior.
			&lt;/p&gt;
		</info>
		<name>Thread Passed Where Runnable Expected</name>
	</findingType>
	<findingType>
		<id>AvoidCollectionOfURLS</id>
		<artifact tool="FindBugs" mnemonic="DMI_COLLECTION_OF_URLS">
		</artifact>
		<shortMessage>
			Maps and sets of URLs can be performance hogs
		</shortMessage>
		<info>
			&lt;p&gt; This method or field is or uses a Map or Set of
			URLs. Since both the equals and hashCode method of URL
			perform domain name resolution, this can result in a big
			performance hit. See &lt;a
			href=&quot;http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html&quot;&gt;http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html&lt;/a&gt;
			for more information. Consider using
			&lt;code&gt;java.net.URI&lt;/code&gt; instead. &lt;/p&gt;
		</info>
		<name>Avoid Collection Of URLs</name>
	</findingType>
	<findingType>
		<id>BlockingMethodsOnURL</id>
		<artifact tool="FindBugs"
			mnemonic="DMI_BLOCKING_METHODS_ON_URL">
		</artifact>
		<shortMessage>
			The equals and hashCode methods of URL are blocking
		</shortMessage>
		<info>
			&lt;p&gt; The equals and hashCode method of URL perform
			domain name resolution, this can result in a big performance
			hit. See &lt;a
			href=&quot;http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html&quot;&gt;http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html&lt;/a&gt;
			for more information. Consider using
			&lt;code&gt;java.net.URI&lt;/code&gt; instead. &lt;/p&gt;
		</info>
		<name>Blocking Methods On URL</name>
	</findingType>
	<findingType>
		<id>AnnotationIsNotVisibleToReflection</id>
		<artifact tool="FindBugs"
			mnemonic="DMI_ANNOTATION_IS_NOT_VISIBLE_TO_REFLECTION">
		</artifact>
		<shortMessage>
			Can't use reflection to check for presence of annotation
			with default retention
		</shortMessage>
		<info>
			&lt;p&gt; Unless an annotation has itself been annotated
			with a @Retention other than the default of source-only
			retention, the annotation isn't retained in the classfile
			and can't be observed using reflection (e.g., by using the
			isAnnotationPresent method). .&lt;/p&gt;
		</info>
		<name>Annotation Is Not Visible To Reflection</name>
	</findingType>
	<findingType>
		<id>AvoidCallingSystemExit</id>
		<artifact tool="FindBugs" mnemonic="DM_EXIT"></artifact>
		<shortMessage>Method invokes System.exit(...)</shortMessage>
		<info>
			&lt;p&gt; Invoking System.exit shuts down the entire Java
			virtual machine. This should only been done when it is
			appropriate. Such calls make it hard or impossible for your
			code to be invoked by other code. Consider throwing a
			RuntimeException instead.&lt;/p&gt;
		</info>
		<name>Avoid Calling System.exit(...)</name>
	</findingType>
	<findingType>
		<id>AvoidCallingSystemRunFinalizersOnExit</id>
		<artifact tool="FindBugs"
			mnemonic="DM_RUN_FINALIZERS_ON_EXIT">
		</artifact>
		<shortMessage>
			Method invokes dangerous method runFinalizersOnExit
		</shortMessage>
		<info>
			&lt;p&gt; &lt;em&gt;Never call System.runFinalizersOnExit or
			Runtime.runFinalizersOnExit for any reason: they are among
			the most dangerous methods in the Java libraries.&lt;/em&gt;
			-- Joshua Bloch&lt;/p&gt;
		</info>
		<name>Avoid Calling System.runFinalizersOnExit()</name>
	</findingType>
	<findingType>
		<id>InefficientStringConstructor</id>
		<artifact tool="FindBugs" mnemonic="DM_STRING_CTOR"></artifact>
		<artifact tool="PMD" mnemonic="StringInstantiation"></artifact>
		<artifact tool="FindBugs" mnemonic="DM_STRING_VOID_CTOR">
		</artifact>
		<shortMessage>
			Method invokes inefficient new String(String) constructor
		</shortMessage>
		<info>
			&lt;p&gt; Using the
			&lt;code&gt;java.lang.String(String)&lt;/code&gt;
			constructor wastes memory because the object so constructed
			will be functionally indistinguishable from the
			&lt;code&gt;String&lt;/code&gt; passed as a
			parameter.&amp;nbsp; Just use the argument
			&lt;code&gt;String&lt;/code&gt; directly.&lt;/p&gt;

			Avoid instantiating String objects; this is usually
			unnecessary.

			&lt;p&gt; Creating a new
			&lt;code&gt;java.lang.String&lt;/code&gt; object using the
			no-argument constructor wastes memory because the object so
			created will be functionally indistinguishable from the
			empty string constant
			&lt;code&gt;&quot;&quot;&lt;/code&gt;.&amp;nbsp; Java
			guarantees that identical string constants will be
			represented by the same &lt;code&gt;String&lt;/code&gt;
			object.&amp;nbsp; Therefore, you should just use the empty
			string constant directly.&lt;/p&gt;
		</info>
		<name>Inefficient String Constructor</name>
	</findingType>
	<findingType>
		<id>AvoidCallingtoStringOnString</id>
		<artifact tool="FindBugs" mnemonic="DM_STRING_TOSTRING">
		</artifact>
		<shortMessage>
			Method invokes toString() method on a String
		</shortMessage>
		<info>
			&lt;p&gt; Calling &lt;code&gt;String.toString()&lt;/code&gt;
			is just a redundant operation. Just use the
			String.&lt;/p&gt;
		</info>
		<name>Avoid Calling toString() On String</name>
	</findingType>
	<findingType>
		<id>AvoidExplicitGarbageCollection</id>
		<artifact tool="FindBugs" mnemonic="DM_GC"></artifact>
		<shortMessage>
			Explicit garbage collection; extremely dubious except in
			benchmarking code
		</shortMessage>
		<info>
			&lt;p&gt; Code explicitly invokes garbage collection. Except
			for specific use in benchmarking, this is very
			dubious.&lt;/p&gt; &lt;p&gt;In the past, situations where
			people have explicitly invoked the garbage collector in
			routines such as close or finalize methods has led to huge
			performance black holes. Garbage collection can be
			expensive. Any situation that forces hundreds or thousands
			of garbage collections will bring the machine to a
			crawl.&lt;/p&gt;
		</info>
		<name>Avoid Explicit Garbage Collection</name>
	</findingType>
	<findingType>
		<id>InefficientBooleanConstructor</id>
		<artifact tool="FindBugs" mnemonic="DM_BOOLEAN_CTOR"></artifact>
		<shortMessage>
			Method invokes inefficient Boolean constructor; use
			Boolean.valueOf(...) instead
		</shortMessage>
		<info>
			&lt;p&gt; Creating new instances of
			&lt;code&gt;java.lang.Boolean&lt;/code&gt; wastes memory,
			since &lt;code&gt;Boolean&lt;/code&gt; objects are immutable
			and there are only two useful values of this type.&amp;nbsp;
			Use the &lt;code&gt;Boolean.valueOf()&lt;/code&gt; method
			(or Java 1.5 autoboxing) to create
			&lt;code&gt;Boolean&lt;/code&gt; objects instead.&lt;/p&gt;
		</info>
		<name>Inefficient Boolean Constructor</name>
	</findingType>
	<findingType>
		<id>InefficientNumberConstructor</id>
		<artifact tool="FindBugs" mnemonic="DM_NUMBER_CTOR"></artifact>
		<artifact tool="PMD" mnemonic="IntegerInstantiation"></artifact>
		<shortMessage>
			Method invokes inefficient Number constructor; use static
			valueOf instead
		</shortMessage>
		<info>
			&lt;p&gt; Using &lt;code&gt;new Integer(int)&lt;/code&gt; is
			guaranteed to always result in a new object whereas
			&lt;code&gt;Integer.valueOf(int)&lt;/code&gt; allows caching
			of values to be done by the compiler, class library, or JVM.
			Using of cached values avoids object allocation and the code
			will be faster. &lt;/p&gt; &lt;p&gt; Values between -128 and
			127 are guaranteed to have corresponding cached instances
			and using &lt;code&gt;valueOf&lt;/code&gt; is approximately
			3.5 times faster than using constructor. For values outside
			the constant range the performance of both styles is the
			same. &lt;/p&gt; &lt;p&gt; Unless the class must be
			compatible with JVMs predating Java 1.5, use either
			autoboxing or the &lt;code&gt;valueOf()&lt;/code&gt; method
			when creating instances of &lt;code&gt;Long&lt;/code&gt;,
			&lt;code&gt;Integer&lt;/code&gt;,
			&lt;code&gt;Short&lt;/code&gt;,
			&lt;code&gt;Character&lt;/code&gt;, and
			&lt;code&gt;Byte&lt;/code&gt;. &lt;/p&gt;

			In JDK 1.5, calling new Integer() causes memory allocation.
			Integer.valueOf() is more memory friendly.
		</info>
		<name>Inefficient Number Constructor</name>
	</findingType>
	<findingType>
		<id>InefficientFloatingPointNumberConstructor</id>
		<artifact tool="FindBugs" mnemonic="DM_FP_NUMBER_CTOR">
		</artifact>
		<shortMessage>
			Method invokes inefficient floating-point Number
			constructor; use static valueOf instead
		</shortMessage>
		<info>
			&lt;p&gt; Using &lt;code&gt;new Double(double)&lt;/code&gt;
			is guaranteed to always result in a new object whereas
			&lt;code&gt;Double.valueOf(double)&lt;/code&gt; allows
			caching of values to be done by the compiler, class library,
			or JVM. Using of cached values avoids object allocation and
			the code will be faster. &lt;/p&gt; &lt;p&gt; Unless the
			class must be compatible with JVMs predating Java 1.5, use
			either autoboxing or the &lt;code&gt;valueOf()&lt;/code&gt;
			method when creating instances of
			&lt;code&gt;Double&lt;/code&gt; and
			&lt;code&gt;Float&lt;/code&gt;. &lt;/p&gt;
		</info>
		<name>Inefficient Floating-Point Number Constructor</name>
	</findingType>
	<findingType>
		<id>UseStringLength</id>
		<artifact tool="FindBugs" mnemonic="DM_STRING_EMPTY_EQUALS">
		</artifact>
		<shortMessage>
			Method invokes inefficient String.equals(&quot;&quot;); use
			String.length() == 0 instead
		</shortMessage>
		<info>
			&lt;p&gt; An object is compared to the empty String object
			using the equals() method here. Checking that the String
			object's length is zero may be faster, and removes String
			constants from the class file.&lt;/p&gt;
		</info>
		<name>Use String Length</name>
	</findingType>
	<findingType>
		<id>UseLocaleParameterizedVersion</id>
		<artifact tool="FindBugs" mnemonic="DM_CONVERT_CASE"></artifact>
		<shortMessage>
			Consider using Locale parameterized version of invoked
			method
		</shortMessage>
		<info>
			&lt;p&gt; A String is being converted to upper or lowercase,
			using the platform's default encoding. This may result in
			improper conversions when used with international
			characters. Use the &lt;/p&gt;
			&lt;table&gt;&lt;tr&gt;&lt;td&gt;String.toUpperCase( Locale
			l
			)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;String.toLowerCase(
			Locale l )&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
			&lt;p&gt;versions instead.&lt;/p&gt;
		</info>
		<name>Use Locale Parameterized Version</name>
	</findingType>
	<findingType>
		<id>UnboxedAndCoercedForTernaryOperator</id>
		<artifact tool="FindBugs"
			mnemonic="BX_UNBOXED_AND_COERCED_FOR_TERNARY_OPERATOR">
		</artifact>
		<shortMessage>
			Primitive value is unboxed and coerced for ternary operator
		</shortMessage>
		<info>
			&lt;p&gt;A wrapped primative value is unboxed and converted
			to another primative type as part of the evaluation of a
			conditional ternary operator (the &lt;code&gt; b ? e1 :
			e2&lt;/code&gt; operator). The semantics of Java mandate
			that if &lt;code&gt;e1&lt;/code&gt; and
			&lt;code&gt;e2&lt;/code&gt; are wrapped numeric values, the
			values are unboxed and converted/coerced to their common
			type (e.g, if &lt;code&gt;e1&lt;/code&gt; is of type
			&lt;code&gt;Integer&lt;/code&gt; and
			&lt;code&gt;e2&lt;/code&gt; is of type
			&lt;code&gt;Float&lt;/code&gt;, then
			&lt;code&gt;e1&lt;/code&gt; is unboxed, converted to a
			floating point value, and boxed. See JLS Section 15.25.
			&lt;/p&gt;
		</info>
		<name>Unboxed And Coerced For Ternary Operator</name>
	</findingType>
	<findingType>
		<id>BoxingImmediatelyUnboxed</id>
		<artifact tool="FindBugs"
			mnemonic="BX_BOXING_IMMEDIATELY_UNBOXED">
		</artifact>
		<shortMessage>
			Primitive value is boxed and then immediately unboxed
		</shortMessage>
		<info>
			&lt;p&gt;A primitive is boxed, and then immediately unboxed.
			This probably is due to a manual boxing in a place where an
			unboxed value is required, thus forcing the compiler to
			immediately undue the work of the boxing. &lt;/p&gt;
		</info>
		<name>Boxing Immediately Unboxed</name>
	</findingType>
	<findingType>
		<id>BoxingImmediatelyUnboxedToPerformCoercion</id>
		<artifact tool="FindBugs"
			mnemonic="BX_BOXING_IMMEDIATELY_UNBOXED_TO_PERFORM_COERCION">
		</artifact>
		<shortMessage>
			Primitive value is boxed then unboxed to perform primative
			coercion
		</shortMessage>
		<info>
			&lt;p&gt;A primitive boxed value constructed and then
			immediately converted into a different primitive type (e.g.,
			&lt;code&gt;new Double(d).intValue()&lt;/code&gt;). Just
			perform direct primitive coercion (e.g., &lt;code&gt;(int)
			d&lt;/code&gt;).&lt;/p&gt;
		</info>
		<name>Boxing Immediately Unboxed To Perform Coercion</name>
	</findingType>
	<findingType>
		<id>BoxedPrimitiveToString</id>
		<artifact tool="FindBugs"
			mnemonic="DM_BOXED_PRIMITIVE_TOSTRING">
		</artifact>
		<shortMessage>
			Method allocates a boxed primitive just to call toString
		</shortMessage>
		<info>
			&lt;p&gt;A boxed primitive is allocated just to call
			toString(). It is more effective to just use the static form
			of toString which takes the primitive value. So,&lt;/p&gt;
			&lt;table&gt;
			&lt;tr&gt;&lt;th&gt;Replace...&lt;/th&gt;&lt;th&gt;With
			this...&lt;/th&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;new
			Integer(1).toString()&lt;/td&gt;&lt;td&gt;Integer.toString(1)&lt;/td&gt;&lt;/tr&gt;
			&lt;tr&gt;&lt;td&gt;new
			Long(1).toString()&lt;/td&gt;&lt;td&gt;Long.toString(1)&lt;/td&gt;&lt;/tr&gt;
			&lt;tr&gt;&lt;td&gt;new
			Float(1.0).toString()&lt;/td&gt;&lt;td&gt;Float.toString(1.0)&lt;/td&gt;&lt;/tr&gt;
			&lt;tr&gt;&lt;td&gt;new
			Double(1.0).toString()&lt;/td&gt;&lt;td&gt;Double.toString(1.0)&lt;/td&gt;&lt;/tr&gt;
			&lt;tr&gt;&lt;td&gt;new
			Byte(1).toString()&lt;/td&gt;&lt;td&gt;Byte.toString(1)&lt;/td&gt;&lt;/tr&gt;
			&lt;tr&gt;&lt;td&gt;new
			Short(1).toString()&lt;/td&gt;&lt;td&gt;Short.toString(1)&lt;/td&gt;&lt;/tr&gt;
			&lt;tr&gt;&lt;td&gt;new
			Boolean(true).toString()&lt;/td&gt;&lt;td&gt;Boolean.toString(true)&lt;/td&gt;&lt;/tr&gt;
			&lt;/table&gt;
		</info>
		<name>Boxed Primitive toString</name>
	</findingType>
	<findingType>
		<id>AvoidAllocatingObjectForObtainingClassObject</id>
		<artifact tool="FindBugs" mnemonic="DM_NEW_FOR_GETCLASS">
		</artifact>
		<shortMessage>
			Method allocates an object, only to get the class object
		</shortMessage>
		<info>
			&lt;p&gt;This method allocates an object just to call
			getClass() on it, in order to retrieve the Class object for
			it. It is simpler to just access the .class property of the
			class.&lt;/p&gt;
		</info>
		<name>Avoid Allocating Object For Obtaining Class Object</name>
	</findingType>
	<findingType>
		<id>MonitorWaitOnCondition</id>
		<artifact tool="FindBugs"
			mnemonic="DM_MONITOR_WAIT_ON_CONDITION">
		</artifact>
		<shortMessage>Monitor wait() called on Condition</shortMessage>
		<info>
			&lt;p&gt; This method calls &lt;code&gt;wait()&lt;/code&gt;
			on a
			&lt;code&gt;java.util.concurrent.locks.Condition&lt;/code&gt;
			object.&amp;nbsp; Waiting for a
			&lt;code&gt;Condition&lt;/code&gt; should be done using one
			of the &lt;code&gt;await()&lt;/code&gt; methods defined by
			the &lt;code&gt;Condition&lt;/code&gt; interface. &lt;/p&gt;
		</info>
		<name>Monitor Wait On Condition</name>
	</findingType>
	<findingType>
		<id>RandomValue01ToInt</id>
		<artifact tool="FindBugs" mnemonic="RV_01_TO_INT"></artifact>
		<shortMessage>
			Random value from 0 to 1 is coerced to the integer 0
		</shortMessage>
		<info>
			&lt;p&gt;A random value from 0 to 1 is being coerced to the
			integer value 0. You probably want to multiple the random
			value by something else before coercing it to an integer, or
			use the Random.nextInt(n) method. &lt;/p&gt;
		</info>
		<name>01 To Int</name>
	</findingType>
	<findingType>
		<id>UseNextIntNotNextDoubleOfRandom</id>
		<artifact tool="FindBugs"
			mnemonic="DM_NEXTINT_VIA_NEXTDOUBLE">
		</artifact>
		<shortMessage>
			Use the nextInt method of Random rather than nextDouble to
			generate a random integer
		</shortMessage>
		<info>
			&lt;p&gt;If r is a java.util.Random, you can generate a
			random number from 0 to n-1 using r.nextInt(n) Rather than
			using (int)(r.nextDouble() * n). &lt;/p&gt;
		</info>
		<name>Use nextInt Not nextDouble Of Random</name>
	</findingType>
	<findingType>
		<id>SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE</id>
		<artifact tool="FindBugs"
			mnemonic="SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE">
		</artifact>
		<shortMessage>
			Nonconstant string passed to execute method on an SQL
			statement
		</shortMessage>
		<info>
			&lt;p&gt;The method invokes the execute method on an SQL
			statement with a String that seems to be dynamically
			generated. Consider using a prepared statement instead. It
			is more efficient and less vulnerable to SQL injection
			attacks. &lt;/p&gt;
		</info>
		<name>Nonconstant String Passed To Execute</name>
	</findingType>
	<findingType>
		<id>
			SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING
		</id>
		<artifact tool="FindBugs"
			mnemonic="SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING">
		</artifact>
		<shortMessage>
			A prepared statement is generated from a nonconstant String
		</shortMessage>
		<info>
			&lt;p&gt;The code creates an SQL prepared statement from a
			nonconstant String. If unchecked, tainted data from a user
			is used in building this String, SQL injection could be used
			to make the prepared statement do something unexpected and
			undesirable. &lt;/p&gt;
		</info>
		<name>
			Prepared Statement Generated From Nonconstant String
		</name>
	</findingType>
	<findingType>
		<id>UselessThread</id>
		<artifact tool="FindBugs" mnemonic="DM_USELESS_THREAD">
		</artifact>
		<shortMessage>
			A thread was created using the default empty run method
		</shortMessage>
		<info>
			&lt;p&gt;This method creates a thread without specifying a
			run method either by deriving from the Thread class, or by
			passing a Runnable object. This thread, then, does nothing
			but waste time. &lt;/p&gt;
		</info>
		<name>Useless Thread</name>
	</findingType>
	<findingType>
		<id>PossibleDoubleCheckOfField</id>
		<artifact tool="FindBugs" mnemonic="DC_DOUBLECHECK"></artifact>
		<artifact tool="PMD" mnemonic="DoubleCheckedLocking"></artifact>
		<shortMessage>Possible double check of field</shortMessage>
		<info>
			&lt;p&gt; This method may contain an instance of
			double-checked locking.&amp;nbsp; This idiom is not correct
			according to the semantics of the Java memory
			model.&amp;nbsp; For more information, see the web page
			&lt;a
			href=&quot;http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html&quot;
			&gt;http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html&lt;/a&gt;
			as well as &lt;a
			href=&quot;http://www.javaworld.com/javaworld/jw-02-2001/jw-0209-double.html&quot;
			&gt;http://www.javaworld.com/javaworld/jw-02-2001/jw-0209-double.html&lt;/a&gt;
			.&lt;/p&gt;
		</info>
		<name>Double-checked Locking</name>
	</findingType>
	<findingType>
		<id>FI_FINALIZER_NULLS_FIELDS</id>
		<artifact tool="FindBugs"
			mnemonic="FI_FINALIZER_NULLS_FIELDS">
		</artifact>
		<shortMessage>Finalizer nulls fields</shortMessage>
		<info>
			&lt;p&gt; This finalizer nulls out fields. This is usually
			an error, as it does not aid garbage collection, and the
			object is going to be garbage collected anyway.
		</info>
		<name>Finalizer Nulls Fields</name>
	</findingType>
	<findingType>
		<id>FI_FINALIZER_ONLY_NULLS_FIELDS</id>
		<artifact tool="FindBugs"
			mnemonic="FI_FINALIZER_ONLY_NULLS_FIELDS">
		</artifact>
		<shortMessage>Finalizer only nulls fields</shortMessage>
		<info>
			&lt;p&gt; This finalizer does nothing except null out
			fields. This is completely pointless, and requires that the
			object be garbage collected, finalized, and then garbage
			collected again. You should just remove the finalize method.
		</info>
		<name>Finalizer Only Nulls Fields</name>
	</findingType>
	<findingType>
		<id>FinalizeShouldBeProtected</id>
		<artifact tool="FindBugs"
			mnemonic="FI_PUBLIC_SHOULD_BE_PROTECTED">
		</artifact>
		<artifact tool="PMD" mnemonic="FinalizeShouldBeProtected">
		</artifact>
		<shortMessage>
			Finalizer should be protected, not public
		</shortMessage>
		<info>
			&lt;p&gt; A class's &lt;code&gt;finalize()&lt;/code&gt;
			method should have protected access, not public.&lt;/p&gt;

			If you override finalize(), make it protected. If you make
			it public, other classes may call it.
		</info>
		<name>Finalize Should Be Protected</name>
	</findingType>
	<findingType>
		<id>EmptyFinalizer</id>
		<artifact tool="FindBugs" mnemonic="FI_EMPTY"></artifact>
		<artifact tool="PMD" mnemonic="EmptyFinalizer"></artifact>
		<shortMessage>Empty finalizer should be deleted</shortMessage>
		<info>
			&lt;p&gt; Empty &lt;code&gt;finalize()&lt;/code&gt; methods
			are useless, so they should be deleted.&lt;/p&gt;

			If the finalize() method is empty, then it does not need to
			exist.
		</info>
		<name>Empty Finalizer Block</name>
	</findingType>
	<findingType>
		<id>FI_NULLIFY_SUPER</id>
		<artifact tool="FindBugs" mnemonic="FI_NULLIFY_SUPER">
		</artifact>
		<shortMessage>
			Finalizer nullifies superclass finalizer
		</shortMessage>
		<info>
			&lt;p&gt; This empty &lt;code&gt;finalize()&lt;/code&gt;
			method explicitly negates the effect of any finalizer
			defined by its superclass.&amp;nbsp; Any finalizer actions
			defined for the superclass will not be performed.&amp;nbsp;
			Unless this is intended, delete this method.&lt;/p&gt;
		</info>
		<name>Nullify Super</name>
	</findingType>
	<findingType>
		<id>FinalizeOnlyCallsSuperFinalize</id>
		<artifact tool="FindBugs" mnemonic="FI_USELESS"></artifact>
		<artifact tool="PMD"
			mnemonic="FinalizeOnlyCallsSuperFinalize">
		</artifact>
		<shortMessage>
			Finalizer does nothing but call superclass finalizer
		</shortMessage>
		<info>
			&lt;p&gt; The only thing this
			&lt;code&gt;finalize()&lt;/code&gt; method does is call the
			superclass's &lt;code&gt;finalize()&lt;/code&gt; method,
			making it redundant.&amp;nbsp; Delete it.&lt;/p&gt;

			If the finalize() is implemented, it should do something
			besides just calling super.finalize().
		</info>
		<name>Finalize Only Calls Super Finalize</name>
	</findingType>
	<findingType>
		<id>FinalizeDoesNotCallSuperFinalize</id>
		<artifact tool="FindBugs" mnemonic="FI_MISSING_SUPER_CALL">
		</artifact>
		<artifact tool="PMD"
			mnemonic="FinalizeDoesNotCallSuperFinalize">
		</artifact>
		<shortMessage>
			Finalizer does not call superclass finalizer
		</shortMessage>
		<info>
			&lt;p&gt; This &lt;code&gt;finalize()&lt;/code&gt; method
			does not make a call to its superclass's
			&lt;code&gt;finalize()&lt;/code&gt; method.&amp;nbsp; So,
			any finalizer actions defined for the superclass will not be
			performed.&amp;nbsp; Add a call to
			&lt;code&gt;super.finalize()&lt;/code&gt;.&lt;/p&gt;

			If the finalize() is implemented, its last action should be
			to call super.finalize.
		</info>
		<name>Finalize Does Not Call Super Finalize</name>
	</findingType>
	<findingType>
		<id>AvoidCallingFinalizeExplicitly</id>
		<artifact tool="FindBugs" mnemonic="FI_EXPLICIT_INVOCATION">
		</artifact>
		<artifact tool="PMD" mnemonic="AvoidCallingFinalize"></artifact>
		<shortMessage>Explicit invocation of finalizer</shortMessage>
		<info>
			&lt;p&gt; This method contains an explicit invocation of the
			&lt;code&gt;finalize()&lt;/code&gt; method on an
			object.&amp;nbsp; Because finalizer methods are supposed to
			be executed once, and only by the VM, this is a bad
			idea.&lt;/p&gt; &lt;p&gt;If a connected set of objects
			beings finalizable, then the VM will invoke the finalize
			method on all the finalizable object, possibly at the same
			time in different threads. Thus, it is a particularly bad
			idea, in the finalize method for a class X, invoke finalize
			on objects referenced by X, because they may already be
			getting finalized in a separate thread.
		</info>
		<name>Avoid Calling Finalize Explicitly</name>
	</findingType>
	<findingType>
		<id>EQ_DONT_DEFINE_EQUALS_FOR_ENUM</id>
		<artifact tool="FindBugs"
			mnemonic="EQ_DONT_DEFINE_EQUALS_FOR_ENUM">
		</artifact>
		<shortMessage>
			Covariant equals() method defined for enum
		</shortMessage>
		<info>
			&lt;p&gt; This class defines an enumeration, and equality on
			enumerations are defined using object identity. Definine a
			covariant equals method for an enumeration value is
			exceptionally bad practice, since it would likely result in
			having two different enumeration values that compare as
			equals using the covariant enum method, and as not equal
			when compared normally. Don't do it. &lt;/p&gt;
		</info>
		<name>Don't Define Equals For enum</name>
	</findingType>
	<findingType>
		<id>EQ_SELF_USE_OBJECT</id>
		<artifact tool="FindBugs" mnemonic="EQ_SELF_USE_OBJECT">
		</artifact>
		<shortMessage>
			Covariant equals() method defined, Object.equals(Object)
			inherited
		</shortMessage>
		<info>
			&lt;p&gt; This class defines a covariant version of the
			&lt;code&gt;equals()&lt;/code&gt; method, but inherits the
			normal &lt;code&gt;equals(Object)&lt;/code&gt; method
			defined in the base
			&lt;code&gt;java.lang.Object&lt;/code&gt; class.&amp;nbsp;
			The class should probably define a non-covariant version of
			&lt;code&gt;equals()&lt;/code&gt;.&amp;nbsp; (I.e., a method
			with the signature &lt;code&gt;boolean
			equals(java.lang.Object)&lt;/code&gt;.&lt;/p&gt;
		</info>
		<name>Self Use Object</name>
	</findingType>
	<findingType>
		<id>EQ_SELF_NO_OBJECT</id>
		<artifact tool="FindBugs" mnemonic="EQ_SELF_NO_OBJECT">
		</artifact>
		<shortMessage>Covariant equals() method defined</shortMessage>
		<info>

			&lt;p&gt; This class defines a covariant version of
			&lt;code&gt;equals()&lt;/code&gt;.&amp;nbsp; To correctly
			override the &lt;code&gt;equals()&lt;/code&gt; method in
			&lt;code&gt;java.lang.Object&lt;/code&gt;, the parameter of
			&lt;code&gt;equals()&lt;/code&gt; must have type
			&lt;code&gt;java.lang.Object&lt;/code&gt;.&lt;/p&gt;

		</info>
		<name>Self No Object</name>
	</findingType>
	<findingType>
		<id>EQ_OVERRIDING_EQUALS_NOT_SYMMETRIC</id>
		<artifact tool="FindBugs"
			mnemonic="EQ_OVERRIDING_EQUALS_NOT_SYMMETRIC">
		</artifact>
		<shortMessage>
			equals method overrides equals in superclass and may not be
			symmetric
		</shortMessage>
		<info>

			&lt;p&gt; This class defines an equals method that overrides
			an equals method in a superclass. Both equals methods
			methods use &lt;code&gt;instanceof&lt;/code&gt; in the
			determination of whether two objects are equals. This is
			fraught with peril, since it is important that the equals
			method is symetrical (in other words,
			&lt;code&gt;a.equals(b) == b.equals(a)&lt;/code&gt;). If B
			is a subtype of A, and A's equals method checks that the
			argument is an instanceof A, and B's equals method checks
			that the argument is an instanceof B, it is quite likely
			that the equivalence relation defined by these methods is
			not symmetric.

		</info>
		<name>Overriding Equals Not Symmetric</name>
	</findingType>
	<findingType>
		<id>HSC_HUGE_SHARED_STRING_CONSTANT</id>
		<artifact tool="FindBugs"
			mnemonic="HSC_HUGE_SHARED_STRING_CONSTANT">
		</artifact>
		<shortMessage>
			Huge string constants is duplicated across multiple class
			files
		</shortMessage>
		<info>

			&lt;p&gt; A large String constant is duplicated across
			multiple class files. This is likely because a final field
			is initialized to a String constant, and the Java language
			mandates that all references to a final field from other
			classes be inlined into that classfile. See &lt;a
			href=&quot;http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6447475&quot;&gt;JDK
			bug 6447475&lt;/a&gt; for a description of an occurrence of
			this bug in the JDK and how resolving it reduced the size of
			the JDK by 1 megabyte. &lt;/p&gt;

		</info>
		<name>Huge Shared String Constant</name>
	</findingType>
	<findingType>
		<id>NP_ARGUMENT_MIGHT_BE_NULL</id>
		<artifact tool="FindBugs"
			mnemonic="NP_ARGUMENT_MIGHT_BE_NULL">
		</artifact>
		<shortMessage>
			Method does not check for null argument
		</shortMessage>
		<info>

			&lt;p&gt; A parameter to this method has been identified as
			a value that should always be checked to see whether or not
			it is null, but it is being dereferenced without a preceding
			null check. &lt;/p&gt;

		</info>
		<name>Argument Might Be Null</name>
	</findingType>
	<findingType>
		<id>NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT</id>
		<artifact tool="FindBugs"
			mnemonic="NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT">
		</artifact>
		<shortMessage>
			equals() method does not check for null argument
		</shortMessage>
		<info>

			&lt;p&gt; This implementation of equals(Object) violates the
			contract defined by java.lang.Object.equals() because it
			does not check for null being passed as the argument. All
			equals() methods should return false if passed a null value.
			&lt;/p&gt;

		</info>
		<name>Equals Should Handle Null Argument</name>
	</findingType>
	<findingType>
		<id>NP_DOES_NOT_HANDLE_NULL</id>
		<artifact tool="FindBugs" mnemonic="NP_DOES_NOT_HANDLE_NULL">
		</artifact>
		<shortMessage>
			equals() method does not check for null parameter
		</shortMessage>
		<info>

			&lt;p&gt; This implementation of equals(Object) violates the
			contract defined by java.lang.Object.equals() because it
			does not check for null being passed as the parameter. All
			equals() methods should return false if passed a null value.
			&lt;/p&gt;

		</info>
		<name>Does Not Handle Null</name>
	</findingType>
	<findingType>
		<id>CO_SELF_NO_OBJECT</id>
		<artifact tool="FindBugs" mnemonic="CO_SELF_NO_OBJECT">
		</artifact>
		<shortMessage>
			Covariant compareTo() method defined
		</shortMessage>
		<info>

			&lt;p&gt; This class defines a covariant version of
			&lt;code&gt;compareTo()&lt;/code&gt;.&amp;nbsp; To correctly
			override the &lt;code&gt;compareTo()&lt;/code&gt; method in
			the &lt;code&gt;Comparable&lt;/code&gt; interface, the
			parameter of &lt;code&gt;compareTo()&lt;/code&gt; must have
			type &lt;code&gt;java.lang.Object&lt;/code&gt;.&lt;/p&gt;

		</info>
		<name>Self No Object</name>
	</findingType>
	<findingType>
		<id>HE_USE_OF_UNHASHABLE_CLASS</id>
		<artifact tool="FindBugs"
			mnemonic="HE_USE_OF_UNHASHABLE_CLASS">
		</artifact>
		<shortMessage>
			Use of class without a hashCode() method in a hashed data
			structure
		</shortMessage>
		<info>

			&lt;p&gt; A class defines an equals(Object) method but not a
			hashCode() method, and thus doesn't fulfill the requirement
			that equal Objects have equal hashCodes. An instance of this
			class is used in a hash data structure, making the need to
			fix this problem of highest importance.

		</info>
		<name>Use Of Unhashable Class</name>
	</findingType>
	<findingType>
		<id>DefinesHashCodeUsesEquals</id>
		<artifact tool="FindBugs"
			mnemonic="HE_HASHCODE_USE_OBJECT_EQUALS">
		</artifact>
		<shortMessage>
			Class defines hashCode() and uses Object.equals()
		</shortMessage>
		<info>

			&lt;p&gt; This class defines a
			&lt;code&gt;hashCode()&lt;/code&gt; method but inherits its
			&lt;code&gt;equals()&lt;/code&gt; method from
			&lt;code&gt;java.lang.Object&lt;/code&gt; (which defines
			equality by comparing object references).&amp;nbsp; Although
			this will probably satisfy the contract that equal objects
			must have equal hashcodes, it is probably not what was
			intended by overriding the
			&lt;code&gt;hashCode()&lt;/code&gt; method.&amp;nbsp;
			(Overriding &lt;code&gt;hashCode()&lt;/code&gt; implies that
			the object's identity is based on criteria more complicated
			than simple reference equality.)&lt;/p&gt; &lt;p&gt;If you
			don't think instances of this class will ever be inserted
			into a HashMap/HashTable, the recommended
			&lt;code&gt;hashCode&lt;/code&gt; implementation to use
			is:&lt;/p&gt; &lt;p&gt;&lt;pre&gt;public int hashCode() {
			assert false : &quot;hashCode not designed&quot;; return 42;
			// any arbitrary constant will do }&lt;/pre&gt;&lt;/p&gt;

			Override both public boolean Object.equals(Object other),
			and public int Object.hashCode(), or override neither. Even
			if you are inheriting a hashCode() from a parent class,
			consider implementing hashCode and explicitly delegating to
			your superclass.
		</info>
		<name>Defines Hash Code Uses Equals</name>
	</findingType>
	<findingType>
		<id>EQ_COMPARETO_USE_OBJECT_EQUALS</id>
		<artifact tool="FindBugs"
			mnemonic="EQ_COMPARETO_USE_OBJECT_EQUALS">
		</artifact>
		<shortMessage>
			Class defines compareTo(...) and uses Object.equals()
		</shortMessage>
		<info>
			&lt;p&gt; This class defines a
			&lt;code&gt;compareTo(...)&lt;/code&gt; method but inherits
			its &lt;code&gt;equals()&lt;/code&gt; method from
			&lt;code&gt;java.lang.Object&lt;/code&gt;. Generally, the
			value of compareTo should return zero if and only if equals
			returns true. If this is violated, weird and unpredictable
			failures will occur in classes such as PriorityQueue. In
			Java 5 the PriorityQueue.remove method uses the compareTo
			method, while in Java 6 it uses the equals method.

			&lt;p&gt;From the JavaDoc for the compareTo method in the
			Comparable interface: &lt;blockquote&gt; It is strongly
			recommended, but not strictly required that
			&lt;code&gt;(x.compareTo(y)==0) ==
			(x.equals(y))&lt;/code&gt;. Generally speaking, any class
			that implements the Comparable interface and violates this
			condition should clearly indicate this fact. The recommended
			language is &quot;Note: this class has a natural ordering
			that is inconsistent with equals.&quot; &lt;/blockquote&gt;

		</info>
		<name>Defines compareTo() Uses Object Equals</name>
	</findingType>
	<findingType>
		<id>DefinesHashcodeNotEquals</id>
		<artifact tool="FindBugs" mnemonic="HE_HASHCODE_NO_EQUALS">
		</artifact>
		<shortMessage>
			Class defines hashCode() but not equals()
		</shortMessage>
		<info>
			&lt;p&gt; This class defines a
			&lt;code&gt;hashCode()&lt;/code&gt; method but not an
			&lt;code&gt;equals()&lt;/code&gt; method.&amp;nbsp;
			Therefore, the class may violate the invariant that equal
			objects must have equal hashcodes.&lt;/p&gt;

			Override both public boolean Object.equals(Object other),
			and public int Object.hashCode(), or override neither. Even
			if you are inheriting a hashCode() from a parent class,
			consider implementing hashCode and explicitly delegating to
			your superclass.
		</info>
		<name>Defines Hashcode Not Equals</name>
	</findingType>
	<findingType>
		<id>DefinesEqualsUsesHashcode</id>
		<artifact tool="FindBugs" mnemonic="HE_EQUALS_USE_HASHCODE">
		</artifact>
		<shortMessage>
			Class defines equals() and uses Object.hashCode()
		</shortMessage>
		<info>

			&lt;p&gt; This class overrides
			&lt;code&gt;equals(Object)&lt;/code&gt;, but does not
			override &lt;code&gt;hashCode()&lt;/code&gt;, and inherits
			the implementation of &lt;code&gt;hashCode()&lt;/code&gt;
			from &lt;code&gt;java.lang.Object&lt;/code&gt; (which
			returns the identity hash code, an arbitrary value assigned
			to the object by the VM).&amp;nbsp; Therefore, the class is
			very likely to violate the invariant that equal objects must
			have equal hashcodes.&lt;/p&gt;

			&lt;p&gt;If you don't think instances of this class will
			ever be inserted into a HashMap/HashTable, the recommended
			&lt;code&gt;hashCode&lt;/code&gt; implementation to use
			is:&lt;/p&gt; &lt;pre&gt;public int hashCode() { assert
			false : &quot;hashCode not designed&quot;; return 42; // any
			arbitrary constant will do }&lt;/pre&gt;

			Override both public boolean Object.equals(Object other),
			and public int Object.hashCode(), or override neither. Even
			if you are inheriting a hashCode() from a parent class,
			consider implementing hashCode and explicitly delegating to
			your superclass.
		</info>
		<name>Defines equals() Uses hashcode()</name>
	</findingType>
	<findingType>
		<id>InheritsEqualsUsesHashCode</id>
		<artifact tool="FindBugs"
			mnemonic="HE_INHERITS_EQUALS_USE_HASHCODE">
		</artifact>
		<shortMessage>
			Class inherits equals() and uses Object.hashCode()
		</shortMessage>
		<info>

			&lt;p&gt; This class inherits
			&lt;code&gt;equals(Object)&lt;/code&gt; from an abstract
			superclass, and &lt;code&gt;hashCode()&lt;/code&gt; from
			&lt;code&gt;java.lang.Object&lt;/code&gt; (which returns the
			identity hash code, an arbitrary value assigned to the
			object by the VM).&amp;nbsp; Therefore, the class is very
			likely to violate the invariant that equal objects must have
			equal hashcodes.&lt;/p&gt;

			&lt;p&gt;If you don't want to define a hashCode method,
			and/or don't believe the object will ever be put into a
			HashMap/Hashtable, define the
			&lt;code&gt;hashCode()&lt;/code&gt; method to throw
			&lt;code&gt;UnsupportedOperationException&lt;/code&gt;.&lt;/p&gt;

			Override both public boolean Object.equals(Object other),
			and public int Object.hashCode(), or override neither. Even
			if you are inheriting a hashCode() from a parent class,
			consider implementing hashCode and explicitly delegating to
			your superclass.

		</info>
		<name>Inherits Equals Uses Hashcode</name>
	</findingType>
	<findingType>
		<id>OverridesEqualsNotHashcode</id>
		<artifact tool="FindBugs" mnemonic="HE_EQUALS_NO_HASHCODE">
		</artifact>
		<shortMessage>
			Class defines equals() but not hashCode()
		</shortMessage>
		<info>

			&lt;p&gt; This class overrides
			&lt;code&gt;equals(Object)&lt;/code&gt;, but does not
			override &lt;code&gt;hashCode()&lt;/code&gt;.&amp;nbsp;
			Therefore, the class may violate the invariant that equal
			objects must have equal hashcodes.&lt;/p&gt;

			Override both public boolean Object.equals(Object other),
			and public int Object.hashCode(), or override neither. Even
			if you are inheriting a hashCode() from a parent class,
			consider implementing hashCode and explicitly delegating to
			your superclass.
		</info>
		<name>Overrides Equals Not Hashcode</name>
	</findingType>
	<findingType>
		<id>EQ_ABSTRACT_SELF</id>
		<artifact tool="FindBugs" mnemonic="EQ_ABSTRACT_SELF">
		</artifact>
		<shortMessage>
			Abstract class defines covariant equals() method
		</shortMessage>
		<info>

			&lt;p&gt; This class defines a covariant version of
			&lt;code&gt;equals()&lt;/code&gt;.&amp;nbsp; To correctly
			override the &lt;code&gt;equals()&lt;/code&gt; method in
			&lt;code&gt;java.lang.Object&lt;/code&gt;, the parameter of
			&lt;code&gt;equals()&lt;/code&gt; must have type
			&lt;code&gt;java.lang.Object&lt;/code&gt;.&lt;/p&gt;

		</info>
		<name>Abstract Self</name>
	</findingType>
	<findingType>
		<id>ES_COMPARING_STRINGS_WITH_EQ</id>
		<artifact tool="FindBugs"
			mnemonic="ES_COMPARING_STRINGS_WITH_EQ">
		</artifact>
		<artifact tool="PMD"
			mnemonic="UseEqualsToCompareStrings"/>				
		<shortMessage>
			Comparison of String objects using == or !=
		</shortMessage>
		<info>

			&lt;p&gt;This code compares
			&lt;code&gt;java.lang.String&lt;/code&gt; objects for
			reference equality using the == or != operators. Unless both
			strings are either constants in a source file, or have been
			interned using the &lt;code&gt;String.intern()&lt;/code&gt;
			method, the same string value may be represented by two
			different String objects. Consider using the
			&lt;code&gt;equals(Object)&lt;/code&gt; method
			instead.&lt;/p&gt;

		</info>
		<name>Comparing Strings With == or !=</name>
	</findingType>
	<findingType>
		<id>ES_COMPARING_PARAMETER_STRING_WITH_EQ</id>
		<artifact tool="FindBugs"
			mnemonic="ES_COMPARING_PARAMETER_STRING_WITH_EQ">
		</artifact>
		<shortMessage>
			Comparison of String parameter using == or !=
		</shortMessage>
		<info>

			&lt;p&gt;This code compares a
			&lt;code&gt;java.lang.String&lt;/code&gt; parameter for
			reference equality using the == or != operators. Requiring
			callers to pass only String constants or interned strings to
			a method is unnecessarily fragile, and rarely leads to
			measurable performance gains. Consider using the
			&lt;code&gt;equals(Object)&lt;/code&gt; method
			instead.&lt;/p&gt;

		</info>
		<name>Comparing Parameter String With == or !=</name>
	</findingType>
	<findingType>
		<id>CO_ABSTRACT_SELF</id>
		<artifact tool="FindBugs" mnemonic="CO_ABSTRACT_SELF">
		</artifact>
		<shortMessage>
			Abstract class defines covariant compareTo() method
		</shortMessage>
		<info>

			&lt;p&gt; This class defines a covariant version of
			&lt;code&gt;compareTo()&lt;/code&gt;.&amp;nbsp; To correctly
			override the &lt;code&gt;compareTo()&lt;/code&gt; method in
			the &lt;code&gt;Comparable&lt;/code&gt; interface, the
			parameter of &lt;code&gt;compareTo()&lt;/code&gt; must have
			type &lt;code&gt;java.lang.Object&lt;/code&gt;.&lt;/p&gt;

		</info>
		<name>Abstract Self</name>
	</findingType>
	<findingType>
		<id>FieldNotGuarded</id>
		<artifact tool="FindBugs" mnemonic="IS_FIELD_NOT_GUARDED">
		</artifact>
		<shortMessage>
			Field not guarded against concurrent access
		</shortMessage>
		<info>

			&lt;p&gt; This field is annotated with
			net.jcip.annotations.GuardedBy, but can be accessed in a way
			that seems to violate the annotation.&lt;/p&gt;

		</info>
		<name>Field Not Guarded</name>
	</findingType>
	<findingType>
		<id>InconsistentSynchronization2</id>
		<artifact tool="FindBugs" mnemonic="IS2_INCONSISTENT_SYNC">
		</artifact>
		<shortMessage>Inconsistent synchronization</shortMessage>
		<info>

			&lt;p&gt; The fields of this class appear to be accessed
			inconsistently with respect to synchronization.&amp;nbsp;
			This bug report indicates that the bug pattern detector
			judged that &lt;/p&gt; &lt;ol&gt; &lt;li&gt; The class
			contains a mix of locked and unlocked accesses,&lt;/li&gt;
			&lt;li&gt; At least one locked access was performed by one
			of the class's own methods, and&lt;/li&gt; &lt;li&gt; The
			number of unsynchronized field accesses (reads and writes)
			was no more than one third of all accesses, with writes
			being weighed twice as high as reads&lt;/li&gt; &lt;/ol&gt;

			&lt;p&gt; A typical bug matching this bug pattern is
			forgetting to synchronize one of the methods in a class that
			is intended to be thread-safe.&lt;/p&gt;

			&lt;p&gt; You can select the nodes labeled
			&quot;Unsynchronized access&quot; to show the code locations
			where the detector believed that a field was accessed
			without synchronization.&lt;/p&gt;

			&lt;p&gt; Note that there are various sources of inaccuracy
			in this detector; for example, the detector cannot
			statically detect all situations in which a lock is
			held.&amp;nbsp; Also, even when the detector is accurate in
			distinguishing locked vs. unlocked accesses, the code in
			question may still be correct.&lt;/p&gt;

			&lt;p&gt; This description refers to the &quot;IS2&quot;
			version of the pattern detector, which has more accurate
			ways of detecting locked vs. unlocked accesses than the
			older &quot;IS&quot; detector.&lt;/p&gt;

		</info>
		<name>Inconsistent Sync</name>
	</findingType>
	<findingType>
		<id>NakedNotifyCall</id>
		<artifact tool="FindBugs" mnemonic="NN_NAKED_NOTIFY"></artifact>
		<shortMessage>Naked notify</shortMessage>
		<info>

			&lt;p&gt; A call to &lt;code&gt;notify()&lt;/code&gt; or
			&lt;code&gt;notifyAll()&lt;/code&gt; was made without any
			(apparent) accompanying modification to mutable object
			state.&amp;nbsp; In general, calling a notify method on a
			monitor is done because some condition another thread is
			waiting for has become true.&amp;nbsp; However, for the
			condition to be meaningful, it must involve a heap object
			that is visible to both threads.&lt;/p&gt;

			&lt;p&gt; This bug does not necessarily indicate an error,
			since the change to mutable object state may have taken
			place in a method which then called the method containing
			the notification.&lt;/p&gt;

		</info>
		<name>Naked Notify</name>
	</findingType>
	<findingType>
		<id>PublicStaticMayExposeInternalRepresentation</id>
		<artifact tool="FindBugs" mnemonic="MS_EXPOSE_REP"></artifact>
		<shortMessage>
			Public static method may expose internal representation by
			returning array
		</shortMessage>
		<info>

			&lt;p&gt; A public static method returns a reference to an
			array that is part of the static state of the class. Any
			code that calls this method can freely modify the underlying
			array. One fix is to return a copy of the array.&lt;/p&gt;

		</info>
		<name>Expose Rep</name>
	</findingType>
	<findingType>
		<id>MayExposeInternalRepresentation</id>
		<artifact tool="FindBugs" mnemonic="EI_EXPOSE_REP"></artifact>
		<shortMessage>
			May expose internal representation by returning reference to
			mutable object
		</shortMessage>
		<info>

			&lt;p&gt; Returning a reference to a mutable object value
			stored in one of the object's fields exposes the internal
			representation of the object.&amp;nbsp; If instances are
			accessed by untrusted code, and unchecked changes to the
			mutable object would compromise security or other important
			properties, you will need to do something different.
			Returning a new copy of the object is better approach in
			many situations.&lt;/p&gt;

		</info>
		<name>Expose Rep</name>
	</findingType>
	<findingType>
		<id>MayExposeInternalRepresentation2</id>
		<artifact tool="FindBugs" mnemonic="EI_EXPOSE_REP2"></artifact>
		<shortMessage>
			May expose internal representation by incorporating
			reference to mutable object
		</shortMessage>
		<info>

			&lt;p&gt; This code stores a reference to an externally
			mutable object into the internal representation of the
			object.&amp;nbsp; If instances are accessed by untrusted
			code, and unchecked changes to the mutable object would
			compromise security or other important properties, you will
			need to do something different. Storing a copy of the object
			is better approach in many situations.&lt;/p&gt;

		</info>
		<name>Expose REP2</name>
	</findingType>
	<findingType>
		<id>MayExposeInternalStaticStatic</id>
		<artifact tool="FindBugs" mnemonic="EI_EXPOSE_STATIC_REP2">
		</artifact>
		<shortMessage>
			May expose internal static state by storing a mutable object
			into a static field
		</shortMessage>
		<info>

			&lt;p&gt; This code stores a reference to an externally
			mutable object into a static field. If unchecked changes to
			the mutable object would compromise security or other
			important properties, you will need to do something
			different. Storing a copy of the object is better approach
			in many situations.&lt;/p&gt;

		</info>
		<name>Expose Static REP2</name>
	</findingType>
	<findingType>
		<id>InvokesRun</id>
		<artifact tool="FindBugs" mnemonic="RU_INVOKE_RUN"></artifact>
		<shortMessage>
			Invokes run on a thread (did you mean to start it instead?)
		</shortMessage>
		<info>

			&lt;p&gt; This method explicitly invokes
			&lt;code&gt;run()&lt;/code&gt; on an object.&amp;nbsp; In
			general, classes implement the
			&lt;code&gt;Runnable&lt;/code&gt; interface because they are
			going to have their &lt;code&gt;run()&lt;/code&gt; method
			invoked in a new thread, in which case
			&lt;code&gt;Thread.start()&lt;/code&gt; is the right method
			to call.&lt;/p&gt;

		</info>
		<name>Invoke Run</name>
	</findingType>
	<findingType>
		<id>MethodSpinsOnField</id>
		<artifact tool="FindBugs" mnemonic="SP_SPIN_ON_FIELD">
		</artifact>
		<shortMessage>Method spins on field</shortMessage>
		<info>

			&lt;p&gt; This method spins in a loop which reads a
			field.&amp;nbsp; The compiler may legally hoist the read out
			of the loop, turning the code into an infinite
			loop.&amp;nbsp; The class should be changed so it uses
			proper synchronization (including wait and notify
			calls).&lt;/p&gt;

		</info>
		<name>Spin On Field</name>
	</findingType>
	<findingType>
		<id>NS_DANGEROUS_NON_SHORT_CIRCUIT</id>
		<artifact tool="FindBugs"
			mnemonic="NS_DANGEROUS_NON_SHORT_CIRCUIT">
		</artifact>
		<shortMessage>
			Potentially dangerous use of non-short-circuit logic
		</shortMessage>
		<info>

			&lt;p&gt; This code seems to be using non-short-circuit
			logic (e.g., &amp;amp; or |) rather than short-circuit logic
			(&amp;amp;&amp;amp; or ||). In addition, it seem possible
			that, depending on the value of the left hand side, you
			might not want to evaluate the right hand side (because it
			would have side effects, could cause an exception or could
			be expensive.&lt;/p&gt; &lt;p&gt; Non-short-circuit logic
			causes both sides of the expression to be evaluated even
			when the result can be inferred from knowing the left-hand
			side. This can be less efficient and can result in errors if
			the left-hand side guards cases when evaluating the
			right-hand side can generate an error. &lt;/p&gt;

			&lt;p&gt;See &lt;a
			href=&quot;http://java.sun.com/docs/books/jls/third_edition/html/expressions.html#15.22.2&quot;&gt;the
			Java Language Specification&lt;/a&gt; for details

			&lt;/p&gt;

		</info>
		<name>Dangerous Non Short Circuit</name>
	</findingType>
	<findingType>
		<id>NS_NON_SHORT_CIRCUIT</id>
		<artifact tool="FindBugs" mnemonic="NS_NON_SHORT_CIRCUIT">
		</artifact>
		<shortMessage>
			Questionable use of non-short-circuit logic
		</shortMessage>
		<info>

			&lt;p&gt; This code seems to be using non-short-circuit
			logic (e.g., &amp;amp; or |) rather than short-circuit logic
			(&amp;amp;&amp;amp; or ||). Non-short-circuit logic causes
			both sides of the expression to be evaluated even when the
			result can be inferred from knowing the left-hand side. This
			can be less efficient and can result in errors if the
			left-hand side guards cases when evaluating the right-hand
			side can generate an error.

			&lt;p&gt;See &lt;a
			href=&quot;http://java.sun.com/docs/books/jls/third_edition/html/expressions.html#15.22.2&quot;&gt;the
			Java Language Specification&lt;/a&gt; for details

			&lt;/p&gt;

		</info>
		<name>Non Short Circuit</name>
	</findingType>
	<findingType>
		<id>WaitWithTwoLocks</id>
		<artifact tool="FindBugs" mnemonic="TLW_TWO_LOCK_WAIT">
		</artifact>
		<shortMessage>Wait with two locks held</shortMessage>
		<info>

			&lt;p&gt; Waiting on a monitor while two locks are held may
			cause deadlock. &amp;nbsp; Performing a wait only releases
			the lock on the object being waited on, not any other locks.
			&amp;nbsp; This not necessarily a bug, but is worth
			examining closely.&lt;/p&gt;

		</info>
		<name>Two Lock Wait</name>
	</findingType>
	<findingType>
		<id>TwoLocksOnNotify</id>
		<artifact tool="FindBugs" mnemonic="TLW_TWO_LOCK_NOTIFY">
		</artifact>
		<shortMessage>Notify with two locks held</shortMessage>
		<info>

			&lt;p&gt; The code calls notify() or notifyAll() while two
			locks are held. If this notification is intended to wake up
			a wait() that is holding the same locks, it may deadlock,
			since the wait will only give up one lock and the notify
			will be unable to get both locks, and thus the notify will
			not succeed. &amp;nbsp; If there is also a warning about a
			two lock wait, the probably of a bug is quite high.
			&lt;/p&gt;

		</info>
		<name>Two Lock Notify</name>
	</findingType>
	<findingType>
		<id>UnconditionalWait</id>
		<artifact tool="FindBugs" mnemonic="UW_UNCOND_WAIT"></artifact>
		<shortMessage>Unconditional wait</shortMessage>
		<info>

			&lt;p&gt; This method contains a call to
			&lt;code&gt;java.lang.Object.wait()&lt;/code&gt; which is
			not guarded by conditional control flow.&amp;nbsp; The code
			should verify that condition it intends to wait for is not
			already satisfied before calling wait; any previous
			notifications will be ignored. &lt;/p&gt;

		</info>
		<name>Unconditional Wait</name>
	</findingType>
	<findingType>
		<id>UR_UNINIT_READ</id>
		<artifact tool="FindBugs" mnemonic="UR_UNINIT_READ"></artifact>
		<shortMessage>
			Uninitialized read of field in constructor
		</shortMessage>
		<info>

			&lt;p&gt; This constructor reads a field which has not yet
			been assigned a value.&amp;nbsp; This is often caused when
			the programmer mistakenly uses the field instead of one of
			the constructor's parameters.&lt;/p&gt;

		</info>
		<name>Uninitialized Read</name>
	</findingType>
	<findingType>
		<id>SynchronizedSetUnsynchronizedGet</id>
		<artifact tool="FindBugs" mnemonic="UG_SYNC_SET_UNSYNC_GET">
		</artifact>
		<shortMessage>
			Unsynchronized get method, synchronized set method
		</shortMessage>
		<info>

			&lt;p&gt; This class contains similarly-named get and set
			methods where the set method is synchronized and the get
			method is not.&amp;nbsp; This may result in incorrect
			behavior at runtime, as callers of the get method will not
			necessarily see a consistent state for the object.&amp;nbsp;
			The get method should be made synchronized.&lt;/p&gt;

		</info>
		<name>Sync Set Unsync Get</name>
	</findingType>
	<findingType>
		<id>IC_INIT_CIRCULARITY</id>
		<artifact tool="FindBugs" mnemonic="IC_INIT_CIRCULARITY">
		</artifact>
		<shortMessage>Initialization circularity</shortMessage>
		<info>

			&lt;p&gt; A circularity was detected in the static
			initializers of the two classes referenced by the bug
			instance.&amp;nbsp; Many kinds of unexpected behavior may
			arise from such circularity.&lt;/p&gt;

		</info>
		<name>Init Circularity</name>
	</findingType>
	<findingType>
		<id>IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION</id>
		<artifact tool="FindBugs"
			mnemonic="IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION">
		</artifact>
		<shortMessage>
			Superclass uses subclass during initialization
		</shortMessage>
		<info>

			&lt;p&gt; During the initialization of a class, the class
			makes an active use of a subclass. That subclass will not
			yet be initialized at the time of this use. For example, in
			the following code, &lt;code&gt;foo&lt;/code&gt; will be
			null.&lt;/p&gt;

			&lt;pre&gt; public class CircularClassInitialization {
			static class InnerClassSingleton extends
			CircularClassInitialization { static InnerClassSingleton
			singleton = new InnerClassSingleton(); }

			static CircularClassInitialization foo =
			InnerClassSingleton.singleton; } &lt;/pre&gt;


		</info>
		<name>Superclass Uses Subclass During Initialization</name>
	</findingType>
	<findingType>
		<id>IT_NO_SUCH_ELEMENT</id>
		<artifact tool="FindBugs" mnemonic="IT_NO_SUCH_ELEMENT">
		</artifact>
		<shortMessage>
			Iterator next() method can't throw NoSuchElement exception
		</shortMessage>
		<info>

			&lt;p&gt; This class implements the
			&lt;code&gt;java.util.Iterator&lt;/code&gt;
			interface.&amp;nbsp; However, its
			&lt;code&gt;next()&lt;/code&gt; method is not capable of
			throwing
			&lt;code&gt;java.util.NoSuchElementException&lt;/code&gt;.&amp;nbsp;
			The &lt;code&gt;next()&lt;/code&gt; method should be changed
			so it throws &lt;code&gt;NoSuchElementException&lt;/code&gt;
			if is called when there are no more elements to
			return.&lt;/p&gt;

		</info>
		<name>No Such Element</name>
	</findingType>
	<findingType>
		<id>SynchronizationOnSharedConstant</id>
		<artifact tool="FindBugs"
			mnemonic="DL_SYNCHRONIZATION_ON_SHARED_CONSTANT">
		</artifact>
		<shortMessage>
			Synchronization on shared constant could lead to deadlock
		</shortMessage>
		<info>

			&lt;p&gt; The code synchronizes on a shared primative
			constant, such as an interned String. &lt;pre&gt; private
			static String LOCK = &quot;LOCK&quot;; ...
			synchronized(LOCK) { ...} ... &lt;/pre&gt; &lt;/p&gt;
			&lt;p&gt;Such constants an interned and shared across all
			other classes loaded by the JVM. Thus, this could is locking
			on something that other code might also be locking. This
			could result in very strange and hard to diagnose blocking
			and deadlock behavior. See &lt;a
			href=&quot;http://www.javalobby.org/java/forums/t96352.html&quot;&gt;http://www.javalobby.org/java/forums/t96352.html&lt;/a&gt;
			and &lt;a
			href=&quot;http://jira.codehaus.org/browse/JETTY-352&quot;&gt;http://jira.codehaus.org/browse/JETTY-352&lt;/a&gt;.
			&lt;/p&gt;

		</info>
		<name>Synchronization On Shared Constant</name>
	</findingType>
	<findingType>
		<id>EmptySynchronizationBlock</id>
		<artifact tool="FindBugs" mnemonic="ESync_EMPTY_SYNC">
		</artifact>
		<artifact tool="PMD" mnemonic="EmptySynchronizedBlock">
		</artifact>
		<shortMessage>Empty synchronized block</shortMessage>
		<info>

			&lt;p&gt; The code contains an empty synchronized
			block:&lt;/p&gt; &lt;pre&gt; synchronized() {} &lt;/pre&gt;
			&lt;p&gt;Empty synchronized blocks are far more subtle and
			hard to use correctly than most people recognize, and empty
			synchronized blocks are almost never a better solution than
			less contrived solutions. &lt;/p&gt;

		</info>
		<name>Empty Sync</name>
	</findingType>
	<findingType>
		<id>InconsistentSynchronization</id>
		<artifact tool="FindBugs" mnemonic="IS_INCONSISTENT_SYNC">
		</artifact>
		<shortMessage>Inconsistent synchronization</shortMessage>
		<info>

			&lt;p&gt; The fields of this class appear to be accessed
			inconsistently with respect to synchronization.&amp;nbsp;
			This bug report indicates that the bug pattern detector
			judged that &lt;/p&gt; &lt;ol&gt; &lt;li&gt; The class
			contains a mix of locked and unlocked accesses,&lt;/li&gt;
			&lt;li&gt; At least one locked access was performed by one
			of the class's own methods, and&lt;/li&gt; &lt;li&gt; The
			number of unsynchronized field accesses (reads and writes)
			was no more than one third of all accesses, with writes
			being weighed twice as high as reads&lt;/li&gt; &lt;/ol&gt;

			&lt;p&gt; A typical bug matching this bug pattern is
			forgetting to synchronize one of the methods in a class that
			is intended to be thread-safe.&lt;/p&gt;

			&lt;p&gt; Note that there are various sources of inaccuracy
			in this detector; for example, the detector cannot
			statically detect all situations in which a lock is
			held.&amp;nbsp; Also, even when the detector is accurate in
			distinguishing locked vs. unlocked accesses, the code in
			question may still be correct.&lt;/p&gt;

		</info>
		<name>Inconsistent Sync</name>
	</findingType>
	<findingType>
		<id>AvoidSynchronizationOnUpdatedField</id>
		<artifact tool="FindBugs" mnemonic="ML_SYNC_ON_UPDATED_FIELD">
		</artifact>
		<shortMessage>
			Method synchronizes on an updated field
		</shortMessage>
		<info>

			&lt;p&gt; This method synchronizes on an object references
			from a mutable field. This is unlikely to have useful
			semantics, since different threads may be synchronizing on
			different objects.&lt;/p&gt;

		</info>
		<name>Sync On Updated Field</name>
	</findingType>
	<findingType>
		<id>FieldShouldBeOutOfInterfaceAndPackageProtected</id>
		<artifact tool="FindBugs" mnemonic="MS_OOI_PKGPROTECT">
		</artifact>
		<shortMessage>
			Field should be moved out of an interface and made package
			protected
		</shortMessage>
		<info>

			&lt;p&gt; A final static field that is defined in an
			interface references a mutable object such as an array or
			hashtable. This mutable object could be changed by malicious
			code or by accident from another package. To solve this, the
			field needs to be moved to a class and made package
			protected to avoid this vulnerability.&lt;/p&gt;

		</info>
		<name>Field Out of Interface and Package Protected</name>
	</findingType>
	<findingType>
		<id>FieldShouldBeFinalAndPackageProtected</id>
		<artifact tool="FindBugs" mnemonic="MS_FINAL_PKGPROTECT">
		</artifact>
		<shortMessage>
			Field should be both final and package protected
		</shortMessage>
		<info>

			&lt;p&gt; A mutable static field could be changed by
			malicious code or by accident from another package. The
			field could be made package protected and/or made final to
			avoid this vulnerability.&lt;/p&gt;

		</info>
		<name>Final and Package Protected</name>
	</findingType>
	<findingType>
		<id>FieldShouldBeFinal</id>
		<artifact tool="FindBugs" mnemonic="MS_SHOULD_BE_FINAL">
		</artifact>
		<shortMessage>Field isn't final but should be</shortMessage>
		<info>

			&lt;p&gt; A mutable static field could be changed by
			malicious code or by accident from another package. The
			field could be made final to avoid this
			vulnerability.&lt;/p&gt;

		</info>
		<name>Should Be Final</name>
	</findingType>
	<findingType>
		<id>PackageProtectField</id>
		<artifact tool="FindBugs" mnemonic="MS_PKGPROTECT"></artifact>
		<shortMessage>Field should be package protected</shortMessage>
		<info>

			&lt;p&gt; A mutable static field could be changed by
			malicious code or by accident. The field could be made
			package protected to avoid this vulnerability.&lt;/p&gt;

		</info>
		<name>Package Protect Field</name>
	</findingType>
	<findingType>
		<id>MutableHashtable</id>
		<artifact tool="FindBugs" mnemonic="MS_MUTABLE_HASHTABLE">
		</artifact>
		<shortMessage>Field is a mutable Hashtable</shortMessage>
		<info>

			&lt;p&gt;A final static field references a Hashtable and can
			be accessed by malicious code or by accident from another
			package. This code can freely modify the contents of the
			Hashtable.&lt;/p&gt;

		</info>
		<name>Mutable Hashtable</name>
	</findingType>
	<findingType>
		<id>MutableArray</id>
		<artifact tool="FindBugs" mnemonic="MS_MUTABLE_ARRAY">
		</artifact>
		<shortMessage>Field is a mutable array</shortMessage>
		<info>

			&lt;p&gt; A final static field references an array and can
			be accessed by malicious code or by accident from another
			package. This code can freely modify the contents of the
			array.&lt;/p&gt;

		</info>
		<name>Mutable Array</name>
	</findingType>
	<findingType>
		<id>CannotBeFinal</id>
		<artifact tool="FindBugs" mnemonic="MS_CANNOT_BE_FINAL">
		</artifact>
		<shortMessage>
			Field isn't final and can't be protected from malicious code
		</shortMessage>
		<info>

			&lt;p&gt; A mutable static field could be changed by
			malicious code or by accident from another package.
			Unfortunately, the way the field is used doesn't allow any
			easy fix to this problem.&lt;/p&gt;

		</info>
		<name>Cannot Be Final</name>
	</findingType>
	<findingType>
		<id>IA_AMBIGUOUS_INVOCATION_OF_INHERITED_OR_OUTER_METHOD</id>
		<artifact tool="FindBugs"
			mnemonic="IA_AMBIGUOUS_INVOCATION_OF_INHERITED_OR_OUTER_METHOD">
		</artifact>
		<shortMessage>
			Ambiguous invocation of either an inherited or outer method
		</shortMessage>
		<info>

			&lt;p&gt; An inner class is invoking a method that could be
			resolved to either a inherited method or a method defined in
			an outer class. By the Java semantics, it will be resolved
			to invoke the inherited method, but this may not be want you
			intend. If you really intend to invoke the inherited method,
			invoke it by invoking the method on super (e.g., invoke
			super.foo(17)), and thus it will be clear to other readers
			of your code and to FindBugs that you want to invoke the
			inherited method, not the method in the outer class.
			&lt;/p&gt;

		</info>
		<name>Ambiguous Invocation Of Inherited Or Outer Method</name>
	</findingType>
	<findingType>
		<id>ClassNamingConventions</id>
		<artifact tool="FindBugs"
			mnemonic="NM_CLASS_NAMING_CONVENTION">
		</artifact>
		<artifact tool="PMD" mnemonic="ClassNamingConventions">
		</artifact>
		<shortMessage>
			Class names should start with an upper case letter
		</shortMessage>
		<info>

			&lt;p&gt; Class names should be nouns, in mixed case with
			the first letter of each internal word capitalized. Try to
			keep your class names simple and descriptive. Use whole
			words-avoid acronyms and abbreviations (unless the
			abbreviation is much more widely used than the long form,
			such as URL or HTML). &lt;/p&gt;

			Class names should always begin with an upper case
			character.

		</info>
		<name>Class Naming Convention</name>
	</findingType>
	<findingType>
		<id>MethodNamingConventions</id>
		<artifact tool="FindBugs"
			mnemonic="NM_METHOD_NAMING_CONVENTION">
		</artifact>
		<artifact tool="PMD" mnemonic="MethodNamingConventions">
		</artifact>
		<shortMessage>
			Method names should start with an lower case letter
		</shortMessage>
		<info>
			&lt;p&gt; Methods should be verbs, in mixed case with the
			first letter lowercase, with the first letter of each
			internal word capitalized. &lt;/p&gt;

			Method names should always begin with a lower case
			character, and should not contain underscores.
		</info>
		<name>Method Naming Convention</name>
	</findingType>
	<findingType>
		<id>FieldNamingConventions</id>
		<artifact tool="FindBugs"
			mnemonic="NM_FIELD_NAMING_CONVENTION">
		</artifact>
		<artifact tool="PMD" mnemonic="VariableNamingConventions">
		</artifact>
		<shortMessage>
			Field names should start with an lower case letter
		</shortMessage>
		<info>

			&lt;p&gt; Names of fields that are not final should be in
			mixed case with a lowercase first letter and the first
			letters of subsequent words capitalized. &lt;/p&gt;

			Final variables that should be fully capitalized and
			non-final variables should not include underscores.
		</info>
		<name>Field Naming Convention</name>
	</findingType>
	<findingType>
		<id>NM_VERY_CONFUSING</id>
		<artifact tool="FindBugs" mnemonic="NM_VERY_CONFUSING">
		</artifact>
		<shortMessage>Very confusing method names</shortMessage>
		<info>

			&lt;p&gt; The referenced methods have names that differ only
			by capitalization or the packages of their parameters. This
			is very confusing because if the capitalization and
			parameter package names were identical then one of the
			methods would override the other. &lt;/p&gt;

		</info>
		<name>Very Confusing</name>
	</findingType>
	<findingType>
		<id>NM_VERY_CONFUSING_INTENTIONAL</id>
		<artifact tool="FindBugs"
			mnemonic="NM_VERY_CONFUSING_INTENTIONAL">
		</artifact>
		<shortMessage>
			Very confusing method names (but intentional)
		</shortMessage>
		<info>

			&lt;p&gt; The referenced methods have names that differ only
			by capitalization or the packages of their parameters. This
			is very confusing because if the capitalization were
			identical then one of the methods would override the other.
			From the existence of other methods, it seems that the
			existence of both of these methods is intentional, but is
			sure is confusing. You should try hard to eliminate one of
			them, unless you are forced to have both due to frozen APIs.
			&lt;/p&gt;

		</info>
		<name>Very Confusing Intentional</name>
	</findingType>
	<findingType>
		<id>NM_CONFUSING</id>
		<artifact tool="FindBugs" mnemonic="NM_CONFUSING"></artifact>
		<shortMessage>Confusing method names</shortMessage>
		<info>

			&lt;p&gt; The referenced methods have names that differ only
			by capitalization.&lt;/p&gt;

		</info>
		<name>Confusing</name>
	</findingType>
	<findingType>
		<id>NM_METHOD_CONSTRUCTOR_CONFUSION</id>
		<artifact tool="FindBugs"
			mnemonic="NM_METHOD_CONSTRUCTOR_CONFUSION">
		</artifact>
		<shortMessage>
			Apparent method/constructor confusion
		</shortMessage>
		<info>

			&lt;p&gt; This regular method has the same name as the class
			it is defined in. It is likely that this was intended to be
			a constructor. If it was intended to be a constructor,
			remove the declaration of a void return value. If you had
			accidently defined this method, realized the mistake,
			defined a proper constructor but can't get rid of this
			method due to backwards compatibility, deprecate the method.
			&lt;/p&gt;

		</info>
		<name>Method Constructor Confusion</name>
	</findingType>
	<findingType>
		<id>SuspiciousHashcodeMethodName</id>
		<artifact tool="FindBugs" mnemonic="NM_LCASE_HASHCODE">
		</artifact>
		<artifact tool="PMD" mnemonic="SuspiciousHashcodeMethodName">
		</artifact>
		<shortMessage>
			Class defines hashcode(); should it be hashCode()?
		</shortMessage>
		<info>

			&lt;p&gt; This class defines a method called
			&lt;code&gt;hashcode()&lt;/code&gt;.&amp;nbsp; This method
			does not override the &lt;code&gt;hashCode()&lt;/code&gt;
			method in &lt;code&gt;java.lang.Object&lt;/code&gt;, which
			is probably what was intended.&lt;/p&gt;

			The method name and return type are suspiciously close to
			hashCode(), which may mean you are intending to override the
			hashCode() method.
		</info>
		<name>Suspicious Hashcode Method Name</name>
	</findingType>
	<findingType>
		<id>NM_LCASE_TOSTRING</id>
		<artifact tool="FindBugs" mnemonic="NM_LCASE_TOSTRING">
		</artifact>
		<shortMessage>
			Class defines tostring(); should it be toString()?
		</shortMessage>
		<info>

			&lt;p&gt; This class defines a method called
			&lt;code&gt;tostring()&lt;/code&gt;.&amp;nbsp; This method
			does not override the &lt;code&gt;toString()&lt;/code&gt;
			method in &lt;code&gt;java.lang.Object&lt;/code&gt;, which
			is probably what was intended.&lt;/p&gt;

		</info>
		<name>Lowercase tostring() Method Defined</name>
	</findingType>
	<findingType>
		<id>SuspiciousEqualsMethodName</id>
		<artifact tool="FindBugs" mnemonic="NM_BAD_EQUAL"></artifact>
		<artifact tool="PMD" mnemonic="SuspiciousEqualsMethodName">
		</artifact>
		<shortMessage>
			Class defines equal(); should it be equals()?
		</shortMessage>
		<info>

			&lt;p&gt; This class defines a method
			&lt;code&gt;equal(Object)&lt;/code&gt;.&amp;nbsp; This
			method does not override the
			&lt;code&gt;equals(Object)&lt;/code&gt; method in
			&lt;code&gt;java.lang.Object&lt;/code&gt;, which is probably
			what was intended.&lt;/p&gt;

			The method name and parameter number are suspiciously close
			to equals(Object), which may mean you are intending to
			override the equals(Object) method.
		</info>
		<name>Suspicious Equals Method Name</name>
	</findingType>
	<findingType>
		<id>NM_CLASS_NOT_EXCEPTION</id>
		<artifact tool="FindBugs" mnemonic="NM_CLASS_NOT_EXCEPTION">
		</artifact>
		<shortMessage>
			Class is not derived from an Exception, even though it is
			named as such
		</shortMessage>
		<info>

			&lt;p&gt; This class is not derived from another exception,
			but ends with 'Exception'. This will be confusing to users
			of this class.&lt;/p&gt;

		</info>
		<name>Class Not Exception</name>
	</findingType>
	<findingType>
		<id>RR_NOT_CHECKED</id>
		<artifact tool="FindBugs" mnemonic="RR_NOT_CHECKED"></artifact>
		<shortMessage>
			Method ignores results of InputStream.read()
		</shortMessage>
		<info>

			&lt;p&gt; This method ignores the return value of one of the
			variants of
			&lt;code&gt;java.io.InputStream.read()&lt;/code&gt; which
			can return multiple bytes.&amp;nbsp; If the return value is
			not checked, the caller will not be able to correctly handle
			the case where fewer bytes were read than the caller
			requested.&amp;nbsp; This is a particularly insidious kind
			of bug, because in many programs, reads from input streams
			usually do read the full amount of data requested, causing
			the program to fail only sporadically.&lt;/p&gt;

		</info>
		<name>Not Checked</name>
	</findingType>
	<findingType>
		<id>SR_NOT_CHECKED</id>
		<artifact tool="FindBugs" mnemonic="SR_NOT_CHECKED"></artifact>
		<shortMessage>
			Method ignores results of InputStream.skip()
		</shortMessage>
		<info>

			&lt;p&gt; This method ignores the return value of
			&lt;code&gt;java.io.InputStream.skip()&lt;/code&gt; which
			can skip multiple bytes.&amp;nbsp; If the return value is
			not checked, the caller will not be able to correctly handle
			the case where fewer bytes were skipped than the caller
			requested.&amp;nbsp; This is a particularly insidious kind
			of bug, because in many programs, skips from input streams
			usually do skip the full amount of data requested, causing
			the program to fail only sporadically. With Buffered
			streams, however, skip() will only skip data in the buffer,
			and will routinely fail to skip the requested number of
			bytes.&lt;/p&gt;

		</info>
		<name>Not Checked</name>
	</findingType>
	<findingType>
		<id>SE_READ_RESOLVE_MUST_RETURN_OBJECT</id>
		<artifact tool="FindBugs"
			mnemonic="SE_READ_RESOLVE_MUST_RETURN_OBJECT">
		</artifact>
		<shortMessage>
			The readResolve method must be declared with a return type
			of Object.
		</shortMessage>
		<info>

			&lt;p&gt; In order for the readResolve method to be
			recognized by the serialization mechanism. &lt;/p&gt;

		</info>
		<name>Read Resolve Must Return Object</name>
	</findingType>
	<findingType>
		<id>SE_TRANSIENT_FIELD_OF_NONSERIALIZABLE_CLASS</id>
		<artifact tool="FindBugs"
			mnemonic="SE_TRANSIENT_FIELD_OF_NONSERIALIZABLE_CLASS">
		</artifact>
		<shortMessage>
			Transient field of class that isn't Serializable.
		</shortMessage>
		<info>

			&lt;p&gt; The field is marked as transient, but the class
			isn't Serializable, so marking it as transient has
			absolutely no effect. This may be leftover marking from a
			previous version of the code in which the class was
			transient, or it may indicate a misunderstanding of how
			serialization works. &lt;/p&gt;

		</info>
		<name>Transient Field Of Nonserializable Class</name>
	</findingType>
	<findingType>
		<id>SE_TRANSIENT_FIELD_NOT_RESTORED</id>
		<artifact tool="FindBugs"
			mnemonic="SE_TRANSIENT_FIELD_NOT_RESTORED">
		</artifact>
		<shortMessage>
			Transient field that isn't set by deserialization.
		</shortMessage>
		<info>

			&lt;p&gt; This class contains a field that is updated at
			multiple places in the class, thus it seems to be part of
			the state of the class. However, since the field is marked
			as transient and not set in readObject or readResolve, it
			will contain the default value in any deserialized instance
			of the class. &lt;/p&gt;

		</info>
		<name>Transient Field Not Restored</name>
	</findingType>
	<findingType>
		<id>SE_METHOD_MUST_BE_PRIVATE</id>
		<artifact tool="FindBugs"
			mnemonic="SE_METHOD_MUST_BE_PRIVATE">
		</artifact>
		<shortMessage>
			Method must be private in order for serialization to work
		</shortMessage>
		<info>

			&lt;p&gt; This class implements the
			&lt;code&gt;Serializable&lt;/code&gt; interface, and defines
			a method for custom serialization/deserialization. But since
			that method isn't declared private, it will be silently
			ignored by the serialization/deserialization API.&lt;/p&gt;

		</info>
		<name>Method Must Be Private</name>
	</findingType>
	<findingType>
		<id>SE_NO_SUITABLE_CONSTRUCTOR_FOR_EXTERNALIZATION</id>
		<artifact tool="FindBugs"
			mnemonic="SE_NO_SUITABLE_CONSTRUCTOR_FOR_EXTERNALIZATION">
		</artifact>
		<shortMessage>
			Class is Externalizable but doesn't define a void
			constructor
		</shortMessage>
		<info>

			&lt;p&gt; This class implements the
			&lt;code&gt;Externalizable&lt;/code&gt; interface, but does
			not define a void constructor. When Externalizable objects
			are deserialized, they first need to be constructed by
			invoking the void constructor. Since this class does not
			have one, serialization and deserialization will fail at
			runtime.&lt;/p&gt;

		</info>
		<name>No Suitable Constructor For Externalization</name>
	</findingType>
	<findingType>
		<id>SE_NO_SUITABLE_CONSTRUCTOR</id>
		<artifact tool="FindBugs"
			mnemonic="SE_NO_SUITABLE_CONSTRUCTOR">
		</artifact>
		<shortMessage>
			Class is Serializable but its superclass doesn't define a
			void constructor
		</shortMessage>
		<info>

			&lt;p&gt; This class implements the
			&lt;code&gt;Serializable&lt;/code&gt; interface and its
			superclass does not. When such an object is deserialized,
			the fields of the superclass need to be initialized by
			invoking the void constructor of the superclass. Since the
			superclass does not have one, serialization and
			deserialization will fail at runtime.&lt;/p&gt;

		</info>
		<name>No Suitable Constructor</name>
	</findingType>
	<findingType>
		<id>SE_NO_SERIALVERSIONID</id>
		<artifact tool="FindBugs" mnemonic="SE_NO_SERIALVERSIONID">
		</artifact>
		<shortMessage>
			Class is Serializable, but doesn't define serialVersionUID
		</shortMessage>
		<info>

			&lt;p&gt; This class implements the
			&lt;code&gt;Serializable&lt;/code&gt; interface, but does
			not define a &lt;code&gt;serialVersionUID&lt;/code&gt;
			field.&amp;nbsp; A change as simple as adding a reference to
			a .class object will add synthetic fields to the class,
			which will unfortunately change the implicit
			serialVersionUID (e.g., adding a reference to
			&lt;code&gt;String.class&lt;/code&gt; will generate a static
			field &lt;code&gt;class$java$lang$String&lt;/code&gt;).
			Also, different source code to bytecode compilers may use
			different naming conventions for synthetic variables
			generated for references to class objects or inner classes.
			To ensure interoperability of Serializable across versions,
			consider adding an explicit serialVersionUID.&lt;/p&gt;

		</info>
		<name>No Serial Version Id Defined</name>
	</findingType>
	<findingType>
		<id>SE_COMPARATOR_SHOULD_BE_SERIALIZABLE</id>
		<artifact tool="FindBugs"
			mnemonic="SE_COMPARATOR_SHOULD_BE_SERIALIZABLE">
		</artifact>
		<shortMessage>
			Comparator doesn't implement Serializable
		</shortMessage>
		<info>

			&lt;p&gt; This class implements the
			&lt;code&gt;Comparator&lt;/code&gt; interface. You should
			consider whether or not it should also implement the
			&lt;code&gt;Serializable&lt;/code&gt; interface. If a
			comparator is used to construct an ordered collection such
			as a &lt;code&gt;TreeMap&lt;/code&gt;, then the
			&lt;code&gt;TreeMap&lt;/code&gt; will be serializable only
			if the comparator is also serializable. As most comparators
			have little or no state, making them serializable is
			generally easy and good defensive programming. &lt;/p&gt;

		</info>
		<name>Comparator Should Be Serializable</name>
	</findingType>
	<findingType>
		<id>SF_SWITCH_FALLTHROUGH</id>
		<artifact tool="FindBugs" mnemonic="SF_SWITCH_FALLTHROUGH">
		</artifact>
		<shortMessage>
			Switch statement found where one case falls through to the
			next case
		</shortMessage>
		<info>

			&lt;p&gt; This method contains a switch statement where one
			case branch will fall through to the next case. Usually you
			need to end this case with a break or return.&lt;/p&gt;

		</info>
		<name>Switch Fallthrough</name>
	</findingType>
	<findingType>
		<id>SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH</id>
		<artifact tool="FindBugs"
			mnemonic="SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH">
		</artifact>
		<shortMessage>
			Dead store due to switch statement fall through
		</shortMessage>
		<info>

			&lt;p&gt; A value stored in the previous switch case is
			overwritten here due to a switch fall through. It is likely
			that you forgot to put a break or return at the end of the
			previous case. &lt;/p&gt;

		</info>
		<name>Dead Store Due To Switch Fallthrough</name>
	</findingType>
	<findingType>
		<id>IncorrectSynchronizationOfWriteObject</id>
		<artifact tool="FindBugs" mnemonic="WS_WRITEOBJECT_SYNC">
		</artifact>
		<shortMessage>
			Class's writeObject() method is synchronized but nothing
			else is
		</shortMessage>
		<info>

			&lt;p&gt; This class has a
			&lt;code&gt;writeObject()&lt;/code&gt; method which is
			synchronized; however, no other method of the class is
			synchronized.&lt;/p&gt;

		</info>
		<name>writeObject Is Only Synchronized Method</name>
	</findingType>
	<findingType>
		<id>AvoidSynchronizationOfReadObject</id>
		<artifact tool="FindBugs" mnemonic="RS_READOBJECT_SYNC">
		</artifact>
		<shortMessage>
			Class's readObject() method is synchronized
		</shortMessage>
		<info>

			&lt;p&gt; This serializable class defines a
			&lt;code&gt;readObject()&lt;/code&gt; which is
			synchronized.&amp;nbsp; By definition, an object created by
			deserialization is only reachable by one thread, and thus
			there is no need for &lt;code&gt;readObject()&lt;/code&gt;
			to be synchronized.&amp;nbsp; If the
			&lt;code&gt;readObject()&lt;/code&gt; method itself is
			causing the object to become visible to another thread, that
			is an example of very dubious coding style.&lt;/p&gt;

		</info>
		<name>readObject Method is Synchronized</name>
	</findingType>
	<findingType>
		<id>SE_NONSTATIC_SERIALVERSIONID</id>
		<artifact tool="FindBugs"
			mnemonic="SE_NONSTATIC_SERIALVERSIONID">
		</artifact>
		<shortMessage>serialVersionUID isn't static</shortMessage>
		<info>

			&lt;p&gt; This class defines a
			&lt;code&gt;serialVersionUID&lt;/code&gt; field that is not
			static.&amp;nbsp; The field should be made static if it is
			intended to specify the version UID for purposes of
			serialization.&lt;/p&gt;

		</info>
		<name>Nonstatic Serial Version Id</name>
	</findingType>
	<findingType>
		<id>SE_NONFINAL_SERIALVERSIONID</id>
		<artifact tool="FindBugs"
			mnemonic="SE_NONFINAL_SERIALVERSIONID">
		</artifact>
		<shortMessage>serialVersionUID isn't final</shortMessage>
		<info>

			&lt;p&gt; This class defines a
			&lt;code&gt;serialVersionUID&lt;/code&gt; field that is not
			final.&amp;nbsp; The field should be made final if it is
			intended to specify the version UID for purposes of
			serialization.&lt;/p&gt;

		</info>
		<name>Nonfinal Serial Version Id</name>
	</findingType>
	<findingType>
		<id>SE_NONLONG_SERIALVERSIONID</id>
		<artifact tool="FindBugs"
			mnemonic="SE_NONLONG_SERIALVERSIONID">
		</artifact>
		<shortMessage>serialVersionUID isn't long</shortMessage>
		<info>

			&lt;p&gt; This class defines a
			&lt;code&gt;serialVersionUID&lt;/code&gt; field that is not
			long.&amp;nbsp; The field should be made long if it is
			intended to specify the version UID for purposes of
			serialization.&lt;/p&gt;

		</info>
		<name>Nonlong Serial Version Id</name>
	</findingType>
	<findingType>
		<id>SE_BAD_FIELD</id>
		<artifact tool="FindBugs" mnemonic="SE_BAD_FIELD"></artifact>
		<shortMessage>
			Non-transient non-serializable instance field in
			serializable class
		</shortMessage>
		<info>

			&lt;p&gt; This Serializable class defines a non-primitive
			instance field which is neither transient, Serializable, or
			&lt;code&gt;java.lang.Object&lt;/code&gt;, and does not
			appear to implement the
			&lt;code&gt;Externalizable&lt;/code&gt; interface or the
			&lt;code&gt;readObject()&lt;/code&gt; and
			&lt;code&gt;writeObject()&lt;/code&gt; methods.&amp;nbsp;
			Objects of this class will not be deserialized correctly if
			a non-Serializable object is stored in this field.&lt;/p&gt;

		</info>
		<name>Bad Field</name>
	</findingType>
	<findingType>
		<id>SE_BAD_FIELD_INNER_CLASS</id>
		<artifact tool="FindBugs" mnemonic="SE_BAD_FIELD_INNER_CLASS">
		</artifact>
		<shortMessage>
			Non-serializable class has a serializable inner class
		</shortMessage>
		<info>

			&lt;p&gt; This Serializable class is an inner class of a
			non-serializable class. Thus, attempts to serialize it will
			also attempt to associate instance of the outer class with
			which it is associated, leading to a runtime error.
			&lt;/p&gt; &lt;p&gt;If possible, making the inner class a
			static inner class should solve the problem. Making the
			outer class serializable might also work, but that would
			mean serializing an instance of the inner class would always
			also serialize the instance of the outer class, which it
			often not what you really want.

		</info>
		<name>Bad Field Inner Class</name>
	</findingType>
	<findingType>
		<id>SE_INNER_CLASS</id>
		<artifact tool="FindBugs" mnemonic="SE_INNER_CLASS"></artifact>
		<shortMessage>Serializable inner class</shortMessage>
		<info>

			&lt;p&gt; This Serializable class is an inner class. Any
			attempt to serialize it will also serialize the associated
			outer instance. The outer instance is serializable, so this
			won't fail, but it might serialize a lot more data than
			intended. If possible, making the inner class a static inner
			class (also known as a nested class) should solve the
			problem.

		</info>
		<name>Inner Class</name>
	</findingType>
	<findingType>
		<id>SE_BAD_FIELD_STORE</id>
		<artifact tool="FindBugs" mnemonic="SE_BAD_FIELD_STORE">
		</artifact>
		<shortMessage>
			Non-serializable value stored into instance field of a
			serializable class
		</shortMessage>
		<info>

			&lt;p&gt; A non-serializable value is stored into a
			non-transient field of a serializable class.&lt;/p&gt;

		</info>
		<name>Bad Field Store</name>
	</findingType>
	<findingType>
		<id>AvoidThreadStartInConstructor</id>
		<artifact tool="FindBugs" mnemonic="SC_START_IN_CTOR">
		</artifact>
		<shortMessage>Constructor invokes Thread.start()</shortMessage>
		<info>

			&lt;p&gt; The constructor starts a thread. This is likely to
			be wrong if the class is ever extended/subclassed, since the
			thread will be started before the subclass constructor is
			started.&lt;/p&gt;

		</info>
		<name>Start In Constructor</name>
	</findingType>
	<findingType>
		<id>SS_SHOULD_BE_STATIC</id>
		<artifact tool="FindBugs" mnemonic="SS_SHOULD_BE_STATIC">
		</artifact>
		<shortMessage>
			Unread field: should this field be static?
		</shortMessage>
		<info>

			&lt;p&gt; This class contains an instance final field that
			is initialized to a compile-time static value. Consider
			making the field static.&lt;/p&gt;

		</info>
		<name>Should Be Static</name>
	</findingType>
	<findingType>
		<id>UnusedField</id>
		<artifact tool="FindBugs" mnemonic="UUF_UNUSED_FIELD"></artifact>
		<artifact tool="PMD" mnemonic="UnusedPrivateField"></artifact>
		<shortMessage>Unused field</shortMessage>
		<info>

			&lt;p&gt; This field is never used.&amp;nbsp; Consider
			removing it from the class.&lt;/p&gt;

			Detects when a private field is declared and/or assigned a
			value, but not used.
		</info>
		<name>Unused Field</name>
	</findingType>
	<findingType>
		<id>URF_UNREAD_FIELD</id>
		<artifact tool="FindBugs" mnemonic="URF_UNREAD_FIELD">
		</artifact>
		<shortMessage>Unread field</shortMessage>
		<info>

			&lt;p&gt; This field is never read.&amp;nbsp; Consider
			removing it from the class.&lt;/p&gt;

		</info>
		<name>Unread Field</name>
	</findingType>
	<findingType>
		<id>QF_QUESTIONABLE_FOR_LOOP</id>
		<artifact tool="FindBugs" mnemonic="QF_QUESTIONABLE_FOR_LOOP">
		</artifact>
		<shortMessage>
			Complicated, subtle or wrong increment in for-loop
		</shortMessage>
		<info>

			&lt;p&gt;Are you sure this for loop is incrementing the
			correct variable? It appears that another variable is being
			initialized and checked by the for loop. &lt;/p&gt;

		</info>
		<name>Questionable For Loop</name>
	</findingType>
	<findingType>
		<id>UWF_NULL_FIELD</id>
		<artifact tool="FindBugs" mnemonic="UWF_NULL_FIELD"></artifact>
		<shortMessage>Field only ever set to null</shortMessage>
		<info>

			&lt;p&gt; All writes to this field are of the constant value
			null, and thus all reads of the field will return null.
			Check for errors, or remove it if it is useless.&lt;/p&gt;

		</info>
		<name>Null Field</name>
	</findingType>
	<findingType>
		<id>UWF_UNWRITTEN_FIELD</id>
		<artifact tool="FindBugs" mnemonic="UWF_UNWRITTEN_FIELD">
		</artifact>
		<shortMessage>Unwritten field</shortMessage>
		<info>

			&lt;p&gt; This field is never written.&amp;nbsp; All reads
			of it will return the default value. Check for errors
			(should it have been initialized?), or remove it if it is
			useless.&lt;/p&gt;

		</info>
		<name>Unwritten Field</name>
	</findingType>
	<findingType>
		<id>ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD</id>
		<artifact tool="FindBugs"
			mnemonic="ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD">
		</artifact>
		<shortMessage>
			Write to static field from instance method
		</shortMessage>
		<info>

			&lt;p&gt; This instance method writes to a static field.
			This is tricky to get correct if multiple instances are
			being manipulated, and generally bad practice. &lt;/p&gt;

		</info>
		<name>Write To Static From Instance Method</name>
	</findingType>
	<findingType>
		<id>NP_LOAD_OF_KNOWN_NULL_VALUE</id>
		<artifact tool="FindBugs"
			mnemonic="NP_LOAD_OF_KNOWN_NULL_VALUE">
		</artifact>
		<shortMessage>Load of known null value</shortMessage>
		<info>

			&lt;p&gt; The variable referenced at this point is known to
			be null due to an earlier check against null. Although this
			is valid, it might be a mistake (perhaps you intended to
			refer to a different variable, or perhaps the earlier check
			to see if the variable is null should have been a check to
			see if it was nonnull. &lt;/p&gt;

		</info>
		<name>Load Of Known Null Value</name>
	</findingType>
	<findingType>
		<id>NP_IMMEDIATE_DEREFERENCE_OF_READLINE</id>
		<artifact tool="FindBugs"
			mnemonic="NP_IMMEDIATE_DEREFERENCE_OF_READLINE">
		</artifact>
		<shortMessage>
			Immediate dereference of the result of readLine()
		</shortMessage>
		<info>

			&lt;p&gt; The result of invoking readLine() is immediately
			dereferenced. If there are no more lines of text to read,
			readLine() will return null and dereferencing that will
			generate a null pointer exception. &lt;/p&gt;

		</info>
		<name>Immediate Dereference Of Readline</name>
	</findingType>
	<findingType>
		<id>NP_UNWRITTEN_FIELD</id>
		<artifact tool="FindBugs" mnemonic="NP_UNWRITTEN_FIELD">
		</artifact>
		<shortMessage>Read of unwritten field</shortMessage>
		<info>

			&lt;p&gt; The program is dereferencing a field that does not
			seem to ever have a non-null value written to it.
			Dereferencing this value will generate a null pointer
			exception. &lt;/p&gt;

		</info>
		<name>Unwritten Field</name>
	</findingType>
	<findingType>
		<id>SIC_INNER_SHOULD_BE_STATIC</id>
		<artifact tool="FindBugs"
			mnemonic="SIC_INNER_SHOULD_BE_STATIC">
		</artifact>
		<shortMessage>Should be a static inner class</shortMessage>
		<info>

			&lt;p&gt; This class is an inner class, but does not use its
			embedded reference to the object which created it.&amp;nbsp;
			This reference makes the instances of the class larger, and
			may keep the reference to the creator object alive longer
			than necessary.&amp;nbsp; If possible, the class should be
			made static. &lt;/p&gt;

		</info>
		<name>Inner Should Be Static</name>
	</findingType>
	<findingType>
		<id>NP_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR</id>
		<artifact tool="FindBugs"
			mnemonic="NP_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR">
		</artifact>
		<shortMessage>
			Read of field not initialized in constructor
		</shortMessage>
		<info>

			&lt;p&gt; This is a read of a field is never initialized
			within any constructor, and is therefore could be null after
			the object is initialized. This might be a coding error, or
			else the class containing the field is written in a way that
			depends upon methods being called in some specific order (a
			little bit dodgy, but not necessarily wrong). &lt;/p&gt;

		</info>
		<name>Field Not Initialized In Constructor</name>
	</findingType>
	<findingType>
		<id>UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR</id>
		<artifact tool="FindBugs"
			mnemonic="UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR">
		</artifact>
		<shortMessage>
			Field not initialized in constructor
		</shortMessage>
		<info>

			&lt;p&gt; This field is never initialized within any
			constructor, and is therefore could be null after the object
			is constructed. This could be a either an error or a
			questionable design, since it means a null pointer exception
			will be generated if that field is dereferenced before being
			initialized. &lt;/p&gt;

		</info>
		<name>Field Not Initialized In Constructor</name>
	</findingType>
	<findingType>
		<id>SIC_INNER_SHOULD_BE_STATIC_ANON</id>
		<artifact tool="FindBugs"
			mnemonic="SIC_INNER_SHOULD_BE_STATIC_ANON">
		</artifact>
		<shortMessage>
			Could be refactored into a named static inner class
		</shortMessage>
		<info>

			&lt;p&gt; This class is an inner class, but does not use its
			embedded reference to the object which created it.&amp;nbsp;
			This reference makes the instances of the class larger, and
			may keep the reference to the creator object alive longer
			than necessary.&amp;nbsp; If possible, the class should be
			made into a &lt;em&gt;static&lt;/em&gt; inner class. Since
			anonymous inner classes cannot be marked as static, doing
			this will requiring refactoring the inner class so that it
			is a named inner class.&lt;/p&gt;

		</info>
		<name>Inner Should Be Static Anon</name>
	</findingType>
	<findingType>
		<id>SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS</id>
		<artifact tool="FindBugs"
			mnemonic="SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS">
		</artifact>
		<shortMessage>
			Could be refactored into a static inner class
		</shortMessage>
		<info>

			&lt;p&gt; This class is an inner class, but does not use its
			embedded reference to the object which created it except
			during construction of the inner object.&amp;nbsp; This
			reference makes the instances of the class larger, and may
			keep the reference to the creator object alive longer than
			necessary.&amp;nbsp; If possible, the class should be made
			into a &lt;em&gt;static&lt;/em&gt; inner class. Since the
			reference to the outer object is required during
			construction of the inner instance, the inner class will
			need to be refactored so as to pass a reference to the outer
			instance to the constructor for the inner class.&lt;/p&gt;

		</info>
		<name>Inner Should Be Static Needs This</name>
	</findingType>
	<findingType>
		<id>WaitNotInLoop</id>
		<artifact tool="FindBugs" mnemonic="WA_NOT_IN_LOOP"></artifact>
		<shortMessage>Wait not in loop</shortMessage>
		<info>

			&lt;p&gt; This method contains a call to
			&lt;code&gt;java.lang.Object.wait()&lt;/code&gt; which is
			not in a loop.&amp;nbsp; If the monitor is used for multiple
			conditions, the condition the caller intended to wait for
			might not be the one that actually occurred.&lt;/p&gt;

		</info>
		<name>Not In Loop</name>
	</findingType>
	<findingType>
		<id>AwaitNotInLoop</id>
		<artifact tool="FindBugs" mnemonic="WA_AWAIT_NOT_IN_LOOP">
		</artifact>
		<shortMessage>Condition.await() not in loop</shortMessage>
		<info>

			&lt;p&gt; This method contains a call to
			&lt;code&gt;java.util.concurrent.await()&lt;/code&gt; (or
			variants) which is not in a loop.&amp;nbsp; If the object is
			used for multiple conditions, the condition the caller
			intended to wait for might not be the one that actually
			occurred.&lt;/p&gt;

		</info>
		<name>Await Not In Loop</name>
	</findingType>
	<findingType>
		<id>UseNotifyAllInsteadOfNotify</id>
		<artifact tool="FindBugs" mnemonic="NO_NOTIFY_NOT_NOTIFYALL">
		</artifact>
		<artifact tool="PMD" mnemonic="UseNotifyAllInsteadOfNotify">
		</artifact>
		<shortMessage>
			Using notify() rather than notifyAll()
		</shortMessage>
		<info>

			&lt;p&gt; This method calls
			&lt;code&gt;notify()&lt;/code&gt; rather than
			&lt;code&gt;notifyAll()&lt;/code&gt;.&amp;nbsp; Java
			monitors are often used for multiple conditions.&amp;nbsp;
			Calling &lt;code&gt;notify()&lt;/code&gt; only wakes up one
			thread, meaning that the thread woken up might not be the
			one waiting for the condition that the caller just
			satisfied.&lt;/p&gt;

			Thread.notify() awakens a thread monitoring the object. If
			more than one thread is monitoring, then only one is chosen.
			The thread chosen is arbitrary; thus it's usually safer to
			call notifyAll() instead.

		</info>
		<name>Notify Not Notifyall</name>
	</findingType>
	<findingType>
		<id>RV_CHECK_FOR_POSITIVE_INDEXOF</id>
		<artifact tool="FindBugs"
			mnemonic="RV_CHECK_FOR_POSITIVE_INDEXOF">
		</artifact>
		<shortMessage>
			Method checks to see if result of String.indexOf is positive
		</shortMessage>
		<info>

			&lt;p&gt; The method invokes String.indexOf and checks to
			see if the result is positive or non-positive. It is much
			more typical to check to see if the result is negative or
			non-negative. It is positive only if the substring checked
			for occurs at some place other than at the beginning of the
			String.&lt;/p&gt;

		</info>
		<name>Check For Positive Indexof</name>
	</findingType>
	<findingType>
		<id>RV_DONT_JUST_NULL_CHECK_READLINE</id>
		<artifact tool="FindBugs"
			mnemonic="RV_DONT_JUST_NULL_CHECK_READLINE">
		</artifact>
		<shortMessage>
			Method discards result of readLine after checking if it is
			nonnull
		</shortMessage>
		<info>

			&lt;p&gt; The value returned by readLine is discarded after
			checking to see if the return value is non-null. In almost
			all situations, if the result is non-null, you will want to
			use that non-null value. Calling readLine again will give
			you a different line.&lt;/p&gt;

		</info>
		<name>Dont Just Null Check Readline</name>
	</findingType>
	<findingType>
		<id>RV_RETURN_VALUE_IGNORED</id>
		<artifact tool="FindBugs" mnemonic="RV_RETURN_VALUE_IGNORED">
		</artifact>
		<shortMessage>Method ignores return value</shortMessage>
		<info>

			&lt;p&gt; The return value of this method should be checked.
			One common cause of this warning is to invoke a method on an
			immutable object, thinking that it updates the object. For
			example, in the following code fragment,&lt;/p&gt;
			&lt;blockquote&gt; &lt;pre&gt; String dateString =
			getHeaderField(name); dateString.trim(); &lt;/pre&gt;
			&lt;/blockquote&gt; &lt;p&gt;the programmer seems to be
			thinking that the trim() method will update the String
			referenced by dateString. But since Strings are immutable,
			the trim() function returns a new String value, which is
			being ignored here. The code should be corrected to:
			&lt;/p&gt; &lt;blockquote&gt; &lt;pre&gt; String dateString
			= getHeaderField(name); dateString = dateString.trim();
			&lt;/pre&gt; &lt;/blockquote&gt;

		</info>
		<name>Return Value Ignored</name>
	</findingType>
	<findingType>
		<id>RV_RETURN_VALUE_IGNORED2</id>
		<artifact tool="FindBugs" mnemonic="RV_RETURN_VALUE_IGNORED2">
		</artifact>
		<shortMessage>Method ignores return value</shortMessage>
		<info>

			&lt;p&gt; The return value of this method should be checked.
			One common cause of this warning is to invoke a method on an
			immutable object, thinking that it updates the object. For
			example, in the following code fragment,&lt;/p&gt;
			&lt;blockquote&gt; &lt;pre&gt; String dateString =
			getHeaderField(name); dateString.trim(); &lt;/pre&gt;
			&lt;/blockquote&gt; &lt;p&gt;the programmer seems to be
			thinking that the trim() method will update the String
			referenced by dateString. But since Strings are immutable,
			the trim() function returns a new String value, which is
			being ignored here. The code should be corrected to:
			&lt;/p&gt; &lt;blockquote&gt; &lt;pre&gt; String dateString
			= getHeaderField(name); dateString = dateString.trim();
			&lt;/pre&gt; &lt;/blockquote&gt;

		</info>
		<name>Return Value IGNORED2</name>
	</findingType>
	<findingType>
		<id>NP_ALWAYS_NULL</id>
		<artifact tool="FindBugs" mnemonic="NP_ALWAYS_NULL"></artifact>
		<shortMessage>Null pointer dereference</shortMessage>
		<info>

			&lt;p&gt; A null pointer is dereferenced here.&amp;nbsp;
			This will lead to a
			&lt;code&gt;NullPointerException&lt;/code&gt; when the code
			is executed.&lt;/p&gt;

		</info>
		<name>Always Null</name>
	</findingType>
	<findingType>
		<id>NP_STORE_INTO_NONNULL_FIELD</id>
		<artifact tool="FindBugs"
			mnemonic="NP_STORE_INTO_NONNULL_FIELD">
		</artifact>
		<shortMessage>
			Store of null value into field annotated NonNull
		</shortMessage>
		<info>

			&lt;p&gt; A value that could be null is stored into a field
			that has been annotated as NonNull. &lt;/p&gt;

		</info>
		<name>Store Into Nonnull Field</name>
	</findingType>
	<findingType>
		<id>NP_ALWAYS_NULL_EXCEPTION</id>
		<artifact tool="FindBugs" mnemonic="NP_ALWAYS_NULL_EXCEPTION">
		</artifact>
		<shortMessage>
			Null pointer dereference in method on exception path
		</shortMessage>
		<info>

			&lt;p&gt; A pointer which is null on an exception path is
			dereferenced here.&amp;nbsp; This will lead to a
			&lt;code&gt;NullPointerException&lt;/code&gt; when the code
			is executed.&amp;nbsp; Note that because FindBugs currently
			does not prune infeasible exception paths, this may be a
			false warning.&lt;/p&gt;

			&lt;p&gt; Also note that FindBugs considers the default case
			of a switch statement to be an exception path, since the
			default case is often infeasible.&lt;/p&gt;

		</info>
		<name>Always Null Exception</name>
	</findingType>
	<findingType>
		<id>NP_NULL_ON_SOME_PATH</id>
		<artifact tool="FindBugs" mnemonic="NP_NULL_ON_SOME_PATH">
		</artifact>
		<shortMessage>Possible null pointer dereference</shortMessage>
		<info>

			&lt;p&gt; A reference value dereferenced here might be null
			at runtime.&amp;nbsp; This may lead to a
			&lt;code&gt;NullPointerException&lt;/code&gt; when the code
			is executed.&lt;/p&gt;

		</info>
		<name>Null On Some Path</name>
	</findingType>
	<findingType>
		<id>NP_NULL_ON_SOME_PATH_EXCEPTION</id>
		<artifact tool="FindBugs"
			mnemonic="NP_NULL_ON_SOME_PATH_EXCEPTION">
		</artifact>
		<shortMessage>
			Possible null pointer dereference in method on exception
			path
		</shortMessage>
		<info>

			&lt;p&gt; A reference value which is null on some exception
			control path is dereferenced here.&amp;nbsp; This may lead
			to a &lt;code&gt;NullPointerException&lt;/code&gt; when the
			code is executed.&amp;nbsp; Note that because FindBugs
			currently does not prune infeasible exception paths, this
			may be a false warning.&lt;/p&gt;

			&lt;p&gt; Also note that FindBugs considers the default case
			of a switch statement to be an exception path, since the
			default case is often infeasible.&lt;/p&gt;

		</info>
		<name>Null On Some Path Exception</name>
	</findingType>
	<findingType>
		<id>NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE</id>
		<artifact tool="FindBugs"
			mnemonic="NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE">
		</artifact>
		<shortMessage>
			Possible null pointer dereference due to return value of
			called method
		</shortMessage>
		<info>

			&lt;p&gt; A reference value which is null on some exception
			control path is dereferenced here.&amp;nbsp; This may lead
			to a &lt;code&gt;NullPointerException&lt;/code&gt; when the
			code is executed.&amp;nbsp; The value may be null because it
			was return from a method which is known to return
			possibly-null values.&lt;/p&gt;

		</info>
		<name>Null On Some Path From Return Value</name>
	</findingType>
	<findingType>
		<id>NP_NULL_PARAM_DEREF_NONVIRTUAL</id>
		<artifact tool="FindBugs"
			mnemonic="NP_NULL_PARAM_DEREF_NONVIRTUAL">
		</artifact>
		<shortMessage>
			Non-virtual method call passes null for unconditionally
			dereferenced parameter
		</shortMessage>
		<info>

			&lt;p&gt; A possibly-null value is passed to a method which
			unconditionally dereferences it. This will almost certainly
			result in a null pointer exception. &lt;/p&gt;

		</info>
		<name>Null Param Deref Nonvirtual</name>
	</findingType>
	<findingType>
		<id>NP_NULL_PARAM_DEREF_ALL_TARGETS_DANGEROUS</id>
		<artifact tool="FindBugs"
			mnemonic="NP_NULL_PARAM_DEREF_ALL_TARGETS_DANGEROUS">
		</artifact>
		<shortMessage>
			Method call passes null for unconditionally dereferenced
			parameter
		</shortMessage>
		<info>

			&lt;p&gt; A possibly-null value is passed at a call site
			where all known target methods will unconditionally
			dereference it. This is very likely to result in a null
			pointer exception. &lt;/p&gt;

		</info>
		<name>Null Param Deref All Targets Dangerous</name>
	</findingType>
	<findingType>
		<id>NP_NULL_PARAM_DEREF</id>
		<artifact tool="FindBugs" mnemonic="NP_NULL_PARAM_DEREF">
		</artifact>
		<shortMessage>
			Method call passes null for unconditionally dereferenced
			parameter
		</shortMessage>
		<info>

			&lt;p&gt; This method call passes a null value to a method
			which might dereference it unconditionally. &lt;/p&gt;

		</info>
		<name>Null Param Deref</name>
	</findingType>
	<findingType>
		<id>NP_NONNULL_PARAM_VIOLATION</id>
		<artifact tool="FindBugs"
			mnemonic="NP_NONNULL_PARAM_VIOLATION">
		</artifact>
		<shortMessage>
			Method call passes null to a nonnull parameter
		</shortMessage>
		<info>

			&lt;p&gt; This method passes a null value as the parameter
			of a method which must be nonnull. Either this parameter has
			been explicitly marked as @Nonnull, or analysis has
			determined that this parameter is always deferenced.
			&lt;/p&gt;

		</info>
		<name>Nonnull Param Violation</name>
	</findingType>
	<findingType>
		<id>NP_NONNULL_RETURN_VIOLATION</id>
		<artifact tool="FindBugs"
			mnemonic="NP_NONNULL_RETURN_VIOLATION">
		</artifact>
		<shortMessage>
			Method may return null, but is declared @NonNull
		</shortMessage>
		<info>

			&lt;p&gt; This method may return a null value, but the
			method (or a superclass method which it overrides) is
			declared to return @NonNull. &lt;/p&gt;

		</info>
		<name>Nonnull Return Violation</name>
	</findingType>
	<findingType>
		<id>NP_CLONE_COULD_RETURN_NULL</id>
		<artifact tool="FindBugs"
			mnemonic="NP_CLONE_COULD_RETURN_NULL">
		</artifact>
		<shortMessage>Clone method may return null</shortMessage>
		<info>

			&lt;p&gt; This clone method seems to return null in some
			circumstances, but clone is never allowed to return a null
			value. If you are convinced this path is unreachable, throw
			an AssertionError instead. &lt;/p&gt;

		</info>
		<name>Clone Could Return Null</name>
	</findingType>
	<findingType>
		<id>NP_TOSTRING_COULD_RETURN_NULL</id>
		<artifact tool="FindBugs"
			mnemonic="NP_TOSTRING_COULD_RETURN_NULL">
		</artifact>
		<shortMessage>toString method may return null</shortMessage>
		<info>

			&lt;p&gt; This toString method seems to return null in some
			circumstances. A liberal reading of the spec could be
			interpreted as allowing this, but it is probably a bad idea
			and could cause other code to break. Return the empty string
			or some other appropriate string rather than null.
			&lt;/p&gt;

		</info>
		<name>Tostring Could Return Null</name>
	</findingType>
	<findingType>
		<id>NP_GUARANTEED_DEREF</id>
		<artifact tool="FindBugs" mnemonic="NP_GUARANTEED_DEREF">
		</artifact>
		<shortMessage>
			Null value is guaranteed to be dereferenced
		</shortMessage>
		<info>

			&lt;p&gt; There is a statement or branch that if executed
			guarantees that a value is null at this point, and that
			value that is guaranteed to be dereferenced (except on
			forward paths involving runtime exceptions). &lt;/p&gt;

		</info>
		<name>Guaranteed Deref</name>
	</findingType>
	<findingType>
		<id>NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH</id>
		<artifact tool="FindBugs"
			mnemonic="NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH">
		</artifact>
		<shortMessage>
			Value is null and guaranteed to be dereferenced on exception
			path
		</shortMessage>
		<info>

			&lt;p&gt; There is a statement or branch on an exception
			path that if executed guarantees that a value is null at
			this point, and that value that is guaranteed to be
			dereferenced (except on forward paths involving runtime
			exceptions). &lt;/p&gt;

		</info>
		<name>Guaranteed Deref On Exception Path</name>
	</findingType>
	<findingType>
		<id>SI_INSTANCE_BEFORE_FINALS_ASSIGNED</id>
		<artifact tool="FindBugs"
			mnemonic="SI_INSTANCE_BEFORE_FINALS_ASSIGNED">
		</artifact>
		<shortMessage>
			Static initializer creates instance before all static final
			fields assigned
		</shortMessage>
		<info>

			&lt;p&gt; The class's static initializer creates an instance
			of the class before all of the static final fields are
			assigned.&lt;/p&gt;

		</info>
		<name>Instance Before Finals Assigned</name>
	</findingType>
	<findingType>
		<id>OS_OPEN_STREAM</id>
		<artifact tool="FindBugs" mnemonic="OS_OPEN_STREAM"></artifact>
		<shortMessage>Method may fail to close stream</shortMessage>
		<info>

			&lt;p&gt; The method creates an IO stream object, does not
			assign it to any fields, pass it to other methods that might
			close it, or return it, and does not appear to close the
			stream on all paths out of the method.&amp;nbsp; This may
			result in a file descriptor leak.&amp;nbsp; It is generally
			a good idea to use a &lt;code&gt;finally&lt;/code&gt; block
			to ensure that streams are closed.&lt;/p&gt;

		</info>
		<name>Open Stream</name>
	</findingType>
	<findingType>
		<id>OS_OPEN_STREAM_EXCEPTION_PATH</id>
		<artifact tool="FindBugs"
			mnemonic="OS_OPEN_STREAM_EXCEPTION_PATH">
		</artifact>
		<shortMessage>
			Method may fail to close stream on exception
		</shortMessage>
		<info>

			&lt;p&gt; The method creates an IO stream object, does not
			assign it to any fields, pass it to other methods, or return
			it, and does not appear to close it on all possible
			exception paths out of the method.&amp;nbsp; This may result
			in a file descriptor leak.&amp;nbsp; It is generally a good
			idea to use a &lt;code&gt;finally&lt;/code&gt; block to
			ensure that streams are closed.&lt;/p&gt;

		</info>
		<name>Open Stream Exception Path</name>
	</findingType>
	<findingType>
		<id>PZLA_PREFER_ZERO_LENGTH_ARRAYS</id>
		<artifact tool="FindBugs"
			mnemonic="PZLA_PREFER_ZERO_LENGTH_ARRAYS">
		</artifact>
		<shortMessage>
			Consider returning a zero length array rather than null
		</shortMessage>
		<info>

			&lt;p&gt; It is often a better design to return a length
			zero array rather than a null reference to indicate that
			there are no results (i.e., an empty list of results). This
			way, no explicit check for null is needed by clients of the
			method.&lt;/p&gt;

			&lt;p&gt;On the other hand, using null to indicate
			&quot;there is no answer to this question&quot;, then it is
			probably appropriate. For example,
			&lt;code&gt;File.listFiles()&lt;/code&gt; returns an empty
			list if given a directory containing no files, and returns
			null if the file is not a directory.&lt;/p&gt;

		</info>
		<name>Prefer Zero Length Arrays</name>
	</findingType>
	<findingType>
		<id>UCF_USELESS_CONTROL_FLOW</id>
		<artifact tool="FindBugs" mnemonic="UCF_USELESS_CONTROL_FLOW">
		</artifact>
		<shortMessage>Useless control flow</shortMessage>
		<info>

			&lt;p&gt; This method contains a useless control flow
			statement, where control flow continues onto the same place
			regardless of whether or not the branch is taken. For
			example, this is caused by having an empty statement block
			fot an &lt;code&gt;if&lt;/code&gt; statement:&lt;/p&gt;
			&lt;pre&gt; if (argv.length == 0) { // TODO: handle this
			case } &lt;/pre&gt;

		</info>
		<name>Useless Control Flow</name>
	</findingType>
	<findingType>
		<id>UCF_USELESS_CONTROL_FLOW_NEXT_LINE</id>
		<artifact tool="FindBugs"
			mnemonic="UCF_USELESS_CONTROL_FLOW_NEXT_LINE">
		</artifact>
		<shortMessage>Useless control flow to next line</shortMessage>
		<info>

			&lt;p&gt; This method contains a useless control flow
			statement in which control flow follows to the same or
			following line regardless of whether or not the branch is
			taken. Often, this is caused by inadvertently using an empty
			statement as the body of an &lt;code&gt;if&lt;/code&gt;
			statement, e.g.:&lt;/p&gt; &lt;pre&gt; if (argv.length ==
			1); System.out.println(&quot;Hello, &quot; + argv[0]);
			&lt;/pre&gt;

		</info>
		<name>Useless Control Flow Next Line</name>
	</findingType>
	<findingType>
		<id>RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE</id>
		<artifact tool="FindBugs"
			mnemonic="RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE">
		</artifact>
		<shortMessage>
			Nullcheck of value previously dereferenced
		</shortMessage>
		<info>

			&lt;p&gt; A value is checked here to see whether it is null,
			but this value can't be null because it was previously
			dereferenced and if it were null a null pointer exception
			would have occurred at the earlier dereference. Essentially,
			this code and the previous dereference disagree as to
			whether this value is allowed to be null. Either the check
			is redundant or the previous dereference is
			erroneous.&lt;/p&gt;

		</info>
		<name>Redundant Nullcheck Would Have Been A NullPointerException</name>
	</findingType>
	<findingType>
		<id>RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE</id>
		<artifact tool="FindBugs"
			mnemonic="RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE">
		</artifact>
		<shortMessage>
			Redundant nullcheck of value known to be null
		</shortMessage>
		<info>

			&lt;p&gt; This method contains a redundant check of a known
			null value against the constant null.&lt;/p&gt;

		</info>
		<name>Redundant Nullcheck Of Null Value</name>
	</findingType>
	<findingType>
		<id>RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE</id>
		<artifact tool="FindBugs"
			mnemonic="RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE">
		</artifact>
		<shortMessage>
			Redundant nullcheck of value known to be non-null
		</shortMessage>
		<info>

			&lt;p&gt; This method contains a redundant check of a known
			non-null value against the constant null.&lt;/p&gt;

		</info>
		<name>Redundant Nullcheck Of Nonnull Value</name>
	</findingType>
	<findingType>
		<id>RCN_REDUNDANT_COMPARISON_TWO_NULL_VALUES</id>
		<artifact tool="FindBugs"
			mnemonic="RCN_REDUNDANT_COMPARISON_TWO_NULL_VALUES">
		</artifact>
		<shortMessage>
			Redundant comparison of two null values
		</shortMessage>
		<info>

			&lt;p&gt; This method contains a redundant comparison of two
			references known to both be definitely null.&lt;/p&gt;

		</info>
		<name>Redundant Comparison Two Null Values</name>
	</findingType>
	<findingType>
		<id>RedundantComparisonOfNullAndNonnullValue</id>
		<artifact tool="FindBugs"
			mnemonic="RCN_REDUNDANT_COMPARISON_OF_NULL_AND_NONNULL_VALUE">
		</artifact>
		<artifact tool="PMD" mnemonic="MisplacedNullCheck"></artifact>
		<shortMessage>
			Redundant comparison of non-null value to null
		</shortMessage>
		<info>
			&lt;p&gt; This method contains a reference known to be
			non-null with another reference known to be null.&lt;/p&gt;

			The null check here is misplaced. if the variable is null
			you'll get a NullPointerException. Either the check is
			useless (the variable will never be &quot;null&quot;) or
			it's incorrect.
		</info>
		<name>Redundant Comparison Of Null And Nonnull Value</name>
	</findingType>
	<findingType>
		<id>UnreleasedLock</id>
		<artifact tool="FindBugs" mnemonic="UL_UNRELEASED_LOCK">
		</artifact>
		<shortMessage>
			Method does not release lock on all paths
		</shortMessage>
		<info>

			&lt;p&gt; This method acquires a JSR-166
			(&lt;code&gt;java.util.concurrent&lt;/code&gt;) lock, but
			does not release it on all paths out of the method. In
			general, the correct idiom for using a JSR-166 lock is:
			&lt;/p&gt; &lt;pre&gt; Lock l = ...; l.lock(); try { // do
			something } finally { l.unlock(); } &lt;/pre&gt;

		</info>
		<name>Unreleased Lock</name>
	</findingType>
	<findingType>
		<id>UnreleasedLockOnExceptionPath</id>
		<artifact tool="FindBugs"
			mnemonic="UL_UNRELEASED_LOCK_EXCEPTION_PATH">
		</artifact>
		<shortMessage>
			Method does not release lock on all exception paths
		</shortMessage>
		<info>

			&lt;p&gt; This method acquires a JSR-166
			(&lt;code&gt;java.util.concurrent&lt;/code&gt;) lock, but
			does not release it on all exception paths out of the
			method. In general, the correct idiom for using a JSR-166
			lock is: &lt;/p&gt; &lt;pre&gt; Lock l = ...; l.lock(); try
			{ // do something } finally { l.unlock(); } &lt;/pre&gt;

		</info>
		<name>Unreleased Lock On An Exception Path</name>
	</findingType>
	<findingType>
		<id>RC_REF_COMPARISON</id>
		<artifact tool="FindBugs" mnemonic="RC_REF_COMPARISON">
		</artifact>
		<shortMessage>Suspicious reference comparison</shortMessage>
		<info>

			&lt;p&gt; This method compares two reference values using
			the == or != operator, where the correct way to compare
			instances of this type is generally with the equals()
			method. Examples of classes which should generally not be
			compared by reference are java.lang.Integer,
			java.lang.Float, etc.&lt;/p&gt;

		</info>
		<name>Ref Comparison</name>
	</findingType>
	<findingType>
		<id>EC_UNRELATED_TYPES</id>
		<artifact tool="FindBugs" mnemonic="EC_UNRELATED_TYPES">
		</artifact>
		<shortMessage>
			Call to equals() comparing different types
		</shortMessage>
		<info>

			&lt;p&gt; This method calls equals(Object) on two references
			of different class types with no common subclasses.
			Therefore, the objects being compared are unlikely to be
			members of the same class at runtime (unless some
			application classes were not analyzed, or dynamic class
			loading can occur at runtime). According to the contract of
			equals(), objects of different classes should always compare
			as unequal; therefore, according to the contract defined by
			java.lang.Object.equals(Object), the result of this
			comparison will always be false at runtime. &lt;/p&gt;

		</info>
		<name>Unrelated Types</name>
	</findingType>
	<findingType>
		<id>EC_UNRELATED_INTERFACES</id>
		<artifact tool="FindBugs" mnemonic="EC_UNRELATED_INTERFACES">
		</artifact>
		<shortMessage>
			Call to equals() comparing different interface types
		</shortMessage>
		<info>

			&lt;p&gt; This method calls equals(Object) on two references
			of unrelated interface types, where neither is a subtype of
			the other, and there are no known non-abstract classes which
			implement both interfaces. Therefore, the objects being
			compared are unlikely to be members of the same class at
			runtime (unless some application classes were not analyzed,
			or dynamic class loading can occur at runtime). According to
			the contract of equals(), objects of different classes
			should always compare as unequal; therefore, according to
			the contract defined by java.lang.Object.equals(Object), the
			result of this comparison will always be false at runtime.
			&lt;/p&gt;

		</info>
		<name>Unrelated Interfaces</name>
	</findingType>
	<findingType>
		<id>EC_UNRELATED_CLASS_AND_INTERFACE</id>
		<artifact tool="FindBugs"
			mnemonic="EC_UNRELATED_CLASS_AND_INTERFACE">
		</artifact>
		<shortMessage>
			Call to equals() comparing unrelated class and interface
		</shortMessage>
		<info>

			&lt;p&gt; This method calls equals(Object) on two
			references, one of which is a class and the other an
			interface, where neither the class nor any of its
			non-abstract subclasses implement the interface. Therefore,
			the objects being compared are unlikely to be members of the
			same class at runtime (unless some application classes were
			not analyzed, or dynamic class loading can occur at
			runtime). According to the contract of equals(), objects of
			different classes should always compare as unequal;
			therefore, according to the contract defined by
			java.lang.Object.equals(Object), the result of this
			comparison will always be false at runtime. &lt;/p&gt;

		</info>
		<name>Unrelated Class And Interface</name>
	</findingType>
	<findingType>
		<id>EqualComparisonToNullArgument</id>
		<artifact tool="FindBugs" mnemonic="EC_NULL_ARG"></artifact>
		<artifact tool="PMD" mnemonic="EqualsNull"></artifact>
		<shortMessage>Call to equals() with null argument</shortMessage>
		<info>

			&lt;p&gt; This method calls equals(Object), passing a null
			value as the argument. According to the contract of the
			equals() method, this call should always return
			&lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;

			Inexperienced programmers sometimes confuse comparison
			concepts and use equals() to compare to null.

		</info>
		<name>Equal Comparison To Null Argument</name>
	</findingType>
	<findingType>
		<id>MismatchedWait</id>
		<artifact tool="FindBugs" mnemonic="MWN_MISMATCHED_WAIT">
		</artifact>
		<shortMessage>Mismatched wait()</shortMessage>
		<info>

			&lt;p&gt; This method calls Object.wait() without obviously
			holding a lock on the object.&amp;nbsp; Calling wait()
			without a lock held will result in an
			&lt;code&gt;IllegalMonitorStateException&lt;/code&gt; being
			thrown.&lt;/p&gt;

		</info>
		<name>Mismatched Wait</name>
	</findingType>
	<findingType>
		<id>MismatchedNotify</id>
		<artifact tool="FindBugs" mnemonic="MWN_MISMATCHED_NOTIFY">
		</artifact>
		<shortMessage>Mismatched notify()</shortMessage>
		<info>

			&lt;p&gt; This method calls Object.notify() or
			Object.notifyAll() without obviously holding a lock on the
			object.&amp;nbsp; Calling notify() or notifyAll() without a
			lock held will result in an
			&lt;code&gt;IllegalMonitorStateException&lt;/code&gt; being
			thrown.&lt;/p&gt;

		</info>
		<name>Mismatched Notify</name>
	</findingType>
	<findingType>
		<id>SA_LOCAL_SELF_ASSIGNMENT</id>
		<artifact tool="FindBugs" mnemonic="SA_LOCAL_SELF_ASSIGNMENT">
		</artifact>
		<shortMessage>Self assignment of local variable</shortMessage>
		<info>

			&lt;p&gt; This method contains a self assignment of a local
			variable; e.g.&lt;/p&gt; &lt;pre&gt; public void foo() { int
			x = 3; x = x; } &lt;/pre&gt; &lt;p&gt; Such assignments are
			useless, and may indicate a logic error or typo. &lt;/p&gt;

		</info>
		<name>Local Self Assignment</name>
	</findingType>
	<findingType>
		<id>SA_FIELD_SELF_ASSIGNMENT</id>
		<artifact tool="FindBugs" mnemonic="SA_FIELD_SELF_ASSIGNMENT">
		</artifact>
		<shortMessage>Self assignment of field</shortMessage>
		<info>

			&lt;p&gt; This method contains a self assignment of a field;
			e.g. &lt;/p&gt; &lt;pre&gt; int x; public void foo() { x =
			x; } &lt;/pre&gt; &lt;p&gt;Such assignments are useless, and
			may indicate a logic error or typo.&lt;/p&gt;

		</info>
		<name>Field Self Assignment</name>
	</findingType>
	<findingType>
		<id>SA_FIELD_DOUBLE_ASSIGNMENT</id>
		<artifact tool="FindBugs"
			mnemonic="SA_FIELD_DOUBLE_ASSIGNMENT">
		</artifact>
		<shortMessage>Double assignment of field</shortMessage>
		<info>

			&lt;p&gt; This method contains a double assignment of a
			field; e.g. &lt;/p&gt; &lt;pre&gt; int x,y; public void
			foo() { x = x = 17; } &lt;/pre&gt; &lt;p&gt;Assigning to a
			field twice is useless, and may indicate a logic error or
			typo.&lt;/p&gt;

		</info>
		<name>Field Double Assignment</name>
	</findingType>
	<findingType>
		<id>SA_LOCAL_DOUBLE_ASSIGNMENT</id>
		<artifact tool="FindBugs"
			mnemonic="SA_LOCAL_DOUBLE_ASSIGNMENT">
		</artifact>
		<shortMessage>Double assignment of local variable</shortMessage>
		<info>

			&lt;p&gt; This method contains a double assignment of a
			local variable; e.g. &lt;/p&gt; &lt;pre&gt; public void
			foo() { int x,y; x = x = 17; } &lt;/pre&gt;
			&lt;p&gt;Assigning the same value to a variable twice is
			useless, and may indicate a logic error or typo.&lt;/p&gt;

		</info>
		<name>Local Double Assignment</name>
	</findingType>
	<findingType>
		<id>SA_FIELD_SELF_COMPUTATION</id>
		<artifact tool="FindBugs"
			mnemonic="SA_FIELD_SELF_COMPUTATION">
		</artifact>
		<shortMessage>
			Nonsensical self computation involving a field (e.g., x
			&amp; x)
		</shortMessage>
		<info>

			&lt;p&gt; This method performs a nonsensical computation of
			a field with another reference to the same field (e.g.,
			x&amp;x or x-x). Because of the nature of the computation,
			this operation doesn't seem to make sense, and may indicate
			a typo or a logic error. Double check the computation.
			&lt;/p&gt;

		</info>
		<name>Field Self Computation</name>
	</findingType>
	<findingType>
		<id>SA_LOCAL_SELF_COMPUTATION</id>
		<artifact tool="FindBugs"
			mnemonic="SA_LOCAL_SELF_COMPUTATION">
		</artifact>
		<shortMessage>
			Nonsensical self computation involving a variable (e.g., x
			&amp; x)
		</shortMessage>
		<info>

			&lt;p&gt; This method performs a nonsensical computation of
			a local variable with another reference to the same variable
			(e.g., x&amp;x or x-x). Because of the nature of the
			computation, this operation doesn't seem to make sense, and
			may indicate a typo or a logic error. Double check the
			computation. &lt;/p&gt;

		</info>
		<name>Local Self Computation</name>
	</findingType>
	<findingType>
		<id>SA_FIELD_SELF_COMPARISON</id>
		<artifact tool="FindBugs" mnemonic="SA_FIELD_SELF_COMPARISON">
		</artifact>
		<shortMessage>
			Self comparison of field with itself
		</shortMessage>
		<info>

			&lt;p&gt; This method compares a field with itself, and may
			indicate a typo or a logic error. Make sure that you are
			comparing the right things. &lt;/p&gt;

		</info>
		<name>Field Self Comparison</name>
	</findingType>
	<findingType>
		<id>SA_LOCAL_SELF_COMPARISON</id>
		<artifact tool="FindBugs" mnemonic="SA_LOCAL_SELF_COMPARISON">
		</artifact>
		<shortMessage>
			Self comparison of value with itself
		</shortMessage>
		<info>

			&lt;p&gt; This method compares a local variable with itself,
			and may indicate a typo or a logic error. Make sure that you
			are comparing the right things. &lt;/p&gt;

		</info>
		<name>Local Self Comparison</name>
	</findingType>
	<findingType>
		<id>DMI_LONG_BITS_TO_DOUBLE_INVOKED_ON_INT</id>
		<artifact tool="FindBugs"
			mnemonic="DMI_LONG_BITS_TO_DOUBLE_INVOKED_ON_INT">
		</artifact>
		<shortMessage>
			Double.longBitsToDouble invoked on an int
		</shortMessage>
		<info>

			&lt;p&gt; The Double.longBitsToDouble method is invoked, but
			a 32 bit int value is passed as an argument. This almostly
			certainly is not intended and is unlikely to give the
			intended result. &lt;/p&gt;

		</info>
		<name>Long Bits To Double Invoked On Int</name>
	</findingType>
	<findingType>
		<id>DMI_RANDOM_USED_ONLY_ONCE</id>
		<artifact tool="FindBugs"
			mnemonic="DMI_RANDOM_USED_ONLY_ONCE">
		</artifact>
		<shortMessage>
			Random object created and used only once
		</shortMessage>
		<info>

			&lt;p&gt; This code creates a java.util.Random object, uses
			it to generate one random number, and then discards the
			Random object. This produces mediocre quality random numbers
			and is inefficient. If possible, rewrite the code so that
			the Random object is created once and saved, and each time a
			new random number is required invoke a method on the
			existing Random object to obtain it. &lt;/p&gt;

			&lt;p&gt;If it is important that the generated Random
			numbers not be guessable, you &lt;em&gt;must&lt;/em&gt; not
			create a new Random for each random number; the values are
			too easily guessable. You should strongly consider using a
			java.security.SecureRandom instead (and avoid allocating a
			new SecureRandom for each random number needed). &lt;/p&gt;

		</info>
		<name>Random Used Only Once</name>
	</findingType>
	<findingType>
		<id>RV_ABSOLUTE_VALUE_OF_RANDOM_INT</id>
		<artifact tool="FindBugs"
			mnemonic="RV_ABSOLUTE_VALUE_OF_RANDOM_INT">
		</artifact>
		<shortMessage>
			Bad attempt to compute absolute value of signed 32-bit
			random integer
		</shortMessage>
		<info>

			&lt;p&gt; This code generates a random signed integer and
			then computes the absolute value of that random integer. If
			the number returned by the random number generator is
			&lt;code&gt;Integer.MIN_VALUE&lt;/code&gt;, then the result
			will be negative as well (since
			&lt;code&gt;Math.abs(Integer.MIN_VALUE) ==
			Integer.MIN_VALUE&lt;/code&gt;). &lt;/p&gt;

		</info>
		<name>Absolute Value Of Random Int</name>
	</findingType>
	<findingType>
		<id>RV_ABSOLUTE_VALUE_OF_HASHCODE</id>
		<artifact tool="FindBugs"
			mnemonic="RV_ABSOLUTE_VALUE_OF_HASHCODE">
		</artifact>
		<shortMessage>
			Bad attempt to compute absolute value of signed 32-bit
			hashcode
		</shortMessage>
		<info>

			&lt;p&gt; This code generates a hashcode and then computes
			the absolute value of that hashcode. If the hashcode is
			&lt;code&gt;Integer.MIN_VALUE&lt;/code&gt;, then the result
			will be negative as well (since
			&lt;code&gt;Math.abs(Integer.MIN_VALUE) ==
			Integer.MIN_VALUE&lt;/code&gt;). &lt;/p&gt;

		</info>
		<name>Absolute Value Of Hashcode</name>
	</findingType>
	<findingType>
		<id>RV_REM_OF_RANDOM_INT</id>
		<artifact tool="FindBugs" mnemonic="RV_REM_OF_RANDOM_INT">
		</artifact>
		<shortMessage>
			Remainder of 32-bit signed random integer
		</shortMessage>
		<info>

			&lt;p&gt; This code generates a random signed integer and
			then computes the remainder of that value modulo another
			value. Since the random number can be negative, the result
			of the remainder operation can also be negative. Be sure
			this is intended, and strongly consider using the
			Random.nextInt(int) method instead. &lt;/p&gt;

		</info>
		<name>Rem Of Random Int</name>
	</findingType>
	<findingType>
		<id>RV_REM_OF_HASHCODE</id>
		<artifact tool="FindBugs" mnemonic="RV_REM_OF_HASHCODE">
		</artifact>
		<shortMessage>
			Remainder of hashCode could be negative
		</shortMessage>
		<info>

			&lt;p&gt; This code computes a hashCode, and then computes
			the remainder of that value modulo another value. Since the
			hashCode can be negative, the result of the remainder
			operation can also be negative. &lt;/p&gt; &lt;p&gt;
			Assuming you want to ensure that the result of your
			computation is nonnegative, you may need to change your
			code. If you know the divisor is a power of 2, you can use a
			bitwise and operator instead (i.e., instead of using
			&lt;code&gt;x.hashCode()%n&lt;/code&gt;, use
			&lt;code&gt;x.hashCode()&amp;amp;(n-1)&lt;/code&gt;. This is
			probably faster than computing the remainder as well. If you
			don't know that the divisor is a power of 2, take the
			absolute value of the result of the remainder operation
			(i.e., use &lt;code&gt;Math.abs(x.hashCode()%n)&lt;/code&gt;
			&lt;/p&gt;

		</info>
		<name>Rem Of Hashcode</name>
	</findingType>
	<findingType>
		<id>INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE</id>
		<artifact tool="FindBugs"
			mnemonic="INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE">
		</artifact>
		<shortMessage>
			Bad comparison of nonnegative value with negative constant
		</shortMessage>
		<info>

			&lt;p&gt; This code compares a value that is guaranteed to
			be non-negative with a negative constant. &lt;/p&gt;

		</info>
		<name>Bad Comparison With Nonnegative Value</name>
	</findingType>
	<findingType>
		<id>INT_BAD_COMPARISON_WITH_SIGNED_BYTE</id>
		<artifact tool="FindBugs"
			mnemonic="INT_BAD_COMPARISON_WITH_SIGNED_BYTE">
		</artifact>
		<shortMessage>Bad comparison of signed byte</shortMessage>
		<info>

			&lt;p&gt; Signed bytes can only have a value in the range
			-128 to 127. Comparing a signed byte with a value outside
			that range is vacuous and likely to be incorrect. To convert
			a signed byte &lt;code&gt;b&lt;/code&gt; to an unsigned
			value in the range 0..255, use &lt;code&gt;0xff &amp;
			b&lt;/code&gt; &lt;/p&gt;

		</info>
		<name>Bad Comparison With Signed Byte</name>
	</findingType>
	<findingType>
		<id>INT_VACUOUS_COMPARISON</id>
		<artifact tool="FindBugs" mnemonic="INT_VACUOUS_COMPARISON">
		</artifact>
		<shortMessage>Vacuous comparison of integer value</shortMessage>
		<info>

			&lt;p&gt; There is an integer comparison that always returns
			the same value (e.g., x &lt;= Integer.MAX_VALUE). &lt;/p&gt;

		</info>
		<name>Vacuous Comparison</name>
	</findingType>
	<findingType>
		<id>INT_BAD_REM_BY_1</id>
		<artifact tool="FindBugs" mnemonic="INT_BAD_REM_BY_1">
		</artifact>
		<shortMessage>Integer remainder modulo 1</shortMessage>
		<info>

			&lt;p&gt; Any expression (exp % 1) is guaranteed to always
			return zero. Did you mean (exp &amp; 1) or (exp % 2)
			instead? &lt;/p&gt;

		</info>
		<name>Bad Rem By 1</name>
	</findingType>
	<findingType>
		<id>BIT_IOR_OF_SIGNED_BYTE</id>
		<artifact tool="FindBugs" mnemonic="BIT_IOR_OF_SIGNED_BYTE">
		</artifact>
		<shortMessage>Bitwise OR of signed byte value</shortMessage>
		<info>

			&lt;p&gt; Loads a value from a byte array and performs a
			bitwise OR with that value. Values loaded from a byte array
			are sign extended to 32 bits before any any bitwise
			operations are performed on the value. Thus, if
			&lt;code&gt;b[0]&lt;/code&gt; contains the value
			&lt;code&gt;0xff&lt;/code&gt;, and
			&lt;code&gt;x&lt;/code&gt; is initially 0, then the code
			&lt;code&gt;((x &lt;&lt; 8) | b[0])&lt;/code&gt; will sign
			extend &lt;code&gt;0xff&lt;/code&gt; to get
			&lt;code&gt;0xffffffff&lt;/code&gt;, and thus give the value
			&lt;code&gt;0xffffffff&lt;/code&gt; as the result.
			&lt;/p&gt;

			&lt;p&gt;In particular, the following code for packing a
			byte array into an int is badly wrong: &lt;/p&gt;
			&lt;code&gt; int result = 0; for(int i = 0; i &lt; 4; i++)
			result = ((result &lt;&lt; 8) | b[i]); &lt;/code&gt;

			&lt;p&gt;The following idiom will work instead: &lt;/p&gt;
			&lt;code&gt; int result = 0; for(int i = 0; i &lt; 4; i++)
			result = ((result &lt;&lt; 8) | (b[i] &amp;amps; 0xff));
			&lt;/code&gt;


		</info>
		<name>Bitwise OR Of Signed Byte</name>
	</findingType>
	<findingType>
		<id>BIT_AND</id>
		<artifact tool="FindBugs" mnemonic="BIT_AND"></artifact>
		<shortMessage>Incompatible bit masks</shortMessage>
		<info>

			&lt;p&gt; This method compares an expression of the form (a
			&amp;amp; C) to D, which will always compare unequal due to
			the specific values of constants C and D. This may indicate
			a logic error or typo.&lt;/p&gt;

		</info>
		<name>Incompatible Bit Masks And</name>
	</findingType>
	<findingType>
		<id>BIT_AND_ZZ</id>
		<artifact tool="FindBugs" mnemonic="BIT_AND_ZZ"></artifact>
		<shortMessage>
			Check to see if ((...) &amp; 0) == 0
		</shortMessage>
		<info>

			&lt;p&gt; This method compares an expression of the form (a
			&amp;amp; 0) to 0, which will always compare equal. This may
			indicate a logic error or typo.&lt;/p&gt;

		</info>
		<name>Incompatible Bit Masks And Zero</name>
	</findingType>
	<findingType>
		<id>BIT_IOR</id>
		<artifact tool="FindBugs" mnemonic="BIT_IOR"></artifact>
		<shortMessage>Incompatible bit masks</shortMessage>
		<info>

			&lt;p&gt; This method compares an expression of the form (a
			| C) to D. which will always compare unequal due to the
			specific values of constants C and D. This may indicate a
			logic error or typo.&lt;/p&gt;

			&lt;p&gt; Typically, this bug occurs because the code wants
			to perform a membership test in a bit set, but uses the
			bitwise OR operator (&quot;|&quot;) instead of bitwise AND
			(&quot;&amp;amp;&quot;).&lt;/p&gt;

		</info>
		<name>Incompatible Bit Masks OR</name>
	</findingType>
	<findingType>
		<id>IncorrectLazyInitializationOfInstance</id>
		<artifact tool="FindBugs" mnemonic="LI_LAZY_INIT_INSTANCE">
		</artifact>
		<shortMessage>
			Incorrect lazy initialization of instance field
		</shortMessage>
		<info>

			&lt;p&gt; This method contains an unsynchronized lazy
			initialization of a non-volatile field. Because the compiler
			or processor may reorder instructions, threads are not
			guaranteed to see a completely initialized object,
			&lt;em&gt;if the method can be called by multiple
			threads&lt;/em&gt;. You can make the field volatile to
			correct the problem. For more information, see the &lt;a
			href=&quot;http://www.cs.umd.edu/~pugh/java/memoryModel/&quot;&gt;Java
			Memory Model web site&lt;/a&gt;. &lt;/p&gt;

		</info>
		<name>Lazy Init Instance</name>
	</findingType>
	<findingType>
		<id>IncorrectLazyInitializationOfStatic</id>
		<artifact tool="FindBugs" mnemonic="LI_LAZY_INIT_STATIC">
		</artifact>
		<shortMessage>
			Incorrect lazy initialization of static field
		</shortMessage>
		<info>

			&lt;p&gt; This method contains an unsynchronized lazy
			initialization of a non-volatile static field. Because the
			compiler or processor may reorder instructions, threads are
			not guaranteed to see a completely initialized object,
			&lt;em&gt;if the method can be called by multiple
			threads&lt;/em&gt;. You can make the field volatile to
			correct the problem. For more information, see the &lt;a
			href=&quot;http://www.cs.umd.edu/~pugh/java/memoryModel/&quot;&gt;Java
			Memory Model web site&lt;/a&gt;. &lt;/p&gt;

		</info>
		<name>Incorrect Lazy Initialization of Static Field</name>
	</findingType>
	<findingType>
		<id>AvoidCallingSynchronizedOnLock</id>
		<artifact tool="FindBugs"
			mnemonic="JLM_JSR166_LOCK_MONITORENTER">
		</artifact>
		<shortMessage>
			Synchronization performed on java.util.concurrent Lock
		</shortMessage>
		<info>

			&lt;p&gt; This method performs synchronization on an
			implementation of
			&lt;code&gt;java.util.concurrent.locks.Lock&lt;/code&gt;.
			You should use the &lt;code&gt;lock()&lt;/code&gt; and
			&lt;code&gt;unlock()&lt;/code&gt; methods instead.
			&lt;/p&gt;

		</info>
		<name>JSR166 Lock Monitor Enter</name>
	</findingType>
	<findingType>
		<id>UPM_UNCALLED_PRIVATE_METHOD</id>
		<artifact tool="FindBugs"
			mnemonic="UPM_UNCALLED_PRIVATE_METHOD">
		</artifact>
		<shortMessage>Private method is never called</shortMessage>
		<info>

			&lt;p&gt; This private method is never called. Although it
			is possible that the method will be invoked through
			reflection, it is more likely that the method is never used,
			and should be removed. &lt;/p&gt;

		</info>
		<name>Uncalled Private Method</name>
	</findingType>
	<findingType>
		<id>UMAC_UNCALLABLE_METHOD_OF_ANONYMOUS_CLASS</id>
		<artifact tool="FindBugs"
			mnemonic="UMAC_UNCALLABLE_METHOD_OF_ANONYMOUS_CLASS">
		</artifact>
		<shortMessage>
			Uncallable method defined in anonymous class
		</shortMessage>
		<info>

			&lt;p&gt; This anonymous class defined a method that is not
			directly invoked and does not override a method in a
			superclass. Since methods in other classes cannot directly
			invoke methods declared in an anonymous class, it seems that
			this method is uncallable. The method might simply be dead
			code, but it is also possible that the method is intended to
			override a method declared in a superclass, and due to an
			typo or other error the method does not, in fact, override
			the method it is intended to. &lt;/p&gt;

		</info>
		<name>Uncallable Method Of Anonymous Class</name>
	</findingType>
	<findingType>
		<id>ODR_OPEN_DATABASE_RESOURCE</id>
		<artifact tool="FindBugs"
			mnemonic="ODR_OPEN_DATABASE_RESOURCE">
		</artifact>
		<shortMessage>
			Method may fail to close database resource
		</shortMessage>
		<info>

			&lt;p&gt; The method creates a database resource (such as a
			database connection or row set), does not assign it to any
			fields, pass it to other methods, or return it, and does not
			appear to close the object on all paths out of the
			method.&amp;nbsp; Failure to close database resources on all
			paths out of a method may result in poor performance, and
			could cause the application to have problems communicating
			with the database. &lt;/p&gt;

		</info>
		<name>Open Database Resource</name>
	</findingType>
	<findingType>
		<id>ODR_OPEN_DATABASE_RESOURCE_EXCEPTION_PATH</id>
		<artifact tool="FindBugs"
			mnemonic="ODR_OPEN_DATABASE_RESOURCE_EXCEPTION_PATH">
		</artifact>
		<shortMessage>
			Method may fail to close database resource on exception
		</shortMessage>
		<info>

			&lt;p&gt; The method creates a database resource (such as a
			database connection or row set), does not assign it to any
			fields, pass it to other methods, or return it, and does not
			appear to close the object on all exception paths out of the
			method.&amp;nbsp; Failure to close database resources on all
			paths out of a method may result in poor performance, and
			could cause the application to have problems communicating
			with the database.&lt;/p&gt;

		</info>
		<name>Open Database Resource Exception Path</name>
	</findingType>
	<findingType>
		<id>UseStringBufferForStringAppends</id>
		<artifact tool="FindBugs"
			mnemonic="SBSC_USE_STRINGBUFFER_CONCATENATION">
		</artifact>
		<artifact tool="PMD"
			mnemonic="UseStringBufferForStringAppends">
		</artifact>
		<shortMessage>
			Method concatenates strings using + in a loop
		</shortMessage>
		<info>

			&lt;p&gt; The method seems to be building a String using
			concatenation in a loop. In each iteration, the String is
			converted to a StringBuffer/StringBuilder, appended to, and
			converted back to a String. This can lead to a cost
			quadratic in the number of iterations, as the growing string
			is recopied in each iteration. &lt;/p&gt;

			&lt;p&gt;Better performance can be obtained by using a
			StringBuffer (or StringBuilder in Java 1.5)
			explicitly.&lt;/p&gt;

			&lt;p&gt; For example:&lt;/p&gt; &lt;pre&gt; // This is bad
			String s = &quot;&quot;; for (int i = 0; i &amp;lt;
			field.length; ++i) { s = s + field[i]; }

			// This is better StringBuffer buf = new StringBuffer(); for
			(int i = 0; i &amp;lt; field.length; ++i) {
			buf.append(field[i]); } String s = buf.toString();
			&lt;/pre&gt;

			Avoid using += for appending strings. Use StringBuffer
			instead.

		</info>
		<name>Use StringBuffer For String Appends</name>
	</findingType>
	<findingType>
		<id>ITA_INEFFICIENT_TO_ARRAY</id>
		<artifact tool="FindBugs" mnemonic="ITA_INEFFICIENT_TO_ARRAY">
		</artifact>
		<shortMessage>
			Method uses toArray() with zero-length array argument
		</shortMessage>
		<info>

			&lt;p&gt; This method uses the toArray() method of a
			collection derived class, and passes in a zero-length
			prototype array argument. It is more efficient to use
			&lt;code&gt;myCollection.toArray(new
			Foo[myCollection.size()])&lt;/code&gt; If the array passed
			in is big enough to store all of the elements of the
			collection, then it is populated and returned directly. This
			avoids the need to create a second array (by reflection) to
			return as the result.&lt;/p&gt;

		</info>
		<name>Inefficient To Array</name>
	</findingType>
	<findingType>
		<id>IJU_ASSERT_METHOD_INVOKED_FROM_RUN_METHOD</id>
		<artifact tool="FindBugs"
			mnemonic="IJU_ASSERT_METHOD_INVOKED_FROM_RUN_METHOD">
		</artifact>
		<shortMessage>
			JUnit assertion in run method will not be noticed by JUnit
		</shortMessage>
		<info>

			&lt;p&gt; A JUnit assertion is performed in a run method.
			Failed JUnit assertions just result in exceptions being
			thrown. Thus, if this exception occurs in a thread other
			than the thread that invokes the test method, the exception
			will terminate the thread but not result in the test
			failing. &lt;/p&gt;

		</info>
		<name>Assert Method Invoked From Run Method</name>
	</findingType>
	<findingType>
		<id>IJU_SETUP_NO_SUPER</id>
		<artifact tool="FindBugs" mnemonic="IJU_SETUP_NO_SUPER">
		</artifact>
		<shortMessage>
			TestCase implements setUp but doesn't call super.setUp()
		</shortMessage>
		<info>

			&lt;p&gt; Class is a JUnit TestCase and implements the setUp
			method. The setUp method should call super.setUp(), but
			doesn't.&lt;/p&gt;

		</info>
		<name>Setup No Super</name>
	</findingType>
	<findingType>
		<id>IJU_TEARDOWN_NO_SUPER</id>
		<artifact tool="FindBugs" mnemonic="IJU_TEARDOWN_NO_SUPER">
		</artifact>
		<shortMessage>
			TestCase implements tearDown but doesn't call
			super.tearDown()
		</shortMessage>
		<info>

			&lt;p&gt; Class is a JUnit TestCase and implements the
			tearDown method. The tearDown method should call
			super.tearDown(), but doesn't.&lt;/p&gt;

		</info>
		<name>Teardown No Super</name>
	</findingType>
	<findingType>
		<id>IJU_SUITE_NOT_STATIC</id>
		<artifact tool="FindBugs" mnemonic="IJU_SUITE_NOT_STATIC">
		</artifact>
		<shortMessage>
			TestCase implements a non-static suite method
		</shortMessage>
		<info>

			&lt;p&gt; Class is a JUnit TestCase and implements the
			suite() method. The suite method should be declared as being
			static, but isn't.&lt;/p&gt;

		</info>
		<name>Suite Not Static</name>
	</findingType>
	<findingType>
		<id>IJU_BAD_SUITE_METHOD</id>
		<artifact tool="FindBugs" mnemonic="IJU_BAD_SUITE_METHOD">
		</artifact>
		<shortMessage>
			TestCase declares a bad suite method
		</shortMessage>
		<info>

			&lt;p&gt; Class is a JUnit TestCase and defines a suite()
			method. However, the suite method needs to be declared as
			either &lt;pre&gt;public static junit.framework.Test
			suite()&lt;/pre&gt; or &lt;pre&gt;public static
			junit.framework.TestSuite suite()&lt;/pre&gt; &lt;/p&gt;

		</info>
		<name>Bad Suite Method</name>
	</findingType>
	<findingType>
		<id>IJU_NO_TESTS</id>
		<artifact tool="FindBugs" mnemonic="IJU_NO_TESTS"></artifact>
		<shortMessage>TestCase has no tests</shortMessage>
		<info>

			&lt;p&gt; Class is a JUnit TestCase but has not implemented
			any test methods&lt;/p&gt;

		</info>
		<name>No Tests</name>
	</findingType>
	<findingType>
		<id>BOA_BADLY_OVERRIDDEN_ADAPTER</id>
		<artifact tool="FindBugs"
			mnemonic="BOA_BADLY_OVERRIDDEN_ADAPTER">
		</artifact>
		<shortMessage>
			Class overrides a method implemented in super class Adapter
			wrongly
		</shortMessage>
		<info>

			&lt;p&gt; This method overrides a method found in a parent
			class, where that class is an Adapter that implements a
			listener defined in the java.awt.event or javax.swing.event
			package. As a result, this method will not get called when
			the event occurs.&lt;/p&gt;

		</info>
		<name>Badly Overridden Adapter</name>
	</findingType>
	<findingType>
		<id>BRSA_BAD_RESULTSET_ACCESS</id>
		<artifact tool="FindBugs"
			mnemonic="BRSA_BAD_RESULTSET_ACCESS">
		</artifact>
		<shortMessage>
			Method attempts to access a result set field with index 0
		</shortMessage>
		<info>

			&lt;p&gt; A call to getXXX or updateXXX methods of a result
			set was made where the field index is 0. As ResultSet fields
			start at index 1, this is always a mistake.&lt;/p&gt;

		</info>
		<name>Bad Resultset Access</name>
	</findingType>
	<findingType>
		<id>SQL_BAD_RESULTSET_ACCESS</id>
		<artifact tool="FindBugs" mnemonic="SQL_BAD_RESULTSET_ACCESS">
		</artifact>
		<shortMessage>
			Method attempts to access a result set field with index 0
		</shortMessage>
		<info>

			&lt;p&gt; A call to getXXX or updateXXX methods of a result
			set was made where the field index is 0. As ResultSet fields
			start at index 1, this is always a mistake.&lt;/p&gt;

		</info>
		<name>Bad Resultset Access</name>
	</findingType>
	<findingType>
		<id>SQL_BAD_PREPARED_STATEMENT_ACCESS</id>
		<artifact tool="FindBugs"
			mnemonic="SQL_BAD_PREPARED_STATEMENT_ACCESS">
		</artifact>
		<shortMessage>
			Method attempts to access a prepared statement parameter
			with index 0
		</shortMessage>
		<info>

			&lt;p&gt; A call to a setXXX method of a prepared statement
			was made where the parameter index is 0. As parameter
			indexes start at index 1, this is always a
			mistake.&lt;/p&gt;

		</info>
		<name>Bad Prepared Statement Access</name>
	</findingType>
	<findingType>
		<id>SIO_SUPERFLUOUS_INSTANCEOF</id>
		<artifact tool="FindBugs"
			mnemonic="SIO_SUPERFLUOUS_INSTANCEOF">
		</artifact>
		<shortMessage>
			Unnecessary type check done using instanceof operator
		</shortMessage>
		<info>

			&lt;p&gt; Type check performed using the instanceof operator
			where it can be statically determined whether the object is
			of the type requested. &lt;/p&gt;

		</info>
		<name>Superfluous instanceof</name>
	</findingType>
	<findingType>
		<id>BAC_BAD_APPLET_CONSTRUCTOR</id>
		<artifact tool="FindBugs"
			mnemonic="BAC_BAD_APPLET_CONSTRUCTOR">
		</artifact>
		<shortMessage>
			Bad Applet Constructor relies on uninitialized AppletStub
		</shortMessage>
		<info>

			&lt;p&gt; This constructor calls methods in the parent
			Applet that rely on the AppletStub. Since the AppletStub
			isn't initialized until the init() method of this applet is
			called, these methods will not perform correctly. &lt;/p&gt;

		</info>
		<name>Bad Applet Constructor</name>
	</findingType>
	<findingType>
		<id>EC_ARRAY_AND_NONARRAY</id>
		<artifact tool="FindBugs" mnemonic="EC_ARRAY_AND_NONARRAY">
		</artifact>
		<shortMessage>
			equals() used to compare array and nonarray
		</shortMessage>
		<info>

			&lt;p&gt; This method invokes the .equals(Object o) to
			compare an array and a reference that doesn't seem to be an
			array. If things being compared are of different types, they
			are guaranteed to be unequal and the comparison is almost
			certainly an error. Even if they are both arrays, the equals
			method on arrays only determines of the two arrays are the
			same object. To compare the contents of the arrays, use
			java.util.Arrays.equals(Object[], Object[]). &lt;/p&gt;

		</info>
		<name>Array And Nonarray</name>
	</findingType>
	<findingType>
		<id>EC_BAD_ARRAY_COMPARE</id>
		<artifact tool="FindBugs" mnemonic="EC_BAD_ARRAY_COMPARE">
		</artifact>
		<shortMessage>
			Invocation of equals() on an array, which is equivalent to
			==
		</shortMessage>
		<info>

			&lt;p&gt; This method invokes the .equals(Object o) method
			on an array. Since arrays do not override the equals method
			of Object, calling equals on an array is the same as
			comparing their addresses. To compare the contents of the
			arrays, use java.util.Arrays.equals(Object[], Object[]).
			&lt;/p&gt;

		</info>
		<name>Bad Array Compare</name>
	</findingType>
	<findingType>
		<id>UOE_USE_OBJECT_EQUALS</id>
		<artifact tool="FindBugs" mnemonic="UOE_USE_OBJECT_EQUALS">
		</artifact>
		<shortMessage>
			Calls to equals on a final class that doesn't override
			Object's version
		</shortMessage>
		<info>

			&lt;p&gt; This method invokes the .equals(Object o) method
			on a final class that doesn't override the equals method in
			the Object class, effectively making the equals method test
			for sameness, like ==. It is good to use the .equals method,
			but you should consider adding an .equals method in this
			class. &lt;/p&gt; &lt;p&gt;[Bill Pugh]: Sorry, but I
			strongly disagree that this should be a warning, and I think
			your code is just fine. Users of your code shouldn't care
			how you've implemented equals(), and they should never
			depend on == to compare instances, since that bypasses the
			libraries ability to control how objects are compared.
			&lt;/p&gt;

		</info>
		<name>Use Object Equals</name>
	</findingType>
	<findingType>
		<id>STI_INTERRUPTED_ON_CURRENTTHREAD</id>
		<artifact tool="FindBugs"
			mnemonic="STI_INTERRUPTED_ON_CURRENTTHREAD">
		</artifact>
		<shortMessage>
			Unneeded use of currentThread() call, to call interrupted()
		</shortMessage>
		<info>

			&lt;p&gt; This method invokes the Thread.currentThread()
			call, just to call the interrupted() method. As
			interrupted() is a static method, is more simple and clear
			to use Thread.interrupted(). &lt;/p&gt;

		</info>
		<name>Interrupted On Currentthread</name>
	</findingType>
	<findingType>
		<id>STI_INTERRUPTED_ON_UNKNOWNTHREAD</id>
		<artifact tool="FindBugs"
			mnemonic="STI_INTERRUPTED_ON_UNKNOWNTHREAD">
		</artifact>
		<shortMessage>
			Static Thread.interrupted() method invoked on thread
			instance
		</shortMessage>
		<info>

			&lt;p&gt; This method invokes the Thread.interrupted()
			method on a Thread object that appears to be a Thread object
			that is not the current thread. As the interrupted() method
			is static, the interrupted method will be called on a
			different object than the one the author intended.
			&lt;/p&gt;

		</info>
		<name>Interrupted On Unknown Thread</name>
	</findingType>
	<findingType>
		<id>IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN</id>
		<artifact tool="FindBugs"
			mnemonic="IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN">
		</artifact>
		<shortMessage>
			A parameter is dead upon entry to a method but overwritten
		</shortMessage>
		<info>

			&lt;p&gt; The initial value of this parameter is ignored,
			and the parameter is overwritten here. This often indicates
			a mistaken belief that the write to the parameter will be
			conveyed back to the caller. &lt;/p&gt;

		</info>
		<name>Parameter Is Dead But Overwritten</name>
	</findingType>
	<findingType>
		<id>DLS_DEAD_LOCAL_STORE</id>
		<artifact tool="FindBugs" mnemonic="DLS_DEAD_LOCAL_STORE">
		</artifact>
		<shortMessage>Dead store to local variable</shortMessage>
		<info>

			&lt;p&gt; This instruction assigns a value to a local
			variable, but the value is not read by any subsequent
			instruction. Often, this indicates an error, because the
			value computed is never used. &lt;/p&gt; &lt;p&gt; Note that
			Sun's javac compiler often generates dead stores for final
			local variables. Because FindBugs is a bytecode-based tool,
			there is no easy way to eliminate these false positives.
			&lt;/p&gt;

		</info>
		<name>Dead Local Store</name>
	</findingType>
	<findingType>
		<id>DLS_DEAD_LOCAL_STORE_OF_NULL</id>
		<artifact tool="FindBugs"
			mnemonic="DLS_DEAD_LOCAL_STORE_OF_NULL">
		</artifact>
		<shortMessage>
			Dead store of null to local variable
		</shortMessage>
		<info>

			&lt;p&gt;The code stores null into a local variable, and
			stored value is not read. This store may have been
			introduced in assist the garbage collector, but as of Java
			SE 6.0, this is no longer needed or useful. &lt;/p&gt;

		</info>
		<name>Dead Local Store Of Null</name>
	</findingType>
	<findingType>
		<id>MF_METHOD_MASKS_FIELD</id>
		<artifact tool="FindBugs" mnemonic="MF_METHOD_MASKS_FIELD">
		</artifact>
		<shortMessage>
			Method defines a variable that obscures a field
		</shortMessage>
		<info>

			&lt;p&gt; This method defines a local variable with the same
			name as a field in this class or a superclass. This may
			cause the method to read an uninitialized value from the
			field, leave the field uninitialized, or both.&lt;/p&gt;

		</info>
		<name>Method Masks Field</name>
	</findingType>
	<findingType>
		<id>MF_CLASS_MASKS_FIELD</id>
		<artifact tool="FindBugs" mnemonic="MF_CLASS_MASKS_FIELD">
		</artifact>
		<shortMessage>
			Class defines field that masks a superclass field
		</shortMessage>
		<info>

			&lt;p&gt; This class defines a field with the same name as a
			visible instance field in a superclass. This is confusing,
			and may indicate an error if methods update or access one of
			the fields when they wanted the other.&lt;/p&gt;

		</info>
		<name>Class Masks Field</name>
	</findingType>
	<findingType>
		<id>WMI_WRONG_MAP_ITERATOR</id>
		<artifact tool="FindBugs" mnemonic="WMI_WRONG_MAP_ITERATOR">
		</artifact>
		<shortMessage>
			Inefficient use of keySet iterator instead of entrySet
			iterator
		</shortMessage>
		<info>

			&lt;p&gt; This method accesses the value of a Map entry,
			using a key that was retrieved from a keySet iterator. It is
			more efficient to use an iterator on the entrySet of the
			map, to avoid the Map.get(key) lookup.&lt;/p&gt;

		</info>
		<name>Wrong Map Iterator</name>
	</findingType>
	<findingType>
		<id>ISC_INSTANTIATE_STATIC_CLASS</id>
		<artifact tool="FindBugs"
			mnemonic="ISC_INSTANTIATE_STATIC_CLASS">
		</artifact>
		<shortMessage>
			Needless instantiation of class that only supplies static
			methods
		</shortMessage>
		<info>

			&lt;p&gt; This class allocates an object that is based on a
			class that only supplies static methods. This object does
			not need to be created, just access the static methods
			directly using the class name as a qualifier.&lt;/p&gt;

		</info>
		<name>Instantiate Static Class</name>
	</findingType>
	<findingType>
		<id>REC_CATCH_EXCEPTION</id>
		<artifact tool="FindBugs" mnemonic="REC_CATCH_EXCEPTION">
		</artifact>
		<shortMessage>
			Exception is caught when Exception is not thrown
		</shortMessage>
		<info>

			&lt;p&gt; This method uses a try-catch block that catches
			Exception objects, but Exception is not thrown within the
			try block, and RuntimeException is not explicitly caught. It
			is a common bug pattern to say try { ... } catch (Exception
			e) { something } as a shorthand for catching a number of
			types of exception each of whose catch blocks is identical,
			but this construct also accidentally catches
			RuntimeException as well, masking potential bugs. &lt;/p&gt;

		</info>
		<name>Catch Exception</name>
	</findingType>
	<findingType>
		<id>FE_TEST_IF_EQUAL_TO_NOT_A_NUMBER</id>
		<artifact tool="FindBugs"
			mnemonic="FE_TEST_IF_EQUAL_TO_NOT_A_NUMBER">
		</artifact>
		<shortMessage>Doomed test for equality to NaN</shortMessage>
		<info>

			&lt;p&gt; This code checks to see if a floating point value
			is equal to the special Not A Number value (e.g.,
			&lt;code&gt;if (x == Double.NaN)&lt;/code&gt;). However,
			because of the special semantics of
			&lt;code&gt;NaN&lt;/code&gt;, no value is equal to
			&lt;code&gt;Nan&lt;/code&gt;, including
			&lt;code&gt;NaN&lt;/code&gt;. Thus, &lt;code&gt;x ==
			Double.NaN&lt;/code&gt; always evaluates to false.

			To check to see if a value contained in
			&lt;code&gt;x&lt;/code&gt; is the special Not A Number
			value, use &lt;code&gt;Double.isNaN(x)&lt;/code&gt; (or
			&lt;code&gt;Float.isNaN(x)&lt;/code&gt; if
			&lt;code&gt;x&lt;/code&gt; is floating point precision).
			&lt;/p&gt;

		</info>
		<name>Test If Equal To Not A Number</name>
	</findingType>
	<findingType>
		<id>FE_FLOATING_POINT_EQUALITY</id>
		<artifact tool="FindBugs"
			mnemonic="FE_FLOATING_POINT_EQUALITY">
		</artifact>
		<shortMessage>Test for floating point equality</shortMessage>
		<info>

			&lt;p&gt; This operation compares two floating point values
			for equality. Because floating point calculations may
			involve rounding, calculated float and double values may not
			be accurate. For values that must be precise, such as
			monetary values, consider using a fixed-precision type such
			as BigDecimal. For values that need not be precise, consider
			comparing for equality within some range, for example:
			&lt;code&gt;if ( Math.abs(x - y) &amp;lt; .0000001
			)&lt;/code&gt;. See the Java Language Specification, section
			4.2.4. &lt;/p&gt;

		</info>
		<name>Floating Point Equality</name>
	</findingType>
	<findingType>
		<id>UM_UNNECESSARY_MATH</id>
		<artifact tool="FindBugs" mnemonic="UM_UNNECESSARY_MATH">
		</artifact>
		<shortMessage>
			Method calls static Math class method on a constant value
		</shortMessage>
		<info>

			&lt;p&gt; This method uses a static method from
			java.lang.Math on a constant value. This method's result in
			this case, can be determined statically, and is faster and
			sometimes more accurate to just use the constant. Methods
			detected are: &lt;/p&gt; &lt;table&gt; &lt;tr&gt;
			&lt;th&gt;Method&lt;/th&gt; &lt;th&gt;Parameter&lt;/th&gt;
			&lt;/tr&gt; &lt;tr&gt; &lt;td&gt;abs&lt;/td&gt;
			&lt;td&gt;-any-&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;
			&lt;td&gt;acos&lt;/td&gt; &lt;td&gt;0.0 or 1.0&lt;/td&gt;
			&lt;/tr&gt; &lt;tr&gt; &lt;td&gt;asin&lt;/td&gt;
			&lt;td&gt;0.0 or 1.0&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;
			&lt;td&gt;atan&lt;/td&gt; &lt;td&gt;0.0 or 1.0&lt;/td&gt;
			&lt;/tr&gt; &lt;tr&gt; &lt;td&gt;atan2&lt;/td&gt;
			&lt;td&gt;0.0&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;
			&lt;td&gt;cbrt&lt;/td&gt; &lt;td&gt;0.0 or 1.0&lt;/td&gt;
			&lt;/tr&gt; &lt;tr&gt; &lt;td&gt;ceil&lt;/td&gt;
			&lt;td&gt;-any-&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;
			&lt;td&gt;cos&lt;/td&gt; &lt;td&gt;0.0&lt;/td&gt;
			&lt;/tr&gt; &lt;tr&gt; &lt;td&gt;cosh&lt;/td&gt;
			&lt;td&gt;0.0&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;
			&lt;td&gt;exp&lt;/td&gt; &lt;td&gt;0.0 or 1.0&lt;/td&gt;
			&lt;/tr&gt; &lt;tr&gt; &lt;td&gt;expm1&lt;/td&gt;
			&lt;td&gt;0.0&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;
			&lt;td&gt;floor&lt;/td&gt; &lt;td&gt;-any-&lt;/td&gt;
			&lt;/tr&gt; &lt;tr&gt; &lt;td&gt;log&lt;/td&gt;
			&lt;td&gt;0.0 or 1.0&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;
			&lt;td&gt;log10&lt;/td&gt; &lt;td&gt;0.0 or 1.0&lt;/td&gt;
			&lt;/tr&gt; &lt;tr&gt; &lt;td&gt;rint&lt;/td&gt;
			&lt;td&gt;-any-&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;
			&lt;td&gt;round&lt;/td&gt; &lt;td&gt;-any-&lt;/td&gt;
			&lt;/tr&gt; &lt;tr&gt; &lt;td&gt;sin&lt;/td&gt;
			&lt;td&gt;0.0&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;
			&lt;td&gt;sinh&lt;/td&gt; &lt;td&gt;0.0&lt;/td&gt;
			&lt;/tr&gt; &lt;tr&gt; &lt;td&gt;sqrt&lt;/td&gt;
			&lt;td&gt;0.0 or 1.0&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;
			&lt;td&gt;tan&lt;/td&gt; &lt;td&gt;0.0&lt;/td&gt;
			&lt;/tr&gt; &lt;tr&gt; &lt;td&gt;tanh&lt;/td&gt;
			&lt;td&gt;0.0&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;
			&lt;td&gt;toDegrees&lt;/td&gt; &lt;td&gt;0.0 or
			1.0&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;
			&lt;td&gt;toRadians&lt;/td&gt; &lt;td&gt;0.0&lt;/td&gt;
			&lt;/tr&gt; &lt;/table&gt;

		</info>
		<name>Unnecessary Math</name>
	</findingType>
	<findingType>
		<id>CD_CIRCULAR_DEPENDENCY</id>
		<artifact tool="FindBugs" mnemonic="CD_CIRCULAR_DEPENDENCY">
		</artifact>
		<shortMessage>
			Test for circular dependencies among classes
		</shortMessage>
		<info>

			&lt;p&gt; This class has a circular dependency with other
			classes. This makes building these classes difficult, as
			each is dependent on the other to build correctly. Consider
			using interfaces to break the hard dependency. &lt;/p&gt;

		</info>
		<name>Circular Dependency</name>
	</findingType>
	<findingType>
		<id>RI_REDUNDANT_INTERFACES</id>
		<artifact tool="FindBugs" mnemonic="RI_REDUNDANT_INTERFACES">
		</artifact>
		<shortMessage>
			Class implements same interface as superclass
		</shortMessage>
		<info>

			&lt;p&gt; This class declares that it implements an
			interface that is also implemented by a superclass. This is
			redundant, once a superclass implements an interface, all
			subclasses by default also implement this interface. It may
			point out that the inheritance hierarchy has changed since
			this class was created, and consideration should be taken
			into account for the ownership of the interface's
			implementation. &lt;/p&gt;

		</info>
		<name>Redundant Interfaces</name>
	</findingType>
	<findingType>
		<id>MTIA_SUSPECT_STRUTS_INSTANCE_FIELD</id>
		<artifact tool="FindBugs"
			mnemonic="MTIA_SUSPECT_STRUTS_INSTANCE_FIELD">
		</artifact>
		<shortMessage>
			Class extends Struts Action class and uses instance
			variables
		</shortMessage>
		<info>

			&lt;p&gt; This class extends from a Struts Action class, and
			uses a instance member variable. Since only one instance of
			a struts Action class is created by the Struts framework,
			and used in a multithreaded way, this paradigm is highly
			discouraged and most likely problematic. Consider only using
			method local variables. &lt;/p&gt;

		</info>
		<name>Suspect Struts Instance Field</name>
	</findingType>
	<findingType>
		<id>MTIA_SUSPECT_SERVLET_INSTANCE_FIELD</id>
		<artifact tool="FindBugs"
			mnemonic="MTIA_SUSPECT_SERVLET_INSTANCE_FIELD">
		</artifact>
		<shortMessage>
			Class extends Servlet class and uses instance variables
		</shortMessage>
		<info>

			&lt;p&gt; This class extends from a Servlet class, and uses
			a instance member variable. Since only one instance of a
			Servlet class is created by the J2EE framework, and used in
			a multithreaded way, this paradigm is highly discouraged and
			most likely problematic. Consider only using method local
			variables. &lt;/p&gt;

		</info>
		<name>Suspect Servlet Instance Field</name>
	</findingType>
	<findingType>
		<id>PS_PUBLIC_SEMAPHORES</id>
		<artifact tool="FindBugs" mnemonic="PS_PUBLIC_SEMAPHORES">
		</artifact>
		<shortMessage>
			Class exposes synchronization and semaphores in its public
			interface
		</shortMessage>
		<info>

			&lt;p&gt; This class uses synchronization along with wait(),
			notify() or notifyAll() on itself (the this reference).
			Client classes that use this class, may, in addition, use an
			instance of this class as a synchronizing object. Because
			two classes are using the same object for synchronization,
			Multithread correctness is suspect. You should not
			synchronize nor call semaphore methods on a public
			reference. Consider using a internal private member variable
			to control synchronization. &lt;/p&gt;

		</info>
		<name>Public Semaphores</name>
	</findingType>
	<findingType>
		<id>ICAST_INTEGER_MULTIPLY_CAST_TO_LONG</id>
		<artifact tool="FindBugs"
			mnemonic="ICAST_INTEGER_MULTIPLY_CAST_TO_LONG">
		</artifact>
		<shortMessage>
			Result of integer multiplication cast to long
		</shortMessage>
		<info>

			&lt;p&gt; This code performs integer multiply and then
			converts the result to a long, as in: &lt;code&gt;
			&lt;pre&gt; long convertDaysToMilliseconds(int days) {
			return 1000*3600*24*days; } &lt;/pre&gt;&lt;/code&gt; If the
			multiplication is done using long arithmetic, you can avoid
			the possibility that the result will overflow. For example,
			you could fix the above code to: &lt;code&gt; &lt;pre&gt;
			long convertDaysToMilliseconds(int days) { return
			1000L*3600*24*days; } &lt;/pre&gt;&lt;/code&gt; or
			&lt;code&gt; &lt;pre&gt; static final long
			MILLISECONDS_PER_DAY = 24L*3600*1000; long
			convertDaysToMilliseconds(int days) { return days *
			MILLISECONDS_PER_DAY; } &lt;/pre&gt;&lt;/code&gt; &lt;/p&gt;


		</info>
		<name>Integer Multiply Cast To Long</name>
	</findingType>
	<findingType>
		<id>ICAST_INT_CAST_TO_FLOAT_PASSED_TO_ROUND</id>
		<artifact tool="FindBugs"
			mnemonic="ICAST_INT_CAST_TO_FLOAT_PASSED_TO_ROUND">
		</artifact>
		<shortMessage>
			int value cast to float and then passed to Math.round
		</shortMessage>
		<info>

			&lt;p&gt; This code converts an int value to a float
			precision floating point number and then passing the result
			to the Math.round() function, which returns the int/long
			closest to the argument. This operation should always be a
			no-op, since the converting an integer to a float should
			give a number with no fractional part. It is likely that the
			operation that generated the value to be passed to
			Math.round was intended to be performed using floating point
			arithmetic. &lt;/p&gt;


		</info>
		<name>Int Cast To Float Passed To Round</name>
	</findingType>
	<findingType>
		<id>ICAST_INT_CAST_TO_DOUBLE_PASSED_TO_CEIL</id>
		<artifact tool="FindBugs"
			mnemonic="ICAST_INT_CAST_TO_DOUBLE_PASSED_TO_CEIL">
		</artifact>
		<shortMessage>
			int value cast to double and then passed to Math.ceil
		</shortMessage>
		<info>

			&lt;p&gt; This code converts an int value to a double
			precision floating point number and then passing the result
			to the Math.ceil() function, which rounds a double to the
			next higher integer value. This operation should always be a
			no-op, since the converting an integer to a double should
			give a number with no fractional part. It is likely that the
			operation that generated the value to be passed to Math.ceil
			was intended to be performed using double precision floating
			point arithmetic. &lt;/p&gt;


		</info>
		<name>Int Cast To Double Passed To Math.ceil</name>
	</findingType>
	<findingType>
		<id>ICAST_IDIV_CAST_TO_DOUBLE</id>
		<artifact tool="FindBugs"
			mnemonic="ICAST_IDIV_CAST_TO_DOUBLE">
		</artifact>
		<shortMessage>
			int division result cast to double or float
		</shortMessage>
		<info>

			&lt;p&gt; This code casts the result of an integer division
			operation to double or float. Doing division on integers
			truncates the result to the integer value closest to zero.
			The fact that the result was cast to double suggests that
			this precision should have been retained. What was probably
			meant was to cast one or both of the operands to double
			&lt;em&gt;before&lt;/em&gt; performing the division. Here is
			an example: &lt;/p&gt; &lt;blockquote&gt; &lt;pre&gt; int x
			= 2; int y = 5; // Wrong: yields result 0.0 double value1 =
			x / y;

			// Right: yields result 0.4 double value2 = x / (double) y;
			&lt;/pre&gt; &lt;/blockquote&gt;

		</info>
		<name>Idiv Cast To Double</name>
	</findingType>
	<findingType>
		<id>J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION</id>
		<artifact tool="FindBugs"
			mnemonic="J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION">
		</artifact>
		<shortMessage>
			Store of non serializable object into HttpSession
		</shortMessage>
		<info>

			&lt;p&gt; This code seems to be storing a non-serializable
			object into an HttpSession. If this session is passivated or
			migrated, an error will result. &lt;/p&gt;

		</info>
		<name>Store Of Non Serializable Object Into Session</name>
	</findingType>
	<findingType>
		<id>DMI_NONSERIALIZABLE_OBJECT_WRITTEN</id>
		<artifact tool="FindBugs"
			mnemonic="DMI_NONSERIALIZABLE_OBJECT_WRITTEN">
		</artifact>
		<shortMessage>
			Non serializable object written to ObjectOutput
		</shortMessage>
		<info>

			&lt;p&gt; This code seems to be passing a non-serializable
			object to the ObjectOutput.writeObject method. If the object
			is, indeed, non-serializable, an error will result.
			&lt;/p&gt;

		</info>
		<name>Nonserializable Object Written</name>
	</findingType>
	<findingType>
		<id>VA_PRIMITIVE_ARRAY_PASSED_TO_OBJECT_VARARG</id>
		<artifact tool="FindBugs"
			mnemonic="VA_PRIMITIVE_ARRAY_PASSED_TO_OBJECT_VARARG">
		</artifact>
		<shortMessage>
			Primitive array passed to function expecting a variable
			number of object arguments
		</shortMessage>
		<info>

			&lt;p&gt; This code passes a primitive array to a function
			that takes a variable number of object arguments. This
			creates an array of length one to hold the primitive array
			and passes it to the function. &lt;/p&gt;

		</info>
		<name>Primitive Array Passed To Object Vararg</name>
	</findingType>
	<findingType>
		<id>BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS</id>
		<artifact tool="FindBugs"
			mnemonic="BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS">
		</artifact>
		<shortMessage>
			Equals method should not assume anything about the type of
			its argument
		</shortMessage>
		<info>

			&lt;p&gt; The &lt;code&gt;equals(Object o)&lt;/code&gt;
			method shouldn't make any assumptions about the type of
			&lt;code&gt;o&lt;/code&gt;. It should simply return false if
			&lt;code&gt;o&lt;/code&gt; is not the same type as
			&lt;code&gt;this&lt;/code&gt;. &lt;/p&gt;

		</info>
		<name>Equals Method Should Work For All Objects</name>
	</findingType>
	<findingType>
		<id>BC_BAD_CAST_TO_ABSTRACT_COLLECTION</id>
		<artifact tool="FindBugs"
			mnemonic="BC_BAD_CAST_TO_ABSTRACT_COLLECTION">
		</artifact>
		<shortMessage>
			Questionable cast to abstract collection
		</shortMessage>
		<info>

			&lt;p&gt; This code casts a Collection to an abstract
			collection (such as &lt;code&gt;List&lt;/code&gt;,
			&lt;code&gt;Set&lt;/code&gt;, or
			&lt;code&gt;Map&lt;/code&gt;). Ensure that you are
			guaranteed that the object is of the type you are casting
			to. If all you need is to be able to iterate through a
			collection, you don't need to cast it to a Set or List.
			&lt;/p&gt;

		</info>
		<name>Bad Cast To Abstract Collection</name>
	</findingType>
	<findingType>
		<id>BC_IMPOSSIBLE_CAST_PRIMITIVE_ARRAY</id>
		<artifact tool="FindBugs"
			mnemonic="BC_IMPOSSIBLE_CAST_PRIMITIVE_ARRAY">
		</artifact>
		<shortMessage>
			Impossible cast involving primitive array
		</shortMessage>
		<info>

			&lt;p&gt; This cast will always throw a ClassCastException.
			&lt;/p&gt;

		</info>
		<name>Impossible Cast Primitive Array</name>
	</findingType>
	<findingType>
		<id>BC_IMPOSSIBLE_CAST</id>
		<artifact tool="FindBugs" mnemonic="BC_IMPOSSIBLE_CAST">
		</artifact>
		<shortMessage>Impossible cast</shortMessage>
		<info>

			&lt;p&gt; This cast will always throw a ClassCastException.
			&lt;/p&gt;

		</info>
		<name>Impossible Cast</name>
	</findingType>
	<findingType>
		<id>NP_NULL_INSTANCEOF</id>
		<artifact tool="FindBugs" mnemonic="NP_NULL_INSTANCEOF">
		</artifact>
		<shortMessage>
			A known null value is checked to see if it is an instance of
			a type
		</shortMessage>
		<info>

			&lt;p&gt; This instanceof test will always return false,
			since the value being checked is guaranteed to be null.
			Although this is safe, make sure it isn't an indication of
			some misunderstanding or some other logic error. &lt;/p&gt;

		</info>
		<name>Null instanceof</name>
	</findingType>
	<findingType>
		<id>BC_NULL_INSTANCEOF</id>
		<artifact tool="FindBugs" mnemonic="BC_NULL_INSTANCEOF">
		</artifact>
		<shortMessage>
			A known null value is checked to see if it is an instance of
			a type
		</shortMessage>
		<info>

			&lt;p&gt; This instanceof test will always return false,
			since the value being checked is guaranteed to be null.
			Although this is safe, make sure it isn't an indication of
			some misunderstanding or some other logic error. &lt;/p&gt;

		</info>
		<name>Null instanceof</name>
	</findingType>
	<findingType>
		<id>BC_IMPOSSIBLE_INSTANCEOF</id>
		<artifact tool="FindBugs" mnemonic="BC_IMPOSSIBLE_INSTANCEOF">
		</artifact>
		<shortMessage>instanceof will always return false</shortMessage>
		<info>

			&lt;p&gt; This instanceof test will always return false.
			Although this is safe, make sure it isn't an indication of
			some misunderstanding or some other logic error. &lt;/p&gt;

		</info>
		<name>Impossible instanceof</name>
	</findingType>
	<findingType>
		<id>BC_VACUOUS_INSTANCEOF</id>
		<artifact tool="FindBugs" mnemonic="BC_VACUOUS_INSTANCEOF">
		</artifact>
		<shortMessage>instanceof will always return true</shortMessage>
		<info>

			&lt;p&gt; This instanceof test will always return true.
			Although this is safe, make sure it isn't an indication of
			some misunderstanding or some other logic error. &lt;/p&gt;

		</info>
		<name>Vacuous instanceof</name>
	</findingType>
	<findingType>
		<id>BC_UNCONFIRMED_CAST</id>
		<artifact tool="FindBugs" mnemonic="BC_UNCONFIRMED_CAST">
		</artifact>
		<shortMessage>Unchecked/unconfirmed cast</shortMessage>
		<info>

			&lt;p&gt; This cast is unchecked, and not all instances of
			the type casted from can be cast to the type it is being
			cast to. Ensure that your program logic ensures that this
			cast will not fail. &lt;/p&gt;

		</info>
		<name>Unconfirmed Cast</name>
	</findingType>
	<findingType>
		<id>BC_BAD_CAST_TO_CONCRETE_COLLECTION</id>
		<artifact tool="FindBugs"
			mnemonic="BC_BAD_CAST_TO_CONCRETE_COLLECTION">
		</artifact>
		<shortMessage>
			Questionable cast to concrete collection
		</shortMessage>
		<info>

			&lt;p&gt; This code casts an abstract collection (such as a
			Collection, List, or Set) to a specific concrete
			implementation (such as an ArrayList or HashSet). This might
			not be correct, and it may make your code fragile, since it
			makes it harder to switch to other concrete implementations
			at a future point. Unless you have a particular reason to do
			so, just use the abstract collection class. &lt;/p&gt;

		</info>
		<name>Bad Cast To Concrete Collection</name>
	</findingType>
	<findingType>
		<id>RE_POSSIBLE_UNINTENDED_PATTERN</id>
		<artifact tool="FindBugs"
			mnemonic="RE_POSSIBLE_UNINTENDED_PATTERN">
		</artifact>
		<shortMessage>
			&quot;.&quot; used for regular expression
		</shortMessage>
		<info>

			&lt;p&gt; A String function is being invoked and
			&quot;.&quot; is being passed to a parameter that takes a
			regular expression as an argument. Is this what you
			intended? For example s.replaceAll(&quot;.&quot;,
			&quot;/&quot;) will return a String in which
			&lt;em&gt;every&lt;/em&gt; character has been replaced by a
			/ character. &lt;/p&gt;

		</info>
		<name>Possible Unintended Pattern</name>
	</findingType>
	<findingType>
		<id>RE_BAD_SYNTAX_FOR_REGULAR_EXPRESSION</id>
		<artifact tool="FindBugs"
			mnemonic="RE_BAD_SYNTAX_FOR_REGULAR_EXPRESSION">
		</artifact>
		<shortMessage>
			Invalid syntax for regular expression
		</shortMessage>
		<info>

			&lt;p&gt; The code here uses a regular expression that is
			invalid according to the syntax for regular expressions.
			This statement will throw a PatternSyntaxException when
			executed. &lt;/p&gt;

		</info>
		<name>Bad Syntax For Regular Expression</name>
	</findingType>
	<findingType>
		<id>RE_CANT_USE_FILE_SEPARATOR_AS_REGULAR_EXPRESSION</id>
		<artifact tool="FindBugs"
			mnemonic="RE_CANT_USE_FILE_SEPARATOR_AS_REGULAR_EXPRESSION">
		</artifact>
		<shortMessage>
			File.separator used for regular expression
		</shortMessage>
		<info>

			&lt;p&gt; The code here uses
			&lt;code&gt;File.separator&lt;/code&gt; where a regular
			expression is required. This will fail on Windows platforms,
			where the &lt;code&gt;File.separator&lt;/code&gt; is a
			backslash, which is interpreted in a regular expression as
			an escape character. Amoung other options, you can just use
			&lt;code&gt;File.separatorChar=='\\' &amp;amp;
			&quot;\\\\&quot; : File.separator&lt;/code&gt; instead of
			&lt;code&gt;File.separator&lt;/code&gt;

			&lt;/p&gt;

		</info>
		<name>Cant Use File Separator As Regular Expression</name>
	</findingType>
	<findingType>
		<id>DLS_OVERWRITTEN_INCREMENT</id>
		<artifact tool="FindBugs"
			mnemonic="DLS_OVERWRITTEN_INCREMENT">
		</artifact>
		<shortMessage>Overwritten increment</shortMessage>
		<info>

			&lt;p&gt; The code performs an increment operation (e.g.,
			&lt;code&gt;i++&lt;/code&gt;) and then immediately
			overwrites it. For example, &lt;code&gt;i = i++&lt;/code&gt;
			immediately overwrites the incremented value with the
			original value. &lt;/p&gt;

		</info>
		<name>Overwritten Increment</name>
	</findingType>
	<findingType>
		<id>ICAST_QUESTIONABLE_UNSIGNED_RIGHT_SHIFT</id>
		<artifact tool="FindBugs"
			mnemonic="ICAST_QUESTIONABLE_UNSIGNED_RIGHT_SHIFT">
		</artifact>
		<shortMessage>
			Unsigned right shift cast to short/byte
		</shortMessage>
		<info>

			&lt;p&gt; The code performs an unsigned right shift, whose
			result is then cast to a short or byte, which discards the
			upper bits of the result. Since the upper bits are
			discarded, there may be no difference between a signed and
			unsigned right shift (depending upon the size of the shift).
			&lt;/p&gt;

		</info>
		<name>Questionable Unsigned Right Shift</name>
	</findingType>
	<findingType>
		<id>ICAST_BAD_SHIFT_AMOUNT</id>
		<artifact tool="FindBugs" mnemonic="ICAST_BAD_SHIFT_AMOUNT">
		</artifact>
		<shortMessage>
			Integer shift by an amount not in the range 0..31
		</shortMessage>
		<info>

			&lt;p&gt; The code performs an integer shift by a constant
			amount outside the range 0..31. The effect of this is to use
			the lower 5 bits of the integer value to decide how much to
			shift by. This probably isn't want was expected, and it at
			least confusing. &lt;/p&gt;

		</info>
		<name>Bad Shift Amount</name>
	</findingType>
	<findingType>
		<id>IM_MULTIPLYING_RESULT_OF_IREM</id>
		<artifact tool="FindBugs"
			mnemonic="IM_MULTIPLYING_RESULT_OF_IREM">
		</artifact>
		<shortMessage>
			Integer multiply of result of integer remainder
		</shortMessage>
		<info>

			&lt;p&gt; The code multiplies the result of an integer
			remaining by an integer constant. Be sure you don't have
			your operator precedence confused. For example i % 60 * 1000
			is (i % 60) * 1000, not i % (60 * 1000). &lt;/p&gt;

		</info>
		<name>Multiplying Result Of Int Remainder</name>
	</findingType>
	<findingType>
		<id>DMI_INVOKING_TOSTRING_ON_ARRAY</id>
		<artifact tool="FindBugs"
			mnemonic="DMI_INVOKING_TOSTRING_ON_ARRAY">
		</artifact>
		<shortMessage>Invocation of toString on an array</shortMessage>
		<info>

			&lt;p&gt; The code invokes toString on an array, which will
			generate a fairly useless result such as [C@16f0472.
			Consider using Arrays.toString to convert the array into a
			readable String that gives the contents of the array. See
			Programming Puzzlers, chapter 3, puzzle 12. &lt;/p&gt;

		</info>
		<name>Invoking toString On Array</name>
	</findingType>
	<findingType>
		<id>IM_AVERAGE_COMPUTATION_COULD_OVERFLOW</id>
		<artifact tool="FindBugs"
			mnemonic="IM_AVERAGE_COMPUTATION_COULD_OVERFLOW">
		</artifact>
		<shortMessage>
			Computation of average could overflow
		</shortMessage>
		<info>

			&lt;p&gt;The code computes the average of two integers using
			either division or signed right shift, and then uses the
			result as the index of an array. If the values being
			averaged are very large, this can overflow (resulting in the
			computation of a negative average). Assuming that the result
			is intended to be nonnegative, you can use an unsigned right
			shift instead. In other words, rather that using
			&lt;code&gt;(low+high)/2&lt;/code&gt;, use
			&lt;code&gt;(low+high) &amp;gt;&amp;gt;&amp;gt;
			1&lt;/code&gt; &lt;/p&gt; &lt;p&gt;This bug exists in many
			earlier implementations of binary search and merge sort.
			Martin Buchholz &lt;a
			href=&quot;http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6412541&quot;&gt;found
			and fixed it&lt;/a&gt; in the JDK libraries, and Joshua
			Bloch &lt;a
			href=&quot;http://googleresearch.blogspot.com/2006/06/extra-extra-read-all-about-it-nearly.html&quot;&gt;widely
			publicized the bug pattern&lt;/a&gt;. &lt;/p&gt;

		</info>
		<name>Average Computation Could Overflow</name>
	</findingType>
	<findingType>
		<id>IM_BAD_CHECK_FOR_ODD</id>
		<artifact tool="FindBugs" mnemonic="IM_BAD_CHECK_FOR_ODD">
		</artifact>
		<shortMessage>
			Check for oddness that won't work for negative numbers
		</shortMessage>
		<info>

			&lt;p&gt; The code uses x % 2 == 1 to check to see if a
			value is odd, but this won't work for negative numbers
			(e.g., (-5) % 2 == -1). If this code is intending to check
			for oddness, consider using x &amp; 1 == 1, or x % 2 != 0.
			&lt;/p&gt;

		</info>
		<name>Bad Check For Odd</name>
	</findingType>
	<findingType>
		<id>DMI_HARDCODED_ABSOLUTE_FILENAME</id>
		<artifact tool="FindBugs"
			mnemonic="DMI_HARDCODED_ABSOLUTE_FILENAME">
		</artifact>
		<shortMessage>
			Code contains a hard coded reference to an absolute pathname
		</shortMessage>
		<info>

			&lt;p&gt;This code constructs a File object using a hard
			coded to an absolute pathname (e.g., &lt;code&gt;new
			File(&quot;/home/dannyc/workspace/j2ee/src/share/com/sun/enterprise/deployment&quot;);&lt;/code&gt;
			&lt;/p&gt;

		</info>
		<name>Hardcoded Absolute Filename</name>
	</findingType>
	<findingType>
		<id>DMI_BAD_MONTH</id>
		<artifact tool="FindBugs" mnemonic="DMI_BAD_MONTH"></artifact>
		<shortMessage>Bad constant value for month</shortMessage>
		<info>

			&lt;p&gt; This code passes a constant month value outside
			the expected range of 0..11 to a method. &lt;/p&gt;

		</info>
		<name>Bad Month</name>
	</findingType>
	<findingType>
		<id>DMI_USELESS_SUBSTRING</id>
		<artifact tool="FindBugs" mnemonic="DMI_USELESS_SUBSTRING">
		</artifact>
		<shortMessage>
			Invocation of substring(0), which returns the original value
		</shortMessage>
		<info>

			&lt;p&gt; This code invokes substring(0) on a String, which
			returns the original value. &lt;/p&gt;

		</info>
		<name>Useless Substring</name>
	</findingType>
	<findingType>
		<id>DMI_CALLING_NEXT_FROM_HASNEXT</id>
		<artifact tool="FindBugs"
			mnemonic="DMI_CALLING_NEXT_FROM_HASNEXT">
		</artifact>
		<shortMessage>hasNext method invokes next</shortMessage>
		<info>

			&lt;p&gt; The hasNext() method invokes the next() method.
			This is almost certainly wrong, since the hasNext() method
			is not supposed to change the state of the iterator, and the
			next method is supposed to change the state of the iterator.
			&lt;/p&gt;

		</info>
		<name>Calling Next From hasNext</name>
	</findingType>
	<findingType>
		<id>AvoidCallingSleepWithLockHeld</id>
		<artifact tool="FindBugs" mnemonic="SWL_SLEEP_WITH_LOCK_HELD">
		</artifact>
		<shortMessage>
			Method calls Thread.sleep() with a lock held
		</shortMessage>
		<info>

			&lt;p&gt; This method calls Thread.sleep() with a lock held.
			This may result in very poor performance and scalability, or
			a deadlock, since other threads may be waiting to acquire
			the lock. It is a much better idea to call wait() on the
			lock, which releases the lock and allows other threads to
			run. &lt;/p&gt;

		</info>
		<name>Sleep With Lock Held</name>
	</findingType>
	<findingType>
		<id>DB_DUPLICATE_BRANCHES</id>
		<artifact tool="FindBugs" mnemonic="DB_DUPLICATE_BRANCHES">
		</artifact>
		<shortMessage>
			Method uses the same code for two branches
		</shortMessage>
		<info>

			&lt;p&gt; This method uses the same code to implement two
			branches of a conditional branch. Check to ensure that this
			isn't a coding mistake. &lt;/p&gt;

		</info>
		<name>Duplicate Branches</name>
	</findingType>
	<findingType>
		<id>DB_DUPLICATE_SWITCH_CLAUSES</id>
		<artifact tool="FindBugs"
			mnemonic="DB_DUPLICATE_SWITCH_CLAUSES">
		</artifact>
		<shortMessage>
			Method uses the same code for two switch clauses
		</shortMessage>
		<info>

			&lt;p&gt; This method uses the same code to implement two
			clauses of a switch statement. This could be a case of
			duplicate code, but it might also indicate a coding mistake.
			&lt;/p&gt;

		</info>
		<name>Duplicate Switch Clauses</name>
	</findingType>
	<findingType>
		<id>IMA_INEFFICIENT_MEMBER_ACCESS</id>
		<artifact tool="FindBugs"
			mnemonic="IMA_INEFFICIENT_MEMBER_ACCESS">
		</artifact>
		<shortMessage>
			Method accesses a private member variable of owning class
		</shortMessage>
		<info>

			&lt;p&gt; This method of an inner class reads from or writes
			to a private member variable of the owning class, or calls a
			private method of the owning class. The compiler must
			generate a special method to access this private member,
			causing this to be less efficient. Relaxing the protection
			of the member variable or method will allow the compiler to
			treat this as a normal access. &lt;/p&gt;

		</info>
		<name>Inefficient Member Access</name>
	</findingType>
	<findingType>
		<id>XFB_XML_FACTORY_BYPASS</id>
		<artifact tool="FindBugs" mnemonic="XFB_XML_FACTORY_BYPASS">
		</artifact>
		<shortMessage>
			Method directly allocates a specific implementation of xml
			interfaces
		</shortMessage>
		<info>

			&lt;p&gt; This method allocates a specific implementation of
			an xml interface. It is preferable to use the supplied
			factory classes to create these objects so that the
			implementation can be changed at runtime. See &lt;/p&gt;
			&lt;ul&gt;
			&lt;li&gt;javax.xml.parsers.DocumentBuilderFactory&lt;/li&gt;
			&lt;li&gt;javax.xml.parsers.SAXParserFactory&lt;/li&gt;
			&lt;li&gt;javax.xml.transform.TransformerFactory&lt;/li&gt;
			&lt;li&gt;org.w3c.dom.Document.create&lt;i&gt;XXXX&lt;/i&gt;&lt;/li&gt;
			&lt;/ul&gt; &lt;p&gt;for details.&lt;/p&gt;

		</info>
		<name>XML Factory Bypass</name>
	</findingType>
	<findingType>
		<id>USM_USELESS_SUBCLASS_METHOD</id>
		<artifact tool="FindBugs"
			mnemonic="USM_USELESS_SUBCLASS_METHOD">
		</artifact>
		<shortMessage>
			Method superfluously delegates to parent class method
		</shortMessage>
		<info>

			&lt;p&gt; This derived method merely calls the same
			superclass method passing in the exact parameters received.
			This method can be removed, as it provides no additional
			value. &lt;/p&gt;

		</info>
		<name>Useless Subclass Method</name>
	</findingType>
	<findingType>
		<id>USM_USELESS_ABSTRACT_METHOD</id>
		<artifact tool="FindBugs"
			mnemonic="USM_USELESS_ABSTRACT_METHOD">
		</artifact>
		<shortMessage>
			Abstract Method is already defined in implemented interface
		</shortMessage>
		<info>

			&lt;p&gt; This abstract method is already defined in an
			interface that is implemented by this abstract class. This
			method can be removed, as it provides no additional value.
			&lt;/p&gt;

		</info>
		<name>Useless Abstract Method</name>
	</findingType>
	<findingType>
		<id>CI_CONFUSED_INHERITANCE</id>
		<artifact tool="FindBugs" mnemonic="CI_CONFUSED_INHERITANCE">
		</artifact>
		<shortMessage>
			Class is final but declares protected field
		</shortMessage>
		<info>

			&lt;p&gt; This class is declared to be final, but declares
			fields to be protected. Since the class is final, it can not
			be derived from, and the use of protected is confusing. The
			access modifier for the field should be changed to private
			or public to represent the true use for the field.
			&lt;/p&gt;

		</info>
		<name>Confused Inheritance</name>
	</findingType>
	<findingType>
		<id>QBA_QUESTIONABLE_BOOLEAN_ASSIGNMENT</id>
		<artifact tool="FindBugs"
			mnemonic="QBA_QUESTIONABLE_BOOLEAN_ASSIGNMENT">
		</artifact>
		<shortMessage>
			Method assigns boolean literal in boolean expression
		</shortMessage>
		<info>

			&lt;p&gt; This method assigns a literal boolean value (true
			or false) to a boolean variable inside an if or while
			expression. Most probably this was supposed to be a boolean
			comparison using ==, not an assignment using =. &lt;/p&gt;

		</info>
		<name>Questionable Boolean Assignment</name>
	</findingType>
	<findingType>
		<id>VR_UNRESOLVABLE_REFERENCE</id>
		<artifact tool="FindBugs"
			mnemonic="VR_UNRESOLVABLE_REFERENCE">
		</artifact>
		<shortMessage>
			Class makes reference to unresolvable class or method
		</shortMessage>
		<info>

			&lt;p&gt; This class makes a reference to a class or method
			that can not be resolved using against the libraries it is
			being analyzed with. &lt;/p&gt;

		</info>
		<name>Unresolvable Reference</name>
	</findingType>
	<findingType>
		<id>GC_UNRELATED_TYPES</id>
		<artifact tool="FindBugs" mnemonic="GC_UNRELATED_TYPES">
		</artifact>
		<shortMessage>
			No relationship between generic parameter and method
			argument
		</shortMessage>
		<info>

			&lt;p&gt; This call to a generic container's method contains
			an argument with a different class type from that of the
			container's parameter. Therefore, it is unlikely that the
			container contains any objects with the same type as the
			method argument used here. &lt;/p&gt;

		</info>
		<name>Unrelated Types</name>
	</findingType>
	<findingType>
		<id>AvoidStaticCalendar</id>
		<artifact tool="FindBugs"
			mnemonic="STCAL_STATIC_CALENDAR_INSTANCE">
		</artifact>
		<shortMessage>Static Calendar</shortMessage>
		<info>

			&lt;p&gt;Even though the JavaDoc does not contain a hint
			about it, Calendars are inherently unsafe for multihtreaded
			use. Sharing a single instance across thread boundaries
			without proper synchronization will result in erratic
			behavior of the application. Under 1.4 problems seem to
			surface less often than under Java 5 where you will probably
			see random ArrayIndexOutOfBoundsExceptions or
			IndexOutOfBoundsExceptions in
			sun.util.calendar.BaseCalendar.getCalendarDateFromFixedDate().&lt;/p&gt;
			&lt;p&gt;You may also experience serialization
			problems.&lt;/p&gt; &lt;p&gt;Using an instance field is
			recommended.&lt;/p&gt; &lt;p&gt;For more information on this
			see &lt;a
			href=&quot;http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6231579&quot;&gt;Sun
			Bug #6231579&lt;/a&gt; and &lt;a
			href=&quot;http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6178997&quot;&gt;Sun
			Bug #6178997&lt;/a&gt;.&lt;/p&gt;

		</info>
		<name>Static Calendar Instance</name>
	</findingType>
	<findingType>
		<id>CallToStaticCalendar</id>
		<artifact tool="FindBugs"
			mnemonic="STCAL_INVOKE_ON_STATIC_CALENDAR_INSTANCE">
		</artifact>
		<shortMessage>Call to static Calendar</shortMessage>
		<info>

			&lt;p&gt;Even though the JavaDoc does not contain a hint
			about it, Calendars are inherently unsafe for multihtreaded
			use. The detector has found a call to an instance of
			Calendar that has been obtained via a static field. This
			looks suspicous.&lt;/p&gt; &lt;p&gt;For more information on
			this see &lt;a
			href=&quot;http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6231579&quot;&gt;Sun
			Bug #6231579&lt;/a&gt; and &lt;a
			href=&quot;http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6178997&quot;&gt;Sun
			Bug #6178997&lt;/a&gt;.&lt;/p&gt;

		</info>
		<name>Invoke On Static Calendar Instance</name>
	</findingType>
	<findingType>
		<id>AvoidStaticDateformat</id>
		<artifact tool="FindBugs"
			mnemonic="STCAL_STATIC_SIMPLE_DATA_FORMAT_INSTANCE">
		</artifact>
		<artifact tool="FindBugs"
			mnemonic="STCAL_STATIC_SIMPLE_DATE_FORMAT_INSTANCE">
		</artifact>
		<shortMessage>Static DateFormat</shortMessage>
		<info>

			&lt;p&gt;As the JavaDoc states, DateFormats are inherently
			unsafe for multithreaded use. Sharing a single instance
			across thread boundaries without proper synchronization will
			result in erratic behavior of the application.&lt;/p&gt;
			&lt;p&gt;You may also experience serialization
			problems.&lt;/p&gt; &lt;p&gt;Using an instance field is
			recommended.&lt;/p&gt; &lt;p&gt;For more information on this
			see &lt;a
			href=&quot;http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6231579&quot;&gt;Sun
			Bug #6231579&lt;/a&gt; and &lt;a
			href=&quot;http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6178997&quot;&gt;Sun
			Bug #6178997&lt;/a&gt;.&lt;/p&gt;

		</info>
		<name>Static Simple Data Format Instance</name>
	</findingType>
	<findingType>
		<id>CallToStaticDateFormat</id>
		<artifact tool="FindBugs"
			mnemonic="STCAL_INVOKE_ON_STATIC_DATE_FORMAT_INSTANCE">
		</artifact>
		<shortMessage>Call to static DateFormat</shortMessage>
		<info>

			&lt;p&gt;As the JavaDoc states, DateFormats are inherently
			unsafe for multithreaded use. The detector has found a call
			to an instance of DateFormat that has been obtained via a
			static field. This looks suspicous.&lt;/p&gt; &lt;p&gt;For
			more information on this see &lt;a
			href=&quot;http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6231579&quot;&gt;Sun
			Bug #6231579&lt;/a&gt; and &lt;a
			href=&quot;http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6178997&quot;&gt;Sun
			Bug #6178997&lt;/a&gt;.&lt;/p&gt;

		</info>
		<name>Invoke On Static Date Format Instance</name>
	</findingType>

	<!-- This type is no longer used.  Do not assign artifacts to it. -->
	<findingType>
		<id>InefficientStringVoidConstructor</id>
		<shortMessage>
			Method invokes inefficient new String() constructor
		</shortMessage>
		<info>

			&lt;p&gt; Creating a new
			&lt;code&gt;java.lang.String&lt;/code&gt; object using the
			no-argument constructor wastes memory because the object so
			created will be functionally indistinguishable from the
			empty string constant
			&lt;code&gt;&quot;&quot;&lt;/code&gt;.&amp;nbsp; Java
			guarantees that identical string constants will be
			represented by the same &lt;code&gt;String&lt;/code&gt;
			object.&amp;nbsp; Therefore, you should just use the empty
			string constant directly.&lt;/p&gt;

		</info>
		<name>Inefficient String Void Constructor</name>
	</findingType>

	<!-- FindBugs 1.3.0 Upgrade -->
	<findingType>
		<id>DoesntOverrideEquals</id>
		<artifact tool="FindBugs"
			mnemonic="EQ_DOESNT_OVERRIDE_EQUALS">
		</artifact>
		<shortMessage>
			Class doesn't override equals in superclass
		</shortMessage>
		<info>

			&lt;p&gt; This class extends a class that defines an equals
			method and adds fields, but doesn't define an equals method
			itself. Thus, equality on instances of this class will
			ignore the identity of the subclass and the added fields. Be
			sure this is what is intended, and that you don't need to
			override the equals method. Even if you don't need to
			override the equals method, consider overriding it anyone to
			document the fact that the equals method for the subclass
			just return the result of invoking super.equals(o).

		</info>
		<name>Doesn't Override Equals</name>
	</findingType>
	<findingType>
		<id>SameSimpleNameAsInterface</id>
		<artifact tool="FindBugs"
			mnemonic="NM_SAME_SIMPLE_NAME_AS_INTERFACE">
		</artifact>
		<shortMessage>
			Class names shouldn't shadow simple name of implemented
			interface
		</shortMessage>
		<info>

			&lt;p&gt; This class/interface has a simple name that is
			identical to that of an implemented/extended interface,
			except that the interface is in a different package (e.g.,
			&lt;code&gt;alpha.Foo&lt;/code&gt; extends
			&lt;code&gt;beta.Foo&lt;/code&gt;). This can be
			exceptionally confusing, create lots of situations in which
			you have to look at import statements to resolve references
			and creates many opportunities to accidently define methods
			that do not override methods in their superclasses.
			&lt;/p&gt;

		</info>
		<name>Same Simple Name As Interface</name>
	</findingType>
	<findingType>
		<id>SameSimpleNameAsSuperclass</id>
		<artifact tool="FindBugs"
			mnemonic="NM_SAME_SIMPLE_NAME_AS_SUPERCLASS">
		</artifact>
		<shortMessage>
			Class names shouldn't shadow simple name of superclass
		</shortMessage>
		<info>

			&lt;p&gt; This class has a simple name that is identical to
			that of its superclass, except that its superclass is in a
			different package (e.g., &lt;code&gt;alpha.Foo&lt;/code&gt;
			extends &lt;code&gt;beta.Foo&lt;/code&gt;). This can be
			exceptionally confusing, create lots of situations in which
			you have to look at import statements to resolve references
			and creates many opportunities to accidently define methods
			that do not override methods in their superclasses.
			&lt;/p&gt;

		</info>
		<name>Same Simple Name As Superclass</name>
	</findingType>
	<findingType>
		<id>WrongPackage</id>
		<artifact tool="FindBugs" mnemonic="NM_WRONG_PACKAGE">
		</artifact>
		<shortMessage>
			Method doesn't override method in superclass due to wrong
			package for parameter
		</shortMessage>
		<info>

			&lt;p&gt; The method in the subclass doesn't override a
			similar method in a superclass because the type of a
			parameter doesn't exactly match the type of the
			corresponding parameter in the superclass. For example, if
			you have:&lt;/p&gt;

			&lt;blockquote&gt; &lt;pre&gt; import alpha.Foo; public
			class A { public int f(Foo x) { return 17; } } ---- import
			beta.Foo; public class B extends A { public int f(Foo x) {
			return 42; } } &lt;/pre&gt; &lt;/blockquote&gt;

			&lt;p&gt;The &lt;code&gt;f(Foo)&lt;/code&gt; method defined
			in class &lt;code&gt;B&lt;/code&gt; doesn't override the
			&lt;code&gt;f(Foo)&lt;/code&gt; method defined in class
			&lt;code&gt;A&lt;/code&gt;, because the argument types are
			&lt;code&gt;Foo&lt;/code&gt;'s from different packages.
			&lt;/p&gt;

		</info>
		<name>Wrong Package</name>
	</findingType>
	<findingType>
		<id>WrongPackageIntentional</id>
		<artifact tool="FindBugs"
			mnemonic="NM_WRONG_PACKAGE_INTENTIONAL">
		</artifact>
		<shortMessage>
			Method doesn't override method in superclass due to wrong
			package for parameter
		</shortMessage>
		<info>

			&lt;p&gt; The method in the subclass doesn't override a
			similar method in a superclass because the type of a
			parameter doesn't exactly match the type of the
			corresponding parameter in the superclass. For example, if
			you have:&lt;/p&gt;

			&lt;blockquote&gt; &lt;pre&gt; import alpha.Foo; public
			class A { public int f(Foo x) { return 17; } } ---- import
			beta.Foo; public class B extends A { public int f(Foo x) {
			return 42; } public int f(alpha.Foo x) { return 27; } }
			&lt;/pre&gt; &lt;/blockquote&gt;

			&lt;p&gt;The &lt;code&gt;f(Foo)&lt;/code&gt; method defined
			in class &lt;code&gt;B&lt;/code&gt; doesn't override the
			&lt;code&gt;f(Foo)&lt;/code&gt; method defined in class
			&lt;code&gt;A&lt;/code&gt;, because the argument types are
			&lt;code&gt;Foo&lt;/code&gt;'s from different packages.
			&lt;/p&gt;

			&lt;p&gt;In this case, the subclass does define a method
			with a signature identical to the method in the superclass,
			so this is presumably understood. However, such methods are
			exceptionally confusing. You should strongly consider
			removing or deprecating the method with the similar but not
			identical signature. &lt;/p&gt;

		</info>
		<name>Wrong Package Intentional</name>
	</findingType>
	<findingType>
		<id>ReturnValueIgnoredBadPractice</id>
		<artifact tool="FindBugs"
			mnemonic="RV_RETURN_VALUE_IGNORED_BAD_PRACTICE">
		</artifact>
		<shortMessage>Method ignores return value</shortMessage>
		<info>

			&lt;p&gt; This method returns a value that is not checked.
			For example, the &lt;code&gt;File.delete()&lt;/code&gt;
			method returns false if the file could not be successfully
			deleted (rather than throwing an Exception). If you don't
			check the result, you won't notice if the method invocation
			signals unexpected behavior by returning an atypical return
			value.

		</info>
		<name>Return Value Ignored Bad Practice</name>
	</findingType>
	<findingType>
		<id>ExceptionNotThrown</id>
		<artifact tool="FindBugs" mnemonic="RV_EXCEPTION_NOT_THROWN">
		</artifact>
		<shortMessage>
			Exception created and dropped rather than thrown
		</shortMessage>
		<info>

			&lt;p&gt; This code creates an exception (or error) object,
			but doesn't do anything with it. For example, something like
			&lt;/p&gt; &lt;blockquote&gt; &lt;pre&gt; if (x &lt; 0) new
			IllegalArgumentException(&quot;x must be nonnegative&quot;);
			&lt;/pre&gt; &lt;/blockquote&gt; &lt;p&gt;It was probably
			the intent of the programmer to throw the created
			exception:&lt;/p&gt; &lt;blockquote&gt; &lt;pre&gt; if (x
			&lt; 0) throw new IllegalArgumentException(&quot;x must be
			nonnegative&quot;); &lt;/pre&gt; &lt;/blockquote&gt;

		</info>
		<name>Exception Not Thrown</name>
	</findingType>
	<findingType>
		<id>UnrelatedTypesUsingPointerEquality</id>
		<artifact tool="FindBugs"
			mnemonic="EC_UNRELATED_TYPES_USING_POINTER_EQUALITY">
		</artifact>
		<shortMessage>
			Using pointer equality to compare different types
		</shortMessage>
		<info>

			&lt;p&gt; This method uses using pointer equality to compare
			two references that seem to be of different types. The
			result of this comparison will always be false at runtime.
			&lt;/p&gt;

		</info>
		<name>Unrelated Types Using Pointer Equality</name>
	</findingType>
	<findingType>
		<id>BitSignedCheck</id>
		<artifact tool="FindBugs" mnemonic="BIT_SIGNED_CHECK">
		</artifact>
		<shortMessage>Check for sign of bitwise operation</shortMessage>
		<info>

			&lt;p&gt; This method compares an expression such as
			&lt;pre&gt;((event.detail &amp; SWT.SELECTED) &gt;
			0)&lt;/pre&gt;. Using bit arithmetic and then comparing with
			the greater than operator can lead to unexpected results (of
			course depending on the value of SWT.SELECTED). If
			SWT.SELECTED is a negative number, this is a candidate for a
			bug. Even when SWT.SELECTED is not negative, it seems good
			practice to use '!= 0' instead of '&gt; 0'. &lt;/p&gt;
			&lt;p&gt; &lt;em&gt;Boris Bokowski&lt;/em&gt; &lt;/p&gt;

		</info>
		<name>Signed Check</name>
	</findingType>
	<findingType>
		<id>BitSignedCheckHighBit</id>
		<artifact tool="FindBugs"
			mnemonic="BIT_SIGNED_CHECK_HIGH_BIT">
		</artifact>
		<shortMessage>Check for sign of bitwise operation</shortMessage>
		<info>

			&lt;p&gt; This method compares an expression such as
			&lt;pre&gt;((event.detail &amp; SWT.SELECTED) &gt;
			0)&lt;/pre&gt;. Using bit arithmetic and then comparing with
			the greater than operator can lead to unexpected results (of
			course depending on the value of SWT.SELECTED). If
			SWT.SELECTED is a negative number, this is a candidate for a
			bug. Even when SWT.SELECTED is not negative, it seems good
			practice to use '!= 0' instead of '&gt; 0'. &lt;/p&gt;
			&lt;p&gt; &lt;em&gt;Boris Bokowski&lt;/em&gt; &lt;/p&gt;

		</info>
		<name>Signed Check High Bit</name>
	</findingType>
	<findingType>
		<id>LazyInitUpdateStatic</id>
		<artifact tool="FindBugs"
			mnemonic="LI_LAZY_INIT_UPDATE_STATIC">
		</artifact>
		<shortMessage>
			Incorrect lazy initialization and update of static field
		</shortMessage>
		<info>

			&lt;p&gt; This method contains an unsynchronized lazy
			initialization of a static field. After the field is set,
			the object stored into that location is further accessed.
			The setting of the field is visible to other threads as soon
			as it is set. If the futher accesses in the method that set
			the field serve to initialize the object, then you have a
			&lt;em&gt;very serious&lt;/em&gt; multithreading bug, unless
			something else prevents any other thread from accessing the
			stored object until it is fully initialized. &lt;/p&gt;

		</info>
		<name>Lazy Init Update Static</name>
	</findingType>
	<findingType>
		<id>DeadStoreOfClassLiteral</id>
		<artifact tool="FindBugs"
			mnemonic="DLS_DEAD_STORE_OF_CLASS_LITERAL">
		</artifact>
		<shortMessage>Dead store of class literal</shortMessage>
		<info>

			&lt;p&gt; This instruction assigns a class literal to a
			variable and then never uses it. &lt;a
			href=&quot;//java.sun.com/j2se/1.5.0/compatibility.html#literal&quot;&gt;The
			behavior of this differs in Java 1.4 and in Java
			5.&lt;/a&gt; In Java 1.4 and earlier, a reference to
			&lt;code&gt;Foo.class&lt;/code&gt; would force the static
			initializer for &lt;code&gt;Foo&lt;/code&gt; to be executed,
			if it has not been executed already. In Java 5 and later, it
			does not. &lt;/p&gt; &lt;p&gt;See Sun's &lt;a
			href=&quot;//java.sun.com/j2se/1.5.0/compatibility.html#literal&quot;&gt;article
			on Java SE compatibility&lt;/a&gt; for more details and
			examples, and suggestions on how to force class
			initialization in Java 5. &lt;/p&gt;

		</info>
		<name>Dead Store Of Class Literal</name>
	</findingType>
	<findingType>
		<id>AlwaysValueUsedWhereNeverRequired</id>
		<artifact tool="FindBugs"
			mnemonic="TQ_ALWAYS_VALUE_USED_WHERE_NEVER_REQUIRED">
		</artifact>
		<shortMessage>
			Value annotated as carrying a type qualifier used where a
			value that must not carry that qualifier is required
		</shortMessage>
		<info>

			&lt;p&gt; A value specified as carrying a type qualifier
			annotation is consumed in a location or locations requiring
			that the value not carry that annotation. &lt;/p&gt;

			&lt;p&gt; More precisely, a value annotated with a type
			qualifier specifying when=ALWAYS is guaranteed to reach a
			use or uses where the same type qualifier specifies
			when=NEVER. &lt;/p&gt;

			&lt;p&gt; For example, say that @NonNegative is a nickname
			for the type qualifier annotation
			@Negative(when=When.NEVER). The following code will generate
			this warning because the return statement requires a
			@NonNegative value, but receives one that is marked as
			@Negative. &lt;/p&gt; &lt;blockquote&gt; &lt;pre&gt; public
			@NonNegative Integer example(@Negative Integer value) {
			return value; } &lt;/pre&gt; &lt;/blockquote&gt;

		</info>
		<name>Always Value Used Where Never Required</name>
	</findingType>
	<findingType>
		<id>NeverValueUsedWhereAlwaysRequired</id>
		<artifact tool="FindBugs"
			mnemonic="TQ_NEVER_VALUE_USED_WHERE_ALWAYS_REQUIRED">
		</artifact>
		<shortMessage>
			Value annotated as never carrying a type qualifier used
			where value carrying that qualifier is required
		</shortMessage>
		<info>

			&lt;p&gt; A value specified as not carrying a type qualifier
			annotation is guaranteed to be consumed in a location or
			locations requiring that the value does carry that
			annotation. &lt;/p&gt;

			&lt;p&gt; More precisely, a value annotated with a type
			qualifier specifying when=NEVER is guaranteed to reach a use
			or uses where the same type qualifier specifies when=ALWAYS.
			&lt;/p&gt;

			&lt;p&gt; TODO: example &lt;/p&gt;

		</info>
		<name>Never Value Used Where Always Required</name>
	</findingType>
	<findingType>
		<id>MaybeSourceValueReachesAlwaysSink</id>
		<artifact tool="FindBugs"
			mnemonic="TQ_MAYBE_SOURCE_VALUE_REACHES_ALWAYS_SINK">
		</artifact>
		<shortMessage>
			Value that might not carry a type qualifier reaches a use
			requiring that type qualifier
		</shortMessage>
		<info>

			&lt;p&gt; A value that might not carry a type qualifier
			annotation reaches a use which requires that annotation.
			&lt;/p&gt;

			&lt;p&gt; For example, consider the following method:
			&lt;/p&gt; &lt;blockquote&gt; &lt;pre&gt; public @Untainted
			Object mustReturnUntainted(Object unknown) { return unknown;
			} &lt;/pre&gt; &lt;/blockquote&gt; &lt;p&gt; The
			&lt;code&gt;mustReturnUntainted&lt;/code&gt; method is
			required to return a value carrying the @Untainted
			annotation, but a value not known to carry that annotation
			is returned. &lt;/p&gt;

		</info>
		<name>Maybe Source Value Reaches Always Sink</name>
	</findingType>
	<findingType>
		<id>MaybeSourceValueReachesNeverSink</id>
		<artifact tool="FindBugs"
			mnemonic="TQ_MAYBE_SOURCE_VALUE_REACHES_NEVER_SINK">
		</artifact>
		<shortMessage>
			Unknown value reaches a use which forbids values carrying
			type qualifier annotation
		</shortMessage>
		<info>

			&lt;p&gt; A value which might carry a type qualifier
			annotation reaches a use which forbids values carrying that
			annotation. &lt;/p&gt;

			&lt;p&gt; TODO: example. &lt;/p&gt;

		</info>
		<name>Maybe Source Value Reaches Never Sink</name>
	</findingType>

	<!-- For FB 1.3.1 -->
	<findingType>
		<id>BooleanMethodReturnsNull</id>
		<artifact tool="FindBugs"
			mnemonic="NP_BOOLEAN_RETURN_NULL">
		</artifact>
		<shortMessage>
			Method with Boolean return type returns explicit null
		</shortMessage>
		<info>

			&lt;p&gt; This method can be invoked as though it returned a value of type boolean, and
	the compiler will insert automatic unboxing of the Boolean value. If a null value is returned,
	this will result in a NullPointerException. &lt;/p&gt;

		</info>
		<name>Boolean-typed Method Returns Null</name>
	</findingType>
	<findingType>
		<id>AppendingToObjectOutputStream</id>
		<artifact tool="FindBugs"
			mnemonic="IO_APPENDING_TO_OBJECT_OUTPUT_STREAM">
		</artifact>
		<shortMessage>
			Appending to an ObjectOutputStream
		</shortMessage>
		<info>

			&lt;p&gt; This code opens a file in append mode and that wraps the result in an object output stream. 
     This won't allow you to append to an existing object output stream stored in a file. If you want to be
     able to append to an object output stream, you need to keep the object output stream open. &lt;/p&gt;

      &lt;p&gt; The only situation in which opening a file in append mode and the writing an object output stream
      could work is if on reading the file you plan to open it in random access mode and seek to the byte offset
      where the append started. &lt;/p&gt;

		</info>
		<name>Appending To ObjectOutputStream</name>
	</findingType>
	<findingType>
		<id>FormatStringArgsMismatch</id>
		<artifact tool="FindBugs"
			mnemonic="VA_FORMAT_STRING_ARG_MISMATCH">
		</artifact>
		<shortMessage>
      Number of format-string arguments does not correspond to number of placeholders
		</shortMessage>
		<info>

			&lt;p&gt; A format-string method with a variable number of arguments is called,
      but the number of arguments passed does not match with the number of
      % placeholders in the format string.  This is probably not what the
      author intended.. &lt;/p&gt;

		</info>
		<name>Mismatch Of Number Of Args For Format String</name>
	</findingType>
	<findingType>
		<id>InvokingToStringOnArray</id>
		<artifact tool="FindBugs"
			mnemonic="DMI_INVOKING_TOSTRING_ON_ANONYMOUS_ARRAY">
		</artifact>
		<shortMessage>
      Invocation of toString() on an array
		</shortMessage>
		<info>

			&lt;p&gt; The code invokes toString on an array, which will generate a fairly useless result
      such as [C@16f0472. Consider using Arrays.toString to convert the array into a readable
      String that gives the contents of the array. 
      See Programming Puzzlers, chapter 3, puzzle 12. &lt;/p&gt;

		</info>
		<name>Invocation Of toString() On Array</name>
	</findingType>
	
	<!-- For FB 1.3.2 -->
	<findingType>
		<id>HttpParameterWrittenToServlet</id>
		<artifact tool="FindBugs"
			mnemonic="XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER">
		</artifact>
		<shortMessage>
			HTTP parameter directly written to Servlet output
		</shortMessage>
		<info>

			&lt;p&gt; This code directly writes an HTTP parameter to Servlet output, which allows for a cross site scripting
vunerability. See &lt;a href="http://en.wikipedia.org/wiki/Cross-site_scripting"&gt;http://en.wikipedia.org/wiki/Cross-site_scripting&lt;/a&gt;
for more information. &lt;/p&gt;

		</info>
		<name>Servlet cross site scripting vulnerability</name>
	</findingType>
	<findingType>
		<id>HttpParameterWrittenToJSP</id>
		<artifact tool="FindBugs"
			mnemonic="XSS_REQUEST_PARAMETER_TO_JSP_WRITER">
		</artifact>
		<shortMessage>
			HTTP parameter directly written to JSP output
		</shortMessage>
		<info>

			&lt;p&gt; This code directly writes an HTTP parameter to JSP output, which allows for a cross site scripting
vunerability. See &lt;a href="http://en.wikipedia.org/wiki/Cross-site_scripting"&gt;http://en.wikipedia.org/wiki/Cross-site_scripting&lt;/a&gt;
for more information. &lt;/p&gt;

		</info>
		<name>JSP cross site scripting vulnerability</name>
	</findingType>
	<findingType>
		<id>EqualsDoesntOverride</id>
		<artifact tool="FindBugs"
			mnemonic="EQ_OTHER_USE_OBJECT">
		</artifact>
		<shortMessage>
			equals() method defined that doesn't override Object.equals(Object)
		</shortMessage>
		<info>

			&lt;p&gt; This class defines an &lt;code&gt;equals()&lt;/code&gt;
  method, that doesn't override the normal &lt;code&gt;equals(Object)&lt;/code&gt; method
  defined in the base &lt;code&gt;java.lang.Object&lt;/code&gt; class.
  The class should probably define a &lt;code&gt;boolean equals(Object)&lt;/code&gt; 
  method. &lt;/p&gt;

		</info>
		<name>equals() doesn't override Object.equals(Object)</name>
	</findingType>
	<findingType>
		<id>EqualsDoesntOverrideInherited</id>
		<artifact tool="FindBugs"
			mnemonic="EQ_OTHER_NO_OBJECT">
		</artifact>
		<shortMessage>
			equals() method defined that doesn't override inherited equals(Object)
		</shortMessage>
		<info>

			&lt;p&gt; This class defines an &lt;code&gt;equals()&lt;/code&gt;
  method, that doesn't override the normal &lt;code&gt;equals(Object)&lt;/code&gt; method
  defined in the base &lt;code&gt;java.lang.Object&lt;/code&gt; class.
  Instead, it inherits an &lt;code&gt;equals(Object)&lt;/code&gt; method from a superclass.
  The class should probably define a &lt;code&gt;boolean equals(Object)&lt;/code&gt; 
  method. &lt;/p&gt;

		</info>
		<name>equals() doesn't override inherited equals(Object)</name>
	</findingType>
	<findingType>
		<id>NP_NULL_ON_SOME_PATH_MIGHT_BE_INFEASIBLE</id>
		<artifact tool="FindBugs"
			mnemonic="NP_NULL_ON_SOME_PATH_MIGHT_BE_INFEASIBLE">
		</artifact>
		<shortMessage>
			Possible null pointer dereference on path that might be infeasible
		</shortMessage>
		<info>

			&lt;p&gt; This class defines an &lt;code&gt;equals()&lt;/code&gt;
  method, that doesn't override the normal &lt;code&gt;equals(Object)&lt;/code&gt; method
  defined in the base &lt;code&gt;java.lang.Object&lt;/code&gt; class.
  Instead, it inherits an &lt;code&gt;equals(Object)&lt;/code&gt; method from a superclass.
  The class should probably define a &lt;code&gt;boolean equals(Object)&lt;/code&gt; 
  method. &lt;/p&gt;

		</info>
		<name>Possible null dereference on potentially infeasible path</name>
	</findingType>	

	<category>
		<id>Correctness</id>
		<findingType>NP_NULL_ON_SOME_PATH_MIGHT_BE_INFEASIBLE</findingType>
		<findingType>EqualsDoesntOverride</findingType>
		<findingType>EqualsDoesntOverrideInherited</findingType>
		<findingType>InvokingToStringOnArray</findingType>
		<findingType>FormatStringArgsMismatch</findingType>
		<findingType>AppendingToObjectOutputStream</findingType>
		<findingType>VR_UNRESOLVABLE_REFERENCE</findingType>
		<findingType>CaughtInfiniteLoop</findingType>
		<findingType>CaughtInfiniteRecursiveLoop</findingType>
		<findingType>ContainerAddedToItself</findingType>
		<findingType>GeneratedFromIncompleteDetectors</findingType>
		<findingType>UnknownBugPattern</findingType>
		<findingType>AvoidUsingFloatForMathOperations</findingType>
		<findingType>FieldIsntFinalInImmutableClass</findingType>
		<findingType>AnnotationIsNotVisibleToReflection</findingType>
		<findingType>UnboxedAndCoercedForTernaryOperator</findingType>
		<findingType>NP_ARGUMENT_MIGHT_BE_NULL</findingType>
		<findingType>RV_ABSOLUTE_VALUE_OF_RANDOM_INT</findingType>
		<findingType>RV_ABSOLUTE_VALUE_OF_HASHCODE</findingType>
		<findingType>RandomValue01ToInt</findingType>
		<findingType>EQ_OVERRIDING_EQUALS_NOT_SYMMETRIC</findingType>
		<findingType>EQ_DONT_DEFINE_EQUALS_FOR_ENUM</findingType>
		<findingType>HE_USE_OF_UNHASHABLE_CLASS</findingType>
		<findingType>NS_DANGEROUS_NON_SHORT_CIRCUIT</findingType>
		<findingType>UR_UNINIT_READ</findingType>
		<findingType>NM_VERY_CONFUSING</findingType>
		<findingType>NM_METHOD_CONSTRUCTOR_CONFUSION</findingType>
		<findingType>SuspiciousHashcodeMethodName</findingType>
		<findingType>NM_LCASE_TOSTRING</findingType>
		<findingType>SuspiciousEqualsMethodName</findingType>
		<findingType>
			SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH
		</findingType>
		<findingType>NP_UNWRITTEN_FIELD</findingType>
		<findingType>UWF_NULL_FIELD</findingType>
		<findingType>UWF_UNWRITTEN_FIELD</findingType>
		<findingType>RV_RETURN_VALUE_IGNORED</findingType>
		<findingType>RV_RETURN_VALUE_IGNORED2</findingType>
		<findingType>RV_DONT_JUST_NULL_CHECK_READLINE</findingType>
		<findingType>NP_ALWAYS_NULL</findingType>
		<findingType>NP_STORE_INTO_NONNULL_FIELD</findingType>
		<findingType>NP_ALWAYS_NULL_EXCEPTION</findingType>
		<findingType>NP_NULL_ON_SOME_PATH</findingType>
		<findingType>NP_NULL_ON_SOME_PATH_EXCEPTION</findingType>
		<findingType>NP_NULL_PARAM_DEREF</findingType>
		<findingType>NP_NULL_PARAM_DEREF_NONVIRTUAL</findingType>
		<findingType>
			NP_NULL_PARAM_DEREF_ALL_TARGETS_DANGEROUS
		</findingType>
		<findingType>NP_NONNULL_PARAM_VIOLATION</findingType>
		<findingType>NP_NONNULL_RETURN_VIOLATION</findingType>
		<findingType>NP_GUARANTEED_DEREF</findingType>
		<findingType>NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH</findingType>
		<findingType>UCF_USELESS_CONTROL_FLOW_NEXT_LINE</findingType>
		<findingType>
			RedundantComparisonOfNullAndNonnullValue
		</findingType>
		<findingType>RC_REF_COMPARISON</findingType>
		<findingType>
			VA_PRIMITIVE_ARRAY_PASSED_TO_OBJECT_VARARG
		</findingType>
		<findingType>EC_UNRELATED_TYPES</findingType>
		<findingType>EC_ARRAY_AND_NONARRAY</findingType>
		<findingType>EqualComparisonToNullArgument</findingType>
		<findingType>EC_UNRELATED_INTERFACES</findingType>
		<findingType>EC_UNRELATED_CLASS_AND_INTERFACE</findingType>
		<findingType>INT_BAD_COMPARISON_WITH_SIGNED_BYTE</findingType>
		<findingType>
			INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE
		</findingType>
		<findingType>INT_BAD_REM_BY_1</findingType>
		<findingType>BIT_IOR_OF_SIGNED_BYTE</findingType>
		<findingType>BIT_AND</findingType>
		<findingType>BIT_AND_ZZ</findingType>
		<findingType>BIT_IOR</findingType>
		<findingType>SA_FIELD_SELF_ASSIGNMENT</findingType>
		<findingType>SA_LOCAL_DOUBLE_ASSIGNMENT</findingType>
		<findingType>SA_FIELD_DOUBLE_ASSIGNMENT</findingType>
		<findingType>SA_FIELD_SELF_COMPUTATION</findingType>
		<findingType>SA_LOCAL_SELF_COMPUTATION</findingType>
		<findingType>SA_FIELD_SELF_COMPARISON</findingType>
		<findingType>SA_LOCAL_SELF_COMPARISON</findingType>
		<findingType>
			UMAC_UNCALLABLE_METHOD_OF_ANONYMOUS_CLASS
		</findingType>
		<findingType>
			IJU_ASSERT_METHOD_INVOKED_FROM_RUN_METHOD
		</findingType>
		<findingType>IJU_BAD_SUITE_METHOD</findingType>
		<findingType>IJU_SETUP_NO_SUPER</findingType>
		<findingType>IJU_TEARDOWN_NO_SUPER</findingType>
		<findingType>IJU_SUITE_NOT_STATIC</findingType>
		<findingType>IJU_NO_TESTS</findingType>
		<findingType>BOA_BADLY_OVERRIDDEN_ADAPTER</findingType>
		<findingType>BRSA_BAD_RESULTSET_ACCESS</findingType>
		<findingType>SQL_BAD_RESULTSET_ACCESS</findingType>
		<findingType>SQL_BAD_PREPARED_STATEMENT_ACCESS</findingType>
		<findingType>SIO_SUPERFLUOUS_INSTANCEOF</findingType>
		<findingType>BAC_BAD_APPLET_CONSTRUCTOR</findingType>
		<findingType>EC_BAD_ARRAY_COMPARE</findingType>
		<findingType>STI_INTERRUPTED_ON_CURRENTTHREAD</findingType>
		<findingType>STI_INTERRUPTED_ON_UNKNOWNTHREAD</findingType>
		<findingType>IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN</findingType>
		<findingType>MF_METHOD_MASKS_FIELD</findingType>
		<findingType>MF_CLASS_MASKS_FIELD</findingType>
		<findingType>FE_TEST_IF_EQUAL_TO_NOT_A_NUMBER</findingType>
		<findingType>
			ICAST_INT_CAST_TO_DOUBLE_PASSED_TO_CEIL
		</findingType>
		<findingType>
			ICAST_INT_CAST_TO_FLOAT_PASSED_TO_ROUND
		</findingType>
		<findingType>NP_NULL_INSTANCEOF</findingType>
		<findingType>BC_NULL_INSTANCEOF</findingType>
		<findingType>
			DMI_LONG_BITS_TO_DOUBLE_INVOKED_ON_INT
		</findingType>
		<findingType>BC_IMPOSSIBLE_CAST_PRIMITIVE_ARRAY</findingType>
		<findingType>BC_IMPOSSIBLE_CAST</findingType>
		<findingType>BC_IMPOSSIBLE_INSTANCEOF</findingType>
		<findingType>RE_POSSIBLE_UNINTENDED_PATTERN</findingType>
		<findingType>RE_BAD_SYNTAX_FOR_REGULAR_EXPRESSION</findingType>
		<findingType>
			RE_CANT_USE_FILE_SEPARATOR_AS_REGULAR_EXPRESSION
		</findingType>
		<findingType>DLS_OVERWRITTEN_INCREMENT</findingType>
		<findingType>ICAST_BAD_SHIFT_AMOUNT</findingType>
		<findingType>IM_MULTIPLYING_RESULT_OF_IREM</findingType>
		<findingType>DMI_INVOKING_TOSTRING_ON_ARRAY</findingType>
		<findingType>DMI_BAD_MONTH</findingType>
		<findingType>DMI_CALLING_NEXT_FROM_HASNEXT</findingType>
		<findingType>QBA_QUESTIONABLE_BOOLEAN_ASSIGNMENT</findingType>
		<findingType>GC_UNRELATED_TYPES</findingType>
		<findingType>WrongPackage</findingType>
		<findingType>ExceptionNotThrown</findingType>
		<findingType>UnrelatedTypesUsingPointerEquality</findingType>
		<findingType>BitSignedCheckHighBit</findingType>
		<findingType>DeadStoreOfClassLiteral</findingType>
		<findingType>AlwaysValueUsedWhereNeverRequired</findingType>
		<findingType>NeverValueUsedWhereAlwaysRequired</findingType>
		<findingType>MaybeSourceValueReachesAlwaysSink</findingType>
		<findingType>MaybeSourceValueReachesNeverSink</findingType>
		<name>Correctness</name>
		<description>
			Probable bug - an apparent coding mistake resulting in code
			that was probably not what the developer intended. We strive
			for a low false positive rate.
		</description>
	</category>
	<category>
		<id>Bad practice</id>
		<findingType>
			SwingMethodsShouldBeInvokedInSwingThread
		</findingType>
		<findingType>FI_FINALIZER_ONLY_NULLS_FIELDS</findingType>
		<findingType>FI_FINALIZER_NULLS_FIELDS</findingType>
		<findingType>UnsafeInheritanceOfGetResource</findingType>
		<findingType>CreatesEmptyZipFileEntry</findingType>
		<findingType>CreatesEmptyJarFileEntry</findingType>
		<findingType>
			DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED
		</findingType>
		<findingType>DP_DO_INSIDE_DO_PRIVILEGED</findingType>
		<findingType>MethodRequiresSecurityPermissionCheck</findingType>
		<findingType>
			ClassloaderCreationRequiresSecurityPermissionCheck
		</findingType>
		<findingType>
			AvoidCatchingIllegalStateMonitorException
		</findingType>
		<findingType>CloneMethodMustImplementCloneable</findingType>
		<findingType>NoSuperCloneCall</findingType>
		<findingType>MethodMightDropException</findingType>
		<findingType>MethodMightIgnoreException</findingType>
		<findingType>AvoidCallingSystemExit</findingType>
		<findingType>UseOfFutureKeywordAsIdentifier</findingType>
		<findingType>UseOfFutureKeywordAsMemberIdentifier</findingType>
		<findingType>AvoidCallingSystemRunFinalizersOnExit</findingType>
		<findingType>NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT</findingType>
		<findingType>
			SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE
		</findingType>
		<findingType>
			SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING
		</findingType>
		<findingType>EmptyFinalizer</findingType>
		<findingType>FI_NULLIFY_SUPER</findingType>
		<findingType>FinalizeOnlyCallsSuperFinalize</findingType>
		<findingType>FinalizeDoesNotCallSuperFinalize</findingType>
		<findingType>AvoidCallingFinalizeExplicitly</findingType>
		<findingType>EQ_SELF_USE_OBJECT</findingType>
		<findingType>EQ_SELF_NO_OBJECT</findingType>
		<findingType>NP_DOES_NOT_HANDLE_NULL</findingType>
		<findingType>CO_SELF_NO_OBJECT</findingType>
		<findingType>ES_COMPARING_STRINGS_WITH_EQ</findingType>
		<findingType>ES_COMPARING_PARAMETER_STRING_WITH_EQ</findingType>
		<findingType>EQ_COMPARETO_USE_OBJECT_EQUALS</findingType>
		<findingType>DefinesHashCodeUsesEquals</findingType>
		<findingType>DefinesHashcodeNotEquals</findingType>
		<findingType>DefinesEqualsUsesHashcode</findingType>
		<findingType>InheritsEqualsUsesHashCode</findingType>
		<findingType>OverridesEqualsNotHashcode</findingType>
		<findingType>EQ_ABSTRACT_SELF</findingType>
		<findingType>CO_ABSTRACT_SELF</findingType>
		<findingType>NS_NON_SHORT_CIRCUIT</findingType>
		<findingType>
			IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION
		</findingType>
		<findingType>SI_INSTANCE_BEFORE_FINALS_ASSIGNED</findingType>
		<findingType>IT_NO_SUCH_ELEMENT</findingType>
		<findingType>MethodNamingConventions</findingType>
		<findingType>FieldNamingConventions</findingType>
		<findingType>ClassNamingConventions</findingType>
		<findingType>NM_VERY_CONFUSING_INTENTIONAL</findingType>
		<findingType>NM_CONFUSING</findingType>
		<findingType>NM_CLASS_NOT_EXCEPTION</findingType>
		<findingType>RR_NOT_CHECKED</findingType>
		<findingType>SR_NOT_CHECKED</findingType>
		<findingType>SE_NO_SUITABLE_CONSTRUCTOR</findingType>
		<findingType>
			SE_NO_SUITABLE_CONSTRUCTOR_FOR_EXTERNALIZATION
		</findingType>
		<findingType>SE_COMPARATOR_SHOULD_BE_SERIALIZABLE</findingType>
		<findingType>SE_NO_SERIALVERSIONID</findingType>
		<findingType>SE_READ_RESOLVE_MUST_RETURN_OBJECT</findingType>
		<findingType>SE_TRANSIENT_FIELD_NOT_RESTORED</findingType>
		<findingType>SE_NONFINAL_SERIALVERSIONID</findingType>
		<findingType>SE_NONSTATIC_SERIALVERSIONID</findingType>
		<findingType>SE_NONLONG_SERIALVERSIONID</findingType>
		<findingType>SE_METHOD_MUST_BE_PRIVATE</findingType>
		<findingType>SE_BAD_FIELD</findingType>
		<findingType>SE_INNER_CLASS</findingType>
		<findingType>SE_BAD_FIELD_INNER_CLASS</findingType>
		<findingType>SE_BAD_FIELD_STORE</findingType>
		<findingType>NP_TOSTRING_COULD_RETURN_NULL</findingType>
		<findingType>NP_CLONE_COULD_RETURN_NULL</findingType>
		<findingType>OS_OPEN_STREAM</findingType>
		<findingType>OS_OPEN_STREAM_EXCEPTION_PATH</findingType>
		<findingType>ODR_OPEN_DATABASE_RESOURCE</findingType>
		<findingType>
			ODR_OPEN_DATABASE_RESOURCE_EXCEPTION_PATH
		</findingType>
		<findingType>ISC_INSTANTIATE_STATIC_CLASS</findingType>
		<findingType>DMI_RANDOM_USED_ONLY_ONCE</findingType>
		<findingType>
			BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS
		</findingType>
		<findingType>
			J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION
		</findingType>
		<findingType>SameSimpleNameAsInterface</findingType>
		<findingType>SameSimpleNameAsSuperclass</findingType>
		<findingType>WrongPackageIntentional</findingType>
		<findingType>ReturnValueIgnoredBadPractice</findingType>
		<findingType>BitSignedCheck</findingType>
		<findingType>BooleanMethodReturnsNull</findingType>
		<name>Bad practice</name>
		<description>
			Violations of recommended and essential coding practice.
			Examples include hash code and equals problems, cloneable
			idiom, dropped exceptions, Serializable problems, and misuse
			of finalize. We strive to make this analysis accurate,
			although some groups may not care about some of the bad
			practices.
		</description>
	</category>
	<category>
		<id>Dodgy</id>
		<findingType>ThreadPassedWhereRunnableExpected</findingType>
		<findingType>NP_IMMEDIATE_DEREFERENCE_OF_READLINE</findingType>
		<findingType>RV_REM_OF_RANDOM_INT</findingType>
		<findingType>RV_REM_OF_HASHCODE</findingType>
		<findingType>IC_INIT_CIRCULARITY</findingType>
		<findingType>
			IA_AMBIGUOUS_INVOCATION_OF_INHERITED_OR_OUTER_METHOD
		</findingType>
		<findingType>
			SE_TRANSIENT_FIELD_OF_NONSERIALIZABLE_CLASS
		</findingType>
		<findingType>SF_SWITCH_FALLTHROUGH</findingType>
		<findingType>QF_QUESTIONABLE_FOR_LOOP</findingType>
		<findingType>
			NP_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR
		</findingType>
		<findingType>
			UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR
		</findingType>
		<findingType>RV_CHECK_FOR_POSITIVE_INDEXOF</findingType>
		<findingType>
			NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE
		</findingType>
		<findingType>NP_LOAD_OF_KNOWN_NULL_VALUE</findingType>
		<findingType>PZLA_PREFER_ZERO_LENGTH_ARRAYS</findingType>
		<findingType>UCF_USELESS_CONTROL_FLOW</findingType>
		<findingType>
			RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE
		</findingType>
		<findingType>RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE</findingType>
		<findingType>
			RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
		</findingType>
		<findingType>
			RCN_REDUNDANT_COMPARISON_TWO_NULL_VALUES
		</findingType>
		<findingType>SA_LOCAL_SELF_ASSIGNMENT</findingType>
		<findingType>INT_VACUOUS_COMPARISON</findingType>
		<findingType>UOE_USE_OBJECT_EQUALS</findingType>
		<findingType>DLS_DEAD_LOCAL_STORE</findingType>
		<findingType>DLS_DEAD_LOCAL_STORE_OF_NULL</findingType>
		<findingType>REC_CATCH_EXCEPTION</findingType>
		<findingType>FE_FLOATING_POINT_EQUALITY</findingType>
		<findingType>CD_CIRCULAR_DEPENDENCY</findingType>
		<findingType>RI_REDUNDANT_INTERFACES</findingType>
		<findingType>MTIA_SUSPECT_STRUTS_INSTANCE_FIELD</findingType>
		<findingType>MTIA_SUSPECT_SERVLET_INSTANCE_FIELD</findingType>
		<findingType>PS_PUBLIC_SEMAPHORES</findingType>
		<findingType>ICAST_INTEGER_MULTIPLY_CAST_TO_LONG</findingType>
		<findingType>ICAST_IDIV_CAST_TO_DOUBLE</findingType>
		<findingType>BC_BAD_CAST_TO_CONCRETE_COLLECTION</findingType>
		<findingType>BC_UNCONFIRMED_CAST</findingType>
		<findingType>BC_VACUOUS_INSTANCEOF</findingType>
		<findingType>BC_BAD_CAST_TO_ABSTRACT_COLLECTION</findingType>
		<findingType>IM_BAD_CHECK_FOR_ODD</findingType>
		<findingType>IM_AVERAGE_COMPUTATION_COULD_OVERFLOW</findingType>
		<findingType>
			ICAST_QUESTIONABLE_UNSIGNED_RIGHT_SHIFT
		</findingType>
		<findingType>DMI_HARDCODED_ABSOLUTE_FILENAME</findingType>
		<findingType>DMI_USELESS_SUBSTRING</findingType>
		<findingType>
			ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD
		</findingType>
		<findingType>DMI_NONSERIALIZABLE_OBJECT_WRITTEN</findingType>
		<findingType>DB_DUPLICATE_BRANCHES</findingType>
		<findingType>DB_DUPLICATE_SWITCH_CLAUSES</findingType>
		<findingType>XFB_XML_FACTORY_BYPASS</findingType>
		<findingType>USM_USELESS_SUBCLASS_METHOD</findingType>
		<findingType>USM_USELESS_ABSTRACT_METHOD</findingType>
		<findingType>CI_CONFUSED_INHERITANCE</findingType>
		<findingType>DoesntOverrideEquals</findingType>
		<name>Dodgy</name>
		<description>
			code that is confusing, anomalous, or written in a way that
			leads itself to errors. Examples include dead local stores,
			switch fall through, unconfirmed casts, and redundant null
			check of value known to be null. More false positives
			accepted. In previous versions of FindBugs, this category
			was known as Style.
		</description>
	</category>
	<category>
		<id>Performance</id>
		<findingType>HSC_HUGE_SHARED_STRING_CONSTANT</findingType>
		<findingType>BlockingMethodsOnURL</findingType>
		<findingType>AvoidCollectionOfURLS</findingType>
		<findingType>InefficientStringConstructor</findingType>
		<findingType>InefficientStringVoidConstructor</findingType>
		<findingType>AvoidCallingtoStringOnString</findingType>
		<findingType>AvoidExplicitGarbageCollection</findingType>
		<findingType>InefficientBooleanConstructor</findingType>
		<findingType>InefficientNumberConstructor</findingType>
		<findingType>
			InefficientFloatingPointNumberConstructor
		</findingType>
		<findingType>UseStringLength</findingType>
		<findingType>BoxedPrimitiveToString</findingType>
		<findingType>BoxingImmediatelyUnboxed</findingType>
		<findingType>
			BoxingImmediatelyUnboxedToPerformCoercion
		</findingType>
		<findingType>
			AvoidAllocatingObjectForObtainingClassObject
		</findingType>
		<findingType>UseNextIntNotNextDoubleOfRandom</findingType>
		<findingType>SS_SHOULD_BE_STATIC</findingType>
		<findingType>UnusedField</findingType>
		<findingType>URF_UNREAD_FIELD</findingType>
		<findingType>SIC_INNER_SHOULD_BE_STATIC</findingType>
		<findingType>SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS</findingType>
		<findingType>SIC_INNER_SHOULD_BE_STATIC_ANON</findingType>
		<findingType>UPM_UNCALLED_PRIVATE_METHOD</findingType>
		<findingType>UseStringBufferForStringAppends</findingType>
		<findingType>ITA_INEFFICIENT_TO_ARRAY</findingType>
		<findingType>WMI_WRONG_MAP_ITERATOR</findingType>
		<findingType>UM_UNNECESSARY_MATH</findingType>
		<findingType>IMA_INEFFICIENT_MEMBER_ACCESS</findingType>
		<name>Performance</name>
		<description>
			code that is not necessarily incorrect but may be
			inefficient
		</description>
	</category>
	<category>
		<id>Malicious code vulnerability</id>
		<findingType>FinalizeShouldBeProtected</findingType>
		<findingType>
			PublicStaticMayExposeInternalRepresentation
		</findingType>
		<findingType>MayExposeInternalRepresentation</findingType>
		<findingType>MayExposeInternalRepresentation2</findingType>
		<findingType>MayExposeInternalStaticStatic</findingType>
		<findingType>
			FieldShouldBeOutOfInterfaceAndPackageProtected
		</findingType>
		<findingType>FieldShouldBeFinalAndPackageProtected</findingType>
		<findingType>FieldShouldBeFinal</findingType>
		<findingType>PackageProtectField</findingType>
		<findingType>MutableHashtable</findingType>
		<findingType>MutableArray</findingType>
		<findingType>CannotBeFinal</findingType>
		<findingType>HttpParameterWrittenToServlet</findingType>
		<findingType>HttpParameterWrittenToJSP</findingType>
		<name>Malicious code vulnerability</name>
		<description>
			code that is vulnerable to attacks from untrusted code
		</description>
	</category>
	<category>
		<id>Multithreaded correctness</id>
		<findingType>AvoidStaticCalendar</findingType>
		<findingType>AvoidStaticDateformat</findingType>
		<findingType>CallToStaticCalendar</findingType>
		<findingType>CallToStaticDateFormat</findingType>
		<findingType>SynchronizeAndNullCheckOnSameField</findingType>
		<findingType>VolatileReferenceToArray</findingType>
		<findingType>MonitorWaitOnCondition</findingType>
		<findingType>UselessThread</findingType>
		<findingType>PossibleDoubleCheckOfField</findingType>
		<findingType>SynchronizationOnSharedConstant</findingType>
		<findingType>EmptySynchronizationBlock</findingType>
		<findingType>InconsistentSynchronization2</findingType>
		<findingType>NakedNotifyCall</findingType>
		<findingType>InvokesRun</findingType>
		<findingType>MethodSpinsOnField</findingType>
		<findingType>WaitWithTwoLocks</findingType>
		<findingType>TwoLocksOnNotify</findingType>
		<findingType>UnconditionalWait</findingType>
		<findingType>SynchronizedSetUnsynchronizedGet</findingType>
		<findingType>InconsistentSynchronization</findingType>
		<findingType>FieldNotGuarded</findingType>
		<findingType>AvoidSynchronizationOnUpdatedField</findingType>
		<findingType>IncorrectSynchronizationOfWriteObject</findingType>
		<findingType>AvoidSynchronizationOfReadObject</findingType>
		<findingType>AvoidThreadStartInConstructor</findingType>
		<findingType>WaitNotInLoop</findingType>
		<findingType>AwaitNotInLoop</findingType>
		<findingType>UseNotifyAllInsteadOfNotify</findingType>
		<findingType>UnreleasedLock</findingType>
		<findingType>UnreleasedLockOnExceptionPath</findingType>
		<findingType>MismatchedWait</findingType>
		<findingType>MismatchedNotify</findingType>
		<findingType>IncorrectLazyInitializationOfInstance</findingType>
		<findingType>IncorrectLazyInitializationOfStatic</findingType>
		<findingType>AvoidCallingSynchronizedOnLock</findingType>
		<findingType>AvoidCallingSleepWithLockHeld</findingType>
		<findingType>LazyInitUpdateStatic</findingType>
		<name>Multithreaded correctness</name>
		<description>
			code flaws having to do with threads, locks, and volatiles
		</description>
	</category>
	<category>
		<id>Internationalization</id>
		<findingType>UseLocaleParameterizedVersion</findingType>
		<name>Internationalization</name>
		<description>
			code flaws having to do with internationalization and locale
		</description>
	</category>
</findingTypes>
