<findingTypes>

  <!-- NOTES: -->
  <!-- No whitespace in "name" or "shortMessage" tags -->
  <!-- Sentence case in "name" tags -->
  <!-- Sentences in "shortMessage" tags (no HTML) -->
  <!-- Use CDATA for "info" tags with HTML -->

  <findingType>
    <id>DuplicatedCode</id>
    <artifact tool="CPD"
	      mnemonic="DuplicatedCode">
    </artifact>
    <name>Suspected duplicated code</name>
    <shortMessage>Duplicated code often causes problems in long-term maintenance, due to flaws being fixed in one copy, but not the other.</shortMessage>
    <info>
<![CDATA[<p>This is often due to copy-and-paste programming, and it
often causes problems in long-term maintenance, due to flaws being
fixed in one copy, but not the other.</p>

<p>Consider refactoring this duplicated code into a single
method.</p>]]>
    </info>
  </findingType>

  <findingType>
    <id>DMI_VACUOUS_CALL_TO_EASYMOCK_METHOD</id>
    <artifact tool="FindBugs"	mnemonic="DMI_VACUOUS_CALL_TO_EASYMOCK_METHOD"/>
    <name>Useless/vacuous call to EasyMock method</name>
    <shortMessage>Useless/vacuous call to EasyMock method.</shortMessage>
    <info>
<![CDATA[<p>This call doesn't pass any objects to the EasyMock method,
so the call doesn't do anything.</p> <p>EasyMock provides Mock Objects
for interfaces in JUnit tests by generating them on the fly using
Java's proxy mechanism.  For more information please visit <a
href="http://www.easymock.org/">www.easymock.org</a>.</p>]]>
    </info>
  </findingType>

  <findingType>
    <id>HE_SIGNATURE_DECLARES_HASHING_OF_UNHASHABLE_CLASS</id>
    <artifact tool="FindBugs"	mnemonic="HE_SIGNATURE_DECLARES_HASHING_OF_UNHASHABLE_CLASS"/>
    <name>Signature declares use of unhashable class in hashed construct</name>
    <shortMessage>Signature declares use of unhashable class in hashed construct.</shortMessage>
    <info>
<![CDATA[<p> A method, field or class declares a generic signature
where a non-hashable class is used in context where a hashable class
is required.  A class that declares an <code>equals()</code> method
but inherits a <code>hashCode()</code> method from
<code>java.lang.Object</code> is unhashable, since it doesn't fulfill
the requirement that equal objects have equal hash codes.</p>]]>
    </info>
  </findingType>

  <findingType>
    <id>GC_UNCHECKED_TYPE_IN_GENERIC_CALL</id>
    <artifact tool="FindBugs"	mnemonic="GC_UNCHECKED_TYPE_IN_GENERIC_CALL"/>
    <name>Unchecked type in generic call</name>
    <shortMessage>Unchecked type in a generic call.  This could be a type mismatch that the compiler is not able to detect.</shortMessage>
    <info>
<![CDATA[<p>This call to a generic collection method passes an
argument of compile type <code>Object</code> where a specific type
from the generic type parameters is expected.  Thus, neither the
standard Java type system nor static analysis can provide useful
information on whether the object being passed as a parameter is of an
appropriate type.</p>

<p>An example of this finding is shown in the code snippet below.</p>

<pre>
final Object o = "1";
Set&lt;Integer&gt; intSet = new HashSet&lt;Integer&gt;();
intSet.remove(o);
</pre>

<p>In this case the call to remove <code>o</code> from the set
compiles because the <code>remove()</code> method takes an argument of
type <code>Object</code> rather than of the generic type (for
backwards compatibility).  In this example the call to
<code>remove()</code> can be safely deleted.  In general, it is
recommended to examine the finding and determine if it has identified
a type mismatch that the compiler was not able to report.</p>]]>
    </info>
  </findingType>

  <findingType>
    <id>SwingMethodsShouldBeInvokedInSwingThread</id>
    <artifact tool="FindBugs"
	      mnemonic="SW_SWING_METHODS_INVOKED_IN_SWING_THREAD">
    </artifact>
    <name>Swing methods should be invoked in Swing thread</name>
    <shortMessage>Certain Swing methods need to be invoked in the Swing event dispatch thread.</shortMessage>
    <info>
<![CDATA[<p>(<a
href="http://java.sun.com/developer/JDCTechTips/2003/tt1208.html#1">From
JDC Tech Tips</a>): The Swing methods <code>show()</code>,
<code>setVisible()</code>, and <code>pack()</code> will create the
associated peer for the frame. With the creation of the peer, the
system creates the event dispatch thread. This makes things
problematic because the event dispatch thread could be notifying
listeners while pack and validate are still processing. This situation
could result in two threads going through the Swing component-based
GUI&mdash;it's a serious flaw that could result in deadlocks or other
related threading issues. A pack call causes components to be
realized. As they are being realized (that is, not necessarily
visible), they could trigger listener notification on the event
dispatch thread.</p>

<p>Recommendations for thread safety have changed slightly since this
article was written. It is now recommended that you use
<code>invokeLater()</code> to create the GUI on the event-dispatching
thread, rather than constructing the GUI on the main thread.  So the
below code violates this recommendation.</p>

<pre>
import javax.swing.JButton;
import javax.swing.JFrame;

public class GUI extends JFrame {

  public GUI() {
    super("GUI");
    setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
    final JButton button = new JButton("Hello, Swing!");
    add(button);
    pack();
  }

  public static void main(String[] args) {
    final GUI gui = new GUI();
    gui.setVisible(true);
 }
}
</pre>

<p>At issue is the construction of the Swing objects and the call to
<code>setVisible()</code> in the main thread.  The below code fixes
the program by moving these actions onto the event dispatch
thread using the <code>invokeLater()</code> method.</p>

<pre>
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.SwingUtilities;

public class GUI extends JFrame {

  public GUI() {
    super("GUI");
    setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
    final JButton button = new JButton("Hello, Swing!");
    add(button);
    pack();
  }

  public static void main(String[] args) {
    SwingUtilities.invokeLater(new Runnable() {
      @Override public void run() {
        final GUI gui = new GUI();
        gui.setVisible(true);
      }
    });
  }
}
</pre>
]]>
    </info>
  </findingType>

  <findingType>
    <id>IL_INFINITE_LOOP</id>
    <artifact tool="FindBugs" mnemonic="IL_INFINITE_LOOP">
    </artifact>
    <name>Caught infinite loop</name>
    <shortMessage>An apparent infinite loop that doesn't seem to have a way to terminate.</shortMessage>
    <info>
<![CDATA[<p>This loop doesn't seem to have a way to terminate (other
than by perhaps throwing an exception).</p>]]>
    </info>
  </findingType>

  <findingType>
    <id>IL_INFINITE_RECURSIVE_LOOP</id>
    <artifact tool="FindBugs"
	      mnemonic="IL_INFINITE_RECURSIVE_LOOP">
    </artifact>
    <name>Caught infinite recursive loop</name>
    <shortMessage>An apparent infinite recursive loop that could result in a stack overflow.</shortMessage>
    <info>
<![CDATA[<p>This method unconditionally invokes itself. This would
seem to indicate an infinite recursive loop that will result in a
stack overflow.</p>]]>
    </info>
  </findingType>

  <findingType>
    <id>IL_CONTAINER_ADDED_TO_ITSELF</id>
    <artifact tool="FindBugs"
	      mnemonic="IL_CONTAINER_ADDED_TO_ITSELF">
    </artifact>
    <name>Container added to itself</name>
    <shortMessage>A container is added to itself, computing its hash code could throw a StackOverflowException.</shortMessage>
    <info>
<![CDATA[<p>A container is added to itself. As a result, computing the
hash code via <code>hashCode()</code> will throw a
StackOverflowException.</p>]]>
    </info>
  </findingType>

  <findingType>
    <id>VO_VOLATILE_REFERENCE_TO_ARRAY</id>
    <artifact tool="FindBugs"
	      mnemonic="VO_VOLATILE_REFERENCE_TO_ARRAY">
    </artifact>
    <name>Volatile reference to array</name>
    <shortMessage>A volatile reference to an array doesn't treat the array elements as volatile.  This could indicate a race condition.</shortMessage>
    <info>
<![CDATA[<p>This declares a volatile reference to an array, which
might not be what you want. With a volatile reference to an array,
reads and writes of the reference to the array are treated as
volatile, but the array elements are non-volatile. To get volatile
array elements, you will need to use one of the atomic array classes
in java.util.concurrent (provided in Java 5.0).<p>]]>
    </info>
  </findingType>

  <findingType>
    <id>UI_INHERITANCE_UNSAFE_GETRESOURCE</id>
    <artifact tool="FindBugs"
	      mnemonic="UI_INHERITANCE_UNSAFE_GETRESOURCE">
    </artifact>
    <name>Unsafe inheritance of the getResource method</name>
    <shortMessage>Usage of the getResource method may be unsafe if class is extended.</shortMessage>
    <info>
<![CDATA[<p>Calling <code>this.getClass().getResource(...)</code>
could give results other than expected if this class is extended by a
class in another package.</p>

<p>To prohibit extension of this class it can be declared to be
final.</p>]]>
    </info>
  </findingType>

  <findingType>
    <id>SynchronizeAndNullCheckOnSameField</id>
    <artifact tool="FindBugs"
	      mnemonic="NP_SYNC_AND_NULL_CHECK_FIELD">
    </artifact>
    <name>Synchronize and subsequent null check on the same field</name>
    <shortMessage>Synchronize and subsequent null check on the same field could indicate that a NullPointerException may be thrown.</shortMessage>
    <info>
<![CDATA[<p>This field is not likely to be <code>null</code> because
it is currently synchronized on. If the field is <code>null</code>
when it is synchronized then a <code>NullPointerException</code> will
be thrown and the subsequent check would be pointless.</p>

<p>This finding might indicated a muddled design or a lack of
understanding of Java semantics.</p>]]>
    </info>
  </findingType>

  <findingType>
    <id>TESTING</id>
    <artifact tool="FindBugs" mnemonic="TESTING"></artifact>
    <name>Generated from incomplete FindBugs detectors</name>
    <shortMessage>This bug pattern is only generated by new, incompletely implemented bug detectors in FindBugs.</shortMessage>
    <info>
<![CDATA[<p>This bug pattern is only generated by new, incompletely
implemented bug detectors in FindBugs.</p>]]>
    </info>
  </findingType>

  <findingType>
    <id>UNKNOWN</id>
    <artifact tool="FindBugs" mnemonic="UNKNOWN"></artifact>
    <name>Unknown FindBugs bug pattern</name>
    <shortMessage>A warning was recorded for an unknown FindBugs bug pattern.</shortMessage>
    <info>
<![CDATA[<p>A warning was recorded, but FindBugs can't find the
description of this bug pattern and so can't describe it.  This should
occur only in cases of a bug in FindBugs or its configuration, or
perhaps if an analysis was generated using a plugin, but that plugin
is not currently loaded.</p>]]>
    </info>
  </findingType>

  <findingType>
    <id>AM_CREATES_EMPTY_ZIP_FILE_ENTRY</id>
    <artifact tool="FindBugs"
	      mnemonic="AM_CREATES_EMPTY_ZIP_FILE_ENTRY">
    </artifact>
    <name>Creates empty Zip file entry</name>
    <shortMessage>Creates an empty Zip file entry</shortMessage>
    <info>
<![CDATA[<p>The code calls <code>putNextEntry()</code>, immediately
followed by a call to <code>closeEntry()</code>.  This results in an
empty ZipFile entry. The contents of the entry should be written to
the ZipFile between the calls to <code>putNextEntry()</code> and
<code>closeEntry()</code>.</p>]]>
    </info>
  </findingType>

  <findingType>
    <id>AM_CREATES_EMPTY_JAR_FILE_ENTRY</id>
    <artifact tool="FindBugs"
	      mnemonic="AM_CREATES_EMPTY_JAR_FILE_ENTRY">
    </artifact>
    <name>Creates empty Jar file entry</name>
    <shortMessage>Creates an empty Jar file entry</shortMessage>
    <info>
<![CDATA[<p>The code calls <code>putNextEntry()</code>, immediately
followed by a call to <code>closeEntry()</code>.  This results in an
empty JarFile entry. The contents of the entry should be written to
the JarFile between the calls to <code>putNextEntry()</code> and
<code>closeEntry()</code>.</p>]]>
    </info>
  </findingType>

  <findingType>
    <id>IMSE_DONT_CATCH_IMSE</id>
    <artifact tool="FindBugs" mnemonic="IMSE_DONT_CATCH_IMSE">
    </artifact>
    <name>Avoid catching IllegalStateMonitorException</name>
    <shortMessage>Dubious code that is catching IllegalMonitorStateException may be masking a design flaw in your code.</shortMessage>
    <info>
<![CDATA[<p>IllegalMonitorStateException is generally only thrown in
case of a design flaw in your code&mdash;calling wait or notify on an
object you do not hold a lock on.</p>

<p>It is recommended that this catch be removed from your code and the
design flaw fixed.</p>]]>
    </info>
  </findingType>

  <findingType>
    <id>FL_MATH_USING_FLOAT_PRECISION</id>
    <artifact tool="FindBugs"
	      mnemonic="FL_MATH_USING_FLOAT_PRECISION">
    </artifact>
    <name>Avoid using float type for math operations</name>
    <shortMessage>Method performs math using floating point precision, consider using double precision instead.</shortMessage>
    <info>
<![CDATA[<p>The method performs math operations using floating point
precision. Floating point precision is very imprecise.  For example,
16777216.0f + 1.0f = 16777216.0f.</p>

<p>Consider using double precision math instead. To do this change
<code>float</code> type variables to <code>double</code> type
variables and avoid the <code>f</code> prefix on floating point
constants.</p>]]>
    </info>
  </findingType>

  <findingType>
    <id>CN_IDIOM</id>
    <artifact tool="FindBugs" mnemonic="CN_IDIOM"></artifact>
    <artifact tool="PMD"
	      mnemonic="CloneMethodMustImplementCloneable">
    </artifact>
    <name>Clone method must implement Cloneable</name>
    <shortMessage>This class implements Cloneable but does not define or use clone method.</shortMessage>
    <info>
<![CDATA[<p>This class implements the <code>Cloneable</code> interface
but does not define or use the <code>clone()</code> method.  A class
that implements <code>Cloneable</code> is expected to provide a
properly functioning public <code>clone()</code> method.</p>

<p>The method <code>clone()</code> should only be implemented if the
class implements the <code>Cloneable</code> interface with the
exception of a final method that only throws
<code>CloneNotSupportedException</code>.</p>

<p>Overall it is considered bad practice to use the extralinguistic
clone mechanism (reference Bloch's Effective Java (2nd edition) item
11).  A copy constructor is one alternative approach.</p>

<pre>
public MyClass(MyClass o) { ... }
</pre>

<p> A copy factory is another alternative approach.</p>

<pre>
public static MyClass newInstance(MyClass o) { ... }
</pre>

<p>Either one of these alternatives is considered better practice in
modern Java programs.</p>]]>
    </info>
  </findingType>

  <findingType>
    <id>CN_IDIOM_NO_SUPER_CALL</id>
    <artifact tool="FindBugs" mnemonic="CN_IDIOM_NO_SUPER_CALL">
    </artifact>
    <artifact tool="PMD" mnemonic="ProperCloneImplementation">
    </artifact>
    <name>No super.clone() call in clone method</name>
    <shortMessage>This non-final class defines a clone method that does not call super.clone().</shortMessage>
    <info>
<![CDATA[<p>This non-final class defines a <code>clone()</code> method
that does not call <code>super.clone()</code>. If this class, which we
will call <code>A</code>, is extended by a subclass <code>B</code>,
and the subclass <code>B</code> calls <code>super.clone()</code>, then
it is likely that <code>B</code>'s <code>clone()</code> method will
return an object of type <code>A</code>, which violates the contract
for <code>clone()</code>.</p>

<p>If all <code>clone()</code> methods call
<code>super.clone()</code>, then they are guaranteed to use
<code>Object.clone()</code>, which always returns an object of the
correct type.</p>

<p>Overall it is considered bad practice to use the extralinguistic
clone mechanism (reference Bloch's Effective Java (2nd edition) item
11).  A copy constructor is one alternative approach.</p>

<pre>
public MyClass(MyClass o) { ... }
</pre>

<p> A copy factory is another alternative approach.</p>

<pre>
public static MyClass newInstance(MyClass o) { ... }
</pre>

<p>Either one of these alternatives is considered better practice in
modern Java programs.</p>]]>
    </info>
  </findingType>

  <findingType>
    <id>NM_FUTURE_KEYWORD_USED_AS_IDENTIFIER</id>
    <artifact tool="FindBugs"
	      mnemonic="NM_FUTURE_KEYWORD_USED_AS_IDENTIFIER">
    </artifact>
    <name>Use of a future keyword as identifier</name>
    <shortMessage>Use of an identifier that is a keyword in later versions of Java.</shortMessage>
    <info>
<![CDATA[<p>The identifier is a word that is reserversed as a keyword
in later versions of Java, and your code will need to be changed in
order for it to compile in later versions of Java.</p>]]>
    </info>
  </findingType>

  <findingType>
    <id>NM_FUTURE_KEYWORD_USED_AS_MEMBER_IDENTIFIER</id>
    <artifact tool="FindBugs"
	      mnemonic="NM_FUTURE_KEYWORD_USED_AS_MEMBER_IDENTIFIER">
    </artifact>
    <name>Use of a future keyword as a member identifier</name>
    <shortMessage>Use of an identifier that is a keyword in later versions of Java.</shortMessage>
    <info>
<![CDATA[<p>This identifier is a word that is used as a keyword in
later versions of Java. This code, and any code that references this
API, will need to be changed in order for it to compile in later
versions of Java.</p>]]>
    </info>
  </findingType>

  <findingType>
    <id>DE_MIGHT_DROP</id>
    <artifact tool="FindBugs" mnemonic="DE_MIGHT_DROP"></artifact>
    <name>Method might drop an exception</name>
    <shortMessage>Method might drop an exception.</shortMessage>
    <info>
<![CDATA[<p>This method might drop an exception that may indicate a
serious problem has occurred in the running program. In general,
exceptions should be handled or reported in some way, or they should
be thrown out of the method.</p>]]>
    </info>
  </findingType>

  <findingType>
    <id>DE_MIGHT_IGNORE</id>
    <artifact tool="FindBugs" mnemonic="DE_MIGHT_IGNORE"></artifact>
    <name>Method might ignore an exception</name>
    <shortMessage>Method might ignore an exception.</shortMessage>
    <info>
<![CDATA[<p>This method might ignore an exception that my indicate a
serious problem has occurred in the running program. In general,
exceptions should be handled or reported in some way, or they should
be thrown out of the method.</p>]]>
    </info>
  </findingType>

  <findingType>
    <id>DP_DO_INSIDE_DO_PRIVILEGED</id>
    <artifact tool="FindBugs"
	      mnemonic="DP_DO_INSIDE_DO_PRIVILEGED"></artifact>
    <artifact tool="FindBugs" mnemonic="DP_DO_INSIDE_DO_PRIVILEDGED"></artifact>
    <name>Method requires security permission check</name>
    <shortMessage>Method is invoked that should be only be invoked inside a doPrivileged block.</shortMessage>
    <info>
<![CDATA[<p>This code invokes a method that requires a security
permission check. If this code will be granted security permissions,
but might be invoked by code that does not have security permissions,
then the invocation needs to occur inside a <code>doPrivileged</code>
block.</p>]]>
    </info>
  </findingType>

  <findingType>
    <id>DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED</id>
    <artifact tool="FindBugs"
	      mnemonic="DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED"></artifact>
    <artifact tool="FindBugs"
	      mnemonic="DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEDGED"></artifact>
    <name>Classloader creation requires security permission check</name>
    <shortMessage>Classloaders should only be created inside a doPrivileged block.</shortMessage>
    <info>
<![CDATA[<p>This code creates a classloader, which requires a security
manager. If this code will be granted security permissions, but might
be invoked by code that does not have security permissions, then the
classloader creation needs to occur inside a <code>doPrivileged</code>
block.</p>]]>
    </info>
  </findingType>

  <findingType>
    <id>FieldIsntFinalInImmutableClass</id>
    <artifact tool="FindBugs"
	      mnemonic="JCIP_FIELD_ISNT_FINAL_IN_IMMUTABLE_CLASS">
    </artifact>
    <shortMessage>
      Fields of immutable classes should be final
    </shortMessage>
    <info>
      &lt;p&gt; The class is annotated with
      net.jcip.annotations.Immutable, and the rules for that
      annotation require that all fields are final. .&lt;/p&gt;
    </info>
    <name>Field Isn't Final In Immutable Class</name>
  </findingType>
  <findingType>
    <id>ThreadPassedWhereRunnableExpected</id>
    <artifact tool="FindBugs"
	      mnemonic="DMI_THREAD_PASSED_WHERE_RUNNABLE_EXPECTED">
    </artifact>
    <shortMessage>
      Thread passed where Runnable expected
    </shortMessage>
    <info>
      &lt;p&gt; A Thread object is passed as a parameter to a
      method where a Runnable is expected. This is rather unusual,
      and may indicate a logic error or cause unexpected behavior.
      &lt;/p&gt;
    </info>
    <name>Thread Passed Where Runnable Expected</name>
  </findingType>
  <findingType>
    <id>AvoidCollectionOfURLS</id>
    <artifact tool="FindBugs" mnemonic="DMI_COLLECTION_OF_URLS">
    </artifact>
    <shortMessage>
      Maps and sets of URLs can be performance hogs
    </shortMessage>
    <info>
      &lt;p&gt; This method or field is or uses a Map or Set of
      URLs. Since both the equals and hashCode method of URL
      perform domain name resolution, this can result in a big
      performance hit. See &lt;a
      href=&quot;http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html&quot;&gt;http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html&lt;/a&gt;
      for more information. Consider using
      &lt;code&gt;java.net.URI&lt;/code&gt; instead. &lt;/p&gt;
    </info>
    <name>Avoid Collection Of URLs</name>
  </findingType>
  <findingType>
    <id>BlockingMethodsOnURL</id>
    <artifact tool="FindBugs"
	      mnemonic="DMI_BLOCKING_METHODS_ON_URL">
    </artifact>
    <shortMessage>
      The equals and hashCode methods of URL are blocking
    </shortMessage>
    <info>
      &lt;p&gt; The equals and hashCode method of URL perform
      domain name resolution, this can result in a big performance
      hit. See &lt;a
      href=&quot;http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html&quot;&gt;http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html&lt;/a&gt;
      for more information. Consider using
      &lt;code&gt;java.net.URI&lt;/code&gt; instead. &lt;/p&gt;
    </info>
    <name>Blocking Methods On URL</name>
  </findingType>
  <findingType>
    <id>AnnotationIsNotVisibleToReflection</id>
    <artifact tool="FindBugs"
	      mnemonic="DMI_ANNOTATION_IS_NOT_VISIBLE_TO_REFLECTION">
    </artifact>
    <shortMessage>
      Can't use reflection to check for presence of annotation
      with default retention
    </shortMessage>
    <info>
      &lt;p&gt; Unless an annotation has itself been annotated
      with a @Retention other than the default of source-only
      retention, the annotation isn't retained in the classfile
      and can't be observed using reflection (e.g., by using the
      isAnnotationPresent method). .&lt;/p&gt;
    </info>
    <name>Annotation Is Not Visible To Reflection</name>
  </findingType>
  <findingType>
    <id>AvoidCallingSystemExit</id>
    <artifact tool="FindBugs" mnemonic="DM_EXIT"></artifact>
    <shortMessage>Method invokes System.exit(...)</shortMessage>
    <info>
      &lt;p&gt; Invoking System.exit shuts down the entire Java
      virtual machine. This should only been done when it is
      appropriate. Such calls make it hard or impossible for your
      code to be invoked by other code. Consider throwing a
      RuntimeException instead.&lt;/p&gt;
    </info>
    <name>Avoid Calling System.exit(...)</name>
  </findingType>
  <findingType>
    <id>AvoidCallingSystemRunFinalizersOnExit</id>
    <artifact tool="FindBugs"
	      mnemonic="DM_RUN_FINALIZERS_ON_EXIT">
    </artifact>
    <shortMessage>
      Method invokes dangerous method runFinalizersOnExit
    </shortMessage>
    <info>
      &lt;p&gt; &lt;em&gt;Never call System.runFinalizersOnExit or
      Runtime.runFinalizersOnExit for any reason: they are among
      the most dangerous methods in the Java libraries.&lt;/em&gt;
      -- Joshua Bloch&lt;/p&gt;
    </info>
    <name>Avoid Calling System.runFinalizersOnExit()</name>
  </findingType>
  <findingType>
    <id>InefficientStringConstructor</id>
    <artifact tool="FindBugs" mnemonic="DM_STRING_CTOR"></artifact>
    <artifact tool="PMD" mnemonic="StringInstantiation"></artifact>
    <artifact tool="FindBugs" mnemonic="DM_STRING_VOID_CTOR">
    </artifact>
    <shortMessage>
      Method invokes inefficient new String(String) constructor
    </shortMessage>
    <info>
      &lt;p&gt; Using the
      &lt;code&gt;java.lang.String(String)&lt;/code&gt;
      constructor wastes memory because the object so constructed
      will be functionally indistinguishable from the
      &lt;code&gt;String&lt;/code&gt; passed as a
      parameter.&amp;nbsp; Just use the argument
      &lt;code&gt;String&lt;/code&gt; directly.&lt;/p&gt;

      Avoid instantiating String objects; this is usually
      unnecessary.

      &lt;p&gt; Creating a new
      &lt;code&gt;java.lang.String&lt;/code&gt; object using the
      no-argument constructor wastes memory because the object so
      created will be functionally indistinguishable from the
      empty string constant
      &lt;code&gt;&quot;&quot;&lt;/code&gt;.&amp;nbsp; Java
      guarantees that identical string constants will be
      represented by the same &lt;code&gt;String&lt;/code&gt;
      object.&amp;nbsp; Therefore, you should just use the empty
      string constant directly.&lt;/p&gt;
    </info>
    <name>Inefficient String Constructor</name>
  </findingType>
  <findingType>
    <id>AvoidCallingtoStringOnString</id>
    <artifact tool="FindBugs" mnemonic="DM_STRING_TOSTRING">
    </artifact>
    <shortMessage>
      Method invokes toString() method on a String
    </shortMessage>
    <info>
      &lt;p&gt; Calling &lt;code&gt;String.toString()&lt;/code&gt;
      is just a redundant operation. Just use the
      String.&lt;/p&gt;
    </info>
    <name>Avoid Calling toString() On String</name>
  </findingType>
  <findingType>
    <id>AvoidExplicitGarbageCollection</id>
    <artifact tool="FindBugs" mnemonic="DM_GC"></artifact>
    <artifact tool="PMD" mnemonic="DoNotCallGarbageCollectionExplicitly"/>
    <shortMessage>
      Explicit garbage collection; extremely dubious except in
      benchmarking code
    </shortMessage>
    <info>
      &lt;p&gt; Code explicitly invokes garbage collection. Except
      for specific use in benchmarking, this is very
      dubious.&lt;/p&gt; &lt;p&gt;In the past, situations where
      people have explicitly invoked the garbage collector in
      routines such as close or finalize methods has led to huge
      performance black holes. Garbage collection can be
      expensive. Any situation that forces hundreds or thousands
      of garbage collections will bring the machine to a
      crawl.&lt;/p&gt;
    </info>
    <name>Avoid Explicit Garbage Collection</name>
  </findingType>
  <findingType>
    <id>InefficientBooleanConstructor</id>
    <artifact tool="FindBugs" mnemonic="DM_BOOLEAN_CTOR"></artifact>
    <shortMessage>
      Method invokes inefficient Boolean constructor; use
      Boolean.valueOf(...) instead
    </shortMessage>
    <info>
      &lt;p&gt; Creating new instances of
      &lt;code&gt;java.lang.Boolean&lt;/code&gt; wastes memory,
      since &lt;code&gt;Boolean&lt;/code&gt; objects are immutable
      and there are only two useful values of this type.&amp;nbsp;
      Use the &lt;code&gt;Boolean.valueOf()&lt;/code&gt; method
      (or Java 1.5 autoboxing) to create
      &lt;code&gt;Boolean&lt;/code&gt; objects instead.&lt;/p&gt;
    </info>
    <name>Inefficient Boolean Constructor</name>
  </findingType>
  <findingType>
    <id>InefficientNumberConstructor</id>
    <artifact tool="FindBugs" mnemonic="DM_NUMBER_CTOR"></artifact>
    <artifact tool="PMD" mnemonic="IntegerInstantiation"></artifact>
    <shortMessage>
      Method invokes inefficient Number constructor; use static
      valueOf instead
    </shortMessage>
    <info>
      &lt;p&gt; Using &lt;code&gt;new Integer(int)&lt;/code&gt; is
      guaranteed to always result in a new object whereas
      &lt;code&gt;Integer.valueOf(int)&lt;/code&gt; allows caching
      of values to be done by the compiler, class library, or JVM.
      Using of cached values avoids object allocation and the code
      will be faster. &lt;/p&gt; &lt;p&gt; Values between -128 and
      127 are guaranteed to have corresponding cached instances
      and using &lt;code&gt;valueOf&lt;/code&gt; is approximately
      3.5 times faster than using constructor. For values outside
      the constant range the performance of both styles is the
      same. &lt;/p&gt; &lt;p&gt; Unless the class must be
      compatible with JVMs predating Java 1.5, use either
      autoboxing or the &lt;code&gt;valueOf()&lt;/code&gt; method
      when creating instances of &lt;code&gt;Long&lt;/code&gt;,
      &lt;code&gt;Integer&lt;/code&gt;,
      &lt;code&gt;Short&lt;/code&gt;,
      &lt;code&gt;Character&lt;/code&gt;, and
      &lt;code&gt;Byte&lt;/code&gt;. &lt;/p&gt;

      In JDK 1.5, calling new Integer() causes memory allocation.
      Integer.valueOf() is more memory friendly.
    </info>
    <name>Inefficient Number Constructor</name>
  </findingType>
  <findingType>
    <id>InefficientFloatingPointNumberConstructor</id>
    <artifact tool="FindBugs" mnemonic="DM_FP_NUMBER_CTOR">
    </artifact>
    <shortMessage>
      Method invokes inefficient floating-point Number
      constructor; use static valueOf instead
    </shortMessage>
    <info>
      &lt;p&gt; Using &lt;code&gt;new Double(double)&lt;/code&gt;
      is guaranteed to always result in a new object whereas
      &lt;code&gt;Double.valueOf(double)&lt;/code&gt; allows
      caching of values to be done by the compiler, class library,
      or JVM. Using of cached values avoids object allocation and
      the code will be faster. &lt;/p&gt; &lt;p&gt; Unless the
      class must be compatible with JVMs predating Java 1.5, use
      either autoboxing or the &lt;code&gt;valueOf()&lt;/code&gt;
      method when creating instances of
      &lt;code&gt;Double&lt;/code&gt; and
      &lt;code&gt;Float&lt;/code&gt;. &lt;/p&gt;
    </info>
    <name>Inefficient Floating-Point Number Constructor</name>
  </findingType>
  <findingType>
    <id>UseStringLength</id>
    <artifact tool="FindBugs" mnemonic="DM_STRING_EMPTY_EQUALS">
    </artifact>
    <shortMessage>
      Method invokes inefficient String.equals(&quot;&quot;); use
      String.length() == 0 instead
    </shortMessage>
    <info>
      &lt;p&gt; An object is compared to the empty String object
      using the equals() method here. Checking that the String
      object's length is zero may be faster, and removes String
      constants from the class file.&lt;/p&gt;
    </info>
    <name>Use String Length</name>
  </findingType>
  <findingType>
    <id>UseLocaleParameterizedVersion</id>
    <artifact tool="FindBugs" mnemonic="DM_CONVERT_CASE"></artifact>
    <shortMessage>
      Consider using Locale parameterized version of invoked
      method
    </shortMessage>
    <info>
      &lt;p&gt; A String is being converted to upper or lowercase,
      using the platform's default encoding. This may result in
      improper conversions when used with international
      characters. Use the &lt;/p&gt;
      &lt;table&gt;&lt;tr&gt;&lt;td&gt;String.toUpperCase( Locale
      l
      )&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;String.toLowerCase(
      Locale l )&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
      &lt;p&gt;versions instead.&lt;/p&gt;
    </info>
    <name>Use Locale Parameterized Version</name>
  </findingType>
  <findingType>
    <id>UnboxedAndCoercedForTernaryOperator</id>
    <artifact tool="FindBugs"
	      mnemonic="BX_UNBOXED_AND_COERCED_FOR_TERNARY_OPERATOR">
    </artifact>
    <shortMessage>
      Primitive value is unboxed and coerced for ternary operator
    </shortMessage>
    <info>
      &lt;p&gt;A wrapped primative value is unboxed and converted
      to another primative type as part of the evaluation of a
      conditional ternary operator (the &lt;code&gt; b ? e1 :
      e2&lt;/code&gt; operator). The semantics of Java mandate
      that if &lt;code&gt;e1&lt;/code&gt; and
      &lt;code&gt;e2&lt;/code&gt; are wrapped numeric values, the
      values are unboxed and converted/coerced to their common
      type (e.g, if &lt;code&gt;e1&lt;/code&gt; is of type
      &lt;code&gt;Integer&lt;/code&gt; and
      &lt;code&gt;e2&lt;/code&gt; is of type
      &lt;code&gt;Float&lt;/code&gt;, then
      &lt;code&gt;e1&lt;/code&gt; is unboxed, converted to a
      floating point value, and boxed. See JLS Section 15.25.
      &lt;/p&gt;
    </info>
    <name>Unboxed And Coerced For Ternary Operator</name>
  </findingType>
  <findingType>
    <id>BoxingImmediatelyUnboxed</id>
    <artifact tool="FindBugs"
	      mnemonic="BX_BOXING_IMMEDIATELY_UNBOXED">
    </artifact>
    <shortMessage>
      Primitive value is boxed and then immediately unboxed
    </shortMessage>
    <info>
      &lt;p&gt;A primitive is boxed, and then immediately unboxed.
      This probably is due to a manual boxing in a place where an
      unboxed value is required, thus forcing the compiler to
      immediately undue the work of the boxing. &lt;/p&gt;
    </info>
    <name>Boxing Immediately Unboxed</name>
  </findingType>
  <findingType>
    <id>BoxingImmediatelyUnboxedToPerformCoercion</id>
    <artifact tool="FindBugs"
	      mnemonic="BX_BOXING_IMMEDIATELY_UNBOXED_TO_PERFORM_COERCION">
    </artifact>
    <shortMessage>
      Primitive value is boxed then unboxed to perform primative
      coercion
    </shortMessage>
    <info>
      &lt;p&gt;A primitive boxed value constructed and then
      immediately converted into a different primitive type (e.g.,
      &lt;code&gt;new Double(d).intValue()&lt;/code&gt;). Just
      perform direct primitive coercion (e.g., &lt;code&gt;(int)
      d&lt;/code&gt;).&lt;/p&gt;
    </info>
    <name>Boxing Immediately Unboxed To Perform Coercion</name>
  </findingType>
  <findingType>
    <id>BoxedPrimitiveToString</id>
    <artifact tool="FindBugs"
	      mnemonic="DM_BOXED_PRIMITIVE_TOSTRING">
    </artifact>
    <shortMessage>
      Method allocates a boxed primitive just to call toString
    </shortMessage>
    <info>
      &lt;p&gt;A boxed primitive is allocated just to call
      toString(). It is more effective to just use the static form
      of toString which takes the primitive value. So,&lt;/p&gt;
      &lt;table&gt;
      &lt;tr&gt;&lt;th&gt;Replace...&lt;/th&gt;&lt;th&gt;With
      this...&lt;/th&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;new
      Integer(1).toString()&lt;/td&gt;&lt;td&gt;Integer.toString(1)&lt;/td&gt;&lt;/tr&gt;
      &lt;tr&gt;&lt;td&gt;new
      Long(1).toString()&lt;/td&gt;&lt;td&gt;Long.toString(1)&lt;/td&gt;&lt;/tr&gt;
      &lt;tr&gt;&lt;td&gt;new
      Float(1.0).toString()&lt;/td&gt;&lt;td&gt;Float.toString(1.0)&lt;/td&gt;&lt;/tr&gt;
      &lt;tr&gt;&lt;td&gt;new
      Double(1.0).toString()&lt;/td&gt;&lt;td&gt;Double.toString(1.0)&lt;/td&gt;&lt;/tr&gt;
      &lt;tr&gt;&lt;td&gt;new
      Byte(1).toString()&lt;/td&gt;&lt;td&gt;Byte.toString(1)&lt;/td&gt;&lt;/tr&gt;
      &lt;tr&gt;&lt;td&gt;new
      Short(1).toString()&lt;/td&gt;&lt;td&gt;Short.toString(1)&lt;/td&gt;&lt;/tr&gt;
      &lt;tr&gt;&lt;td&gt;new
      Boolean(true).toString()&lt;/td&gt;&lt;td&gt;Boolean.toString(true)&lt;/td&gt;&lt;/tr&gt;
      &lt;/table&gt;
    </info>
    <name>Boxed Primitive toString</name>
  </findingType>
  <findingType>
    <id>AvoidAllocatingObjectForObtainingClassObject</id>
    <artifact tool="FindBugs" mnemonic="DM_NEW_FOR_GETCLASS">
    </artifact>
    <shortMessage>
      Method allocates an object, only to get the class object
    </shortMessage>
    <info>
      &lt;p&gt;This method allocates an object just to call
      getClass() on it, in order to retrieve the Class object for
      it. It is simpler to just access the .class property of the
      class.&lt;/p&gt;
    </info>
    <name>Avoid Allocating Object For Obtaining Class Object</name>
  </findingType>
  <findingType>
    <id>MonitorWaitOnCondition</id>
    <artifact tool="FindBugs"
	      mnemonic="DM_MONITOR_WAIT_ON_CONDITION">
    </artifact>
    <shortMessage>Monitor wait() called on Condition</shortMessage>
    <info>
      &lt;p&gt; This method calls &lt;code&gt;wait()&lt;/code&gt;
      on a
      &lt;code&gt;java.util.concurrent.locks.Condition&lt;/code&gt;
      object.&amp;nbsp; Waiting for a
      &lt;code&gt;Condition&lt;/code&gt; should be done using one
      of the &lt;code&gt;await()&lt;/code&gt; methods defined by
      the &lt;code&gt;Condition&lt;/code&gt; interface. &lt;/p&gt;
    </info>
    <name>Monitor Wait On Condition</name>
  </findingType>
  <findingType>
    <id>RandomValue01ToInt</id>
    <artifact tool="FindBugs" mnemonic="RV_01_TO_INT"></artifact>
    <shortMessage>
      Random value from 0 to 1 is coerced to the integer 0
    </shortMessage>
    <info>
      &lt;p&gt;A random value from 0 to 1 is being coerced to the
      integer value 0. You probably want to multiple the random
      value by something else before coercing it to an integer, or
      use the Random.nextInt(n) method. &lt;/p&gt;
    </info>
    <name>01 To Int</name>
  </findingType>
  <findingType>
    <id>UseNextIntNotNextDoubleOfRandom</id>
    <artifact tool="FindBugs"
	      mnemonic="DM_NEXTINT_VIA_NEXTDOUBLE">
    </artifact>
    <shortMessage>
      Use the nextInt method of Random rather than nextDouble to
      generate a random integer
    </shortMessage>
    <info>
      &lt;p&gt;If r is a java.util.Random, you can generate a
      random number from 0 to n-1 using r.nextInt(n) Rather than
      using (int)(r.nextDouble() * n). &lt;/p&gt;
    </info>
    <name>Use nextInt Not nextDouble Of Random</name>
  </findingType>
  <findingType>
    <id>SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE</id>
    <artifact tool="FindBugs"
	      mnemonic="SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE">
    </artifact>
    <shortMessage>
      Nonconstant string passed to execute method on an SQL
      statement
    </shortMessage>
    <info>
      &lt;p&gt;The method invokes the execute method on an SQL
      statement with a String that seems to be dynamically
      generated. Consider using a prepared statement instead. It
      is more efficient and less vulnerable to SQL injection
      attacks. &lt;/p&gt;
    </info>
    <name>Nonconstant String Passed To Execute</name>
  </findingType>
  <findingType>
    <id>
      SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING
    </id>
    <artifact tool="FindBugs"
	      mnemonic="SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING">
    </artifact>
    <shortMessage>
      A prepared statement is generated from a nonconstant String
    </shortMessage>
    <info>
      &lt;p&gt;The code creates an SQL prepared statement from a
      nonconstant String. If unchecked, tainted data from a user
      is used in building this String, SQL injection could be used
      to make the prepared statement do something unexpected and
      undesirable. &lt;/p&gt;
    </info>
    <name>
      Prepared Statement Generated From Nonconstant String
    </name>
  </findingType>
  <findingType>
    <id>UselessThread</id>
    <artifact tool="FindBugs" mnemonic="DM_USELESS_THREAD">
    </artifact>
    <shortMessage>
      A thread was created using the default empty run method
    </shortMessage>
    <info>
      &lt;p&gt;This method creates a thread without specifying a
      run method either by deriving from the Thread class, or by
      passing a Runnable object. This thread, then, does nothing
      but waste time. &lt;/p&gt;
    </info>
    <name>Useless Thread</name>
  </findingType>
  <findingType>
    <id>PossibleDoubleCheckOfField</id>
    <artifact tool="FindBugs" mnemonic="DC_DOUBLECHECK"></artifact>
    <artifact tool="PMD" mnemonic="DoubleCheckedLocking"></artifact>
    <shortMessage>Possible double check of field</shortMessage>
    <info>
      &lt;p&gt; This method may contain an instance of
      double-checked locking.&amp;nbsp; This idiom is not correct
      according to the semantics of the Java memory
      model.&amp;nbsp; For more information, see the web page
      &lt;a
      href=&quot;http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html&quot;
      &gt;http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html&lt;/a&gt;
      as well as &lt;a
      href=&quot;http://www.javaworld.com/javaworld/jw-02-2001/jw-0209-double.html&quot;
      &gt;http://www.javaworld.com/javaworld/jw-02-2001/jw-0209-double.html&lt;/a&gt;
      .&lt;/p&gt;
    </info>
    <name>Double-checked Locking</name>
  </findingType>
  <findingType>
    <id>FI_FINALIZER_NULLS_FIELDS</id>
    <artifact tool="FindBugs"
	      mnemonic="FI_FINALIZER_NULLS_FIELDS">
    </artifact>
    <shortMessage>Finalizer nulls fields</shortMessage>
    <info>
      &lt;p&gt; This finalizer nulls out fields. This is usually
      an error, as it does not aid garbage collection, and the
      object is going to be garbage collected anyway.
    </info>
    <name>Finalizer Nulls Fields</name>
  </findingType>
  <findingType>
    <id>FI_FINALIZER_ONLY_NULLS_FIELDS</id>
    <artifact tool="FindBugs"
	      mnemonic="FI_FINALIZER_ONLY_NULLS_FIELDS">
    </artifact>
    <shortMessage>Finalizer only nulls fields</shortMessage>
    <info>
      &lt;p&gt; This finalizer does nothing except null out
      fields. This is completely pointless, and requires that the
      object be garbage collected, finalized, and then garbage
      collected again. You should just remove the finalize method.
    </info>
    <name>Finalizer Only Nulls Fields</name>
  </findingType>
  <findingType>
    <id>FinalizeShouldBeProtected</id>
    <artifact tool="FindBugs"
	      mnemonic="FI_PUBLIC_SHOULD_BE_PROTECTED">
    </artifact>
    <artifact tool="PMD" mnemonic="FinalizeShouldBeProtected">
    </artifact>
    <shortMessage>
      Finalizer should be protected, not public
    </shortMessage>
    <info>
      &lt;p&gt; A class's &lt;code&gt;finalize()&lt;/code&gt;
      method should have protected access, not public.&lt;/p&gt;

      If you override finalize(), make it protected. If you make
      it public, other classes may call it.
    </info>
    <name>Finalize Should Be Protected</name>
  </findingType>
  <findingType>
    <id>EmptyFinalizer</id>
    <artifact tool="FindBugs" mnemonic="FI_EMPTY"></artifact>
    <artifact tool="PMD" mnemonic="EmptyFinalizer"></artifact>
    <shortMessage>Empty finalizer should be deleted</shortMessage>
    <info>
      &lt;p&gt; Empty &lt;code&gt;finalize()&lt;/code&gt; methods
      are useless, so they should be deleted.&lt;/p&gt;

      If the finalize() method is empty, then it does not need to
      exist.
    </info>
    <name>Empty Finalizer Block</name>
  </findingType>
  <findingType>
    <id>FI_NULLIFY_SUPER</id>
    <artifact tool="FindBugs" mnemonic="FI_NULLIFY_SUPER">
    </artifact>
    <shortMessage>
      Finalizer nullifies superclass finalizer
    </shortMessage>
    <info>
      &lt;p&gt; This empty &lt;code&gt;finalize()&lt;/code&gt;
      method explicitly negates the effect of any finalizer
      defined by its superclass.&amp;nbsp; Any finalizer actions
      defined for the superclass will not be performed.&amp;nbsp;
      Unless this is intended, delete this method.&lt;/p&gt;
    </info>
    <name>Nullify Super</name>
  </findingType>
  <findingType>
    <id>FinalizeOnlyCallsSuperFinalize</id>
    <artifact tool="FindBugs" mnemonic="FI_USELESS"></artifact>
    <artifact tool="PMD"
	      mnemonic="FinalizeOnlyCallsSuperFinalize">
    </artifact>
    <shortMessage>
      Finalizer does nothing but call superclass finalizer
    </shortMessage>
    <info>
      &lt;p&gt; The only thing this
      &lt;code&gt;finalize()&lt;/code&gt; method does is call the
      superclass's &lt;code&gt;finalize()&lt;/code&gt; method,
      making it redundant.&amp;nbsp; Delete it.&lt;/p&gt;

      If the finalize() is implemented, it should do something
      besides just calling super.finalize().
    </info>
    <name>Finalize Only Calls Super Finalize</name>
  </findingType>
  <findingType>
    <id>FinalizeDoesNotCallSuperFinalize</id>
    <artifact tool="FindBugs" mnemonic="FI_MISSING_SUPER_CALL">
    </artifact>
    <artifact tool="PMD"
	      mnemonic="FinalizeDoesNotCallSuperFinalize">
    </artifact>
    <shortMessage>
      Finalizer does not call superclass finalizer
    </shortMessage>
    <info>
      &lt;p&gt; This &lt;code&gt;finalize()&lt;/code&gt; method
      does not make a call to its superclass's
      &lt;code&gt;finalize()&lt;/code&gt; method.&amp;nbsp; So,
      any finalizer actions defined for the superclass will not be
      performed.&amp;nbsp; Add a call to
      &lt;code&gt;super.finalize()&lt;/code&gt;.&lt;/p&gt;

      If the finalize() is implemented, its last action should be
      to call super.finalize.
    </info>
    <name>Finalize Does Not Call Super Finalize</name>
  </findingType>
  <findingType>
    <id>AvoidCallingFinalizeExplicitly</id>
    <artifact tool="FindBugs" mnemonic="FI_EXPLICIT_INVOCATION">
    </artifact>
    <artifact tool="PMD" mnemonic="AvoidCallingFinalize"></artifact>
    <shortMessage>Explicit invocation of finalizer</shortMessage>
    <info>
      &lt;p&gt; This method contains an explicit invocation of the
      &lt;code&gt;finalize()&lt;/code&gt; method on an
      object.&amp;nbsp; Because finalizer methods are supposed to
      be executed once, and only by the VM, this is a bad
      idea.&lt;/p&gt; &lt;p&gt;If a connected set of objects
      beings finalizable, then the VM will invoke the finalize
      method on all the finalizable object, possibly at the same
      time in different threads. Thus, it is a particularly bad
      idea, in the finalize method for a class X, invoke finalize
      on objects referenced by X, because they may already be
      getting finalized in a separate thread.
    </info>
    <name>Avoid Calling Finalize Explicitly</name>
  </findingType>
  <findingType>
    <id>EQ_DONT_DEFINE_EQUALS_FOR_ENUM</id>
    <artifact tool="FindBugs"
	      mnemonic="EQ_DONT_DEFINE_EQUALS_FOR_ENUM">
    </artifact>
    <shortMessage>
      Covariant equals() method defined for enum
    </shortMessage>
    <info>
      &lt;p&gt; This class defines an enumeration, and equality on
      enumerations are defined using object identity. Definine a
      covariant equals method for an enumeration value is
      exceptionally bad practice, since it would likely result in
      having two different enumeration values that compare as
      equals using the covariant enum method, and as not equal
      when compared normally. Don't do it. &lt;/p&gt;
    </info>
    <name>Don't Define Equals For enum</name>
  </findingType>
  <findingType>
    <id>EQ_SELF_USE_OBJECT</id>
    <artifact tool="FindBugs" mnemonic="EQ_SELF_USE_OBJECT">
    </artifact>
    <shortMessage>
      Covariant equals() method defined, Object.equals(Object)
      inherited
    </shortMessage>
    <info>
      &lt;p&gt; This class defines a covariant version of the
      &lt;code&gt;equals()&lt;/code&gt; method, but inherits the
      normal &lt;code&gt;equals(Object)&lt;/code&gt; method
      defined in the base
      &lt;code&gt;java.lang.Object&lt;/code&gt; class.&amp;nbsp;
      The class should probably define a non-covariant version of
      &lt;code&gt;equals()&lt;/code&gt;.&amp;nbsp; (I.e., a method
      with the signature &lt;code&gt;boolean
      equals(java.lang.Object)&lt;/code&gt;.&lt;/p&gt;
    </info>
    <name>Self Use Object</name>
  </findingType>
  <findingType>
    <id>EQ_SELF_NO_OBJECT</id>
    <artifact tool="FindBugs" mnemonic="EQ_SELF_NO_OBJECT">
    </artifact>
    <shortMessage>Covariant equals() method defined</shortMessage>
    <info>

      &lt;p&gt; This class defines a covariant version of
      &lt;code&gt;equals()&lt;/code&gt;.&amp;nbsp; To correctly
      override the &lt;code&gt;equals()&lt;/code&gt; method in
      &lt;code&gt;java.lang.Object&lt;/code&gt;, the parameter of
      &lt;code&gt;equals()&lt;/code&gt; must have type
      &lt;code&gt;java.lang.Object&lt;/code&gt;.&lt;/p&gt;

    </info>
    <name>Self No Object</name>
  </findingType>
  <findingType>
    <id>EQ_OVERRIDING_EQUALS_NOT_SYMMETRIC</id>
    <artifact tool="FindBugs"
	      mnemonic="EQ_OVERRIDING_EQUALS_NOT_SYMMETRIC">
    </artifact>
    <shortMessage>
      equals method overrides equals in superclass and may not be
      symmetric
    </shortMessage>
    <info>

      &lt;p&gt; This class defines an equals method that overrides
      an equals method in a superclass. Both equals methods
      methods use &lt;code&gt;instanceof&lt;/code&gt; in the
      determination of whether two objects are equals. This is
      fraught with peril, since it is important that the equals
      method is symetrical (in other words,
      &lt;code&gt;a.equals(b) == b.equals(a)&lt;/code&gt;). If B
      is a subtype of A, and A's equals method checks that the
      argument is an instanceof A, and B's equals method checks
      that the argument is an instanceof B, it is quite likely
      that the equivalence relation defined by these methods is
      not symmetric.

    </info>
    <name>Overriding Equals Not Symmetric</name>
  </findingType>
  <findingType>
    <id>HSC_HUGE_SHARED_STRING_CONSTANT</id>
    <artifact tool="FindBugs"
	      mnemonic="HSC_HUGE_SHARED_STRING_CONSTANT">
    </artifact>
    <shortMessage>
      Huge string constants is duplicated across multiple class
      files
    </shortMessage>
    <info>

      &lt;p&gt; A large String constant is duplicated across
      multiple class files. This is likely because a final field
      is initialized to a String constant, and the Java language
      mandates that all references to a final field from other
      classes be inlined into that classfile. See &lt;a
      href=&quot;http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6447475&quot;&gt;JDK
      bug 6447475&lt;/a&gt; for a description of an occurrence of
      this bug in the JDK and how resolving it reduced the size of
      the JDK by 1 megabyte. &lt;/p&gt;

    </info>
    <name>Huge Shared String Constant</name>
  </findingType>
  <findingType>
    <id>NP_ARGUMENT_MIGHT_BE_NULL</id>
    <artifact tool="FindBugs"
	      mnemonic="NP_ARGUMENT_MIGHT_BE_NULL">
    </artifact>
    <shortMessage>
      Method does not check for null argument
    </shortMessage>
    <info>

      &lt;p&gt; A parameter to this method has been identified as
      a value that should always be checked to see whether or not
      it is null, but it is being dereferenced without a preceding
      null check. &lt;/p&gt;

    </info>
    <name>Argument Might Be Null</name>
  </findingType>
  <findingType>
    <id>NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT</id>
    <artifact tool="FindBugs"
	      mnemonic="NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT">
    </artifact>
    <shortMessage>
      equals() method does not check for null argument
    </shortMessage>
    <info>

      &lt;p&gt; This implementation of equals(Object) violates the
      contract defined by java.lang.Object.equals() because it
      does not check for null being passed as the argument. All
      equals() methods should return false if passed a null value.
      &lt;/p&gt;

    </info>
    <name>Equals Should Handle Null Argument</name>
  </findingType>
  <findingType>
    <id>NP_DOES_NOT_HANDLE_NULL</id>
    <artifact tool="FindBugs" mnemonic="NP_DOES_NOT_HANDLE_NULL">
    </artifact>
    <shortMessage>
      equals() method does not check for null parameter
    </shortMessage>
    <info>

      &lt;p&gt; This implementation of equals(Object) violates the
      contract defined by java.lang.Object.equals() because it
      does not check for null being passed as the parameter. All
      equals() methods should return false if passed a null value.
      &lt;/p&gt;

    </info>
    <name>Does Not Handle Null</name>
  </findingType>
  <findingType>
    <id>CO_SELF_NO_OBJECT</id>
    <artifact tool="FindBugs" mnemonic="CO_SELF_NO_OBJECT">
    </artifact>
    <shortMessage>
      Covariant compareTo() method defined
    </shortMessage>
    <info>

      &lt;p&gt; This class defines a covariant version of
      &lt;code&gt;compareTo()&lt;/code&gt;.&amp;nbsp; To correctly
      override the &lt;code&gt;compareTo()&lt;/code&gt; method in
      the &lt;code&gt;Comparable&lt;/code&gt; interface, the
      parameter of &lt;code&gt;compareTo()&lt;/code&gt; must have
      type &lt;code&gt;java.lang.Object&lt;/code&gt;.&lt;/p&gt;

    </info>
    <name>Self No Object</name>
  </findingType>
  <findingType>
    <id>HE_USE_OF_UNHASHABLE_CLASS</id>
    <artifact tool="FindBugs"
	      mnemonic="HE_USE_OF_UNHASHABLE_CLASS">
    </artifact>
    <shortMessage>
      Use of class without a hashCode() method in a hashed data
      structure
    </shortMessage>
    <info>

      &lt;p&gt; A class defines an equals(Object) method but not a
      hashCode() method, and thus doesn't fulfill the requirement
      that equal Objects have equal hashCodes. An instance of this
      class is used in a hash data structure, making the need to
      fix this problem of highest importance.

    </info>
    <name>Use Of Unhashable Class</name>
  </findingType>
  <findingType>
    <id>DefinesHashCodeUsesEquals</id>
    <artifact tool="FindBugs"
	      mnemonic="HE_HASHCODE_USE_OBJECT_EQUALS">
    </artifact>
    <shortMessage>
      Class defines hashCode() and uses Object.equals()
    </shortMessage>
    <info>

      &lt;p&gt; This class defines a
      &lt;code&gt;hashCode()&lt;/code&gt; method but inherits its
      &lt;code&gt;equals()&lt;/code&gt; method from
      &lt;code&gt;java.lang.Object&lt;/code&gt; (which defines
      equality by comparing object references).&amp;nbsp; Although
      this will probably satisfy the contract that equal objects
      must have equal hashcodes, it is probably not what was
      intended by overriding the
      &lt;code&gt;hashCode()&lt;/code&gt; method.&amp;nbsp;
      (Overriding &lt;code&gt;hashCode()&lt;/code&gt; implies that
      the object's identity is based on criteria more complicated
      than simple reference equality.)&lt;/p&gt; &lt;p&gt;If you
      don't think instances of this class will ever be inserted
      into a HashMap/HashTable, the recommended
      &lt;code&gt;hashCode&lt;/code&gt; implementation to use
      is:&lt;/p&gt; &lt;p&gt;&lt;pre&gt;public int hashCode() {
      assert false : &quot;hashCode not designed&quot;; return 42;
      // any arbitrary constant will do }&lt;/pre&gt;&lt;/p&gt;

      Override both public boolean Object.equals(Object other),
      and public int Object.hashCode(), or override neither. Even
      if you are inheriting a hashCode() from a parent class,
      consider implementing hashCode and explicitly delegating to
      your superclass.
    </info>
    <name>Defines Hash Code Uses Equals</name>
  </findingType>
  <findingType>
    <id>EQ_COMPARETO_USE_OBJECT_EQUALS</id>
    <artifact tool="FindBugs"
	      mnemonic="EQ_COMPARETO_USE_OBJECT_EQUALS">
    </artifact>
    <shortMessage>
      Class defines compareTo(...) and uses Object.equals()
    </shortMessage>
    <info>
      &lt;p&gt; This class defines a
      &lt;code&gt;compareTo(...)&lt;/code&gt; method but inherits
      its &lt;code&gt;equals()&lt;/code&gt; method from
      &lt;code&gt;java.lang.Object&lt;/code&gt;. Generally, the
      value of compareTo should return zero if and only if equals
      returns true. If this is violated, weird and unpredictable
      failures will occur in classes such as PriorityQueue. In
      Java 5 the PriorityQueue.remove method uses the compareTo
      method, while in Java 6 it uses the equals method.

      &lt;p&gt;From the JavaDoc for the compareTo method in the
      Comparable interface: &lt;blockquote&gt; It is strongly
      recommended, but not strictly required that
      &lt;code&gt;(x.compareTo(y)==0) ==
      (x.equals(y))&lt;/code&gt;. Generally speaking, any class
      that implements the Comparable interface and violates this
      condition should clearly indicate this fact. The recommended
      language is &quot;Note: this class has a natural ordering
      that is inconsistent with equals.&quot; &lt;/blockquote&gt;

    </info>
    <name>Defines compareTo() Uses Object Equals</name>
  </findingType>
  <findingType>
    <id>DefinesHashcodeNotEquals</id>
    <artifact tool="FindBugs" mnemonic="HE_HASHCODE_NO_EQUALS">
    </artifact>
    <shortMessage>
      Class defines hashCode() but not equals()
    </shortMessage>
    <info>
      &lt;p&gt; This class defines a
      &lt;code&gt;hashCode()&lt;/code&gt; method but not an
      &lt;code&gt;equals()&lt;/code&gt; method.&amp;nbsp;
      Therefore, the class may violate the invariant that equal
      objects must have equal hashcodes.&lt;/p&gt;

      Override both public boolean Object.equals(Object other),
      and public int Object.hashCode(), or override neither. Even
      if you are inheriting a hashCode() from a parent class,
      consider implementing hashCode and explicitly delegating to
      your superclass.
    </info>
    <name>Defines Hashcode Not Equals</name>
  </findingType>
  <findingType>
    <id>DefinesEqualsUsesHashcode</id>
    <artifact tool="FindBugs" mnemonic="HE_EQUALS_USE_HASHCODE">
    </artifact>
    <shortMessage>
      Class defines equals() and uses Object.hashCode()
    </shortMessage>
    <info>

      &lt;p&gt; This class overrides
      &lt;code&gt;equals(Object)&lt;/code&gt;, but does not
      override &lt;code&gt;hashCode()&lt;/code&gt;, and inherits
      the implementation of &lt;code&gt;hashCode()&lt;/code&gt;
      from &lt;code&gt;java.lang.Object&lt;/code&gt; (which
      returns the identity hash code, an arbitrary value assigned
      to the object by the VM).&amp;nbsp; Therefore, the class is
      very likely to violate the invariant that equal objects must
      have equal hashcodes.&lt;/p&gt;

      &lt;p&gt;If you don't think instances of this class will
      ever be inserted into a HashMap/HashTable, the recommended
      &lt;code&gt;hashCode&lt;/code&gt; implementation to use
      is:&lt;/p&gt; &lt;pre&gt;public int hashCode() { assert
      false : &quot;hashCode not designed&quot;; return 42; // any
      arbitrary constant will do }&lt;/pre&gt;

      Override both public boolean Object.equals(Object other),
      and public int Object.hashCode(), or override neither. Even
      if you are inheriting a hashCode() from a parent class,
      consider implementing hashCode and explicitly delegating to
      your superclass.
    </info>
    <name>Defines equals() Uses hashcode()</name>
  </findingType>
  <findingType>
    <id>InheritsEqualsUsesHashCode</id>
    <artifact tool="FindBugs"
	      mnemonic="HE_INHERITS_EQUALS_USE_HASHCODE">
    </artifact>
    <shortMessage>
      Class inherits equals() and uses Object.hashCode()
    </shortMessage>
    <info>

      &lt;p&gt; This class inherits
      &lt;code&gt;equals(Object)&lt;/code&gt; from an abstract
      superclass, and &lt;code&gt;hashCode()&lt;/code&gt; from
      &lt;code&gt;java.lang.Object&lt;/code&gt; (which returns the
      identity hash code, an arbitrary value assigned to the
      object by the VM).&amp;nbsp; Therefore, the class is very
      likely to violate the invariant that equal objects must have
      equal hashcodes.&lt;/p&gt;

      &lt;p&gt;If you don't want to define a hashCode method,
      and/or don't believe the object will ever be put into a
      HashMap/Hashtable, define the
      &lt;code&gt;hashCode()&lt;/code&gt; method to throw
      &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.&lt;/p&gt;

      Override both public boolean Object.equals(Object other),
      and public int Object.hashCode(), or override neither. Even
      if you are inheriting a hashCode() from a parent class,
      consider implementing hashCode and explicitly delegating to
      your superclass.

    </info>
    <name>Inherits Equals Uses Hashcode</name>
  </findingType>
  <findingType>
    <id>OverridesEqualsNotHashcode</id>
    <artifact tool="FindBugs" mnemonic="HE_EQUALS_NO_HASHCODE">
    </artifact>
    <shortMessage>
      Class defines equals() but not hashCode()
    </shortMessage>
    <info>

      &lt;p&gt; This class overrides
      &lt;code&gt;equals(Object)&lt;/code&gt;, but does not
      override &lt;code&gt;hashCode()&lt;/code&gt;.&amp;nbsp;
      Therefore, the class may violate the invariant that equal
      objects must have equal hashcodes.&lt;/p&gt;

      Override both public boolean Object.equals(Object other),
      and public int Object.hashCode(), or override neither. Even
      if you are inheriting a hashCode() from a parent class,
      consider implementing hashCode and explicitly delegating to
      your superclass.
    </info>
    <name>Overrides Equals Not Hashcode</name>
  </findingType>
  <findingType>
    <id>EQ_ABSTRACT_SELF</id>
    <artifact tool="FindBugs" mnemonic="EQ_ABSTRACT_SELF">
    </artifact>
    <shortMessage>
      Abstract class defines covariant equals() method
    </shortMessage>
    <info>

      &lt;p&gt; This class defines a covariant version of
      &lt;code&gt;equals()&lt;/code&gt;.&amp;nbsp; To correctly
      override the &lt;code&gt;equals()&lt;/code&gt; method in
      &lt;code&gt;java.lang.Object&lt;/code&gt;, the parameter of
      &lt;code&gt;equals()&lt;/code&gt; must have type
      &lt;code&gt;java.lang.Object&lt;/code&gt;.&lt;/p&gt;

    </info>
    <name>Abstract Self</name>
  </findingType>
  <findingType>
    <id>ES_COMPARING_STRINGS_WITH_EQ</id>
    <artifact tool="FindBugs"
	      mnemonic="ES_COMPARING_STRINGS_WITH_EQ">
    </artifact>
    <artifact tool="PMD"
	      mnemonic="UseEqualsToCompareStrings"/>				
    <shortMessage>
      Comparison of String objects using == or !=
    </shortMessage>
    <info>

      &lt;p&gt;This code compares
      &lt;code&gt;java.lang.String&lt;/code&gt; objects for
      reference equality using the == or != operators. Unless both
      strings are either constants in a source file, or have been
      interned using the &lt;code&gt;String.intern()&lt;/code&gt;
      method, the same string value may be represented by two
      different String objects. Consider using the
      &lt;code&gt;equals(Object)&lt;/code&gt; method
      instead.&lt;/p&gt;

    </info>
    <name>Comparing Strings With == or !=</name>
  </findingType>
  <findingType>
    <id>ES_COMPARING_PARAMETER_STRING_WITH_EQ</id>
    <artifact tool="FindBugs"
	      mnemonic="ES_COMPARING_PARAMETER_STRING_WITH_EQ">
    </artifact>
    <shortMessage>
      Comparison of String parameter using == or !=
    </shortMessage>
    <info>

      &lt;p&gt;This code compares a
      &lt;code&gt;java.lang.String&lt;/code&gt; parameter for
      reference equality using the == or != operators. Requiring
      callers to pass only String constants or interned strings to
      a method is unnecessarily fragile, and rarely leads to
      measurable performance gains. Consider using the
      &lt;code&gt;equals(Object)&lt;/code&gt; method
      instead.&lt;/p&gt;

    </info>
    <name>Comparing Parameter String With == or !=</name>
  </findingType>
  <findingType>
    <id>CO_ABSTRACT_SELF</id>
    <artifact tool="FindBugs" mnemonic="CO_ABSTRACT_SELF">
    </artifact>
    <shortMessage>
      Abstract class defines covariant compareTo() method
    </shortMessage>
    <info>

      &lt;p&gt; This class defines a covariant version of
      &lt;code&gt;compareTo()&lt;/code&gt;.&amp;nbsp; To correctly
      override the &lt;code&gt;compareTo()&lt;/code&gt; method in
      the &lt;code&gt;Comparable&lt;/code&gt; interface, the
      parameter of &lt;code&gt;compareTo()&lt;/code&gt; must have
      type &lt;code&gt;java.lang.Object&lt;/code&gt;.&lt;/p&gt;

    </info>
    <name>Abstract Self</name>
  </findingType>
  <findingType>
    <id>FieldNotGuarded</id>
    <artifact tool="FindBugs" mnemonic="IS_FIELD_NOT_GUARDED">
    </artifact>
    <shortMessage>
      Field not guarded against concurrent access
    </shortMessage>
    <info>

      &lt;p&gt; This field is annotated with
      net.jcip.annotations.GuardedBy, but can be accessed in a way
      that seems to violate the annotation.&lt;/p&gt;

    </info>
    <name>Field Not Guarded</name>
  </findingType>
  <findingType>
    <id>InconsistentSynchronization2</id>
    <artifact tool="FindBugs" mnemonic="IS2_INCONSISTENT_SYNC">
    </artifact>
    <shortMessage>Inconsistent synchronization</shortMessage>
    <info>

      &lt;p&gt; The fields of this class appear to be accessed
      inconsistently with respect to synchronization.&amp;nbsp;
      This bug report indicates that the bug pattern detector
      judged that &lt;/p&gt; &lt;ol&gt; &lt;li&gt; The class
      contains a mix of locked and unlocked accesses,&lt;/li&gt;
      &lt;li&gt; At least one locked access was performed by one
      of the class's own methods, and&lt;/li&gt; &lt;li&gt; The
      number of unsynchronized field accesses (reads and writes)
      was no more than one third of all accesses, with writes
      being weighed twice as high as reads&lt;/li&gt; &lt;/ol&gt;

      &lt;p&gt; A typical bug matching this bug pattern is
      forgetting to synchronize one of the methods in a class that
      is intended to be thread-safe.&lt;/p&gt;

      &lt;p&gt; You can select the nodes labeled
      &quot;Unsynchronized access&quot; to show the code locations
      where the detector believed that a field was accessed
      without synchronization.&lt;/p&gt;

      &lt;p&gt; Note that there are various sources of inaccuracy
      in this detector; for example, the detector cannot
      statically detect all situations in which a lock is
      held.&amp;nbsp; Also, even when the detector is accurate in
      distinguishing locked vs. unlocked accesses, the code in
      question may still be correct.&lt;/p&gt;

      &lt;p&gt; This description refers to the &quot;IS2&quot;
      version of the pattern detector, which has more accurate
      ways of detecting locked vs. unlocked accesses than the
      older &quot;IS&quot; detector.&lt;/p&gt;

    </info>
    <name>Inconsistent Sync</name>
  </findingType>
  <findingType>
    <id>NakedNotifyCall</id>
    <artifact tool="FindBugs" mnemonic="NN_NAKED_NOTIFY"></artifact>
    <shortMessage>Naked notify</shortMessage>
    <info>

      &lt;p&gt; A call to &lt;code&gt;notify()&lt;/code&gt; or
      &lt;code&gt;notifyAll()&lt;/code&gt; was made without any
      (apparent) accompanying modification to mutable object
      state.&amp;nbsp; In general, calling a notify method on a
      monitor is done because some condition another thread is
      waiting for has become true.&amp;nbsp; However, for the
      condition to be meaningful, it must involve a heap object
      that is visible to both threads.&lt;/p&gt;

      &lt;p&gt; This bug does not necessarily indicate an error,
      since the change to mutable object state may have taken
      place in a method which then called the method containing
      the notification.&lt;/p&gt;

    </info>
    <name>Naked Notify</name>
  </findingType>
  <findingType>
    <id>PublicStaticMayExposeInternalRepresentation</id>
    <artifact tool="FindBugs" mnemonic="MS_EXPOSE_REP"></artifact>
    <shortMessage>
      Public static method may expose internal representation by
      returning array
    </shortMessage>
    <info>

      &lt;p&gt; A public static method returns a reference to an
      array that is part of the static state of the class. Any
      code that calls this method can freely modify the underlying
      array. One fix is to return a copy of the array.&lt;/p&gt;

    </info>
    <name>Expose Rep</name>
  </findingType>
  <findingType>
    <id>MayExposeInternalRepresentation</id>
    <artifact tool="FindBugs" mnemonic="EI_EXPOSE_REP"></artifact>
    <shortMessage>
      May expose internal representation by returning reference to
      mutable object
    </shortMessage>
    <info>

      &lt;p&gt; Returning a reference to a mutable object value
      stored in one of the object's fields exposes the internal
      representation of the object.&amp;nbsp; If instances are
      accessed by untrusted code, and unchecked changes to the
      mutable object would compromise security or other important
      properties, you will need to do something different.
      Returning a new copy of the object is better approach in
      many situations.&lt;/p&gt;

    </info>
    <name>Expose Rep</name>
  </findingType>
  <findingType>
    <id>MayExposeInternalRepresentation2</id>
    <artifact tool="FindBugs" mnemonic="EI_EXPOSE_REP2"></artifact>
    <shortMessage>
      May expose internal representation by incorporating
      reference to mutable object
    </shortMessage>
    <info>

      &lt;p&gt; This code stores a reference to an externally
      mutable object into the internal representation of the
      object.&amp;nbsp; If instances are accessed by untrusted
      code, and unchecked changes to the mutable object would
      compromise security or other important properties, you will
      need to do something different. Storing a copy of the object
      is better approach in many situations.&lt;/p&gt;

    </info>
    <name>Expose REP2</name>
  </findingType>
  <findingType>
    <id>MayExposeInternalStaticStatic</id>
    <artifact tool="FindBugs" mnemonic="EI_EXPOSE_STATIC_REP2">
    </artifact>
    <shortMessage>
      May expose internal static state by storing a mutable object
      into a static field
    </shortMessage>
    <info>

      &lt;p&gt; This code stores a reference to an externally
      mutable object into a static field. If unchecked changes to
      the mutable object would compromise security or other
      important properties, you will need to do something
      different. Storing a copy of the object is better approach
      in many situations.&lt;/p&gt;

    </info>
    <name>Expose Static REP2</name>
  </findingType>
  <findingType>
    <id>InvokesRun</id>
    <artifact tool="FindBugs" mnemonic="RU_INVOKE_RUN"></artifact>
    <shortMessage>
      Invokes run on a thread (did you mean to start it instead?)
    </shortMessage>
    <info>

      &lt;p&gt; This method explicitly invokes
      &lt;code&gt;run()&lt;/code&gt; on an object.&amp;nbsp; In
      general, classes implement the
      &lt;code&gt;Runnable&lt;/code&gt; interface because they are
      going to have their &lt;code&gt;run()&lt;/code&gt; method
      invoked in a new thread, in which case
      &lt;code&gt;Thread.start()&lt;/code&gt; is the right method
      to call.&lt;/p&gt;

    </info>
    <name>Invoke Run</name>
  </findingType>
  <findingType>
    <id>MethodSpinsOnField</id>
    <artifact tool="FindBugs" mnemonic="SP_SPIN_ON_FIELD">
    </artifact>
    <shortMessage>Method spins on field</shortMessage>
    <info>

      &lt;p&gt; This method spins in a loop which reads a
      field.&amp;nbsp; The compiler may legally hoist the read out
      of the loop, turning the code into an infinite
      loop.&amp;nbsp; The class should be changed so it uses
      proper synchronization (including wait and notify
      calls).&lt;/p&gt;

    </info>
    <name>Spin On Field</name>
  </findingType>
  <findingType>
    <id>NS_DANGEROUS_NON_SHORT_CIRCUIT</id>
    <artifact tool="FindBugs"
	      mnemonic="NS_DANGEROUS_NON_SHORT_CIRCUIT">
    </artifact>
    <shortMessage>
      Potentially dangerous use of non-short-circuit logic
    </shortMessage>
    <info>

      &lt;p&gt; This code seems to be using non-short-circuit
      logic (e.g., &amp;amp; or |) rather than short-circuit logic
      (&amp;amp;&amp;amp; or ||). In addition, it seem possible
      that, depending on the value of the left hand side, you
      might not want to evaluate the right hand side (because it
      would have side effects, could cause an exception or could
      be expensive.&lt;/p&gt; &lt;p&gt; Non-short-circuit logic
      causes both sides of the expression to be evaluated even
      when the result can be inferred from knowing the left-hand
      side. This can be less efficient and can result in errors if
      the left-hand side guards cases when evaluating the
      right-hand side can generate an error. &lt;/p&gt;

      &lt;p&gt;See &lt;a
      href=&quot;http://java.sun.com/docs/books/jls/third_edition/html/expressions.html#15.22.2&quot;&gt;the
      Java Language Specification&lt;/a&gt; for details

      &lt;/p&gt;

    </info>
    <name>Dangerous Non Short Circuit</name>
  </findingType>
  <findingType>
    <id>NS_NON_SHORT_CIRCUIT</id>
    <artifact tool="FindBugs" mnemonic="NS_NON_SHORT_CIRCUIT">
    </artifact>
    <shortMessage>
      Questionable use of non-short-circuit logic
    </shortMessage>
    <info>

      &lt;p&gt; This code seems to be using non-short-circuit
      logic (e.g., &amp;amp; or |) rather than short-circuit logic
      (&amp;amp;&amp;amp; or ||). Non-short-circuit logic causes
      both sides of the expression to be evaluated even when the
      result can be inferred from knowing the left-hand side. This
      can be less efficient and can result in errors if the
      left-hand side guards cases when evaluating the right-hand
      side can generate an error.

      &lt;p&gt;See &lt;a
      href=&quot;http://java.sun.com/docs/books/jls/third_edition/html/expressions.html#15.22.2&quot;&gt;the
      Java Language Specification&lt;/a&gt; for details

      &lt;/p&gt;

    </info>
    <name>Non Short Circuit</name>
  </findingType>
  <findingType>
    <id>WaitWithTwoLocks</id>
    <artifact tool="FindBugs" mnemonic="TLW_TWO_LOCK_WAIT">
    </artifact>
    <shortMessage>Wait with two locks held</shortMessage>
    <info>

      &lt;p&gt; Waiting on a monitor while two locks are held may
      cause deadlock. &amp;nbsp; Performing a wait only releases
      the lock on the object being waited on, not any other locks.
      &amp;nbsp; This not necessarily a bug, but is worth
      examining closely.&lt;/p&gt;

    </info>
    <name>Two Lock Wait</name>
  </findingType>
  <findingType>
    <id>TwoLocksOnNotify</id>
    <artifact tool="FindBugs" mnemonic="TLW_TWO_LOCK_NOTIFY">
    </artifact>
    <shortMessage>Notify with two locks held</shortMessage>
    <info>

      &lt;p&gt; The code calls notify() or notifyAll() while two
      locks are held. If this notification is intended to wake up
      a wait() that is holding the same locks, it may deadlock,
      since the wait will only give up one lock and the notify
      will be unable to get both locks, and thus the notify will
      not succeed. &amp;nbsp; If there is also a warning about a
      two lock wait, the probably of a bug is quite high.
      &lt;/p&gt;

    </info>
    <name>Two Lock Notify</name>
  </findingType>
  <findingType>
    <id>UnconditionalWait</id>
    <artifact tool="FindBugs" mnemonic="UW_UNCOND_WAIT"></artifact>
    <shortMessage>Unconditional wait</shortMessage>
    <info>

      &lt;p&gt; This method contains a call to
      &lt;code&gt;java.lang.Object.wait()&lt;/code&gt; which is
      not guarded by conditional control flow.&amp;nbsp; The code
      should verify that condition it intends to wait for is not
      already satisfied before calling wait; any previous
      notifications will be ignored. &lt;/p&gt;

    </info>
    <name>Unconditional Wait</name>
  </findingType>
  <findingType>
    <id>UR_UNINIT_READ</id>
    <artifact tool="FindBugs" mnemonic="UR_UNINIT_READ"></artifact>
    <shortMessage>
      Uninitialized read of field in constructor
    </shortMessage>
    <info>

      &lt;p&gt; This constructor reads a field which has not yet
      been assigned a value.&amp;nbsp; This is often caused when
      the programmer mistakenly uses the field instead of one of
      the constructor's parameters.&lt;/p&gt;

    </info>
    <name>Uninitialized Read</name>
  </findingType>
  <findingType>
    <id>SynchronizedSetUnsynchronizedGet</id>
    <artifact tool="FindBugs" mnemonic="UG_SYNC_SET_UNSYNC_GET">
    </artifact>
    <shortMessage>
      Unsynchronized get method, synchronized set method
    </shortMessage>
    <info>

      &lt;p&gt; This class contains similarly-named get and set
      methods where the set method is synchronized and the get
      method is not.&amp;nbsp; This may result in incorrect
      behavior at runtime, as callers of the get method will not
      necessarily see a consistent state for the object.&amp;nbsp;
      The get method should be made synchronized.&lt;/p&gt;

    </info>
    <name>Sync Set Unsync Get</name>
  </findingType>
  <findingType>
    <id>IC_INIT_CIRCULARITY</id>
    <artifact tool="FindBugs" mnemonic="IC_INIT_CIRCULARITY">
    </artifact>
    <shortMessage>Initialization circularity</shortMessage>
    <info>

      &lt;p&gt; A circularity was detected in the static
      initializers of the two classes referenced by the bug
      instance.&amp;nbsp; Many kinds of unexpected behavior may
      arise from such circularity.&lt;/p&gt;

    </info>
    <name>Init Circularity</name>
  </findingType>
  <findingType>
    <id>IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION</id>
    <artifact tool="FindBugs"
	      mnemonic="IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION">
    </artifact>
    <shortMessage>
      Superclass uses subclass during initialization
    </shortMessage>
    <info>

      &lt;p&gt; During the initialization of a class, the class
      makes an active use of a subclass. That subclass will not
      yet be initialized at the time of this use. For example, in
      the following code, &lt;code&gt;foo&lt;/code&gt; will be
      null.&lt;/p&gt;

      &lt;pre&gt; public class CircularClassInitialization {
      static class InnerClassSingleton extends
      CircularClassInitialization { static InnerClassSingleton
      singleton = new InnerClassSingleton(); }

      static CircularClassInitialization foo =
      InnerClassSingleton.singleton; } &lt;/pre&gt;


    </info>
    <name>Superclass Uses Subclass During Initialization</name>
  </findingType>
  <findingType>
    <id>IT_NO_SUCH_ELEMENT</id>
    <artifact tool="FindBugs" mnemonic="IT_NO_SUCH_ELEMENT">
    </artifact>
    <shortMessage>
      Iterator next() method can't throw NoSuchElement exception
    </shortMessage>
    <info>

      &lt;p&gt; This class implements the
      &lt;code&gt;java.util.Iterator&lt;/code&gt;
      interface.&amp;nbsp; However, its
      &lt;code&gt;next()&lt;/code&gt; method is not capable of
      throwing
      &lt;code&gt;java.util.NoSuchElementException&lt;/code&gt;.&amp;nbsp;
      The &lt;code&gt;next()&lt;/code&gt; method should be changed
      so it throws &lt;code&gt;NoSuchElementException&lt;/code&gt;
      if is called when there are no more elements to
      return.&lt;/p&gt;

    </info>
    <name>No Such Element</name>
  </findingType>
  <findingType>
    <id>SynchronizationOnSharedConstant</id>
    <artifact tool="FindBugs"
	      mnemonic="DL_SYNCHRONIZATION_ON_SHARED_CONSTANT">
    </artifact>
    <shortMessage>
      Synchronization on shared constant could lead to deadlock
    </shortMessage>
    <info>

      &lt;p&gt; The code synchronizes on a shared primative
      constant, such as an interned String. &lt;pre&gt; private
      static String LOCK = &quot;LOCK&quot;; ...
      synchronized(LOCK) { ...} ... &lt;/pre&gt; &lt;/p&gt;
      &lt;p&gt;Such constants an interned and shared across all
      other classes loaded by the JVM. Thus, this could is locking
      on something that other code might also be locking. This
      could result in very strange and hard to diagnose blocking
      and deadlock behavior. See &lt;a
      href=&quot;http://www.javalobby.org/java/forums/t96352.html&quot;&gt;http://www.javalobby.org/java/forums/t96352.html&lt;/a&gt;
      and &lt;a
      href=&quot;http://jira.codehaus.org/browse/JETTY-352&quot;&gt;http://jira.codehaus.org/browse/JETTY-352&lt;/a&gt;.
      &lt;/p&gt;

    </info>
    <name>Synchronization On Shared Constant</name>
  </findingType>
  <findingType>
    <id>EmptySynchronizationBlock</id>
    <artifact tool="FindBugs" mnemonic="ESync_EMPTY_SYNC">
    </artifact>
    <artifact tool="PMD" mnemonic="EmptySynchronizedBlock">
    </artifact>
    <shortMessage>Empty synchronized block</shortMessage>
    <info>

      &lt;p&gt; The code contains an empty synchronized
      block:&lt;/p&gt; &lt;pre&gt; synchronized() {} &lt;/pre&gt;
      &lt;p&gt;Empty synchronized blocks are far more subtle and
      hard to use correctly than most people recognize, and empty
      synchronized blocks are almost never a better solution than
      less contrived solutions. &lt;/p&gt;

    </info>
    <name>Empty Sync</name>
  </findingType>
  <findingType>
    <id>InconsistentSynchronization</id>
    <artifact tool="FindBugs" mnemonic="IS_INCONSISTENT_SYNC">
    </artifact>
    <shortMessage>Inconsistent synchronization</shortMessage>
    <info>

      &lt;p&gt; The fields of this class appear to be accessed
      inconsistently with respect to synchronization.&amp;nbsp;
      This bug report indicates that the bug pattern detector
      judged that &lt;/p&gt; &lt;ol&gt; &lt;li&gt; The class
      contains a mix of locked and unlocked accesses,&lt;/li&gt;
      &lt;li&gt; At least one locked access was performed by one
      of the class's own methods, and&lt;/li&gt; &lt;li&gt; The
      number of unsynchronized field accesses (reads and writes)
      was no more than one third of all accesses, with writes
      being weighed twice as high as reads&lt;/li&gt; &lt;/ol&gt;

      &lt;p&gt; A typical bug matching this bug pattern is
      forgetting to synchronize one of the methods in a class that
      is intended to be thread-safe.&lt;/p&gt;

      &lt;p&gt; Note that there are various sources of inaccuracy
      in this detector; for example, the detector cannot
      statically detect all situations in which a lock is
      held.&amp;nbsp; Also, even when the detector is accurate in
      distinguishing locked vs. unlocked accesses, the code in
      question may still be correct.&lt;/p&gt;

    </info>
    <name>Inconsistent Sync</name>
  </findingType>
  <findingType>
    <id>AvoidSynchronizationOnUpdatedField</id>
    <artifact tool="FindBugs" mnemonic="ML_SYNC_ON_UPDATED_FIELD">
    </artifact>
    <shortMessage>
      Method synchronizes on an updated field
    </shortMessage>
    <info>

      &lt;p&gt; This method synchronizes on an object references
      from a mutable field. This is unlikely to have useful
      semantics, since different threads may be synchronizing on
      different objects.&lt;/p&gt;

    </info>
    <name>Sync On Updated Field</name>
  </findingType>
  <findingType>
    <id>FieldShouldBeOutOfInterfaceAndPackageProtected</id>
    <artifact tool="FindBugs" mnemonic="MS_OOI_PKGPROTECT">
    </artifact>
    <shortMessage>
      Field should be moved out of an interface and made package
      protected
    </shortMessage>
    <info>

      &lt;p&gt; A final static field that is defined in an
      interface references a mutable object such as an array or
      hashtable. This mutable object could be changed by malicious
      code or by accident from another package. To solve this, the
      field needs to be moved to a class and made package
      protected to avoid this vulnerability.&lt;/p&gt;

    </info>
    <name>Field Out of Interface and Package Protected</name>
  </findingType>
  <findingType>
    <id>FieldShouldBeFinalAndPackageProtected</id>
    <artifact tool="FindBugs" mnemonic="MS_FINAL_PKGPROTECT">
    </artifact>
    <shortMessage>
      Field should be both final and package protected
    </shortMessage>
    <info>

      &lt;p&gt; A mutable static field could be changed by
      malicious code or by accident from another package. The
      field could be made package protected and/or made final to
      avoid this vulnerability.&lt;/p&gt;

    </info>
    <name>Final and Package Protected</name>
  </findingType>
  <findingType>
    <id>FieldShouldBeFinal</id>
    <artifact tool="FindBugs" mnemonic="MS_SHOULD_BE_FINAL">
    </artifact>
    <shortMessage>Field isn't final but should be</shortMessage>
    <info>

      &lt;p&gt; A mutable static field could be changed by
      malicious code or by accident from another package. The
      field could be made final to avoid this
      vulnerability.&lt;/p&gt;

    </info>
    <name>Should Be Final</name>
  </findingType>
  <findingType>
    <id>PackageProtectField</id>
    <artifact tool="FindBugs" mnemonic="MS_PKGPROTECT"></artifact>
    <shortMessage>Field should be package protected</shortMessage>
    <info>

      &lt;p&gt; A mutable static field could be changed by
      malicious code or by accident. The field could be made
      package protected to avoid this vulnerability.&lt;/p&gt;

    </info>
    <name>Package Protect Field</name>
  </findingType>
  <findingType>
    <id>MutableHashtable</id>
    <artifact tool="FindBugs" mnemonic="MS_MUTABLE_HASHTABLE">
    </artifact>
    <shortMessage>Field is a mutable Hashtable</shortMessage>
    <info>

      &lt;p&gt;A final static field references a Hashtable and can
      be accessed by malicious code or by accident from another
      package. This code can freely modify the contents of the
      Hashtable.&lt;/p&gt;

    </info>
    <name>Mutable Hashtable</name>
  </findingType>
  <findingType>
    <id>MutableArray</id>
    <artifact tool="FindBugs" mnemonic="MS_MUTABLE_ARRAY">
    </artifact>
    <shortMessage>Field is a mutable array</shortMessage>
    <info>

      &lt;p&gt; A final static field references an array and can
      be accessed by malicious code or by accident from another
      package. This code can freely modify the contents of the
      array.&lt;/p&gt;

    </info>
    <name>Mutable Array</name>
  </findingType>
  <findingType>
    <id>CannotBeFinal</id>
    <artifact tool="FindBugs" mnemonic="MS_CANNOT_BE_FINAL">
    </artifact>
    <shortMessage>
      Field isn't final and can't be protected from malicious code
    </shortMessage>
    <info>

      &lt;p&gt; A mutable static field could be changed by
      malicious code or by accident from another package.
      Unfortunately, the way the field is used doesn't allow any
      easy fix to this problem.&lt;/p&gt;

    </info>
    <name>Cannot Be Final</name>
  </findingType>
  <findingType>
    <id>IA_AMBIGUOUS_INVOCATION_OF_INHERITED_OR_OUTER_METHOD</id>
    <artifact tool="FindBugs"
	      mnemonic="IA_AMBIGUOUS_INVOCATION_OF_INHERITED_OR_OUTER_METHOD">
    </artifact>
    <shortMessage>
      Ambiguous invocation of either an inherited or outer method
    </shortMessage>
    <info>

      &lt;p&gt; An inner class is invoking a method that could be
      resolved to either a inherited method or a method defined in
      an outer class. By the Java semantics, it will be resolved
      to invoke the inherited method, but this may not be want you
      intend. If you really intend to invoke the inherited method,
      invoke it by invoking the method on super (e.g., invoke
      super.foo(17)), and thus it will be clear to other readers
      of your code and to FindBugs that you want to invoke the
      inherited method, not the method in the outer class.
      &lt;/p&gt;

    </info>
    <name>Ambiguous Invocation Of Inherited Or Outer Method</name>
  </findingType>
  <findingType>
    <id>ClassNamingConventions</id>
    <artifact tool="FindBugs"
	      mnemonic="NM_CLASS_NAMING_CONVENTION">
    </artifact>
    <artifact tool="PMD" mnemonic="ClassNamingConventions">
    </artifact>
    <shortMessage>
      Class names should start with an upper case letter
    </shortMessage>
    <info>

      &lt;p&gt; Class names should be nouns, in mixed case with
      the first letter of each internal word capitalized. Try to
      keep your class names simple and descriptive. Use whole
      words-avoid acronyms and abbreviations (unless the
      abbreviation is much more widely used than the long form,
      such as URL or HTML). &lt;/p&gt;

      Class names should always begin with an upper case
      character.

    </info>
    <name>Class Naming Convention</name>
  </findingType>
  <findingType>
    <id>MethodNamingConventions</id>
    <artifact tool="FindBugs"
	      mnemonic="NM_METHOD_NAMING_CONVENTION">
    </artifact>
    <artifact tool="PMD" mnemonic="MethodNamingConventions">
    </artifact>
    <shortMessage>
      Method names should start with an lower case letter
    </shortMessage>
    <info>
      &lt;p&gt; Methods should be verbs, in mixed case with the
      first letter lowercase, with the first letter of each
      internal word capitalized. &lt;/p&gt;

      Method names should always begin with a lower case
      character, and should not contain underscores.
    </info>
    <name>Method Naming Convention</name>
  </findingType>
  <findingType>
    <id>FieldNamingConventions</id>
    <artifact tool="FindBugs"
	      mnemonic="NM_FIELD_NAMING_CONVENTION">
    </artifact>
    <artifact tool="PMD" mnemonic="VariableNamingConventions">
    </artifact>
    <shortMessage>
      Field names should start with an lower case letter
    </shortMessage>
    <info>

      &lt;p&gt; Names of fields that are not final should be in
      mixed case with a lowercase first letter and the first
      letters of subsequent words capitalized. &lt;/p&gt;

      Final variables that should be fully capitalized and
      non-final variables should not include underscores.
    </info>
    <name>Field Naming Convention</name>
  </findingType>
  <findingType>
    <id>NM_VERY_CONFUSING</id>
    <artifact tool="FindBugs" mnemonic="NM_VERY_CONFUSING">
    </artifact>
    <shortMessage>Very confusing method names</shortMessage>
    <info>

      &lt;p&gt; The referenced methods have names that differ only
      by capitalization or the packages of their parameters. This
      is very confusing because if the capitalization and
      parameter package names were identical then one of the
      methods would override the other. &lt;/p&gt;

    </info>
    <name>Very Confusing</name>
  </findingType>
  <findingType>
    <id>NM_VERY_CONFUSING_INTENTIONAL</id>
    <artifact tool="FindBugs"
	      mnemonic="NM_VERY_CONFUSING_INTENTIONAL">
    </artifact>
    <shortMessage>
      Very confusing method names (but intentional)
    </shortMessage>
    <info>

      &lt;p&gt; The referenced methods have names that differ only
      by capitalization or the packages of their parameters. This
      is very confusing because if the capitalization were
      identical then one of the methods would override the other.
      From the existence of other methods, it seems that the
      existence of both of these methods is intentional, but is
      sure is confusing. You should try hard to eliminate one of
      them, unless you are forced to have both due to frozen APIs.
      &lt;/p&gt;

    </info>
    <name>Very Confusing Intentional</name>
  </findingType>
  <findingType>
    <id>NM_CONFUSING</id>
    <artifact tool="FindBugs" mnemonic="NM_CONFUSING"></artifact>
    <shortMessage>Confusing method names</shortMessage>
    <info>

      &lt;p&gt; The referenced methods have names that differ only
      by capitalization.&lt;/p&gt;

    </info>
    <name>Confusing</name>
  </findingType>
  <findingType>
    <id>NM_METHOD_CONSTRUCTOR_CONFUSION</id>
    <artifact tool="FindBugs"
	      mnemonic="NM_METHOD_CONSTRUCTOR_CONFUSION">
    </artifact>
    <shortMessage>
      Apparent method/constructor confusion
    </shortMessage>
    <info>

      &lt;p&gt; This regular method has the same name as the class
      it is defined in. It is likely that this was intended to be
      a constructor. If it was intended to be a constructor,
      remove the declaration of a void return value. If you had
      accidently defined this method, realized the mistake,
      defined a proper constructor but can't get rid of this
      method due to backwards compatibility, deprecate the method.
      &lt;/p&gt;

    </info>
    <name>Method Constructor Confusion</name>
  </findingType>
  <findingType>
    <id>SuspiciousHashcodeMethodName</id>
    <artifact tool="FindBugs" mnemonic="NM_LCASE_HASHCODE">
    </artifact>
    <artifact tool="PMD" mnemonic="SuspiciousHashcodeMethodName">
    </artifact>
    <shortMessage>
      Class defines hashcode(); should it be hashCode()?
    </shortMessage>
    <info>

      &lt;p&gt; This class defines a method called
      &lt;code&gt;hashcode()&lt;/code&gt;.&amp;nbsp; This method
      does not override the &lt;code&gt;hashCode()&lt;/code&gt;
      method in &lt;code&gt;java.lang.Object&lt;/code&gt;, which
      is probably what was intended.&lt;/p&gt;

      The method name and return type are suspiciously close to
      hashCode(), which may mean you are intending to override the
      hashCode() method.
    </info>
    <name>Suspicious Hashcode Method Name</name>
  </findingType>
  <findingType>
    <id>NM_LCASE_TOSTRING</id>
    <artifact tool="FindBugs" mnemonic="NM_LCASE_TOSTRING">
    </artifact>
    <shortMessage>
      Class defines tostring(); should it be toString()?
    </shortMessage>
    <info>

      &lt;p&gt; This class defines a method called
      &lt;code&gt;tostring()&lt;/code&gt;.&amp;nbsp; This method
      does not override the &lt;code&gt;toString()&lt;/code&gt;
      method in &lt;code&gt;java.lang.Object&lt;/code&gt;, which
      is probably what was intended.&lt;/p&gt;

    </info>
    <name>Lowercase tostring() Method Defined</name>
  </findingType>
  <findingType>
    <id>SuspiciousEqualsMethodName</id>
    <artifact tool="FindBugs" mnemonic="NM_BAD_EQUAL"></artifact>
    <artifact tool="PMD" mnemonic="SuspiciousEqualsMethodName">
    </artifact>
    <shortMessage>
      Class defines equal(); should it be equals()?
    </shortMessage>
    <info>

      &lt;p&gt; This class defines a method
      &lt;code&gt;equal(Object)&lt;/code&gt;.&amp;nbsp; This
      method does not override the
      &lt;code&gt;equals(Object)&lt;/code&gt; method in
      &lt;code&gt;java.lang.Object&lt;/code&gt;, which is probably
      what was intended.&lt;/p&gt;

      The method name and parameter number are suspiciously close
      to equals(Object), which may mean you are intending to
      override the equals(Object) method.
    </info>
    <name>Suspicious Equals Method Name</name>
  </findingType>
  <findingType>
    <id>NM_CLASS_NOT_EXCEPTION</id>
    <artifact tool="FindBugs" mnemonic="NM_CLASS_NOT_EXCEPTION">
    </artifact>
    <shortMessage>
      Class is not derived from an Exception, even though it is
      named as such
    </shortMessage>
    <info>

      &lt;p&gt; This class is not derived from another exception,
      but ends with 'Exception'. This will be confusing to users
      of this class.&lt;/p&gt;

    </info>
    <name>Class Not Exception</name>
  </findingType>
  <findingType>
    <id>RR_NOT_CHECKED</id>
    <artifact tool="FindBugs" mnemonic="RR_NOT_CHECKED"></artifact>
    <shortMessage>
      Method ignores results of InputStream.read()
    </shortMessage>
    <info>

      &lt;p&gt; This method ignores the return value of one of the
      variants of
      &lt;code&gt;java.io.InputStream.read()&lt;/code&gt; which
      can return multiple bytes.&amp;nbsp; If the return value is
      not checked, the caller will not be able to correctly handle
      the case where fewer bytes were read than the caller
      requested.&amp;nbsp; This is a particularly insidious kind
      of bug, because in many programs, reads from input streams
      usually do read the full amount of data requested, causing
      the program to fail only sporadically.&lt;/p&gt;

    </info>
    <name>Not Checked</name>
  </findingType>
  <findingType>
    <id>SR_NOT_CHECKED</id>
    <artifact tool="FindBugs" mnemonic="SR_NOT_CHECKED"></artifact>
    <shortMessage>
      Method ignores results of InputStream.skip()
    </shortMessage>
    <info>

      &lt;p&gt; This method ignores the return value of
      &lt;code&gt;java.io.InputStream.skip()&lt;/code&gt; which
      can skip multiple bytes.&amp;nbsp; If the return value is
      not checked, the caller will not be able to correctly handle
      the case where fewer bytes were skipped than the caller
      requested.&amp;nbsp; This is a particularly insidious kind
      of bug, because in many programs, skips from input streams
      usually do skip the full amount of data requested, causing
      the program to fail only sporadically. With Buffered
      streams, however, skip() will only skip data in the buffer,
      and will routinely fail to skip the requested number of
      bytes.&lt;/p&gt;

    </info>
    <name>Not Checked</name>
  </findingType>
  <findingType>
    <id>SE_READ_RESOLVE_MUST_RETURN_OBJECT</id>
    <artifact tool="FindBugs"
	      mnemonic="SE_READ_RESOLVE_MUST_RETURN_OBJECT">
    </artifact>
    <shortMessage>
      The readResolve method must be declared with a return type
      of Object.
    </shortMessage>
    <info>

      &lt;p&gt; In order for the readResolve method to be
      recognized by the serialization mechanism. &lt;/p&gt;

    </info>
    <name>Read Resolve Must Return Object</name>
  </findingType>
  <findingType>
    <id>SE_TRANSIENT_FIELD_OF_NONSERIALIZABLE_CLASS</id>
    <artifact tool="FindBugs"
	      mnemonic="SE_TRANSIENT_FIELD_OF_NONSERIALIZABLE_CLASS">
    </artifact>
    <shortMessage>
      Transient field of class that isn't Serializable.
    </shortMessage>
    <info>

      &lt;p&gt; The field is marked as transient, but the class
      isn't Serializable, so marking it as transient has
      absolutely no effect. This may be leftover marking from a
      previous version of the code in which the class was
      transient, or it may indicate a misunderstanding of how
      serialization works. &lt;/p&gt;

    </info>
    <name>Transient Field Of Nonserializable Class</name>
  </findingType>
  <findingType>
    <id>SE_TRANSIENT_FIELD_NOT_RESTORED</id>
    <artifact tool="FindBugs"
	      mnemonic="SE_TRANSIENT_FIELD_NOT_RESTORED">
    </artifact>
    <shortMessage>
      Transient field that isn't set by deserialization.
    </shortMessage>
    <info>

      &lt;p&gt; This class contains a field that is updated at
      multiple places in the class, thus it seems to be part of
      the state of the class. However, since the field is marked
      as transient and not set in readObject or readResolve, it
      will contain the default value in any deserialized instance
      of the class. &lt;/p&gt;

    </info>
    <name>Transient Field Not Restored</name>
  </findingType>
  <findingType>
    <id>SE_METHOD_MUST_BE_PRIVATE</id>
    <artifact tool="FindBugs"
	      mnemonic="SE_METHOD_MUST_BE_PRIVATE">
    </artifact>
    <shortMessage>
      Method must be private in order for serialization to work
    </shortMessage>
    <info>

      &lt;p&gt; This class implements the
      &lt;code&gt;Serializable&lt;/code&gt; interface, and defines
      a method for custom serialization/deserialization. But since
      that method isn't declared private, it will be silently
      ignored by the serialization/deserialization API.&lt;/p&gt;

    </info>
    <name>Method Must Be Private</name>
  </findingType>
  <findingType>
    <id>SE_NO_SUITABLE_CONSTRUCTOR_FOR_EXTERNALIZATION</id>
    <artifact tool="FindBugs"
	      mnemonic="SE_NO_SUITABLE_CONSTRUCTOR_FOR_EXTERNALIZATION">
    </artifact>
    <shortMessage>
      Class is Externalizable but doesn't define a void
      constructor
    </shortMessage>
    <info>

      &lt;p&gt; This class implements the
      &lt;code&gt;Externalizable&lt;/code&gt; interface, but does
      not define a void constructor. When Externalizable objects
      are deserialized, they first need to be constructed by
      invoking the void constructor. Since this class does not
      have one, serialization and deserialization will fail at
      runtime.&lt;/p&gt;

    </info>
    <name>No Suitable Constructor For Externalization</name>
  </findingType>
  <findingType>
    <id>SE_NO_SUITABLE_CONSTRUCTOR</id>
    <artifact tool="FindBugs"
	      mnemonic="SE_NO_SUITABLE_CONSTRUCTOR">
    </artifact>
    <shortMessage>
      Class is Serializable but its superclass doesn't define a
      void constructor
    </shortMessage>
    <info>

      &lt;p&gt; This class implements the
      &lt;code&gt;Serializable&lt;/code&gt; interface and its
      superclass does not. When such an object is deserialized,
      the fields of the superclass need to be initialized by
      invoking the void constructor of the superclass. Since the
      superclass does not have one, serialization and
      deserialization will fail at runtime.&lt;/p&gt;

    </info>
    <name>No Suitable Constructor</name>
  </findingType>
  <findingType>
    <id>SE_NO_SERIALVERSIONID</id>
    <artifact tool="FindBugs" mnemonic="SE_NO_SERIALVERSIONID">
    </artifact>
    <shortMessage>
      Class is Serializable, but doesn't define serialVersionUID
    </shortMessage>
    <info>

      &lt;p&gt; This class implements the
      &lt;code&gt;Serializable&lt;/code&gt; interface, but does
      not define a &lt;code&gt;serialVersionUID&lt;/code&gt;
      field.&amp;nbsp; A change as simple as adding a reference to
      a .class object will add synthetic fields to the class,
      which will unfortunately change the implicit
      serialVersionUID (e.g., adding a reference to
      &lt;code&gt;String.class&lt;/code&gt; will generate a static
      field &lt;code&gt;class$java$lang$String&lt;/code&gt;).
      Also, different source code to bytecode compilers may use
      different naming conventions for synthetic variables
      generated for references to class objects or inner classes.
      To ensure interoperability of Serializable across versions,
      consider adding an explicit serialVersionUID.&lt;/p&gt;

    </info>
    <name>No Serial Version Id Defined</name>
  </findingType>
  <findingType>
    <id>SE_COMPARATOR_SHOULD_BE_SERIALIZABLE</id>
    <artifact tool="FindBugs"
	      mnemonic="SE_COMPARATOR_SHOULD_BE_SERIALIZABLE">
    </artifact>
    <shortMessage>
      Comparator doesn't implement Serializable
    </shortMessage>
    <info>

      &lt;p&gt; This class implements the
      &lt;code&gt;Comparator&lt;/code&gt; interface. You should
      consider whether or not it should also implement the
      &lt;code&gt;Serializable&lt;/code&gt; interface. If a
      comparator is used to construct an ordered collection such
      as a &lt;code&gt;TreeMap&lt;/code&gt;, then the
      &lt;code&gt;TreeMap&lt;/code&gt; will be serializable only
      if the comparator is also serializable. As most comparators
      have little or no state, making them serializable is
      generally easy and good defensive programming. &lt;/p&gt;

    </info>
    <name>Comparator Should Be Serializable</name>
  </findingType>
  <findingType>
    <id>SF_SWITCH_FALLTHROUGH</id>
    <artifact tool="FindBugs" mnemonic="SF_SWITCH_FALLTHROUGH">
    </artifact>
    <shortMessage>
      Switch statement found where one case falls through to the
      next case
    </shortMessage>
    <info>

      &lt;p&gt; This method contains a switch statement where one
      case branch will fall through to the next case. Usually you
      need to end this case with a break or return.&lt;/p&gt;

    </info>
    <name>Switch Fallthrough</name>
  </findingType>
  <findingType>
    <id>SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH</id>
    <artifact tool="FindBugs"
	      mnemonic="SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH">
    </artifact>
    <shortMessage>
      Dead store due to switch statement fall through
    </shortMessage>
    <info>

      &lt;p&gt; A value stored in the previous switch case is
      overwritten here due to a switch fall through. It is likely
      that you forgot to put a break or return at the end of the
      previous case. &lt;/p&gt;

    </info>
    <name>Dead Store Due To Switch Fallthrough</name>
  </findingType>
  <findingType>
    <id>IncorrectSynchronizationOfWriteObject</id>
    <artifact tool="FindBugs" mnemonic="WS_WRITEOBJECT_SYNC">
    </artifact>
    <shortMessage>
      Class's writeObject() method is synchronized but nothing
      else is
    </shortMessage>
    <info>

      &lt;p&gt; This class has a
      &lt;code&gt;writeObject()&lt;/code&gt; method which is
      synchronized; however, no other method of the class is
      synchronized.&lt;/p&gt;

    </info>
    <name>writeObject Is Only Synchronized Method</name>
  </findingType>
  <findingType>
    <id>AvoidSynchronizationOfReadObject</id>
    <artifact tool="FindBugs" mnemonic="RS_READOBJECT_SYNC">
    </artifact>
    <shortMessage>
      Class's readObject() method is synchronized
    </shortMessage>
    <info>

      &lt;p&gt; This serializable class defines a
      &lt;code&gt;readObject()&lt;/code&gt; which is
      synchronized.&amp;nbsp; By definition, an object created by
      deserialization is only reachable by one thread, and thus
      there is no need for &lt;code&gt;readObject()&lt;/code&gt;
      to be synchronized.&amp;nbsp; If the
      &lt;code&gt;readObject()&lt;/code&gt; method itself is
      causing the object to become visible to another thread, that
      is an example of very dubious coding style.&lt;/p&gt;

    </info>
    <name>readObject Method is Synchronized</name>
  </findingType>
  <findingType>
    <id>SE_NONSTATIC_SERIALVERSIONID</id>
    <artifact tool="FindBugs"
	      mnemonic="SE_NONSTATIC_SERIALVERSIONID">
    </artifact>
    <shortMessage>serialVersionUID isn't static</shortMessage>
    <info>

      &lt;p&gt; This class defines a
      &lt;code&gt;serialVersionUID&lt;/code&gt; field that is not
      static.&amp;nbsp; The field should be made static if it is
      intended to specify the version UID for purposes of
      serialization.&lt;/p&gt;

    </info>
    <name>Nonstatic Serial Version Id</name>
  </findingType>
  <findingType>
    <id>SE_NONFINAL_SERIALVERSIONID</id>
    <artifact tool="FindBugs"
	      mnemonic="SE_NONFINAL_SERIALVERSIONID">
    </artifact>
    <shortMessage>serialVersionUID isn't final</shortMessage>
    <info>

      &lt;p&gt; This class defines a
      &lt;code&gt;serialVersionUID&lt;/code&gt; field that is not
      final.&amp;nbsp; The field should be made final if it is
      intended to specify the version UID for purposes of
      serialization.&lt;/p&gt;

    </info>
    <name>Nonfinal Serial Version Id</name>
  </findingType>
  <findingType>
    <id>SE_NONLONG_SERIALVERSIONID</id>
    <artifact tool="FindBugs"
	      mnemonic="SE_NONLONG_SERIALVERSIONID">
    </artifact>
    <shortMessage>serialVersionUID isn't long</shortMessage>
    <info>

      &lt;p&gt; This class defines a
      &lt;code&gt;serialVersionUID&lt;/code&gt; field that is not
      long.&amp;nbsp; The field should be made long if it is
      intended to specify the version UID for purposes of
      serialization.&lt;/p&gt;

    </info>
    <name>Nonlong Serial Version Id</name>
  </findingType>
  <findingType>
    <id>SE_BAD_FIELD</id>
    <artifact tool="FindBugs" mnemonic="SE_BAD_FIELD"></artifact>
    <shortMessage>
      Non-transient non-serializable instance field in
      serializable class
    </shortMessage>
    <info>

      &lt;p&gt; This Serializable class defines a non-primitive
      instance field which is neither transient, Serializable, or
      &lt;code&gt;java.lang.Object&lt;/code&gt;, and does not
      appear to implement the
      &lt;code&gt;Externalizable&lt;/code&gt; interface or the
      &lt;code&gt;readObject()&lt;/code&gt; and
      &lt;code&gt;writeObject()&lt;/code&gt; methods.&amp;nbsp;
      Objects of this class will not be deserialized correctly if
      a non-Serializable object is stored in this field.&lt;/p&gt;

    </info>
    <name>Bad Field</name>
  </findingType>
  <findingType>
    <id>SE_BAD_FIELD_INNER_CLASS</id>
    <artifact tool="FindBugs" mnemonic="SE_BAD_FIELD_INNER_CLASS">
    </artifact>
    <shortMessage>
      Non-serializable class has a serializable inner class
    </shortMessage>
    <info>

      &lt;p&gt; This Serializable class is an inner class of a
      non-serializable class. Thus, attempts to serialize it will
      also attempt to associate instance of the outer class with
      which it is associated, leading to a runtime error.
      &lt;/p&gt; &lt;p&gt;If possible, making the inner class a
      static inner class should solve the problem. Making the
      outer class serializable might also work, but that would
      mean serializing an instance of the inner class would always
      also serialize the instance of the outer class, which it
      often not what you really want.

    </info>
    <name>Bad Field Inner Class</name>
  </findingType>
  <findingType>
    <id>SE_INNER_CLASS</id>
    <artifact tool="FindBugs" mnemonic="SE_INNER_CLASS"></artifact>
    <shortMessage>Serializable inner class</shortMessage>
    <info>

      &lt;p&gt; This Serializable class is an inner class. Any
      attempt to serialize it will also serialize the associated
      outer instance. The outer instance is serializable, so this
      won't fail, but it might serialize a lot more data than
      intended. If possible, making the inner class a static inner
      class (also known as a nested class) should solve the
      problem.

    </info>
    <name>Inner Class</name>
  </findingType>
  <findingType>
    <id>SE_BAD_FIELD_STORE</id>
    <artifact tool="FindBugs" mnemonic="SE_BAD_FIELD_STORE">
    </artifact>
    <shortMessage>
      Non-serializable value stored into instance field of a
      serializable class
    </shortMessage>
    <info>

      &lt;p&gt; A non-serializable value is stored into a
      non-transient field of a serializable class.&lt;/p&gt;

    </info>
    <name>Bad Field Store</name>
  </findingType>
  <findingType>
    <id>AvoidThreadStartInConstructor</id>
    <artifact tool="FindBugs" mnemonic="SC_START_IN_CTOR">
    </artifact>
    <shortMessage>Constructor invokes Thread.start()</shortMessage>
    <info>

      &lt;p&gt; The constructor starts a thread. This is likely to
      be wrong if the class is ever extended/subclassed, since the
      thread will be started before the subclass constructor is
      started.&lt;/p&gt;

    </info>
    <name>Start In Constructor</name>
  </findingType>
  <findingType>
    <id>SS_SHOULD_BE_STATIC</id>
    <artifact tool="FindBugs" mnemonic="SS_SHOULD_BE_STATIC">
    </artifact>
    <shortMessage>
      Unread field: should this field be static?
    </shortMessage>
    <info>

      &lt;p&gt; This class contains an instance final field that
      is initialized to a compile-time static value. Consider
      making the field static.&lt;/p&gt;

    </info>
    <name>Should Be Static</name>
  </findingType>
  <findingType>
    <id>UnusedField</id>
    <artifact tool="FindBugs" mnemonic="UUF_UNUSED_FIELD"></artifact>
    <artifact tool="PMD" mnemonic="UnusedPrivateField"></artifact>
    <shortMessage>Unused field</shortMessage>
    <info>

      &lt;p&gt; This field is never used.&amp;nbsp; Consider
      removing it from the class.&lt;/p&gt;

      Detects when a private field is declared and/or assigned a
      value, but not used.
    </info>
    <name>Unused Field</name>
  </findingType>
  <findingType>
    <id>URF_UNREAD_FIELD</id>
    <artifact tool="FindBugs" mnemonic="URF_UNREAD_FIELD">
    </artifact>
    <shortMessage>Unread field</shortMessage>
    <info>

      &lt;p&gt; This field is never read.&amp;nbsp; Consider
      removing it from the class.&lt;/p&gt;

    </info>
    <name>Unread Field</name>
  </findingType>
  <findingType>
    <id>QF_QUESTIONABLE_FOR_LOOP</id>
    <artifact tool="FindBugs" mnemonic="QF_QUESTIONABLE_FOR_LOOP">
    </artifact>
    <shortMessage>
      Complicated, subtle or wrong increment in for-loop
    </shortMessage>
    <info>

      &lt;p&gt;Are you sure this for loop is incrementing the
      correct variable? It appears that another variable is being
      initialized and checked by the for loop. &lt;/p&gt;

    </info>
    <name>Questionable For Loop</name>
  </findingType>
  <findingType>
    <id>UWF_NULL_FIELD</id>
    <artifact tool="FindBugs" mnemonic="UWF_NULL_FIELD"></artifact>
    <shortMessage>Field only ever set to null</shortMessage>
    <info>

      &lt;p&gt; All writes to this field are of the constant value
      null, and thus all reads of the field will return null.
      Check for errors, or remove it if it is useless.&lt;/p&gt;

    </info>
    <name>Null Field</name>
  </findingType>
  <findingType>
    <id>UWF_UNWRITTEN_FIELD</id>
    <artifact tool="FindBugs" mnemonic="UWF_UNWRITTEN_FIELD">
    </artifact>
    <shortMessage>Unwritten field</shortMessage>
    <info>

      &lt;p&gt; This field is never written.&amp;nbsp; All reads
      of it will return the default value. Check for errors
      (should it have been initialized?), or remove it if it is
      useless.&lt;/p&gt;

    </info>
    <name>Unwritten Field</name>
  </findingType>
  <findingType>
    <id>ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD</id>
    <artifact tool="FindBugs"
	      mnemonic="ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD">
    </artifact>
    <shortMessage>
      Write to static field from instance method
    </shortMessage>
    <info>

      &lt;p&gt; This instance method writes to a static field.
      This is tricky to get correct if multiple instances are
      being manipulated, and generally bad practice. &lt;/p&gt;

    </info>
    <name>Write To Static From Instance Method</name>
  </findingType>
  <findingType>
    <id>NP_LOAD_OF_KNOWN_NULL_VALUE</id>
    <artifact tool="FindBugs"
	      mnemonic="NP_LOAD_OF_KNOWN_NULL_VALUE">
    </artifact>
    <shortMessage>Load of known null value</shortMessage>
    <info>

      &lt;p&gt; The variable referenced at this point is known to
      be null due to an earlier check against null. Although this
      is valid, it might be a mistake (perhaps you intended to
      refer to a different variable, or perhaps the earlier check
      to see if the variable is null should have been a check to
      see if it was nonnull. &lt;/p&gt;

    </info>
    <name>Load Of Known Null Value</name>
  </findingType>
  <findingType>
    <id>NP_IMMEDIATE_DEREFERENCE_OF_READLINE</id>
    <artifact tool="FindBugs"
	      mnemonic="NP_IMMEDIATE_DEREFERENCE_OF_READLINE">
    </artifact>
    <shortMessage>
      Immediate dereference of the result of readLine()
    </shortMessage>
    <info>

      &lt;p&gt; The result of invoking readLine() is immediately
      dereferenced. If there are no more lines of text to read,
      readLine() will return null and dereferencing that will
      generate a null pointer exception. &lt;/p&gt;

    </info>
    <name>Immediate Dereference Of Readline</name>
  </findingType>
  <findingType>
    <id>NP_UNWRITTEN_FIELD</id>
    <artifact tool="FindBugs" mnemonic="NP_UNWRITTEN_FIELD">
    </artifact>
    <shortMessage>Read of unwritten field</shortMessage>
    <info>

      &lt;p&gt; The program is dereferencing a field that does not
      seem to ever have a non-null value written to it.
      Dereferencing this value will generate a null pointer
      exception. &lt;/p&gt;

    </info>
    <name>Unwritten Field</name>
  </findingType>
  <findingType>
    <id>SIC_INNER_SHOULD_BE_STATIC</id>
    <artifact tool="FindBugs"
	      mnemonic="SIC_INNER_SHOULD_BE_STATIC">
    </artifact>
    <shortMessage>Should be a static inner class</shortMessage>
    <info>

      &lt;p&gt; This class is an inner class, but does not use its
      embedded reference to the object which created it.&amp;nbsp;
      This reference makes the instances of the class larger, and
      may keep the reference to the creator object alive longer
      than necessary.&amp;nbsp; If possible, the class should be
      made static. &lt;/p&gt;

    </info>
    <name>Inner Should Be Static</name>
  </findingType>
  <findingType>
    <id>NP_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR</id>
    <artifact tool="FindBugs"
	      mnemonic="NP_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR">
    </artifact>
    <shortMessage>
      Read of field not initialized in constructor
    </shortMessage>
    <info>

      &lt;p&gt; This is a read of a field is never initialized
      within any constructor, and is therefore could be null after
      the object is initialized. This might be a coding error, or
      else the class containing the field is written in a way that
      depends upon methods being called in some specific order (a
      little bit dodgy, but not necessarily wrong). &lt;/p&gt;

    </info>
    <name>Field Not Initialized In Constructor</name>
  </findingType>
  <findingType>
    <id>UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR</id>
    <artifact tool="FindBugs"
	      mnemonic="UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR">
    </artifact>
    <shortMessage>
      Field not initialized in constructor
    </shortMessage>
    <info>

      &lt;p&gt; This field is never initialized within any
      constructor, and is therefore could be null after the object
      is constructed. This could be a either an error or a
      questionable design, since it means a null pointer exception
      will be generated if that field is dereferenced before being
      initialized. &lt;/p&gt;

    </info>
    <name>Field Not Initialized In Constructor</name>
  </findingType>
  <findingType>
    <id>SIC_INNER_SHOULD_BE_STATIC_ANON</id>
    <artifact tool="FindBugs"
	      mnemonic="SIC_INNER_SHOULD_BE_STATIC_ANON">
    </artifact>
    <shortMessage>
      Could be refactored into a named static inner class
    </shortMessage>
    <info>

      &lt;p&gt; This class is an inner class, but does not use its
      embedded reference to the object which created it.&amp;nbsp;
      This reference makes the instances of the class larger, and
      may keep the reference to the creator object alive longer
      than necessary.&amp;nbsp; If possible, the class should be
      made into a &lt;em&gt;static&lt;/em&gt; inner class. Since
      anonymous inner classes cannot be marked as static, doing
      this will requiring refactoring the inner class so that it
      is a named inner class.&lt;/p&gt;

    </info>
    <name>Inner Should Be Static Anon</name>
  </findingType>
  <findingType>
    <id>SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS</id>
    <artifact tool="FindBugs"
	      mnemonic="SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS">
    </artifact>
    <shortMessage>
      Could be refactored into a static inner class
    </shortMessage>
    <info>

      &lt;p&gt; This class is an inner class, but does not use its
      embedded reference to the object which created it except
      during construction of the inner object.&amp;nbsp; This
      reference makes the instances of the class larger, and may
      keep the reference to the creator object alive longer than
      necessary.&amp;nbsp; If possible, the class should be made
      into a &lt;em&gt;static&lt;/em&gt; inner class. Since the
      reference to the outer object is required during
      construction of the inner instance, the inner class will
      need to be refactored so as to pass a reference to the outer
      instance to the constructor for the inner class.&lt;/p&gt;

    </info>
    <name>Inner Should Be Static Needs This</name>
  </findingType>
  <findingType>
    <id>WaitNotInLoop</id>
    <artifact tool="FindBugs" mnemonic="WA_NOT_IN_LOOP"></artifact>
    <shortMessage>Wait not in loop</shortMessage>
    <info>

      &lt;p&gt; This method contains a call to
      &lt;code&gt;java.lang.Object.wait()&lt;/code&gt; which is
      not in a loop.&amp;nbsp; If the monitor is used for multiple
      conditions, the condition the caller intended to wait for
      might not be the one that actually occurred.&lt;/p&gt;

    </info>
    <name>Not In Loop</name>
  </findingType>
  <findingType>
    <id>AwaitNotInLoop</id>
    <artifact tool="FindBugs" mnemonic="WA_AWAIT_NOT_IN_LOOP">
    </artifact>
    <shortMessage>Condition.await() not in loop</shortMessage>
    <info>

      &lt;p&gt; This method contains a call to
      &lt;code&gt;java.util.concurrent.await()&lt;/code&gt; (or
      variants) which is not in a loop.&amp;nbsp; If the object is
      used for multiple conditions, the condition the caller
      intended to wait for might not be the one that actually
      occurred.&lt;/p&gt;

    </info>
    <name>Await Not In Loop</name>
  </findingType>
  <findingType>
    <id>UseNotifyAllInsteadOfNotify</id>
    <artifact tool="FindBugs" mnemonic="NO_NOTIFY_NOT_NOTIFYALL">
    </artifact>
    <artifact tool="PMD" mnemonic="UseNotifyAllInsteadOfNotify">
    </artifact>
    <shortMessage>
      Using notify() rather than notifyAll()
    </shortMessage>
    <info>

      &lt;p&gt; This method calls
      &lt;code&gt;notify()&lt;/code&gt; rather than
      &lt;code&gt;notifyAll()&lt;/code&gt;.&amp;nbsp; Java
      monitors are often used for multiple conditions.&amp;nbsp;
      Calling &lt;code&gt;notify()&lt;/code&gt; only wakes up one
      thread, meaning that the thread woken up might not be the
      one waiting for the condition that the caller just
      satisfied.&lt;/p&gt;

      Thread.notify() awakens a thread monitoring the object. If
      more than one thread is monitoring, then only one is chosen.
      The thread chosen is arbitrary; thus it's usually safer to
      call notifyAll() instead.

    </info>
    <name>Notify Not Notifyall</name>
  </findingType>
  <findingType>
    <id>RV_CHECK_FOR_POSITIVE_INDEXOF</id>
    <artifact tool="FindBugs"
	      mnemonic="RV_CHECK_FOR_POSITIVE_INDEXOF">
    </artifact>
    <shortMessage>
      Method checks to see if result of String.indexOf is positive
    </shortMessage>
    <info>

      &lt;p&gt; The method invokes String.indexOf and checks to
      see if the result is positive or non-positive. It is much
      more typical to check to see if the result is negative or
      non-negative. It is positive only if the substring checked
      for occurs at some place other than at the beginning of the
      String.&lt;/p&gt;

    </info>
    <name>Check For Positive Indexof</name>
  </findingType>
  <findingType>
    <id>RV_DONT_JUST_NULL_CHECK_READLINE</id>
    <artifact tool="FindBugs"
	      mnemonic="RV_DONT_JUST_NULL_CHECK_READLINE">
    </artifact>
    <shortMessage>
      Method discards result of readLine after checking if it is
      nonnull
    </shortMessage>
    <info>

      &lt;p&gt; The value returned by readLine is discarded after
      checking to see if the return value is non-null. In almost
      all situations, if the result is non-null, you will want to
      use that non-null value. Calling readLine again will give
      you a different line.&lt;/p&gt;

    </info>
    <name>Dont Just Null Check Readline</name>
  </findingType>
  <findingType>
    <id>RV_RETURN_VALUE_IGNORED</id>
    <artifact tool="FindBugs" mnemonic="RV_RETURN_VALUE_IGNORED">
    </artifact>
    <shortMessage>Method ignores return value</shortMessage>
    <info>

      &lt;p&gt; The return value of this method should be checked.
      One common cause of this warning is to invoke a method on an
      immutable object, thinking that it updates the object. For
      example, in the following code fragment,&lt;/p&gt;
      &lt;blockquote&gt; &lt;pre&gt; String dateString =
      getHeaderField(name); dateString.trim(); &lt;/pre&gt;
      &lt;/blockquote&gt; &lt;p&gt;the programmer seems to be
      thinking that the trim() method will update the String
      referenced by dateString. But since Strings are immutable,
      the trim() function returns a new String value, which is
      being ignored here. The code should be corrected to:
      &lt;/p&gt; &lt;blockquote&gt; &lt;pre&gt; String dateString
      = getHeaderField(name); dateString = dateString.trim();
      &lt;/pre&gt; &lt;/blockquote&gt;

    </info>
    <name>Return Value Ignored</name>
  </findingType>
  <findingType>
    <id>RV_RETURN_VALUE_IGNORED2</id>
    <artifact tool="FindBugs" mnemonic="RV_RETURN_VALUE_IGNORED2">
    </artifact>
    <shortMessage>Method ignores return value</shortMessage>
    <info>

      &lt;p&gt; The return value of this method should be checked.
      One common cause of this warning is to invoke a method on an
      immutable object, thinking that it updates the object. For
      example, in the following code fragment,&lt;/p&gt;
      &lt;blockquote&gt; &lt;pre&gt; String dateString =
      getHeaderField(name); dateString.trim(); &lt;/pre&gt;
      &lt;/blockquote&gt; &lt;p&gt;the programmer seems to be
      thinking that the trim() method will update the String
      referenced by dateString. But since Strings are immutable,
      the trim() function returns a new String value, which is
      being ignored here. The code should be corrected to:
      &lt;/p&gt; &lt;blockquote&gt; &lt;pre&gt; String dateString
      = getHeaderField(name); dateString = dateString.trim();
      &lt;/pre&gt; &lt;/blockquote&gt;

    </info>
    <name>Return Value IGNORED2</name>
  </findingType>
  <findingType>
    <id>NP_ALWAYS_NULL</id>
    <artifact tool="FindBugs" mnemonic="NP_ALWAYS_NULL"></artifact>
    <shortMessage>Null pointer dereference</shortMessage>
    <info>

      &lt;p&gt; A null pointer is dereferenced here.&amp;nbsp;
      This will lead to a
      &lt;code&gt;NullPointerException&lt;/code&gt; when the code
      is executed.&lt;/p&gt;

    </info>
    <name>Always Null</name>
  </findingType>
  <findingType>
    <id>NP_STORE_INTO_NONNULL_FIELD</id>
    <artifact tool="FindBugs"
	      mnemonic="NP_STORE_INTO_NONNULL_FIELD">
    </artifact>
    <shortMessage>
      Store of null value into field annotated NonNull
    </shortMessage>
    <info>

      &lt;p&gt; A value that could be null is stored into a field
      that has been annotated as NonNull. &lt;/p&gt;

    </info>
    <name>Store Into Nonnull Field</name>
  </findingType>
  <findingType>
    <id>NP_ALWAYS_NULL_EXCEPTION</id>
    <artifact tool="FindBugs" mnemonic="NP_ALWAYS_NULL_EXCEPTION">
    </artifact>
    <shortMessage>
      Null pointer dereference in method on exception path
    </shortMessage>
    <info>

      &lt;p&gt; A pointer which is null on an exception path is
      dereferenced here.&amp;nbsp; This will lead to a
      &lt;code&gt;NullPointerException&lt;/code&gt; when the code
      is executed.&amp;nbsp; Note that because FindBugs currently
      does not prune infeasible exception paths, this may be a
      false warning.&lt;/p&gt;

      &lt;p&gt; Also note that FindBugs considers the default case
      of a switch statement to be an exception path, since the
      default case is often infeasible.&lt;/p&gt;

    </info>
    <name>Always Null Exception</name>
  </findingType>
  <findingType>
    <id>NP_NULL_ON_SOME_PATH</id>
    <artifact tool="FindBugs" mnemonic="NP_NULL_ON_SOME_PATH">
    </artifact>
    <shortMessage>Possible null pointer dereference</shortMessage>
    <info>

      &lt;p&gt; A reference value dereferenced here might be null
      at runtime.&amp;nbsp; This may lead to a
      &lt;code&gt;NullPointerException&lt;/code&gt; when the code
      is executed.&lt;/p&gt;

    </info>
    <name>Null On Some Path</name>
  </findingType>
  <findingType>
    <id>NP_NULL_ON_SOME_PATH_EXCEPTION</id>
    <artifact tool="FindBugs"
	      mnemonic="NP_NULL_ON_SOME_PATH_EXCEPTION">
    </artifact>
    <shortMessage>
      Possible null pointer dereference in method on exception
      path
    </shortMessage>
    <info>

      &lt;p&gt; A reference value which is null on some exception
      control path is dereferenced here.&amp;nbsp; This may lead
      to a &lt;code&gt;NullPointerException&lt;/code&gt; when the
      code is executed.&amp;nbsp; Note that because FindBugs
      currently does not prune infeasible exception paths, this
      may be a false warning.&lt;/p&gt;

      &lt;p&gt; Also note that FindBugs considers the default case
      of a switch statement to be an exception path, since the
      default case is often infeasible.&lt;/p&gt;

    </info>
    <name>Null On Some Path Exception</name>
  </findingType>
  <findingType>
    <id>NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE</id>
    <artifact tool="FindBugs"
	      mnemonic="NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE">
    </artifact>
    <shortMessage>
      Possible null pointer dereference due to return value of
      called method
    </shortMessage>
    <info>

      &lt;p&gt; A reference value which is null on some exception
      control path is dereferenced here.&amp;nbsp; This may lead
      to a &lt;code&gt;NullPointerException&lt;/code&gt; when the
      code is executed.&amp;nbsp; The value may be null because it
      was return from a method which is known to return
      possibly-null values.&lt;/p&gt;

    </info>
    <name>Null On Some Path From Return Value</name>
  </findingType>
  <findingType>
    <id>NP_NULL_PARAM_DEREF_NONVIRTUAL</id>
    <artifact tool="FindBugs"
	      mnemonic="NP_NULL_PARAM_DEREF_NONVIRTUAL">
    </artifact>
    <shortMessage>
      Non-virtual method call passes null for unconditionally
      dereferenced parameter
    </shortMessage>
    <info>

      &lt;p&gt; A possibly-null value is passed to a method which
      unconditionally dereferences it. This will almost certainly
      result in a null pointer exception. &lt;/p&gt;

    </info>
    <name>Null Param Deref Nonvirtual</name>
  </findingType>
  <findingType>
    <id>NP_NULL_PARAM_DEREF_ALL_TARGETS_DANGEROUS</id>
    <artifact tool="FindBugs"
	      mnemonic="NP_NULL_PARAM_DEREF_ALL_TARGETS_DANGEROUS">
    </artifact>
    <shortMessage>
      Method call passes null for unconditionally dereferenced
      parameter
    </shortMessage>
    <info>

      &lt;p&gt; A possibly-null value is passed at a call site
      where all known target methods will unconditionally
      dereference it. This is very likely to result in a null
      pointer exception. &lt;/p&gt;

    </info>
    <name>Null Param Deref All Targets Dangerous</name>
  </findingType>
  <findingType>
    <id>NP_NULL_PARAM_DEREF</id>
    <artifact tool="FindBugs" mnemonic="NP_NULL_PARAM_DEREF">
    </artifact>
    <shortMessage>
      Method call passes null for unconditionally dereferenced
      parameter
    </shortMessage>
    <info>

      &lt;p&gt; This method call passes a null value to a method
      which might dereference it unconditionally. &lt;/p&gt;

    </info>
    <name>Null Param Deref</name>
  </findingType>
  <findingType>
    <id>NP_NONNULL_PARAM_VIOLATION</id>
    <artifact tool="FindBugs"
	      mnemonic="NP_NONNULL_PARAM_VIOLATION">
    </artifact>
    <shortMessage>
      Method call passes null to a nonnull parameter
    </shortMessage>
    <info>

      &lt;p&gt; This method passes a null value as the parameter
      of a method which must be nonnull. Either this parameter has
      been explicitly marked as @Nonnull, or analysis has
      determined that this parameter is always deferenced.
      &lt;/p&gt;

    </info>
    <name>Nonnull Param Violation</name>
  </findingType>
  <findingType>
    <id>NP_NONNULL_RETURN_VIOLATION</id>
    <artifact tool="FindBugs"
	      mnemonic="NP_NONNULL_RETURN_VIOLATION">
    </artifact>
    <shortMessage>
      Method may return null, but is declared @NonNull
    </shortMessage>
    <info>

      &lt;p&gt; This method may return a null value, but the
      method (or a superclass method which it overrides) is
      declared to return @NonNull. &lt;/p&gt;

    </info>
    <name>Nonnull Return Violation</name>
  </findingType>
  <findingType>
    <id>NP_CLONE_COULD_RETURN_NULL</id>
    <artifact tool="FindBugs"
	      mnemonic="NP_CLONE_COULD_RETURN_NULL">
    </artifact>
    <shortMessage>Clone method may return null</shortMessage>
    <info>

      &lt;p&gt; This clone method seems to return null in some
      circumstances, but clone is never allowed to return a null
      value. If you are convinced this path is unreachable, throw
      an AssertionError instead. &lt;/p&gt;

    </info>
    <name>Clone Could Return Null</name>
  </findingType>
  <findingType>
    <id>NP_TOSTRING_COULD_RETURN_NULL</id>
    <artifact tool="FindBugs"
	      mnemonic="NP_TOSTRING_COULD_RETURN_NULL">
    </artifact>
    <shortMessage>toString method may return null</shortMessage>
    <info>

      &lt;p&gt; This toString method seems to return null in some
      circumstances. A liberal reading of the spec could be
      interpreted as allowing this, but it is probably a bad idea
      and could cause other code to break. Return the empty string
      or some other appropriate string rather than null.
      &lt;/p&gt;

    </info>
    <name>Tostring Could Return Null</name>
  </findingType>
  <findingType>
    <id>NP_GUARANTEED_DEREF</id>
    <artifact tool="FindBugs" mnemonic="NP_GUARANTEED_DEREF">
    </artifact>
    <shortMessage>
      Null value is guaranteed to be dereferenced
    </shortMessage>
    <info>

      &lt;p&gt; There is a statement or branch that if executed
      guarantees that a value is null at this point, and that
      value that is guaranteed to be dereferenced (except on
      forward paths involving runtime exceptions). &lt;/p&gt;

    </info>
    <name>Guaranteed Deref</name>
  </findingType>
  <findingType>
    <id>NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH</id>
    <artifact tool="FindBugs"
	      mnemonic="NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH">
    </artifact>
    <shortMessage>
      Value is null and guaranteed to be dereferenced on exception
      path
    </shortMessage>
    <info>

      &lt;p&gt; There is a statement or branch on an exception
      path that if executed guarantees that a value is null at
      this point, and that value that is guaranteed to be
      dereferenced (except on forward paths involving runtime
      exceptions). &lt;/p&gt;

    </info>
    <name>Guaranteed Deref On Exception Path</name>
  </findingType>
  <findingType>
    <id>SI_INSTANCE_BEFORE_FINALS_ASSIGNED</id>
    <artifact tool="FindBugs"
	      mnemonic="SI_INSTANCE_BEFORE_FINALS_ASSIGNED">
    </artifact>
    <shortMessage>
      Static initializer creates instance before all static final
      fields assigned
    </shortMessage>
    <info>

      &lt;p&gt; The class's static initializer creates an instance
      of the class before all of the static final fields are
      assigned.&lt;/p&gt;

    </info>
    <name>Instance Before Finals Assigned</name>
  </findingType>
  <findingType>
    <id>OS_OPEN_STREAM</id>
    <artifact tool="FindBugs" mnemonic="OS_OPEN_STREAM"></artifact>
    <shortMessage>Method may fail to close stream</shortMessage>
    <info>

      &lt;p&gt; The method creates an IO stream object, does not
      assign it to any fields, pass it to other methods that might
      close it, or return it, and does not appear to close the
      stream on all paths out of the method.&amp;nbsp; This may
      result in a file descriptor leak.&amp;nbsp; It is generally
      a good idea to use a &lt;code&gt;finally&lt;/code&gt; block
      to ensure that streams are closed.&lt;/p&gt;

    </info>
    <name>Open Stream</name>
  </findingType>
  <findingType>
    <id>OS_OPEN_STREAM_EXCEPTION_PATH</id>
    <artifact tool="FindBugs"
	      mnemonic="OS_OPEN_STREAM_EXCEPTION_PATH">
    </artifact>
    <shortMessage>
      Method may fail to close stream on exception
    </shortMessage>
    <info>

      &lt;p&gt; The method creates an IO stream object, does not
      assign it to any fields, pass it to other methods, or return
      it, and does not appear to close it on all possible
      exception paths out of the method.&amp;nbsp; This may result
      in a file descriptor leak.&amp;nbsp; It is generally a good
      idea to use a &lt;code&gt;finally&lt;/code&gt; block to
      ensure that streams are closed.&lt;/p&gt;

    </info>
    <name>Open Stream Exception Path</name>
  </findingType>
  <findingType>
    <id>PZLA_PREFER_ZERO_LENGTH_ARRAYS</id>
    <artifact tool="FindBugs"
	      mnemonic="PZLA_PREFER_ZERO_LENGTH_ARRAYS">
    </artifact>
    <artifact tool="PMD" mnemonic="ReturnEmptyArrayRatherThanNull">
    </artifact>		
    <shortMessage>
      Consider returning a zero length array rather than null
    </shortMessage>
    <info>

      &lt;p&gt; It is often a better design to return a length
      zero array rather than a null reference to indicate that
      there are no results (i.e., an empty list of results). This
      way, no explicit check for null is needed by clients of the
      method.&lt;/p&gt;

      &lt;p&gt;On the other hand, using null to indicate
      &quot;there is no answer to this question&quot;, then it is
      probably appropriate. For example,
      &lt;code&gt;File.listFiles()&lt;/code&gt; returns an empty
      list if given a directory containing no files, and returns
      null if the file is not a directory.&lt;/p&gt;

    </info>
    <name>Prefer Zero Length Arrays</name>
  </findingType>
  <findingType>
    <id>UCF_USELESS_CONTROL_FLOW</id>
    <artifact tool="FindBugs" mnemonic="UCF_USELESS_CONTROL_FLOW">
    </artifact>
    <shortMessage>Useless control flow</shortMessage>
    <info>

      &lt;p&gt; This method contains a useless control flow
      statement, where control flow continues onto the same place
      regardless of whether or not the branch is taken. For
      example, this is caused by having an empty statement block
      fot an &lt;code&gt;if&lt;/code&gt; statement:&lt;/p&gt;
      &lt;pre&gt; if (argv.length == 0) { // TODO: handle this
      case } &lt;/pre&gt;

    </info>
    <name>Useless Control Flow</name>
  </findingType>
  <findingType>
    <id>UCF_USELESS_CONTROL_FLOW_NEXT_LINE</id>
    <artifact tool="FindBugs"
	      mnemonic="UCF_USELESS_CONTROL_FLOW_NEXT_LINE">
    </artifact>
    <shortMessage>Useless control flow to next line</shortMessage>
    <info>

      &lt;p&gt; This method contains a useless control flow
      statement in which control flow follows to the same or
      following line regardless of whether or not the branch is
      taken. Often, this is caused by inadvertently using an empty
      statement as the body of an &lt;code&gt;if&lt;/code&gt;
      statement, e.g.:&lt;/p&gt; &lt;pre&gt; if (argv.length ==
      1); System.out.println(&quot;Hello, &quot; + argv[0]);
      &lt;/pre&gt;

    </info>
    <name>Useless Control Flow Next Line</name>
  </findingType>
  <findingType>
    <id>RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE</id>
    <artifact tool="FindBugs"
	      mnemonic="RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE">
    </artifact>
    <shortMessage>
      Nullcheck of value previously dereferenced
    </shortMessage>
    <info>

      &lt;p&gt; A value is checked here to see whether it is null,
      but this value can't be null because it was previously
      dereferenced and if it were null a null pointer exception
      would have occurred at the earlier dereference. Essentially,
      this code and the previous dereference disagree as to
      whether this value is allowed to be null. Either the check
      is redundant or the previous dereference is
      erroneous.&lt;/p&gt;

    </info>
    <name>Redundant Nullcheck Would Have Been A NullPointerException</name>
  </findingType>
  <findingType>
    <id>RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE</id>
    <artifact tool="FindBugs"
	      mnemonic="RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE">
    </artifact>
    <shortMessage>
      Redundant nullcheck of value known to be null
    </shortMessage>
    <info>

      &lt;p&gt; This method contains a redundant check of a known
      null value against the constant null.&lt;/p&gt;

    </info>
    <name>Redundant Nullcheck Of Null Value</name>
  </findingType>
  <findingType>
    <id>RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE</id>
    <artifact tool="FindBugs"
	      mnemonic="RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE">
    </artifact>
    <shortMessage>
      Redundant nullcheck of value known to be non-null
    </shortMessage>
    <info>

      &lt;p&gt; This method contains a redundant check of a known
      non-null value against the constant null.&lt;/p&gt;

    </info>
    <name>Redundant Nullcheck Of Nonnull Value</name>
  </findingType>
  <findingType>
    <id>RCN_REDUNDANT_COMPARISON_TWO_NULL_VALUES</id>
    <artifact tool="FindBugs"
	      mnemonic="RCN_REDUNDANT_COMPARISON_TWO_NULL_VALUES">
    </artifact>
    <shortMessage>
      Redundant comparison of two null values
    </shortMessage>
    <info>

      &lt;p&gt; This method contains a redundant comparison of two
      references known to both be definitely null.&lt;/p&gt;

    </info>
    <name>Redundant Comparison Two Null Values</name>
  </findingType>
  <findingType>
    <id>RedundantComparisonOfNullAndNonnullValue</id>
    <artifact tool="FindBugs"
	      mnemonic="RCN_REDUNDANT_COMPARISON_OF_NULL_AND_NONNULL_VALUE">
    </artifact>
    <artifact tool="PMD" mnemonic="MisplacedNullCheck"></artifact>
    <shortMessage>
      Redundant comparison of non-null value to null
    </shortMessage>
    <info>
      &lt;p&gt; This method contains a reference known to be
      non-null with another reference known to be null.&lt;/p&gt;

      The null check here is misplaced. if the variable is null
      you'll get a NullPointerException. Either the check is
      useless (the variable will never be &quot;null&quot;) or
      it's incorrect.
    </info>
    <name>Redundant Comparison Of Null And Nonnull Value</name>
  </findingType>
  <findingType>
    <id>UnreleasedLock</id>
    <artifact tool="FindBugs" mnemonic="UL_UNRELEASED_LOCK">
    </artifact>
    <shortMessage>
      Method does not release lock on all paths
    </shortMessage>
    <info>

      &lt;p&gt; This method acquires a JSR-166
      (&lt;code&gt;java.util.concurrent&lt;/code&gt;) lock, but
      does not release it on all paths out of the method. In
      general, the correct idiom for using a JSR-166 lock is:
      &lt;/p&gt; &lt;pre&gt; Lock l = ...; l.lock(); try { // do
      something } finally { l.unlock(); } &lt;/pre&gt;

    </info>
    <name>Unreleased Lock</name>
  </findingType>
  <findingType>
    <id>UnreleasedLockOnExceptionPath</id>
    <artifact tool="FindBugs"
	      mnemonic="UL_UNRELEASED_LOCK_EXCEPTION_PATH">
    </artifact>
    <shortMessage>
      Method does not release lock on all exception paths
    </shortMessage>
    <info>

      &lt;p&gt; This method acquires a JSR-166
      (&lt;code&gt;java.util.concurrent&lt;/code&gt;) lock, but
      does not release it on all exception paths out of the
      method. In general, the correct idiom for using a JSR-166
      lock is: &lt;/p&gt; &lt;pre&gt; Lock l = ...; l.lock(); try
      { // do something } finally { l.unlock(); } &lt;/pre&gt;

    </info>
    <name>Unreleased Lock On An Exception Path</name>
  </findingType>
  <findingType>
    <id>RC_REF_COMPARISON</id>
    <artifact tool="FindBugs" mnemonic="RC_REF_COMPARISON">
    </artifact>
    <shortMessage>Suspicious reference comparison</shortMessage>
    <info>

      &lt;p&gt; This method compares two reference values using
      the == or != operator, where the correct way to compare
      instances of this type is generally with the equals()
      method. Examples of classes which should generally not be
      compared by reference are java.lang.Integer,
      java.lang.Float, etc.&lt;/p&gt;

    </info>
    <name>Ref Comparison</name>
  </findingType>
  <findingType>
    <id>EC_UNRELATED_TYPES</id>
    <artifact tool="FindBugs" mnemonic="EC_UNRELATED_TYPES">
    </artifact>
    <shortMessage>
      Call to equals() comparing different types
    </shortMessage>
    <info>

      &lt;p&gt; This method calls equals(Object) on two references
      of different class types with no common subclasses.
      Therefore, the objects being compared are unlikely to be
      members of the same class at runtime (unless some
      application classes were not analyzed, or dynamic class
      loading can occur at runtime). According to the contract of
      equals(), objects of different classes should always compare
      as unequal; therefore, according to the contract defined by
      java.lang.Object.equals(Object), the result of this
      comparison will always be false at runtime. &lt;/p&gt;

    </info>
    <name>Unrelated Types</name>
  </findingType>
  <findingType>
    <id>EC_UNRELATED_INTERFACES</id>
    <artifact tool="FindBugs" mnemonic="EC_UNRELATED_INTERFACES">
    </artifact>
    <shortMessage>
      Call to equals() comparing different interface types
    </shortMessage>
    <info>

      &lt;p&gt; This method calls equals(Object) on two references
      of unrelated interface types, where neither is a subtype of
      the other, and there are no known non-abstract classes which
      implement both interfaces. Therefore, the objects being
      compared are unlikely to be members of the same class at
      runtime (unless some application classes were not analyzed,
      or dynamic class loading can occur at runtime). According to
      the contract of equals(), objects of different classes
      should always compare as unequal; therefore, according to
      the contract defined by java.lang.Object.equals(Object), the
      result of this comparison will always be false at runtime.
      &lt;/p&gt;

    </info>
    <name>Unrelated Interfaces</name>
  </findingType>
  <findingType>
    <id>EC_UNRELATED_CLASS_AND_INTERFACE</id>
    <artifact tool="FindBugs"
	      mnemonic="EC_UNRELATED_CLASS_AND_INTERFACE">
    </artifact>
    <shortMessage>
      Call to equals() comparing unrelated class and interface
    </shortMessage>
    <info>

      &lt;p&gt; This method calls equals(Object) on two
      references, one of which is a class and the other an
      interface, where neither the class nor any of its
      non-abstract subclasses implement the interface. Therefore,
      the objects being compared are unlikely to be members of the
      same class at runtime (unless some application classes were
      not analyzed, or dynamic class loading can occur at
      runtime). According to the contract of equals(), objects of
      different classes should always compare as unequal;
      therefore, according to the contract defined by
      java.lang.Object.equals(Object), the result of this
      comparison will always be false at runtime. &lt;/p&gt;

    </info>
    <name>Unrelated Class And Interface</name>
  </findingType>
  <findingType>
    <id>EqualComparisonToNullArgument</id>
    <artifact tool="FindBugs" mnemonic="EC_NULL_ARG"></artifact>
    <artifact tool="PMD" mnemonic="EqualsNull"></artifact>
    <shortMessage>Call to equals() with null argument</shortMessage>
    <info>

      &lt;p&gt; This method calls equals(Object), passing a null
      value as the argument. According to the contract of the
      equals() method, this call should always return
      &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;

      Inexperienced programmers sometimes confuse comparison
      concepts and use equals() to compare to null.

    </info>
    <name>Equal Comparison To Null Argument</name>
  </findingType>
  <findingType>
    <id>MismatchedWait</id>
    <artifact tool="FindBugs" mnemonic="MWN_MISMATCHED_WAIT">
    </artifact>
    <shortMessage>Mismatched wait()</shortMessage>
    <info>

      &lt;p&gt; This method calls Object.wait() without obviously
      holding a lock on the object.&amp;nbsp; Calling wait()
      without a lock held will result in an
      &lt;code&gt;IllegalMonitorStateException&lt;/code&gt; being
      thrown.&lt;/p&gt;

    </info>
    <name>Mismatched Wait</name>
  </findingType>
  <findingType>
    <id>MismatchedNotify</id>
    <artifact tool="FindBugs" mnemonic="MWN_MISMATCHED_NOTIFY">
    </artifact>
    <shortMessage>Mismatched notify()</shortMessage>
    <info>

      &lt;p&gt; This method calls Object.notify() or
      Object.notifyAll() without obviously holding a lock on the
      object.&amp;nbsp; Calling notify() or notifyAll() without a
      lock held will result in an
      &lt;code&gt;IllegalMonitorStateException&lt;/code&gt; being
      thrown.&lt;/p&gt;

    </info>
    <name>Mismatched Notify</name>
  </findingType>
  <findingType>
    <id>SA_LOCAL_SELF_ASSIGNMENT</id>
    <artifact tool="FindBugs" mnemonic="SA_LOCAL_SELF_ASSIGNMENT">
    </artifact>
    <shortMessage>Self assignment of local variable</shortMessage>
    <info>

      &lt;p&gt; This method contains a self assignment of a local
      variable; e.g.&lt;/p&gt; &lt;pre&gt; public void foo() { int
      x = 3; x = x; } &lt;/pre&gt; &lt;p&gt; Such assignments are
      useless, and may indicate a logic error or typo. &lt;/p&gt;

    </info>
    <name>Local Self Assignment</name>
  </findingType>
  <findingType>
    <id>SA_FIELD_SELF_ASSIGNMENT</id>
    <artifact tool="FindBugs" mnemonic="SA_FIELD_SELF_ASSIGNMENT">
    </artifact>
    <shortMessage>Self assignment of field</shortMessage>
    <info>

      &lt;p&gt; This method contains a self assignment of a field;
      e.g. &lt;/p&gt; &lt;pre&gt; int x; public void foo() { x =
      x; } &lt;/pre&gt; &lt;p&gt;Such assignments are useless, and
      may indicate a logic error or typo.&lt;/p&gt;

    </info>
    <name>Field Self Assignment</name>
  </findingType>
  <findingType>
    <id>SA_FIELD_DOUBLE_ASSIGNMENT</id>
    <artifact tool="FindBugs"
	      mnemonic="SA_FIELD_DOUBLE_ASSIGNMENT">
    </artifact>
    <shortMessage>Double assignment of field</shortMessage>
    <info>

      &lt;p&gt; This method contains a double assignment of a
      field; e.g. &lt;/p&gt; &lt;pre&gt; int x,y; public void
      foo() { x = x = 17; } &lt;/pre&gt; &lt;p&gt;Assigning to a
      field twice is useless, and may indicate a logic error or
      typo.&lt;/p&gt;

    </info>
    <name>Field Double Assignment</name>
  </findingType>
  <findingType>
    <id>SA_LOCAL_DOUBLE_ASSIGNMENT</id>
    <artifact tool="FindBugs"
	      mnemonic="SA_LOCAL_DOUBLE_ASSIGNMENT">
    </artifact>
    <shortMessage>Double assignment of local variable</shortMessage>
    <info>

      &lt;p&gt; This method contains a double assignment of a
      local variable; e.g. &lt;/p&gt; &lt;pre&gt; public void
      foo() { int x,y; x = x = 17; } &lt;/pre&gt;
      &lt;p&gt;Assigning the same value to a variable twice is
      useless, and may indicate a logic error or typo.&lt;/p&gt;

    </info>
    <name>Local Double Assignment</name>
  </findingType>
  <findingType>
    <id>SA_FIELD_SELF_COMPUTATION</id>
    <artifact tool="FindBugs"
	      mnemonic="SA_FIELD_SELF_COMPUTATION">
    </artifact>
    <shortMessage>
      Nonsensical self computation involving a field (e.g., x
      &amp; x)
    </shortMessage>
    <info>

      &lt;p&gt; This method performs a nonsensical computation of
      a field with another reference to the same field (e.g.,
      x&amp;x or x-x). Because of the nature of the computation,
      this operation doesn't seem to make sense, and may indicate
      a typo or a logic error. Double check the computation.
      &lt;/p&gt;

    </info>
    <name>Field Self Computation</name>
  </findingType>
  <findingType>
    <id>SA_LOCAL_SELF_COMPUTATION</id>
    <artifact tool="FindBugs"
	      mnemonic="SA_LOCAL_SELF_COMPUTATION">
    </artifact>
    <shortMessage>
      Nonsensical self computation involving a variable (e.g., x
      &amp; x)
    </shortMessage>
    <info>

      &lt;p&gt; This method performs a nonsensical computation of
      a local variable with another reference to the same variable
      (e.g., x&amp;x or x-x). Because of the nature of the
      computation, this operation doesn't seem to make sense, and
      may indicate a typo or a logic error. Double check the
      computation. &lt;/p&gt;

    </info>
    <name>Local Self Computation</name>
  </findingType>
  <findingType>
    <id>SA_FIELD_SELF_COMPARISON</id>
    <artifact tool="FindBugs" mnemonic="SA_FIELD_SELF_COMPARISON">
    </artifact>
    <shortMessage>
      Self comparison of field with itself
    </shortMessage>
    <info>

      &lt;p&gt; This method compares a field with itself, and may
      indicate a typo or a logic error. Make sure that you are
      comparing the right things. &lt;/p&gt;

    </info>
    <name>Field Self Comparison</name>
  </findingType>
  <findingType>
    <id>SA_LOCAL_SELF_COMPARISON</id>
    <artifact tool="FindBugs" mnemonic="SA_LOCAL_SELF_COMPARISON">
    </artifact>
    <shortMessage>
      Self comparison of value with itself
    </shortMessage>
    <info>

      &lt;p&gt; This method compares a local variable with itself,
      and may indicate a typo or a logic error. Make sure that you
      are comparing the right things. &lt;/p&gt;

    </info>
    <name>Local Self Comparison</name>
  </findingType>
  <findingType>
    <id>DMI_LONG_BITS_TO_DOUBLE_INVOKED_ON_INT</id>
    <artifact tool="FindBugs"
	      mnemonic="DMI_LONG_BITS_TO_DOUBLE_INVOKED_ON_INT">
    </artifact>
    <shortMessage>
      Double.longBitsToDouble invoked on an int
    </shortMessage>
    <info>

      &lt;p&gt; The Double.longBitsToDouble method is invoked, but
      a 32 bit int value is passed as an argument. This almostly
      certainly is not intended and is unlikely to give the
      intended result. &lt;/p&gt;

    </info>
    <name>Long Bits To Double Invoked On Int</name>
  </findingType>
  <findingType>
    <id>DMI_RANDOM_USED_ONLY_ONCE</id>
    <artifact tool="FindBugs"
	      mnemonic="DMI_RANDOM_USED_ONLY_ONCE">
    </artifact>
    <shortMessage>
      Random object created and used only once
    </shortMessage>
    <info>

      &lt;p&gt; This code creates a java.util.Random object, uses
      it to generate one random number, and then discards the
      Random object. This produces mediocre quality random numbers
      and is inefficient. If possible, rewrite the code so that
      the Random object is created once and saved, and each time a
      new random number is required invoke a method on the
      existing Random object to obtain it. &lt;/p&gt;

      &lt;p&gt;If it is important that the generated Random
      numbers not be guessable, you &lt;em&gt;must&lt;/em&gt; not
      create a new Random for each random number; the values are
      too easily guessable. You should strongly consider using a
      java.security.SecureRandom instead (and avoid allocating a
      new SecureRandom for each random number needed). &lt;/p&gt;

    </info>
    <name>Random Used Only Once</name>
  </findingType>
  <findingType>
    <id>RV_ABSOLUTE_VALUE_OF_RANDOM_INT</id>
    <artifact tool="FindBugs"
	      mnemonic="RV_ABSOLUTE_VALUE_OF_RANDOM_INT">
    </artifact>
    <shortMessage>
      Bad attempt to compute absolute value of signed 32-bit
      random integer
    </shortMessage>
    <info>

      &lt;p&gt; This code generates a random signed integer and
      then computes the absolute value of that random integer. If
      the number returned by the random number generator is
      &lt;code&gt;Integer.MIN_VALUE&lt;/code&gt;, then the result
      will be negative as well (since
      &lt;code&gt;Math.abs(Integer.MIN_VALUE) ==
      Integer.MIN_VALUE&lt;/code&gt;). &lt;/p&gt;

    </info>
    <name>Absolute Value Of Random Int</name>
  </findingType>
  <findingType>
    <id>RV_ABSOLUTE_VALUE_OF_HASHCODE</id>
    <artifact tool="FindBugs"
	      mnemonic="RV_ABSOLUTE_VALUE_OF_HASHCODE">
    </artifact>
    <shortMessage>
      Bad attempt to compute absolute value of signed 32-bit
      hashcode
    </shortMessage>
    <info>

      &lt;p&gt; This code generates a hashcode and then computes
      the absolute value of that hashcode. If the hashcode is
      &lt;code&gt;Integer.MIN_VALUE&lt;/code&gt;, then the result
      will be negative as well (since
      &lt;code&gt;Math.abs(Integer.MIN_VALUE) ==
      Integer.MIN_VALUE&lt;/code&gt;). &lt;/p&gt;

    </info>
    <name>Absolute Value Of Hashcode</name>
  </findingType>
  <findingType>
    <id>RV_REM_OF_RANDOM_INT</id>
    <artifact tool="FindBugs" mnemonic="RV_REM_OF_RANDOM_INT">
    </artifact>
    <shortMessage>
      Remainder of 32-bit signed random integer
    </shortMessage>
    <info>

      &lt;p&gt; This code generates a random signed integer and
      then computes the remainder of that value modulo another
      value. Since the random number can be negative, the result
      of the remainder operation can also be negative. Be sure
      this is intended, and strongly consider using the
      Random.nextInt(int) method instead. &lt;/p&gt;

    </info>
    <name>Rem Of Random Int</name>
  </findingType>
  <findingType>
    <id>RV_REM_OF_HASHCODE</id>
    <artifact tool="FindBugs" mnemonic="RV_REM_OF_HASHCODE">
    </artifact>
    <shortMessage>
      Remainder of hashCode could be negative
    </shortMessage>
    <info>

      &lt;p&gt; This code computes a hashCode, and then computes
      the remainder of that value modulo another value. Since the
      hashCode can be negative, the result of the remainder
      operation can also be negative. &lt;/p&gt; &lt;p&gt;
      Assuming you want to ensure that the result of your
      computation is nonnegative, you may need to change your
      code. If you know the divisor is a power of 2, you can use a
      bitwise and operator instead (i.e., instead of using
      &lt;code&gt;x.hashCode()%n&lt;/code&gt;, use
      &lt;code&gt;x.hashCode()&amp;amp;(n-1)&lt;/code&gt;. This is
      probably faster than computing the remainder as well. If you
      don't know that the divisor is a power of 2, take the
      absolute value of the result of the remainder operation
      (i.e., use &lt;code&gt;Math.abs(x.hashCode()%n)&lt;/code&gt;
      &lt;/p&gt;

    </info>
    <name>Rem Of Hashcode</name>
  </findingType>
  <findingType>
    <id>INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE</id>
    <artifact tool="FindBugs"
	      mnemonic="INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE">
    </artifact>
    <shortMessage>
      Bad comparison of nonnegative value with negative constant
    </shortMessage>
    <info>

      &lt;p&gt; This code compares a value that is guaranteed to
      be non-negative with a negative constant. &lt;/p&gt;

    </info>
    <name>Bad Comparison With Nonnegative Value</name>
  </findingType>
  <findingType>
    <id>INT_BAD_COMPARISON_WITH_SIGNED_BYTE</id>
    <artifact tool="FindBugs"
	      mnemonic="INT_BAD_COMPARISON_WITH_SIGNED_BYTE">
    </artifact>
    <shortMessage>Bad comparison of signed byte</shortMessage>
    <info>

      &lt;p&gt; Signed bytes can only have a value in the range
      -128 to 127. Comparing a signed byte with a value outside
      that range is vacuous and likely to be incorrect. To convert
      a signed byte &lt;code&gt;b&lt;/code&gt; to an unsigned
      value in the range 0..255, use &lt;code&gt;0xff &amp;
      b&lt;/code&gt; &lt;/p&gt;

    </info>
    <name>Bad Comparison With Signed Byte</name>
  </findingType>
  <findingType>
    <id>INT_VACUOUS_COMPARISON</id>
    <artifact tool="FindBugs" mnemonic="INT_VACUOUS_COMPARISON">
    </artifact>
    <shortMessage>Vacuous comparison of integer value</shortMessage>
    <info>

      &lt;p&gt; There is an integer comparison that always returns
      the same value (e.g., x &lt;= Integer.MAX_VALUE). &lt;/p&gt;

    </info>
    <name>Vacuous Comparison</name>
  </findingType>
  <findingType>
    <id>INT_BAD_REM_BY_1</id>
    <artifact tool="FindBugs" mnemonic="INT_BAD_REM_BY_1">
    </artifact>
    <shortMessage>Integer remainder modulo 1</shortMessage>
    <info>

      &lt;p&gt; Any expression (exp % 1) is guaranteed to always
      return zero. Did you mean (exp &amp; 1) or (exp % 2)
      instead? &lt;/p&gt;

    </info>
    <name>Bad Rem By 1</name>
  </findingType>
  <findingType>
    <id>BIT_IOR_OF_SIGNED_BYTE</id>
    <artifact tool="FindBugs" mnemonic="BIT_IOR_OF_SIGNED_BYTE">
    </artifact>
    <shortMessage>Bitwise OR of signed byte value</shortMessage>
    <info>

      &lt;p&gt; Loads a value from a byte array and performs a
      bitwise OR with that value. Values loaded from a byte array
      are sign extended to 32 bits before any any bitwise
      operations are performed on the value. Thus, if
      &lt;code&gt;b[0]&lt;/code&gt; contains the value
      &lt;code&gt;0xff&lt;/code&gt;, and
      &lt;code&gt;x&lt;/code&gt; is initially 0, then the code
      &lt;code&gt;((x &lt;&lt; 8) | b[0])&lt;/code&gt; will sign
      extend &lt;code&gt;0xff&lt;/code&gt; to get
      &lt;code&gt;0xffffffff&lt;/code&gt;, and thus give the value
      &lt;code&gt;0xffffffff&lt;/code&gt; as the result.
      &lt;/p&gt;

      &lt;p&gt;In particular, the following code for packing a
      byte array into an int is badly wrong: &lt;/p&gt;
      &lt;code&gt; int result = 0; for(int i = 0; i &lt; 4; i++)
      result = ((result &lt;&lt; 8) | b[i]); &lt;/code&gt;

      &lt;p&gt;The following idiom will work instead: &lt;/p&gt;
      &lt;code&gt; int result = 0; for(int i = 0; i &lt; 4; i++)
      result = ((result &lt;&lt; 8) | (b[i] &amp;amps; 0xff));
      &lt;/code&gt;


    </info>
    <name>Bitwise OR Of Signed Byte</name>
  </findingType>
  <findingType>
    <id>BIT_AND</id>
    <artifact tool="FindBugs" mnemonic="BIT_AND"></artifact>
    <shortMessage>Incompatible bit masks</shortMessage>
    <info>

      &lt;p&gt; This method compares an expression of the form (a
      &amp;amp; C) to D, which will always compare unequal due to
      the specific values of constants C and D. This may indicate
      a logic error or typo.&lt;/p&gt;

    </info>
    <name>Incompatible Bit Masks And</name>
  </findingType>
  <findingType>
    <id>BIT_AND_ZZ</id>
    <artifact tool="FindBugs" mnemonic="BIT_AND_ZZ"></artifact>
    <shortMessage>
      Check to see if ((...) &amp; 0) == 0
    </shortMessage>
    <info>

      &lt;p&gt; This method compares an expression of the form (a
      &amp;amp; 0) to 0, which will always compare equal. This may
      indicate a logic error or typo.&lt;/p&gt;

    </info>
    <name>Incompatible Bit Masks And Zero</name>
  </findingType>
  <findingType>
    <id>BIT_IOR</id>
    <artifact tool="FindBugs" mnemonic="BIT_IOR"></artifact>
    <shortMessage>Incompatible bit masks</shortMessage>
    <info>

      &lt;p&gt; This method compares an expression of the form (a
      | C) to D. which will always compare unequal due to the
      specific values of constants C and D. This may indicate a
      logic error or typo.&lt;/p&gt;

      &lt;p&gt; Typically, this bug occurs because the code wants
      to perform a membership test in a bit set, but uses the
      bitwise OR operator (&quot;|&quot;) instead of bitwise AND
      (&quot;&amp;amp;&quot;).&lt;/p&gt;

    </info>
    <name>Incompatible Bit Masks OR</name>
  </findingType>
  <findingType>
    <id>IncorrectLazyInitializationOfInstance</id>
    <artifact tool="FindBugs" mnemonic="LI_LAZY_INIT_INSTANCE">
    </artifact>
    <shortMessage>
      Incorrect lazy initialization of instance field
    </shortMessage>
    <info>

      &lt;p&gt; This method contains an unsynchronized lazy
      initialization of a non-volatile field. Because the compiler
      or processor may reorder instructions, threads are not
      guaranteed to see a completely initialized object,
      &lt;em&gt;if the method can be called by multiple
      threads&lt;/em&gt;. You can make the field volatile to
      correct the problem. For more information, see the &lt;a
      href=&quot;http://www.cs.umd.edu/~pugh/java/memoryModel/&quot;&gt;Java
      Memory Model web site&lt;/a&gt;. &lt;/p&gt;

    </info>
    <name>Lazy Init Instance</name>
  </findingType>
  <findingType>
    <id>IncorrectLazyInitializationOfStatic</id>
    <artifact tool="FindBugs" mnemonic="LI_LAZY_INIT_STATIC">
    </artifact>
    <shortMessage>
      Incorrect lazy initialization of static field
    </shortMessage>
    <info>

      &lt;p&gt; This method contains an unsynchronized lazy
      initialization of a non-volatile static field. Because the
      compiler or processor may reorder instructions, threads are
      not guaranteed to see a completely initialized object,
      &lt;em&gt;if the method can be called by multiple
      threads&lt;/em&gt;. You can make the field volatile to
      correct the problem. For more information, see the &lt;a
      href=&quot;http://www.cs.umd.edu/~pugh/java/memoryModel/&quot;&gt;Java
      Memory Model web site&lt;/a&gt;. &lt;/p&gt;

    </info>
    <name>Incorrect Lazy Initialization of Static Field</name>
  </findingType>
  <findingType>
    <id>AvoidCallingSynchronizedOnLock</id>
    <artifact tool="FindBugs"
	      mnemonic="JLM_JSR166_LOCK_MONITORENTER">
    </artifact>
    <shortMessage>
      Synchronization performed on java.util.concurrent Lock
    </shortMessage>
    <info>

      &lt;p&gt; This method performs synchronization on an
      implementation of
      &lt;code&gt;java.util.concurrent.locks.Lock&lt;/code&gt;.
      You should use the &lt;code&gt;lock()&lt;/code&gt; and
      &lt;code&gt;unlock()&lt;/code&gt; methods instead.
      &lt;/p&gt;

    </info>
    <name>JSR166 Lock Monitor Enter</name>
  </findingType>
  <findingType>
    <id>UPM_UNCALLED_PRIVATE_METHOD</id>
    <artifact tool="FindBugs"
	      mnemonic="UPM_UNCALLED_PRIVATE_METHOD">
    </artifact>
    <shortMessage>Private method is never called</shortMessage>
    <info>

      &lt;p&gt; This private method is never called. Although it
      is possible that the method will be invoked through
      reflection, it is more likely that the method is never used,
      and should be removed. &lt;/p&gt;

    </info>
    <name>Uncalled Private Method</name>
  </findingType>
  <findingType>
    <id>UMAC_UNCALLABLE_METHOD_OF_ANONYMOUS_CLASS</id>
    <artifact tool="FindBugs"
	      mnemonic="UMAC_UNCALLABLE_METHOD_OF_ANONYMOUS_CLASS">
    </artifact>
    <shortMessage>
      Uncallable method defined in anonymous class
    </shortMessage>
    <info>

      &lt;p&gt; This anonymous class defined a method that is not
      directly invoked and does not override a method in a
      superclass. Since methods in other classes cannot directly
      invoke methods declared in an anonymous class, it seems that
      this method is uncallable. The method might simply be dead
      code, but it is also possible that the method is intended to
      override a method declared in a superclass, and due to an
      typo or other error the method does not, in fact, override
      the method it is intended to. &lt;/p&gt;

    </info>
    <name>Uncallable Method Of Anonymous Class</name>
  </findingType>
  <findingType>
    <id>ODR_OPEN_DATABASE_RESOURCE</id>
    <artifact tool="FindBugs"
	      mnemonic="ODR_OPEN_DATABASE_RESOURCE">
    </artifact>
    <shortMessage>
      Method may fail to close database resource
    </shortMessage>
    <info>

      &lt;p&gt; The method creates a database resource (such as a
      database connection or row set), does not assign it to any
      fields, pass it to other methods, or return it, and does not
      appear to close the object on all paths out of the
      method.&amp;nbsp; Failure to close database resources on all
      paths out of a method may result in poor performance, and
      could cause the application to have problems communicating
      with the database. &lt;/p&gt;

    </info>
    <name>Open Database Resource</name>
  </findingType>
  <findingType>
    <id>ODR_OPEN_DATABASE_RESOURCE_EXCEPTION_PATH</id>
    <artifact tool="FindBugs"
	      mnemonic="ODR_OPEN_DATABASE_RESOURCE_EXCEPTION_PATH">
    </artifact>
    <shortMessage>
      Method may fail to close database resource on exception
    </shortMessage>
    <info>

      &lt;p&gt; The method creates a database resource (such as a
      database connection or row set), does not assign it to any
      fields, pass it to other methods, or return it, and does not
      appear to close the object on all exception paths out of the
      method.&amp;nbsp; Failure to close database resources on all
      paths out of a method may result in poor performance, and
      could cause the application to have problems communicating
      with the database.&lt;/p&gt;

    </info>
    <name>Open Database Resource Exception Path</name>
  </findingType>
  <findingType>
    <id>UseStringBufferForStringAppends</id>
    <artifact tool="FindBugs"
	      mnemonic="SBSC_USE_STRINGBUFFER_CONCATENATION">
    </artifact>
    <artifact tool="PMD"
	      mnemonic="UseStringBufferForStringAppends">
    </artifact>
    <shortMessage>
      Method concatenates strings using + in a loop
    </shortMessage>
    <info>

      &lt;p&gt; The method seems to be building a String using
      concatenation in a loop. In each iteration, the String is
      converted to a StringBuffer/StringBuilder, appended to, and
      converted back to a String. This can lead to a cost
      quadratic in the number of iterations, as the growing string
      is recopied in each iteration. &lt;/p&gt;

      &lt;p&gt;Better performance can be obtained by using a
      StringBuffer (or StringBuilder in Java 1.5)
      explicitly.&lt;/p&gt;

      &lt;p&gt; For example:&lt;/p&gt; &lt;pre&gt; // This is bad
      String s = &quot;&quot;; for (int i = 0; i &amp;lt;
      field.length; ++i) { s = s + field[i]; }

      // This is better StringBuffer buf = new StringBuffer(); for
      (int i = 0; i &amp;lt; field.length; ++i) {
      buf.append(field[i]); } String s = buf.toString();
      &lt;/pre&gt;

      Avoid using += for appending strings. Use StringBuffer
      instead.

    </info>
    <name>Use StringBuffer For String Appends</name>
  </findingType>
  <findingType>
    <id>ITA_INEFFICIENT_TO_ARRAY</id>
    <artifact tool="FindBugs" mnemonic="ITA_INEFFICIENT_TO_ARRAY">
    </artifact>
    <shortMessage>
      Method uses toArray() with zero-length array argument
    </shortMessage>
    <info>

      &lt;p&gt; This method uses the toArray() method of a
      collection derived class, and passes in a zero-length
      prototype array argument. It is more efficient to use
      &lt;code&gt;myCollection.toArray(new
      Foo[myCollection.size()])&lt;/code&gt; If the array passed
      in is big enough to store all of the elements of the
      collection, then it is populated and returned directly. This
      avoids the need to create a second array (by reflection) to
      return as the result.&lt;/p&gt;

    </info>
    <name>Inefficient To Array</name>
  </findingType>
  <findingType>
    <id>IJU_ASSERT_METHOD_INVOKED_FROM_RUN_METHOD</id>
    <artifact tool="FindBugs"
	      mnemonic="IJU_ASSERT_METHOD_INVOKED_FROM_RUN_METHOD">
    </artifact>
    <shortMessage>
      JUnit assertion in run method will not be noticed by JUnit
    </shortMessage>
    <info>

      &lt;p&gt; A JUnit assertion is performed in a run method.
      Failed JUnit assertions just result in exceptions being
      thrown. Thus, if this exception occurs in a thread other
      than the thread that invokes the test method, the exception
      will terminate the thread but not result in the test
      failing. &lt;/p&gt;

    </info>
    <name>Assert Method Invoked From Run Method</name>
  </findingType>
  <findingType>
    <id>IJU_SETUP_NO_SUPER</id>
    <artifact tool="FindBugs" mnemonic="IJU_SETUP_NO_SUPER">
    </artifact>
    <shortMessage>
      TestCase implements setUp but doesn't call super.setUp()
    </shortMessage>
    <info>

      &lt;p&gt; Class is a JUnit TestCase and implements the setUp
      method. The setUp method should call super.setUp(), but
      doesn't.&lt;/p&gt;

    </info>
    <name>Setup No Super</name>
  </findingType>
  <findingType>
    <id>IJU_TEARDOWN_NO_SUPER</id>
    <artifact tool="FindBugs" mnemonic="IJU_TEARDOWN_NO_SUPER">
    </artifact>
    <shortMessage>
      TestCase implements tearDown but doesn't call
      super.tearDown()
    </shortMessage>
    <info>

      &lt;p&gt; Class is a JUnit TestCase and implements the
      tearDown method. The tearDown method should call
      super.tearDown(), but doesn't.&lt;/p&gt;

    </info>
    <name>Teardown No Super</name>
  </findingType>
  <findingType>
    <id>IJU_SUITE_NOT_STATIC</id>
    <artifact tool="FindBugs" mnemonic="IJU_SUITE_NOT_STATIC">
    </artifact>
    <shortMessage>
      TestCase implements a non-static suite method
    </shortMessage>
    <info>

      &lt;p&gt; Class is a JUnit TestCase and implements the
      suite() method. The suite method should be declared as being
      static, but isn't.&lt;/p&gt;

    </info>
    <name>Suite Not Static</name>
  </findingType>
  <findingType>
    <id>IJU_BAD_SUITE_METHOD</id>
    <artifact tool="FindBugs" mnemonic="IJU_BAD_SUITE_METHOD">
    </artifact>
    <shortMessage>
      TestCase declares a bad suite method
    </shortMessage>
    <info>

      &lt;p&gt; Class is a JUnit TestCase and defines a suite()
      method. However, the suite method needs to be declared as
      either &lt;pre&gt;public static junit.framework.Test
      suite()&lt;/pre&gt; or &lt;pre&gt;public static
      junit.framework.TestSuite suite()&lt;/pre&gt; &lt;/p&gt;

    </info>
    <name>Bad Suite Method</name>
  </findingType>
  <findingType>
    <id>IJU_NO_TESTS</id>
    <artifact tool="FindBugs" mnemonic="IJU_NO_TESTS"></artifact>
    <shortMessage>TestCase has no tests</shortMessage>
    <info>

      &lt;p&gt; Class is a JUnit TestCase but has not implemented
      any test methods&lt;/p&gt;

    </info>
    <name>No Tests</name>
  </findingType>
  <findingType>
    <id>BOA_BADLY_OVERRIDDEN_ADAPTER</id>
    <artifact tool="FindBugs"
	      mnemonic="BOA_BADLY_OVERRIDDEN_ADAPTER">
    </artifact>
    <shortMessage>
      Class overrides a method implemented in super class Adapter
      wrongly
    </shortMessage>
    <info>

      &lt;p&gt; This method overrides a method found in a parent
      class, where that class is an Adapter that implements a
      listener defined in the java.awt.event or javax.swing.event
      package. As a result, this method will not get called when
      the event occurs.&lt;/p&gt;

    </info>
    <name>Badly Overridden Adapter</name>
  </findingType>
  <findingType>
    <id>BRSA_BAD_RESULTSET_ACCESS</id>
    <artifact tool="FindBugs"
	      mnemonic="BRSA_BAD_RESULTSET_ACCESS">
    </artifact>
    <shortMessage>
      Method attempts to access a result set field with index 0
    </shortMessage>
    <info>

      &lt;p&gt; A call to getXXX or updateXXX methods of a result
      set was made where the field index is 0. As ResultSet fields
      start at index 1, this is always a mistake.&lt;/p&gt;

    </info>
    <name>Bad Resultset Access</name>
  </findingType>
  <findingType>
    <id>SQL_BAD_RESULTSET_ACCESS</id>
    <artifact tool="FindBugs" mnemonic="SQL_BAD_RESULTSET_ACCESS">
    </artifact>
    <shortMessage>
      Method attempts to access a result set field with index 0
    </shortMessage>
    <info>

      &lt;p&gt; A call to getXXX or updateXXX methods of a result
      set was made where the field index is 0. As ResultSet fields
      start at index 1, this is always a mistake.&lt;/p&gt;

    </info>
    <name>Bad Resultset Access</name>
  </findingType>
  <findingType>
    <id>SQL_BAD_PREPARED_STATEMENT_ACCESS</id>
    <artifact tool="FindBugs"
	      mnemonic="SQL_BAD_PREPARED_STATEMENT_ACCESS">
    </artifact>
    <shortMessage>
      Method attempts to access a prepared statement parameter
      with index 0
    </shortMessage>
    <info>

      &lt;p&gt; A call to a setXXX method of a prepared statement
      was made where the parameter index is 0. As parameter
      indexes start at index 1, this is always a
      mistake.&lt;/p&gt;

    </info>
    <name>Bad Prepared Statement Access</name>
  </findingType>
  <findingType>
    <id>SIO_SUPERFLUOUS_INSTANCEOF</id>
    <artifact tool="FindBugs"
	      mnemonic="SIO_SUPERFLUOUS_INSTANCEOF">
    </artifact>
    <shortMessage>
      Unnecessary type check done using instanceof operator
    </shortMessage>
    <info>

      &lt;p&gt; Type check performed using the instanceof operator
      where it can be statically determined whether the object is
      of the type requested. &lt;/p&gt;

    </info>
    <name>Superfluous instanceof</name>
  </findingType>
  <findingType>
    <id>BAC_BAD_APPLET_CONSTRUCTOR</id>
    <artifact tool="FindBugs"
	      mnemonic="BAC_BAD_APPLET_CONSTRUCTOR">
    </artifact>
    <shortMessage>
      Bad Applet Constructor relies on uninitialized AppletStub
    </shortMessage>
    <info>

      &lt;p&gt; This constructor calls methods in the parent
      Applet that rely on the AppletStub. Since the AppletStub
      isn't initialized until the init() method of this applet is
      called, these methods will not perform correctly. &lt;/p&gt;

    </info>
    <name>Bad Applet Constructor</name>
  </findingType>
  <findingType>
    <id>EC_ARRAY_AND_NONARRAY</id>
    <artifact tool="FindBugs" mnemonic="EC_ARRAY_AND_NONARRAY">
    </artifact>
    <shortMessage>
      equals() used to compare array and nonarray
    </shortMessage>
    <info>

      &lt;p&gt; This method invokes the .equals(Object o) to
      compare an array and a reference that doesn't seem to be an
      array. If things being compared are of different types, they
      are guaranteed to be unequal and the comparison is almost
      certainly an error. Even if they are both arrays, the equals
      method on arrays only determines of the two arrays are the
      same object. To compare the contents of the arrays, use
      java.util.Arrays.equals(Object[], Object[]). &lt;/p&gt;

    </info>
    <name>Array And Nonarray</name>
  </findingType>
  <findingType>
    <id>EC_BAD_ARRAY_COMPARE</id>
    <artifact tool="FindBugs" mnemonic="EC_BAD_ARRAY_COMPARE">
    </artifact>
    <shortMessage>
      Invocation of equals() on an array, which is equivalent to
      ==
    </shortMessage>
    <info>

      &lt;p&gt; This method invokes the .equals(Object o) method
      on an array. Since arrays do not override the equals method
      of Object, calling equals on an array is the same as
      comparing their addresses. To compare the contents of the
      arrays, use java.util.Arrays.equals(Object[], Object[]).
      &lt;/p&gt;

    </info>
    <name>Bad Array Compare</name>
  </findingType>
  <findingType>
    <id>UOE_USE_OBJECT_EQUALS</id>
    <artifact tool="FindBugs" mnemonic="UOE_USE_OBJECT_EQUALS">
    </artifact>
    <shortMessage>
      Calls to equals on a final class that doesn't override
      Object's version
    </shortMessage>
    <info>

      &lt;p&gt; This method invokes the .equals(Object o) method
      on a final class that doesn't override the equals method in
      the Object class, effectively making the equals method test
      for sameness, like ==. It is good to use the .equals method,
      but you should consider adding an .equals method in this
      class. &lt;/p&gt; &lt;p&gt;[Bill Pugh]: Sorry, but I
      strongly disagree that this should be a warning, and I think
      your code is just fine. Users of your code shouldn't care
      how you've implemented equals(), and they should never
      depend on == to compare instances, since that bypasses the
      libraries ability to control how objects are compared.
      &lt;/p&gt;

    </info>
    <name>Use Object Equals</name>
  </findingType>
  <findingType>
    <id>STI_INTERRUPTED_ON_CURRENTTHREAD</id>
    <artifact tool="FindBugs"
	      mnemonic="STI_INTERRUPTED_ON_CURRENTTHREAD">
    </artifact>
    <shortMessage>
      Unneeded use of currentThread() call, to call interrupted()
    </shortMessage>
    <info>

      &lt;p&gt; This method invokes the Thread.currentThread()
      call, just to call the interrupted() method. As
      interrupted() is a static method, is more simple and clear
      to use Thread.interrupted(). &lt;/p&gt;

    </info>
    <name>Interrupted On Currentthread</name>
  </findingType>
  <findingType>
    <id>STI_INTERRUPTED_ON_UNKNOWNTHREAD</id>
    <artifact tool="FindBugs"
	      mnemonic="STI_INTERRUPTED_ON_UNKNOWNTHREAD">
    </artifact>
    <shortMessage>
      Static Thread.interrupted() method invoked on thread
      instance
    </shortMessage>
    <info>

      &lt;p&gt; This method invokes the Thread.interrupted()
      method on a Thread object that appears to be a Thread object
      that is not the current thread. As the interrupted() method
      is static, the interrupted method will be called on a
      different object than the one the author intended.
      &lt;/p&gt;

    </info>
    <name>Interrupted On Unknown Thread</name>
  </findingType>
  <findingType>
    <id>IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN</id>
    <artifact tool="FindBugs"
	      mnemonic="IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN">
    </artifact>
    <shortMessage>
      A parameter is dead upon entry to a method but overwritten
    </shortMessage>
    <info>

      &lt;p&gt; The initial value of this parameter is ignored,
      and the parameter is overwritten here. This often indicates
      a mistaken belief that the write to the parameter will be
      conveyed back to the caller. &lt;/p&gt;

    </info>
    <name>Parameter Is Dead But Overwritten</name>
  </findingType>
  <findingType>
    <id>DLS_DEAD_LOCAL_STORE</id>
    <artifact tool="FindBugs" mnemonic="DLS_DEAD_LOCAL_STORE">
    </artifact>
    <shortMessage>Dead store to local variable</shortMessage>
    <info>

      &lt;p&gt; This instruction assigns a value to a local
      variable, but the value is not read by any subsequent
      instruction. Often, this indicates an error, because the
      value computed is never used. &lt;/p&gt; &lt;p&gt; Note that
      Sun's javac compiler often generates dead stores for final
      local variables. Because FindBugs is a bytecode-based tool,
      there is no easy way to eliminate these false positives.
      &lt;/p&gt;

    </info>
    <name>Dead Local Store</name>
  </findingType>
  <findingType>
    <id>DLS_DEAD_LOCAL_STORE_OF_NULL</id>
    <artifact tool="FindBugs"
	      mnemonic="DLS_DEAD_LOCAL_STORE_OF_NULL">
    </artifact>
    <shortMessage>
      Dead store of null to local variable
    </shortMessage>
    <info>

      &lt;p&gt;The code stores null into a local variable, and
      stored value is not read. This store may have been
      introduced in assist the garbage collector, but as of Java
      SE 6.0, this is no longer needed or useful. &lt;/p&gt;

    </info>
    <name>Dead Local Store Of Null</name>
  </findingType>
  <findingType>
    <id>MF_METHOD_MASKS_FIELD</id>
    <artifact tool="FindBugs" mnemonic="MF_METHOD_MASKS_FIELD">
    </artifact>
    <shortMessage>
      Method defines a variable that obscures a field
    </shortMessage>
    <info>

      &lt;p&gt; This method defines a local variable with the same
      name as a field in this class or a superclass. This may
      cause the method to read an uninitialized value from the
      field, leave the field uninitialized, or both.&lt;/p&gt;

    </info>
    <name>Method Masks Field</name>
  </findingType>
  <findingType>
    <id>MF_CLASS_MASKS_FIELD</id>
    <artifact tool="FindBugs" mnemonic="MF_CLASS_MASKS_FIELD">
    </artifact>
    <shortMessage>
      Class defines field that masks a superclass field
    </shortMessage>
    <info>

      &lt;p&gt; This class defines a field with the same name as a
      visible instance field in a superclass. This is confusing,
      and may indicate an error if methods update or access one of
      the fields when they wanted the other.&lt;/p&gt;

    </info>
    <name>Class Masks Field</name>
  </findingType>
  <findingType>
    <id>WMI_WRONG_MAP_ITERATOR</id>
    <artifact tool="FindBugs" mnemonic="WMI_WRONG_MAP_ITERATOR">
    </artifact>
    <shortMessage>
      Inefficient use of keySet iterator instead of entrySet
      iterator
    </shortMessage>
    <info>

      &lt;p&gt; This method accesses the value of a Map entry,
      using a key that was retrieved from a keySet iterator. It is
      more efficient to use an iterator on the entrySet of the
      map, to avoid the Map.get(key) lookup.&lt;/p&gt;

    </info>
    <name>Wrong Map Iterator</name>
  </findingType>
  <findingType>
    <id>ISC_INSTANTIATE_STATIC_CLASS</id>
    <artifact tool="FindBugs"
	      mnemonic="ISC_INSTANTIATE_STATIC_CLASS">
    </artifact>
    <shortMessage>
      Needless instantiation of class that only supplies static
      methods
    </shortMessage>
    <info>

      &lt;p&gt; This class allocates an object that is based on a
      class that only supplies static methods. This object does
      not need to be created, just access the static methods
      directly using the class name as a qualifier.&lt;/p&gt;

    </info>
    <name>Instantiate Static Class</name>
  </findingType>
  <findingType>
    <id>REC_CATCH_EXCEPTION</id>
    <artifact tool="FindBugs" mnemonic="REC_CATCH_EXCEPTION">
    </artifact>
    <shortMessage>
      Exception is caught when Exception is not thrown
    </shortMessage>
    <info>

      &lt;p&gt; This method uses a try-catch block that catches
      Exception objects, but Exception is not thrown within the
      try block, and RuntimeException is not explicitly caught. It
      is a common bug pattern to say try { ... } catch (Exception
      e) { something } as a shorthand for catching a number of
      types of exception each of whose catch blocks is identical,
      but this construct also accidentally catches
      RuntimeException as well, masking potential bugs. &lt;/p&gt;

    </info>
    <name>Catch Exception</name>
  </findingType>
  <findingType>
    <id>FE_TEST_IF_EQUAL_TO_NOT_A_NUMBER</id>
    <artifact tool="FindBugs"
	      mnemonic="FE_TEST_IF_EQUAL_TO_NOT_A_NUMBER">
    </artifact>
    <shortMessage>Doomed test for equality to NaN</shortMessage>
    <info>

      &lt;p&gt; This code checks to see if a floating point value
      is equal to the special Not A Number value (e.g.,
      &lt;code&gt;if (x == Double.NaN)&lt;/code&gt;). However,
      because of the special semantics of
      &lt;code&gt;NaN&lt;/code&gt;, no value is equal to
      &lt;code&gt;Nan&lt;/code&gt;, including
      &lt;code&gt;NaN&lt;/code&gt;. Thus, &lt;code&gt;x ==
      Double.NaN&lt;/code&gt; always evaluates to false.

      To check to see if a value contained in
      &lt;code&gt;x&lt;/code&gt; is the special Not A Number
      value, use &lt;code&gt;Double.isNaN(x)&lt;/code&gt; (or
      &lt;code&gt;Float.isNaN(x)&lt;/code&gt; if
      &lt;code&gt;x&lt;/code&gt; is floating point precision).
      &lt;/p&gt;

    </info>
    <name>Test If Equal To Not A Number</name>
  </findingType>
  <findingType>
    <id>FE_FLOATING_POINT_EQUALITY</id>
    <artifact tool="FindBugs"
	      mnemonic="FE_FLOATING_POINT_EQUALITY">
    </artifact>
    <shortMessage>Test for floating point equality</shortMessage>
    <info>

      &lt;p&gt; This operation compares two floating point values
      for equality. Because floating point calculations may
      involve rounding, calculated float and double values may not
      be accurate. For values that must be precise, such as
      monetary values, consider using a fixed-precision type such
      as BigDecimal. For values that need not be precise, consider
      comparing for equality within some range, for example:
      &lt;code&gt;if ( Math.abs(x - y) &amp;lt; .0000001
      )&lt;/code&gt;. See the Java Language Specification, section
      4.2.4. &lt;/p&gt;

    </info>
    <name>Floating Point Equality</name>
  </findingType>
  <findingType>
    <id>UM_UNNECESSARY_MATH</id>
    <artifact tool="FindBugs" mnemonic="UM_UNNECESSARY_MATH">
    </artifact>
    <shortMessage>
      Method calls static Math class method on a constant value
    </shortMessage>
    <info>

      &lt;p&gt; This method uses a static method from
      java.lang.Math on a constant value. This method's result in
      this case, can be determined statically, and is faster and
      sometimes more accurate to just use the constant. Methods
      detected are: &lt;/p&gt; &lt;table&gt; &lt;tr&gt;
      &lt;th&gt;Method&lt;/th&gt; &lt;th&gt;Parameter&lt;/th&gt;
      &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;abs&lt;/td&gt;
      &lt;td&gt;-any-&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;
      &lt;td&gt;acos&lt;/td&gt; &lt;td&gt;0.0 or 1.0&lt;/td&gt;
      &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;asin&lt;/td&gt;
      &lt;td&gt;0.0 or 1.0&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;
      &lt;td&gt;atan&lt;/td&gt; &lt;td&gt;0.0 or 1.0&lt;/td&gt;
      &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;atan2&lt;/td&gt;
      &lt;td&gt;0.0&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;
      &lt;td&gt;cbrt&lt;/td&gt; &lt;td&gt;0.0 or 1.0&lt;/td&gt;
      &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;ceil&lt;/td&gt;
      &lt;td&gt;-any-&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;
      &lt;td&gt;cos&lt;/td&gt; &lt;td&gt;0.0&lt;/td&gt;
      &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;cosh&lt;/td&gt;
      &lt;td&gt;0.0&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;
      &lt;td&gt;exp&lt;/td&gt; &lt;td&gt;0.0 or 1.0&lt;/td&gt;
      &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;expm1&lt;/td&gt;
      &lt;td&gt;0.0&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;
      &lt;td&gt;floor&lt;/td&gt; &lt;td&gt;-any-&lt;/td&gt;
      &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;log&lt;/td&gt;
      &lt;td&gt;0.0 or 1.0&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;
      &lt;td&gt;log10&lt;/td&gt; &lt;td&gt;0.0 or 1.0&lt;/td&gt;
      &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;rint&lt;/td&gt;
      &lt;td&gt;-any-&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;
      &lt;td&gt;round&lt;/td&gt; &lt;td&gt;-any-&lt;/td&gt;
      &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;sin&lt;/td&gt;
      &lt;td&gt;0.0&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;
      &lt;td&gt;sinh&lt;/td&gt; &lt;td&gt;0.0&lt;/td&gt;
      &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;sqrt&lt;/td&gt;
      &lt;td&gt;0.0 or 1.0&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;
      &lt;td&gt;tan&lt;/td&gt; &lt;td&gt;0.0&lt;/td&gt;
      &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;tanh&lt;/td&gt;
      &lt;td&gt;0.0&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;
      &lt;td&gt;toDegrees&lt;/td&gt; &lt;td&gt;0.0 or
      1.0&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;
      &lt;td&gt;toRadians&lt;/td&gt; &lt;td&gt;0.0&lt;/td&gt;
      &lt;/tr&gt; &lt;/table&gt;

    </info>
    <name>Unnecessary Math</name>
  </findingType>
  <findingType>
    <id>CD_CIRCULAR_DEPENDENCY</id>
    <artifact tool="FindBugs" mnemonic="CD_CIRCULAR_DEPENDENCY">
    </artifact>
    <shortMessage>
      Test for circular dependencies among classes
    </shortMessage>
    <info>

      &lt;p&gt; This class has a circular dependency with other
      classes. This makes building these classes difficult, as
      each is dependent on the other to build correctly. Consider
      using interfaces to break the hard dependency. &lt;/p&gt;

    </info>
    <name>Circular Dependency</name>
  </findingType>
  <findingType>
    <id>RI_REDUNDANT_INTERFACES</id>
    <artifact tool="FindBugs" mnemonic="RI_REDUNDANT_INTERFACES">
    </artifact>
    <shortMessage>
      Class implements same interface as superclass
    </shortMessage>
    <info>

      &lt;p&gt; This class declares that it implements an
      interface that is also implemented by a superclass. This is
      redundant, once a superclass implements an interface, all
      subclasses by default also implement this interface. It may
      point out that the inheritance hierarchy has changed since
      this class was created, and consideration should be taken
      into account for the ownership of the interface's
      implementation. &lt;/p&gt;

    </info>
    <name>Redundant Interfaces</name>
  </findingType>
  <findingType>
    <id>MTIA_SUSPECT_STRUTS_INSTANCE_FIELD</id>
    <artifact tool="FindBugs"
	      mnemonic="MTIA_SUSPECT_STRUTS_INSTANCE_FIELD">
    </artifact>
    <shortMessage>
      Class extends Struts Action class and uses instance
      variables
    </shortMessage>
    <info>

      &lt;p&gt; This class extends from a Struts Action class, and
      uses a instance member variable. Since only one instance of
      a struts Action class is created by the Struts framework,
      and used in a multithreaded way, this paradigm is highly
      discouraged and most likely problematic. Consider only using
      method local variables. &lt;/p&gt;

    </info>
    <name>Suspect Struts Instance Field</name>
  </findingType>
  <findingType>
    <id>MTIA_SUSPECT_SERVLET_INSTANCE_FIELD</id>
    <artifact tool="FindBugs"
	      mnemonic="MTIA_SUSPECT_SERVLET_INSTANCE_FIELD">
    </artifact>
    <shortMessage>
      Class extends Servlet class and uses instance variables
    </shortMessage>
    <info>

      &lt;p&gt; This class extends from a Servlet class, and uses
      a instance member variable. Since only one instance of a
      Servlet class is created by the J2EE framework, and used in
      a multithreaded way, this paradigm is highly discouraged and
      most likely problematic. Consider only using method local
      variables. &lt;/p&gt;

    </info>
    <name>Suspect Servlet Instance Field</name>
  </findingType>
  <findingType>
    <id>PS_PUBLIC_SEMAPHORES</id>
    <artifact tool="FindBugs" mnemonic="PS_PUBLIC_SEMAPHORES">
    </artifact>
    <shortMessage>
      Class exposes synchronization and semaphores in its public
      interface
    </shortMessage>
    <info>

      &lt;p&gt; This class uses synchronization along with wait(),
      notify() or notifyAll() on itself (the this reference).
      Client classes that use this class, may, in addition, use an
      instance of this class as a synchronizing object. Because
      two classes are using the same object for synchronization,
      Multithread correctness is suspect. You should not
      synchronize nor call semaphore methods on a public
      reference. Consider using a internal private member variable
      to control synchronization. &lt;/p&gt;

    </info>
    <name>Public Semaphores</name>
  </findingType>
  <findingType>
    <id>ICAST_INTEGER_MULTIPLY_CAST_TO_LONG</id>
    <artifact tool="FindBugs"
	      mnemonic="ICAST_INTEGER_MULTIPLY_CAST_TO_LONG">
    </artifact>
    <shortMessage>
      Result of integer multiplication cast to long
    </shortMessage>
    <info>

      &lt;p&gt; This code performs integer multiply and then
      converts the result to a long, as in: &lt;code&gt;
      &lt;pre&gt; long convertDaysToMilliseconds(int days) {
      return 1000*3600*24*days; } &lt;/pre&gt;&lt;/code&gt; If the
      multiplication is done using long arithmetic, you can avoid
      the possibility that the result will overflow. For example,
      you could fix the above code to: &lt;code&gt; &lt;pre&gt;
      long convertDaysToMilliseconds(int days) { return
      1000L*3600*24*days; } &lt;/pre&gt;&lt;/code&gt; or
      &lt;code&gt; &lt;pre&gt; static final long
      MILLISECONDS_PER_DAY = 24L*3600*1000; long
      convertDaysToMilliseconds(int days) { return days *
      MILLISECONDS_PER_DAY; } &lt;/pre&gt;&lt;/code&gt; &lt;/p&gt;


    </info>
    <name>Integer Multiply Cast To Long</name>
  </findingType>
  <findingType>
    <id>ICAST_INT_CAST_TO_FLOAT_PASSED_TO_ROUND</id>
    <artifact tool="FindBugs"
	      mnemonic="ICAST_INT_CAST_TO_FLOAT_PASSED_TO_ROUND">
    </artifact>
    <shortMessage>
      int value cast to float and then passed to Math.round
    </shortMessage>
    <info>

      &lt;p&gt; This code converts an int value to a float
      precision floating point number and then passing the result
      to the Math.round() function, which returns the int/long
      closest to the argument. This operation should always be a
      no-op, since the converting an integer to a float should
      give a number with no fractional part. It is likely that the
      operation that generated the value to be passed to
      Math.round was intended to be performed using floating point
      arithmetic. &lt;/p&gt;


    </info>
    <name>Int Cast To Float Passed To Round</name>
  </findingType>
  <findingType>
    <id>ICAST_INT_CAST_TO_DOUBLE_PASSED_TO_CEIL</id>
    <artifact tool="FindBugs"
	      mnemonic="ICAST_INT_CAST_TO_DOUBLE_PASSED_TO_CEIL">
    </artifact>
    <shortMessage>
      int value cast to double and then passed to Math.ceil
    </shortMessage>
    <info>

      &lt;p&gt; This code converts an int value to a double
      precision floating point number and then passing the result
      to the Math.ceil() function, which rounds a double to the
      next higher integer value. This operation should always be a
      no-op, since the converting an integer to a double should
      give a number with no fractional part. It is likely that the
      operation that generated the value to be passed to Math.ceil
      was intended to be performed using double precision floating
      point arithmetic. &lt;/p&gt;


    </info>
    <name>Int Cast To Double Passed To Math.ceil</name>
  </findingType>
  <findingType>
    <id>ICAST_IDIV_CAST_TO_DOUBLE</id>
    <artifact tool="FindBugs"
	      mnemonic="ICAST_IDIV_CAST_TO_DOUBLE">
    </artifact>
    <shortMessage>
      int division result cast to double or float
    </shortMessage>
    <info>

      &lt;p&gt; This code casts the result of an integer division
      operation to double or float. Doing division on integers
      truncates the result to the integer value closest to zero.
      The fact that the result was cast to double suggests that
      this precision should have been retained. What was probably
      meant was to cast one or both of the operands to double
      &lt;em&gt;before&lt;/em&gt; performing the division. Here is
      an example: &lt;/p&gt; &lt;blockquote&gt; &lt;pre&gt; int x
      = 2; int y = 5; // Wrong: yields result 0.0 double value1 =
      x / y;

      // Right: yields result 0.4 double value2 = x / (double) y;
      &lt;/pre&gt; &lt;/blockquote&gt;

    </info>
    <name>Idiv Cast To Double</name>
  </findingType>
  <findingType>
    <id>J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION</id>
    <artifact tool="FindBugs"
	      mnemonic="J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION">
    </artifact>
    <shortMessage>
      Store of non serializable object into HttpSession
    </shortMessage>
    <info>

      &lt;p&gt; This code seems to be storing a non-serializable
      object into an HttpSession. If this session is passivated or
      migrated, an error will result. &lt;/p&gt;

    </info>
    <name>Store Of Non Serializable Object Into Session</name>
  </findingType>
  <findingType>
    <id>DMI_NONSERIALIZABLE_OBJECT_WRITTEN</id>
    <artifact tool="FindBugs"
	      mnemonic="DMI_NONSERIALIZABLE_OBJECT_WRITTEN">
    </artifact>
    <shortMessage>
      Non serializable object written to ObjectOutput
    </shortMessage>
    <info>

      &lt;p&gt; This code seems to be passing a non-serializable
      object to the ObjectOutput.writeObject method. If the object
      is, indeed, non-serializable, an error will result.
      &lt;/p&gt;

    </info>
    <name>Nonserializable Object Written</name>
  </findingType>
  <findingType>
    <id>VA_PRIMITIVE_ARRAY_PASSED_TO_OBJECT_VARARG</id>
    <artifact tool="FindBugs"
	      mnemonic="VA_PRIMITIVE_ARRAY_PASSED_TO_OBJECT_VARARG">
    </artifact>
    <shortMessage>
      Primitive array passed to function expecting a variable
      number of object arguments
    </shortMessage>
    <info>

      &lt;p&gt; This code passes a primitive array to a function
      that takes a variable number of object arguments. This
      creates an array of length one to hold the primitive array
      and passes it to the function. &lt;/p&gt;

    </info>
    <name>Primitive Array Passed To Object Vararg</name>
  </findingType>
  <findingType>
    <id>BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS</id>
    <artifact tool="FindBugs"
	      mnemonic="BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS">
    </artifact>
    <shortMessage>
      Equals method should not assume anything about the type of
      its argument
    </shortMessage>
    <info>

      &lt;p&gt; The &lt;code&gt;equals(Object o)&lt;/code&gt;
      method shouldn't make any assumptions about the type of
      &lt;code&gt;o&lt;/code&gt;. It should simply return false if
      &lt;code&gt;o&lt;/code&gt; is not the same type as
      &lt;code&gt;this&lt;/code&gt;. &lt;/p&gt;

    </info>
    <name>Equals Method Should Work For All Objects</name>
  </findingType>
  <findingType>
    <id>BC_BAD_CAST_TO_ABSTRACT_COLLECTION</id>
    <artifact tool="FindBugs"
	      mnemonic="BC_BAD_CAST_TO_ABSTRACT_COLLECTION">
    </artifact>
    <shortMessage>
      Questionable cast to abstract collection
    </shortMessage>
    <info>

      &lt;p&gt; This code casts a Collection to an abstract
      collection (such as &lt;code&gt;List&lt;/code&gt;,
      &lt;code&gt;Set&lt;/code&gt;, or
      &lt;code&gt;Map&lt;/code&gt;). Ensure that you are
      guaranteed that the object is of the type you are casting
      to. If all you need is to be able to iterate through a
      collection, you don't need to cast it to a Set or List.
      &lt;/p&gt;

    </info>
    <name>Bad Cast To Abstract Collection</name>
  </findingType>
  <findingType>
    <id>BC_IMPOSSIBLE_CAST_PRIMITIVE_ARRAY</id>
    <artifact tool="FindBugs"
	      mnemonic="BC_IMPOSSIBLE_CAST_PRIMITIVE_ARRAY">
    </artifact>
    <shortMessage>
      Impossible cast involving primitive array
    </shortMessage>
    <info>

      &lt;p&gt; This cast will always throw a ClassCastException.
      &lt;/p&gt;

    </info>
    <name>Impossible Cast Primitive Array</name>
  </findingType>
  <findingType>
    <id>BC_IMPOSSIBLE_CAST</id>
    <artifact tool="FindBugs" mnemonic="BC_IMPOSSIBLE_CAST">
    </artifact>
    <shortMessage>Impossible cast</shortMessage>
    <info>

      &lt;p&gt; This cast will always throw a ClassCastException.
      &lt;/p&gt;

    </info>
    <name>Impossible Cast</name>
  </findingType>
  <findingType>
    <id>NP_NULL_INSTANCEOF</id>
    <artifact tool="FindBugs" mnemonic="NP_NULL_INSTANCEOF">
    </artifact>
    <shortMessage>
      A known null value is checked to see if it is an instance of
      a type
    </shortMessage>
    <info>

      &lt;p&gt; This instanceof test will always return false,
      since the value being checked is guaranteed to be null.
      Although this is safe, make sure it isn't an indication of
      some misunderstanding or some other logic error. &lt;/p&gt;

    </info>
    <name>Null instanceof</name>
  </findingType>
  <findingType>
    <id>BC_NULL_INSTANCEOF</id>
    <artifact tool="FindBugs" mnemonic="BC_NULL_INSTANCEOF">
    </artifact>
    <shortMessage>
      A known null value is checked to see if it is an instance of
      a type
    </shortMessage>
    <info>

      &lt;p&gt; This instanceof test will always return false,
      since the value being checked is guaranteed to be null.
      Although this is safe, make sure it isn't an indication of
      some misunderstanding or some other logic error. &lt;/p&gt;

    </info>
    <name>Null instanceof</name>
  </findingType>
  <findingType>
    <id>BC_IMPOSSIBLE_INSTANCEOF</id>
    <artifact tool="FindBugs" mnemonic="BC_IMPOSSIBLE_INSTANCEOF">
    </artifact>
    <shortMessage>instanceof will always return false</shortMessage>
    <info>

      &lt;p&gt; This instanceof test will always return false.
      Although this is safe, make sure it isn't an indication of
      some misunderstanding or some other logic error. &lt;/p&gt;

    </info>
    <name>Impossible instanceof</name>
  </findingType>
  <findingType>
    <id>BC_VACUOUS_INSTANCEOF</id>
    <artifact tool="FindBugs" mnemonic="BC_VACUOUS_INSTANCEOF">
    </artifact>
    <shortMessage>instanceof will always return true</shortMessage>
    <info>

      &lt;p&gt; This instanceof test will always return true.
      Although this is safe, make sure it isn't an indication of
      some misunderstanding or some other logic error. &lt;/p&gt;

    </info>
    <name>Vacuous instanceof</name>
  </findingType>
  <findingType>
    <id>BC_UNCONFIRMED_CAST</id>
    <artifact tool="FindBugs" mnemonic="BC_UNCONFIRMED_CAST">
    </artifact>
    <shortMessage>Unchecked/unconfirmed cast</shortMessage>
    <info>

      &lt;p&gt; This cast is unchecked, and not all instances of
      the type casted from can be cast to the type it is being
      cast to. Ensure that your program logic ensures that this
      cast will not fail. &lt;/p&gt;

    </info>
    <name>Unconfirmed Cast</name>
  </findingType>
  <findingType>
    <id>BC_BAD_CAST_TO_CONCRETE_COLLECTION</id>
    <artifact tool="FindBugs"
	      mnemonic="BC_BAD_CAST_TO_CONCRETE_COLLECTION">
    </artifact>
    <shortMessage>
      Questionable cast to concrete collection
    </shortMessage>
    <info>

      &lt;p&gt; This code casts an abstract collection (such as a
      Collection, List, or Set) to a specific concrete
      implementation (such as an ArrayList or HashSet). This might
      not be correct, and it may make your code fragile, since it
      makes it harder to switch to other concrete implementations
      at a future point. Unless you have a particular reason to do
      so, just use the abstract collection class. &lt;/p&gt;

    </info>
    <name>Bad Cast To Concrete Collection</name>
  </findingType>
  <findingType>
    <id>RE_POSSIBLE_UNINTENDED_PATTERN</id>
    <artifact tool="FindBugs"
	      mnemonic="RE_POSSIBLE_UNINTENDED_PATTERN">
    </artifact>
    <shortMessage>
      &quot;.&quot; used for regular expression
    </shortMessage>
    <info>

      &lt;p&gt; A String function is being invoked and
      &quot;.&quot; is being passed to a parameter that takes a
      regular expression as an argument. Is this what you
      intended? For example s.replaceAll(&quot;.&quot;,
      &quot;/&quot;) will return a String in which
      &lt;em&gt;every&lt;/em&gt; character has been replaced by a
      / character. &lt;/p&gt;

    </info>
    <name>Possible Unintended Pattern</name>
  </findingType>
  <findingType>
    <id>RE_BAD_SYNTAX_FOR_REGULAR_EXPRESSION</id>
    <artifact tool="FindBugs"
	      mnemonic="RE_BAD_SYNTAX_FOR_REGULAR_EXPRESSION">
    </artifact>
    <shortMessage>
      Invalid syntax for regular expression
    </shortMessage>
    <info>

      &lt;p&gt; The code here uses a regular expression that is
      invalid according to the syntax for regular expressions.
      This statement will throw a PatternSyntaxException when
      executed. &lt;/p&gt;

    </info>
    <name>Bad Syntax For Regular Expression</name>
  </findingType>
  <findingType>
    <id>RE_CANT_USE_FILE_SEPARATOR_AS_REGULAR_EXPRESSION</id>
    <artifact tool="FindBugs"
	      mnemonic="RE_CANT_USE_FILE_SEPARATOR_AS_REGULAR_EXPRESSION">
    </artifact>
    <shortMessage>
      File.separator used for regular expression
    </shortMessage>
    <info>

      &lt;p&gt; The code here uses
      &lt;code&gt;File.separator&lt;/code&gt; where a regular
      expression is required. This will fail on Windows platforms,
      where the &lt;code&gt;File.separator&lt;/code&gt; is a
      backslash, which is interpreted in a regular expression as
      an escape character. Amoung other options, you can just use
      &lt;code&gt;File.separatorChar=='\\' &amp;amp;
      &quot;\\\\&quot; : File.separator&lt;/code&gt; instead of
      &lt;code&gt;File.separator&lt;/code&gt;

      &lt;/p&gt;

    </info>
    <name>Cant Use File Separator As Regular Expression</name>
  </findingType>
  <findingType>
    <id>DLS_OVERWRITTEN_INCREMENT</id>
    <artifact tool="FindBugs"
	      mnemonic="DLS_OVERWRITTEN_INCREMENT">
    </artifact>
    <shortMessage>Overwritten increment</shortMessage>
    <info>

      &lt;p&gt; The code performs an increment operation (e.g.,
      &lt;code&gt;i++&lt;/code&gt;) and then immediately
      overwrites it. For example, &lt;code&gt;i = i++&lt;/code&gt;
      immediately overwrites the incremented value with the
      original value. &lt;/p&gt;

    </info>
    <name>Overwritten Increment</name>
  </findingType>
  <findingType>
    <id>ICAST_QUESTIONABLE_UNSIGNED_RIGHT_SHIFT</id>
    <artifact tool="FindBugs"
	      mnemonic="ICAST_QUESTIONABLE_UNSIGNED_RIGHT_SHIFT">
    </artifact>
    <shortMessage>
      Unsigned right shift cast to short/byte
    </shortMessage>
    <info>

      &lt;p&gt; The code performs an unsigned right shift, whose
      result is then cast to a short or byte, which discards the
      upper bits of the result. Since the upper bits are
      discarded, there may be no difference between a signed and
      unsigned right shift (depending upon the size of the shift).
      &lt;/p&gt;

    </info>
    <name>Questionable Unsigned Right Shift</name>
  </findingType>
  <findingType>
    <id>ICAST_BAD_SHIFT_AMOUNT</id>
    <artifact tool="FindBugs" mnemonic="ICAST_BAD_SHIFT_AMOUNT">
    </artifact>
    <shortMessage>
      Integer shift by an amount not in the range 0..31
    </shortMessage>
    <info>

      &lt;p&gt; The code performs an integer shift by a constant
      amount outside the range 0..31. The effect of this is to use
      the lower 5 bits of the integer value to decide how much to
      shift by. This probably isn't want was expected, and it at
      least confusing. &lt;/p&gt;

    </info>
    <name>Bad Shift Amount</name>
  </findingType>
  <findingType>
    <id>IM_MULTIPLYING_RESULT_OF_IREM</id>
    <artifact tool="FindBugs"
	      mnemonic="IM_MULTIPLYING_RESULT_OF_IREM">
    </artifact>
    <shortMessage>
      Integer multiply of result of integer remainder
    </shortMessage>
    <info>

      &lt;p&gt; The code multiplies the result of an integer
      remaining by an integer constant. Be sure you don't have
      your operator precedence confused. For example i % 60 * 1000
      is (i % 60) * 1000, not i % (60 * 1000). &lt;/p&gt;

    </info>
    <name>Multiplying Result Of Int Remainder</name>
  </findingType>
  <findingType>
    <id>DMI_INVOKING_TOSTRING_ON_ARRAY</id>
    <artifact tool="FindBugs"
	      mnemonic="DMI_INVOKING_TOSTRING_ON_ARRAY">
    </artifact>
    <shortMessage>Invocation of toString on an array</shortMessage>
    <info>

      &lt;p&gt; The code invokes toString on an array, which will
      generate a fairly useless result such as [C@16f0472.
      Consider using Arrays.toString to convert the array into a
      readable String that gives the contents of the array. See
      Programming Puzzlers, chapter 3, puzzle 12. &lt;/p&gt;

    </info>
    <name>Invoking toString On Array</name>
  </findingType>
  <findingType>
    <id>IM_AVERAGE_COMPUTATION_COULD_OVERFLOW</id>
    <artifact tool="FindBugs"
	      mnemonic="IM_AVERAGE_COMPUTATION_COULD_OVERFLOW">
    </artifact>
    <shortMessage>
      Computation of average could overflow
    </shortMessage>
    <info>

      &lt;p&gt;The code computes the average of two integers using
      either division or signed right shift, and then uses the
      result as the index of an array. If the values being
      averaged are very large, this can overflow (resulting in the
      computation of a negative average). Assuming that the result
      is intended to be nonnegative, you can use an unsigned right
      shift instead. In other words, rather that using
      &lt;code&gt;(low+high)/2&lt;/code&gt;, use
      &lt;code&gt;(low+high) &amp;gt;&amp;gt;&amp;gt;
      1&lt;/code&gt; &lt;/p&gt; &lt;p&gt;This bug exists in many
      earlier implementations of binary search and merge sort.
      Martin Buchholz &lt;a
      href=&quot;http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6412541&quot;&gt;found
      and fixed it&lt;/a&gt; in the JDK libraries, and Joshua
      Bloch &lt;a
      href=&quot;http://googleresearch.blogspot.com/2006/06/extra-extra-read-all-about-it-nearly.html&quot;&gt;widely
      publicized the bug pattern&lt;/a&gt;. &lt;/p&gt;

    </info>
    <name>Average Computation Could Overflow</name>
  </findingType>
  <findingType>
    <id>IM_BAD_CHECK_FOR_ODD</id>
    <artifact tool="FindBugs" mnemonic="IM_BAD_CHECK_FOR_ODD">
    </artifact>
    <shortMessage>
      Check for oddness that won't work for negative numbers
    </shortMessage>
    <info>

      &lt;p&gt; The code uses x % 2 == 1 to check to see if a
      value is odd, but this won't work for negative numbers
      (e.g., (-5) % 2 == -1). If this code is intending to check
      for oddness, consider using x &amp; 1 == 1, or x % 2 != 0.
      &lt;/p&gt;

    </info>
    <name>Bad Check For Odd</name>
  </findingType>
  <findingType>
    <id>DMI_HARDCODED_ABSOLUTE_FILENAME</id>
    <artifact tool="FindBugs"
	      mnemonic="DMI_HARDCODED_ABSOLUTE_FILENAME">
    </artifact>
    <shortMessage>
      Code contains a hard coded reference to an absolute pathname
    </shortMessage>
    <info>

      &lt;p&gt;This code constructs a File object using a hard
      coded to an absolute pathname (e.g., &lt;code&gt;new
      File(&quot;/home/dannyc/workspace/j2ee/src/share/com/sun/enterprise/deployment&quot;);&lt;/code&gt;
      &lt;/p&gt;

    </info>
    <name>Hardcoded Absolute Filename</name>
  </findingType>
  <findingType>
    <id>DMI_BAD_MONTH</id>
    <artifact tool="FindBugs" mnemonic="DMI_BAD_MONTH"></artifact>
    <shortMessage>Bad constant value for month</shortMessage>
    <info>

      &lt;p&gt; This code passes a constant month value outside
      the expected range of 0..11 to a method. &lt;/p&gt;

    </info>
    <name>Bad Month</name>
  </findingType>
  <findingType>
    <id>DMI_USELESS_SUBSTRING</id>
    <artifact tool="FindBugs" mnemonic="DMI_USELESS_SUBSTRING">
    </artifact>
    <shortMessage>
      Invocation of substring(0), which returns the original value
    </shortMessage>
    <info>

      &lt;p&gt; This code invokes substring(0) on a String, which
      returns the original value. &lt;/p&gt;

    </info>
    <name>Useless Substring</name>
  </findingType>
  <findingType>
    <id>DMI_CALLING_NEXT_FROM_HASNEXT</id>
    <artifact tool="FindBugs"
	      mnemonic="DMI_CALLING_NEXT_FROM_HASNEXT">
    </artifact>
    <shortMessage>hasNext method invokes next</shortMessage>
    <info>

      &lt;p&gt; The hasNext() method invokes the next() method.
      This is almost certainly wrong, since the hasNext() method
      is not supposed to change the state of the iterator, and the
      next method is supposed to change the state of the iterator.
      &lt;/p&gt;

    </info>
    <name>Calling Next From hasNext</name>
  </findingType>
  <findingType>
    <id>AvoidCallingSleepWithLockHeld</id>
    <artifact tool="FindBugs" mnemonic="SWL_SLEEP_WITH_LOCK_HELD">
    </artifact>
    <shortMessage>
      Method calls Thread.sleep() with a lock held
    </shortMessage>
    <info>

      &lt;p&gt; This method calls Thread.sleep() with a lock held.
      This may result in very poor performance and scalability, or
      a deadlock, since other threads may be waiting to acquire
      the lock. It is a much better idea to call wait() on the
      lock, which releases the lock and allows other threads to
      run. &lt;/p&gt;

    </info>
    <name>Sleep With Lock Held</name>
  </findingType>
  <findingType>
    <id>DB_DUPLICATE_BRANCHES</id>
    <artifact tool="FindBugs" mnemonic="DB_DUPLICATE_BRANCHES">
    </artifact>
    <shortMessage>
      Method uses the same code for two branches
    </shortMessage>
    <info>

      &lt;p&gt; This method uses the same code to implement two
      branches of a conditional branch. Check to ensure that this
      isn't a coding mistake. &lt;/p&gt;

    </info>
    <name>Duplicate Branches</name>
  </findingType>
  <findingType>
    <id>DB_DUPLICATE_SWITCH_CLAUSES</id>
    <artifact tool="FindBugs"
	      mnemonic="DB_DUPLICATE_SWITCH_CLAUSES">
    </artifact>
    <shortMessage>
      Method uses the same code for two switch clauses
    </shortMessage>
    <info>

      &lt;p&gt; This method uses the same code to implement two
      clauses of a switch statement. This could be a case of
      duplicate code, but it might also indicate a coding mistake.
      &lt;/p&gt;

    </info>
    <name>Duplicate Switch Clauses</name>
  </findingType>
  <findingType>
    <id>IMA_INEFFICIENT_MEMBER_ACCESS</id>
    <artifact tool="FindBugs"
	      mnemonic="IMA_INEFFICIENT_MEMBER_ACCESS">
    </artifact>
    <shortMessage>
      Method accesses a private member variable of owning class
    </shortMessage>
    <info>

      &lt;p&gt; This method of an inner class reads from or writes
      to a private member variable of the owning class, or calls a
      private method of the owning class. The compiler must
      generate a special method to access this private member,
      causing this to be less efficient. Relaxing the protection
      of the member variable or method will allow the compiler to
      treat this as a normal access. &lt;/p&gt;

    </info>
    <name>Inefficient Member Access</name>
  </findingType>
  <findingType>
    <id>XFB_XML_FACTORY_BYPASS</id>
    <artifact tool="FindBugs" mnemonic="XFB_XML_FACTORY_BYPASS">
    </artifact>
    <shortMessage>
      Method directly allocates a specific implementation of xml
      interfaces
    </shortMessage>
    <info>

      &lt;p&gt; This method allocates a specific implementation of
      an xml interface. It is preferable to use the supplied
      factory classes to create these objects so that the
      implementation can be changed at runtime. See &lt;/p&gt;
      &lt;ul&gt;
      &lt;li&gt;javax.xml.parsers.DocumentBuilderFactory&lt;/li&gt;
      &lt;li&gt;javax.xml.parsers.SAXParserFactory&lt;/li&gt;
      &lt;li&gt;javax.xml.transform.TransformerFactory&lt;/li&gt;
      &lt;li&gt;org.w3c.dom.Document.create&lt;i&gt;XXXX&lt;/i&gt;&lt;/li&gt;
      &lt;/ul&gt; &lt;p&gt;for details.&lt;/p&gt;

    </info>
    <name>XML Factory Bypass</name>
  </findingType>
  <findingType>
    <id>USM_USELESS_SUBCLASS_METHOD</id>
    <artifact tool="FindBugs"
	      mnemonic="USM_USELESS_SUBCLASS_METHOD">
    </artifact>
    <shortMessage>
      Method superfluously delegates to parent class method
    </shortMessage>
    <info>

      &lt;p&gt; This derived method merely calls the same
      superclass method passing in the exact parameters received.
      This method can be removed, as it provides no additional
      value. &lt;/p&gt;

    </info>
    <name>Useless Subclass Method</name>
  </findingType>
  <findingType>
    <id>USM_USELESS_ABSTRACT_METHOD</id>
    <artifact tool="FindBugs"
	      mnemonic="USM_USELESS_ABSTRACT_METHOD">
    </artifact>
    <shortMessage>
      Abstract Method is already defined in implemented interface
    </shortMessage>
    <info>

      &lt;p&gt; This abstract method is already defined in an
      interface that is implemented by this abstract class. This
      method can be removed, as it provides no additional value.
      &lt;/p&gt;

    </info>
    <name>Useless Abstract Method</name>
  </findingType>
  <findingType>
    <id>CI_CONFUSED_INHERITANCE</id>
    <artifact tool="FindBugs" mnemonic="CI_CONFUSED_INHERITANCE">
    </artifact>
    <shortMessage>
      Class is final but declares protected field
    </shortMessage>
    <info>

      &lt;p&gt; This class is declared to be final, but declares
      fields to be protected. Since the class is final, it can not
      be derived from, and the use of protected is confusing. The
      access modifier for the field should be changed to private
      or public to represent the true use for the field.
      &lt;/p&gt;

    </info>
    <name>Confused Inheritance</name>
  </findingType>
  <findingType>
    <id>QBA_QUESTIONABLE_BOOLEAN_ASSIGNMENT</id>
    <artifact tool="FindBugs"
	      mnemonic="QBA_QUESTIONABLE_BOOLEAN_ASSIGNMENT">
    </artifact>
    <shortMessage>
      Method assigns boolean literal in boolean expression
    </shortMessage>
    <info>

      &lt;p&gt; This method assigns a literal boolean value (true
      or false) to a boolean variable inside an if or while
      expression. Most probably this was supposed to be a boolean
      comparison using ==, not an assignment using =. &lt;/p&gt;

    </info>
    <name>Questionable Boolean Assignment</name>
  </findingType>
  <findingType>
    <id>VR_UNRESOLVABLE_REFERENCE</id>
    <artifact tool="FindBugs"
	      mnemonic="VR_UNRESOLVABLE_REFERENCE">
    </artifact>
    <shortMessage>
      Class makes reference to unresolvable class or method
    </shortMessage>
    <info>

      &lt;p&gt; This class makes a reference to a class or method
      that can not be resolved using against the libraries it is
      being analyzed with. &lt;/p&gt;

    </info>
    <name>Unresolvable Reference</name>
  </findingType>
  <findingType>
    <id>GC_UNRELATED_TYPES</id>
    <artifact tool="FindBugs" mnemonic="GC_UNRELATED_TYPES">
    </artifact>
    <shortMessage>
      No relationship between generic parameter and method
      argument
    </shortMessage>
    <info>

      &lt;p&gt; This call to a generic container's method contains
      an argument with a different class type from that of the
      container's parameter. Therefore, it is unlikely that the
      container contains any objects with the same type as the
      method argument used here. &lt;/p&gt;

    </info>
    <name>Unrelated Types</name>
  </findingType>
  <findingType>
    <id>AvoidStaticCalendar</id>
    <artifact tool="FindBugs"
	      mnemonic="STCAL_STATIC_CALENDAR_INSTANCE">
    </artifact>
    <shortMessage>Static Calendar</shortMessage>
    <info>

      &lt;p&gt;Even though the JavaDoc does not contain a hint
      about it, Calendars are inherently unsafe for multihtreaded
      use. Sharing a single instance across thread boundaries
      without proper synchronization will result in erratic
      behavior of the application. Under 1.4 problems seem to
      surface less often than under Java 5 where you will probably
      see random ArrayIndexOutOfBoundsExceptions or
      IndexOutOfBoundsExceptions in
      sun.util.calendar.BaseCalendar.getCalendarDateFromFixedDate().&lt;/p&gt;
      &lt;p&gt;You may also experience serialization
      problems.&lt;/p&gt; &lt;p&gt;Using an instance field is
      recommended.&lt;/p&gt; &lt;p&gt;For more information on this
      see &lt;a
      href=&quot;http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6231579&quot;&gt;Sun
      Bug #6231579&lt;/a&gt; and &lt;a
      href=&quot;http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6178997&quot;&gt;Sun
      Bug #6178997&lt;/a&gt;.&lt;/p&gt;

    </info>
    <name>Static Calendar Instance</name>
  </findingType>
  <findingType>
    <id>CallToStaticCalendar</id>
    <artifact tool="FindBugs"
	      mnemonic="STCAL_INVOKE_ON_STATIC_CALENDAR_INSTANCE">
    </artifact>
    <shortMessage>Call to static Calendar</shortMessage>
    <info>

      &lt;p&gt;Even though the JavaDoc does not contain a hint
      about it, Calendars are inherently unsafe for multihtreaded
      use. The detector has found a call to an instance of
      Calendar that has been obtained via a static field. This
      looks suspicous.&lt;/p&gt; &lt;p&gt;For more information on
      this see &lt;a
      href=&quot;http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6231579&quot;&gt;Sun
      Bug #6231579&lt;/a&gt; and &lt;a
      href=&quot;http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6178997&quot;&gt;Sun
      Bug #6178997&lt;/a&gt;.&lt;/p&gt;

    </info>
    <name>Invoke On Static Calendar Instance</name>
  </findingType>
  <findingType>
    <id>AvoidStaticDateformat</id>
    <artifact tool="FindBugs"
	      mnemonic="STCAL_STATIC_SIMPLE_DATA_FORMAT_INSTANCE">
    </artifact>
    <artifact tool="FindBugs"
	      mnemonic="STCAL_STATIC_SIMPLE_DATE_FORMAT_INSTANCE">
    </artifact>
    <shortMessage>Static DateFormat</shortMessage>
    <info>

      &lt;p&gt;As the JavaDoc states, DateFormats are inherently
      unsafe for multithreaded use. Sharing a single instance
      across thread boundaries without proper synchronization will
      result in erratic behavior of the application.&lt;/p&gt;
      &lt;p&gt;You may also experience serialization
      problems.&lt;/p&gt; &lt;p&gt;Using an instance field is
      recommended.&lt;/p&gt; &lt;p&gt;For more information on this
      see &lt;a
      href=&quot;http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6231579&quot;&gt;Sun
      Bug #6231579&lt;/a&gt; and &lt;a
      href=&quot;http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6178997&quot;&gt;Sun
      Bug #6178997&lt;/a&gt;.&lt;/p&gt;

    </info>
    <name>Static Simple Data Format Instance</name>
  </findingType>
  <findingType>
    <id>CallToStaticDateFormat</id>
    <artifact tool="FindBugs"
	      mnemonic="STCAL_INVOKE_ON_STATIC_DATE_FORMAT_INSTANCE">
    </artifact>
    <shortMessage>Call to static DateFormat</shortMessage>
    <info>

      &lt;p&gt;As the JavaDoc states, DateFormats are inherently
      unsafe for multithreaded use. The detector has found a call
      to an instance of DateFormat that has been obtained via a
      static field. This looks suspicous.&lt;/p&gt; &lt;p&gt;For
      more information on this see &lt;a
      href=&quot;http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6231579&quot;&gt;Sun
      Bug #6231579&lt;/a&gt; and &lt;a
      href=&quot;http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6178997&quot;&gt;Sun
      Bug #6178997&lt;/a&gt;.&lt;/p&gt;

    </info>
    <name>Invoke On Static Date Format Instance</name>
  </findingType>

  <!-- This type is no longer used.  Do not assign artifacts to it. -->
  <findingType>
    <id>InefficientStringVoidConstructor</id>
    <shortMessage>
      Method invokes inefficient new String() constructor
    </shortMessage>
    <info>

      &lt;p&gt; Creating a new
      &lt;code&gt;java.lang.String&lt;/code&gt; object using the
      no-argument constructor wastes memory because the object so
      created will be functionally indistinguishable from the
      empty string constant
      &lt;code&gt;&quot;&quot;&lt;/code&gt;.&amp;nbsp; Java
      guarantees that identical string constants will be
      represented by the same &lt;code&gt;String&lt;/code&gt;
      object.&amp;nbsp; Therefore, you should just use the empty
      string constant directly.&lt;/p&gt;

    </info>
    <name>Inefficient String Void Constructor</name>
  </findingType>

  <!-- FindBugs 1.3.0 Upgrade -->
  <findingType>
    <id>DoesntOverrideEquals</id>
    <artifact tool="FindBugs"
	      mnemonic="EQ_DOESNT_OVERRIDE_EQUALS">
    </artifact>
    <shortMessage>
      Class doesn't override equals in superclass
    </shortMessage>
    <info>

      &lt;p&gt; This class extends a class that defines an equals
      method and adds fields, but doesn't define an equals method
      itself. Thus, equality on instances of this class will
      ignore the identity of the subclass and the added fields. Be
      sure this is what is intended, and that you don't need to
      override the equals method. Even if you don't need to
      override the equals method, consider overriding it anyone to
      document the fact that the equals method for the subclass
      just return the result of invoking super.equals(o).

    </info>
    <name>Doesn't Override Equals</name>
  </findingType>
  <findingType>
    <id>SameSimpleNameAsInterface</id>
    <artifact tool="FindBugs"
	      mnemonic="NM_SAME_SIMPLE_NAME_AS_INTERFACE">
    </artifact>
    <shortMessage>
      Class names shouldn't shadow simple name of implemented
      interface
    </shortMessage>
    <info>

      &lt;p&gt; This class/interface has a simple name that is
      identical to that of an implemented/extended interface,
      except that the interface is in a different package (e.g.,
      &lt;code&gt;alpha.Foo&lt;/code&gt; extends
      &lt;code&gt;beta.Foo&lt;/code&gt;). This can be
      exceptionally confusing, create lots of situations in which
      you have to look at import statements to resolve references
      and creates many opportunities to accidently define methods
      that do not override methods in their superclasses.
      &lt;/p&gt;

    </info>
    <name>Same Simple Name As Interface</name>
  </findingType>
  <findingType>
    <id>SameSimpleNameAsSuperclass</id>
    <artifact tool="FindBugs"
	      mnemonic="NM_SAME_SIMPLE_NAME_AS_SUPERCLASS">
    </artifact>
    <shortMessage>
      Class names shouldn't shadow simple name of superclass
    </shortMessage>
    <info>

      &lt;p&gt; This class has a simple name that is identical to
      that of its superclass, except that its superclass is in a
      different package (e.g., &lt;code&gt;alpha.Foo&lt;/code&gt;
      extends &lt;code&gt;beta.Foo&lt;/code&gt;). This can be
      exceptionally confusing, create lots of situations in which
      you have to look at import statements to resolve references
      and creates many opportunities to accidently define methods
      that do not override methods in their superclasses.
      &lt;/p&gt;

    </info>
    <name>Same Simple Name As Superclass</name>
  </findingType>
  <findingType>
    <id>WrongPackage</id>
    <artifact tool="FindBugs" mnemonic="NM_WRONG_PACKAGE">
    </artifact>
    <shortMessage>
      Method doesn't override method in superclass due to wrong
      package for parameter
    </shortMessage>
    <info>

      &lt;p&gt; The method in the subclass doesn't override a
      similar method in a superclass because the type of a
      parameter doesn't exactly match the type of the
      corresponding parameter in the superclass. For example, if
      you have:&lt;/p&gt;

      &lt;blockquote&gt; &lt;pre&gt; import alpha.Foo; public
      class A { public int f(Foo x) { return 17; } } ---- import
      beta.Foo; public class B extends A { public int f(Foo x) {
      return 42; } } &lt;/pre&gt; &lt;/blockquote&gt;

      &lt;p&gt;The &lt;code&gt;f(Foo)&lt;/code&gt; method defined
      in class &lt;code&gt;B&lt;/code&gt; doesn't override the
      &lt;code&gt;f(Foo)&lt;/code&gt; method defined in class
      &lt;code&gt;A&lt;/code&gt;, because the argument types are
      &lt;code&gt;Foo&lt;/code&gt;'s from different packages.
      &lt;/p&gt;

    </info>
    <name>Wrong Package</name>
  </findingType>
  <findingType>
    <id>WrongPackageIntentional</id>
    <artifact tool="FindBugs"
	      mnemonic="NM_WRONG_PACKAGE_INTENTIONAL">
    </artifact>
    <shortMessage>
      Method doesn't override method in superclass due to wrong
      package for parameter
    </shortMessage>
    <info>

      &lt;p&gt; The method in the subclass doesn't override a
      similar method in a superclass because the type of a
      parameter doesn't exactly match the type of the
      corresponding parameter in the superclass. For example, if
      you have:&lt;/p&gt;

      &lt;blockquote&gt; &lt;pre&gt; import alpha.Foo; public
      class A { public int f(Foo x) { return 17; } } ---- import
      beta.Foo; public class B extends A { public int f(Foo x) {
      return 42; } public int f(alpha.Foo x) { return 27; } }
      &lt;/pre&gt; &lt;/blockquote&gt;

      &lt;p&gt;The &lt;code&gt;f(Foo)&lt;/code&gt; method defined
      in class &lt;code&gt;B&lt;/code&gt; doesn't override the
      &lt;code&gt;f(Foo)&lt;/code&gt; method defined in class
      &lt;code&gt;A&lt;/code&gt;, because the argument types are
      &lt;code&gt;Foo&lt;/code&gt;'s from different packages.
      &lt;/p&gt;

      &lt;p&gt;In this case, the subclass does define a method
      with a signature identical to the method in the superclass,
      so this is presumably understood. However, such methods are
      exceptionally confusing. You should strongly consider
      removing or deprecating the method with the similar but not
      identical signature. &lt;/p&gt;

    </info>
    <name>Wrong Package Intentional</name>
  </findingType>
  <findingType>
    <id>ReturnValueIgnoredBadPractice</id>
    <artifact tool="FindBugs"
	      mnemonic="RV_RETURN_VALUE_IGNORED_BAD_PRACTICE">
    </artifact>
    <shortMessage>Method ignores return value</shortMessage>
    <info>

      &lt;p&gt; This method returns a value that is not checked.
      For example, the &lt;code&gt;File.delete()&lt;/code&gt;
      method returns false if the file could not be successfully
      deleted (rather than throwing an Exception). If you don't
      check the result, you won't notice if the method invocation
      signals unexpected behavior by returning an atypical return
      value.

    </info>
    <name>Return Value Ignored Bad Practice</name>
  </findingType>
  <findingType>
    <id>ExceptionNotThrown</id>
    <artifact tool="FindBugs" mnemonic="RV_EXCEPTION_NOT_THROWN">
    </artifact>
    <shortMessage>
      Exception created and dropped rather than thrown
    </shortMessage>
    <info>

      &lt;p&gt; This code creates an exception (or error) object,
      but doesn't do anything with it. For example, something like
      &lt;/p&gt; &lt;blockquote&gt; &lt;pre&gt; if (x &lt; 0) new
      IllegalArgumentException(&quot;x must be nonnegative&quot;);
      &lt;/pre&gt; &lt;/blockquote&gt; &lt;p&gt;It was probably
      the intent of the programmer to throw the created
      exception:&lt;/p&gt; &lt;blockquote&gt; &lt;pre&gt; if (x
      &lt; 0) throw new IllegalArgumentException(&quot;x must be
      nonnegative&quot;); &lt;/pre&gt; &lt;/blockquote&gt;

    </info>
    <name>Exception Not Thrown</name>
  </findingType>
  <findingType>
    <id>UnrelatedTypesUsingPointerEquality</id>
    <artifact tool="FindBugs"
	      mnemonic="EC_UNRELATED_TYPES_USING_POINTER_EQUALITY">
    </artifact>
    <shortMessage>
      Using pointer equality to compare different types
    </shortMessage>
    <info>

      &lt;p&gt; This method uses using pointer equality to compare
      two references that seem to be of different types. The
      result of this comparison will always be false at runtime.
      &lt;/p&gt;

    </info>
    <name>Unrelated Types Using Pointer Equality</name>
  </findingType>
  <findingType>
    <id>BitSignedCheck</id>
    <artifact tool="FindBugs" mnemonic="BIT_SIGNED_CHECK">
    </artifact>
    <shortMessage>Check for sign of bitwise operation</shortMessage>
    <info>

      &lt;p&gt; This method compares an expression such as
      &lt;pre&gt;((event.detail &amp; SWT.SELECTED) &gt;
      0)&lt;/pre&gt;. Using bit arithmetic and then comparing with
      the greater than operator can lead to unexpected results (of
      course depending on the value of SWT.SELECTED). If
      SWT.SELECTED is a negative number, this is a candidate for a
      bug. Even when SWT.SELECTED is not negative, it seems good
      practice to use '!= 0' instead of '&gt; 0'. &lt;/p&gt;
      &lt;p&gt; &lt;em&gt;Boris Bokowski&lt;/em&gt; &lt;/p&gt;

    </info>
    <name>Signed Check</name>
  </findingType>
  <findingType>
    <id>BitSignedCheckHighBit</id>
    <artifact tool="FindBugs"
	      mnemonic="BIT_SIGNED_CHECK_HIGH_BIT">
    </artifact>
    <shortMessage>Check for sign of bitwise operation</shortMessage>
    <info>

      &lt;p&gt; This method compares an expression such as
      &lt;pre&gt;((event.detail &amp; SWT.SELECTED) &gt;
      0)&lt;/pre&gt;. Using bit arithmetic and then comparing with
      the greater than operator can lead to unexpected results (of
      course depending on the value of SWT.SELECTED). If
      SWT.SELECTED is a negative number, this is a candidate for a
      bug. Even when SWT.SELECTED is not negative, it seems good
      practice to use '!= 0' instead of '&gt; 0'. &lt;/p&gt;
      &lt;p&gt; &lt;em&gt;Boris Bokowski&lt;/em&gt; &lt;/p&gt;

    </info>
    <name>Signed Check High Bit</name>
  </findingType>
  <findingType>
    <id>LazyInitUpdateStatic</id>
    <artifact tool="FindBugs"
	      mnemonic="LI_LAZY_INIT_UPDATE_STATIC">
    </artifact>
    <shortMessage>
      Incorrect lazy initialization and update of static field
    </shortMessage>
    <info>

      &lt;p&gt; This method contains an unsynchronized lazy
      initialization of a static field. After the field is set,
      the object stored into that location is further accessed.
      The setting of the field is visible to other threads as soon
      as it is set. If the futher accesses in the method that set
      the field serve to initialize the object, then you have a
      &lt;em&gt;very serious&lt;/em&gt; multithreading bug, unless
      something else prevents any other thread from accessing the
      stored object until it is fully initialized. &lt;/p&gt;

    </info>
    <name>Lazy Init Update Static</name>
  </findingType>
  <findingType>
    <id>DeadStoreOfClassLiteral</id>
    <artifact tool="FindBugs"
	      mnemonic="DLS_DEAD_STORE_OF_CLASS_LITERAL">
    </artifact>
    <shortMessage>Dead store of class literal</shortMessage>
    <info>

      &lt;p&gt; This instruction assigns a class literal to a
      variable and then never uses it. &lt;a
      href=&quot;//java.sun.com/j2se/1.5.0/compatibility.html#literal&quot;&gt;The
      behavior of this differs in Java 1.4 and in Java
      5.&lt;/a&gt; In Java 1.4 and earlier, a reference to
      &lt;code&gt;Foo.class&lt;/code&gt; would force the static
      initializer for &lt;code&gt;Foo&lt;/code&gt; to be executed,
      if it has not been executed already. In Java 5 and later, it
      does not. &lt;/p&gt; &lt;p&gt;See Sun's &lt;a
      href=&quot;//java.sun.com/j2se/1.5.0/compatibility.html#literal&quot;&gt;article
      on Java SE compatibility&lt;/a&gt; for more details and
      examples, and suggestions on how to force class
      initialization in Java 5. &lt;/p&gt;

    </info>
    <name>Dead Store Of Class Literal</name>
  </findingType>
  <findingType>
    <id>AlwaysValueUsedWhereNeverRequired</id>
    <artifact tool="FindBugs"
	      mnemonic="TQ_ALWAYS_VALUE_USED_WHERE_NEVER_REQUIRED">
    </artifact>
    <shortMessage>
      Value annotated as carrying a type qualifier used where a
      value that must not carry that qualifier is required
    </shortMessage>
    <info>

      &lt;p&gt; A value specified as carrying a type qualifier
      annotation is consumed in a location or locations requiring
      that the value not carry that annotation. &lt;/p&gt;

      &lt;p&gt; More precisely, a value annotated with a type
      qualifier specifying when=ALWAYS is guaranteed to reach a
      use or uses where the same type qualifier specifies
      when=NEVER. &lt;/p&gt;

      &lt;p&gt; For example, say that @NonNegative is a nickname
      for the type qualifier annotation
      @Negative(when=When.NEVER). The following code will generate
      this warning because the return statement requires a
      @NonNegative value, but receives one that is marked as
      @Negative. &lt;/p&gt; &lt;blockquote&gt; &lt;pre&gt; public
      @NonNegative Integer example(@Negative Integer value) {
      return value; } &lt;/pre&gt; &lt;/blockquote&gt;

    </info>
    <name>Always Value Used Where Never Required</name>
  </findingType>
  <findingType>
    <id>NeverValueUsedWhereAlwaysRequired</id>
    <artifact tool="FindBugs"
	      mnemonic="TQ_NEVER_VALUE_USED_WHERE_ALWAYS_REQUIRED">
    </artifact>
    <shortMessage>
      Value annotated as never carrying a type qualifier used
      where value carrying that qualifier is required
    </shortMessage>
    <info>

      &lt;p&gt; A value specified as not carrying a type qualifier
      annotation is guaranteed to be consumed in a location or
      locations requiring that the value does carry that
      annotation. &lt;/p&gt;

      &lt;p&gt; More precisely, a value annotated with a type
      qualifier specifying when=NEVER is guaranteed to reach a use
      or uses where the same type qualifier specifies when=ALWAYS.
      &lt;/p&gt;

      &lt;p&gt; TODO: example &lt;/p&gt;

    </info>
    <name>Never Value Used Where Always Required</name>
  </findingType>
  <findingType>
    <id>MaybeSourceValueReachesAlwaysSink</id>
    <artifact tool="FindBugs"
	      mnemonic="TQ_MAYBE_SOURCE_VALUE_REACHES_ALWAYS_SINK">
    </artifact>
    <shortMessage>
      Value that might not carry a type qualifier reaches a use
      requiring that type qualifier
    </shortMessage>
    <info>

      &lt;p&gt; A value that might not carry a type qualifier
      annotation reaches a use which requires that annotation.
      &lt;/p&gt;

      &lt;p&gt; For example, consider the following method:
      &lt;/p&gt; &lt;blockquote&gt; &lt;pre&gt; public @Untainted
      Object mustReturnUntainted(Object unknown) { return unknown;
      } &lt;/pre&gt; &lt;/blockquote&gt; &lt;p&gt; The
      &lt;code&gt;mustReturnUntainted&lt;/code&gt; method is
      required to return a value carrying the @Untainted
      annotation, but a value not known to carry that annotation
      is returned. &lt;/p&gt;

    </info>
    <name>Maybe Source Value Reaches Always Sink</name>
  </findingType>
  <findingType>
    <id>MaybeSourceValueReachesNeverSink</id>
    <artifact tool="FindBugs"
	      mnemonic="TQ_MAYBE_SOURCE_VALUE_REACHES_NEVER_SINK">
    </artifact>
    <shortMessage>
      Unknown value reaches a use which forbids values carrying
      type qualifier annotation
    </shortMessage>
    <info>

      &lt;p&gt; A value which might carry a type qualifier
      annotation reaches a use which forbids values carrying that
      annotation. &lt;/p&gt;

      &lt;p&gt; TODO: example. &lt;/p&gt;

    </info>
    <name>Maybe Source Value Reaches Never Sink</name>
  </findingType>

  <!-- For FB 1.3.1 -->
  <findingType>
    <id>BooleanMethodReturnsNull</id>
    <artifact tool="FindBugs"
	      mnemonic="NP_BOOLEAN_RETURN_NULL">
    </artifact>
    <shortMessage>
      Method with Boolean return type returns explicit null
    </shortMessage>
    <info>

      &lt;p&gt; This method can be invoked as though it returned a value of type boolean, and
      the compiler will insert automatic unboxing of the Boolean value. If a null value is returned,
      this will result in a NullPointerException. &lt;/p&gt;

    </info>
    <name>Boolean-typed Method Returns Null</name>
  </findingType>
  <findingType>
    <id>AppendingToObjectOutputStream</id>
    <artifact tool="FindBugs"
	      mnemonic="IO_APPENDING_TO_OBJECT_OUTPUT_STREAM">
    </artifact>
    <shortMessage>
      Appending to an ObjectOutputStream
    </shortMessage>
    <info>

      &lt;p&gt; This code opens a file in append mode and that wraps the result in an object output stream. 
      This won't allow you to append to an existing object output stream stored in a file. If you want to be
      able to append to an object output stream, you need to keep the object output stream open. &lt;/p&gt;

      &lt;p&gt; The only situation in which opening a file in append mode and the writing an object output stream
      could work is if on reading the file you plan to open it in random access mode and seek to the byte offset
      where the append started. &lt;/p&gt;

    </info>
    <name>Appending To ObjectOutputStream</name>
  </findingType>
  <findingType>
    <id>FormatStringArgsMismatch</id>
    <artifact tool="FindBugs"
	      mnemonic="VA_FORMAT_STRING_ARG_MISMATCH">
    </artifact>
    <shortMessage>
      Number of format-string arguments does not correspond to number of placeholders
    </shortMessage>
    <info>

      &lt;p&gt; A format-string method with a variable number of arguments is called,
      but the number of arguments passed does not match with the number of
      % placeholders in the format string.  This is probably not what the
      author intended.. &lt;/p&gt;

    </info>
    <name>Mismatch Of Number Of Args For Format String</name>
  </findingType>
  <findingType>
    <id>InvokingToStringOnArray</id>
    <artifact tool="FindBugs"
	      mnemonic="DMI_INVOKING_TOSTRING_ON_ANONYMOUS_ARRAY">
    </artifact>
    <shortMessage>
      Invocation of toString() on an array
    </shortMessage>
    <info>

      &lt;p&gt; The code invokes toString on an array, which will generate a fairly useless result
      such as [C@16f0472. Consider using Arrays.toString to convert the array into a readable
      String that gives the contents of the array. 
      See Programming Puzzlers, chapter 3, puzzle 12. &lt;/p&gt;

    </info>
    <name>Invocation Of toString() On Array</name>
  </findingType>
  
  <!-- For FB 1.3.2 -->
  <findingType>
    <id>HttpParameterWrittenToServlet</id>
    <artifact tool="FindBugs"
	      mnemonic="XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER">
    </artifact>
    <shortMessage>
      HTTP parameter directly written to Servlet output
    </shortMessage>
    <info>

      &lt;p&gt; This code directly writes an HTTP parameter to Servlet output, which allows for a cross site scripting
      vunerability. See &lt;a href="http://en.wikipedia.org/wiki/Cross-site_scripting"&gt;http://en.wikipedia.org/wiki/Cross-site_scripting&lt;/a&gt;
      for more information. &lt;/p&gt;

    </info>
    <name>Servlet cross site scripting vulnerability</name>
  </findingType>
  <findingType>
    <id>HttpParameterWrittenToJSP</id>
    <artifact tool="FindBugs"
	      mnemonic="XSS_REQUEST_PARAMETER_TO_JSP_WRITER">
    </artifact>
    <shortMessage>
      HTTP parameter directly written to JSP output
    </shortMessage>
    <info>

      &lt;p&gt; This code directly writes an HTTP parameter to JSP output, which allows for a cross site scripting
      vunerability. See &lt;a href="http://en.wikipedia.org/wiki/Cross-site_scripting"&gt;http://en.wikipedia.org/wiki/Cross-site_scripting&lt;/a&gt;
      for more information. &lt;/p&gt;

    </info>
    <name>JSP cross site scripting vulnerability</name>
  </findingType>
  <findingType>
    <id>EqualsDoesntOverride</id>
    <artifact tool="FindBugs"
	      mnemonic="EQ_OTHER_USE_OBJECT">
    </artifact>
    <shortMessage>
      equals() method defined that doesn't override Object.equals(Object)
    </shortMessage>
    <info>

      &lt;p&gt; This class defines an &lt;code&gt;equals()&lt;/code&gt;
      method, that doesn't override the normal &lt;code&gt;equals(Object)&lt;/code&gt; method
      defined in the base &lt;code&gt;java.lang.Object&lt;/code&gt; class.
      The class should probably define a &lt;code&gt;boolean equals(Object)&lt;/code&gt; 
      method. &lt;/p&gt;

    </info>
    <name>equals() doesn't override Object.equals(Object)</name>
  </findingType>
  <findingType>
    <id>EqualsDoesntOverrideInherited</id>
    <artifact tool="FindBugs"
	      mnemonic="EQ_OTHER_NO_OBJECT">
    </artifact>
    <shortMessage>
      equals() method defined that doesn't override inherited equals(Object)
    </shortMessage>
    <info>

      &lt;p&gt; This class defines an &lt;code&gt;equals()&lt;/code&gt;
      method, that doesn't override the normal &lt;code&gt;equals(Object)&lt;/code&gt; method
      defined in the base &lt;code&gt;java.lang.Object&lt;/code&gt; class.
      Instead, it inherits an &lt;code&gt;equals(Object)&lt;/code&gt; method from a superclass.
      The class should probably define a &lt;code&gt;boolean equals(Object)&lt;/code&gt; 
      method. &lt;/p&gt;

    </info>
    <name>equals() doesn't override inherited equals(Object)</name>
  </findingType>
  <findingType>
    <id>NP_NULL_ON_SOME_PATH_MIGHT_BE_INFEASIBLE</id>
    <artifact tool="FindBugs"
	      mnemonic="NP_NULL_ON_SOME_PATH_MIGHT_BE_INFEASIBLE">
    </artifact>
    <shortMessage>
      Possible null pointer dereference on path that might be infeasible
    </shortMessage>
    <info>

      &lt;p&gt; This class defines an &lt;code&gt;equals()&lt;/code&gt;
      method, that doesn't override the normal &lt;code&gt;equals(Object)&lt;/code&gt; method
      defined in the base &lt;code&gt;java.lang.Object&lt;/code&gt; class.
      Instead, it inherits an &lt;code&gt;equals(Object)&lt;/code&gt; method from a superclass.
      The class should probably define a &lt;code&gt;boolean equals(Object)&lt;/code&gt; 
      method. &lt;/p&gt;

    </info>
    <name>Possible null dereference on potentially infeasible path</name>
  </findingType>	

  <!-- For FB 1.3.3 -->
  <findingType>
    <id>HRS_REQUEST_PARAMETER_TO_HTTP_HEADER</id>
    <artifact tool="FindBugs"
	      mnemonic="HRS_REQUEST_PARAMETER_TO_HTTP_HEADER">
    </artifact>
    <shortMessage>
      HTTP parameter directly written to HTTP header output
    </shortMessage>
    <info>
      &lt;p&gt; This code directly writes an HTTP parameter to an HTTP header, 
      which allows for a HTTP response splitting vulnerability. 
      See &lt;a href="http://en.wikipedia.org/wiki/HTTP_response_splitting"&gt;
      http://en.wikipedia.org/wiki/HTTP_response_splitting&lt;/a&gt;
      for more information.&lt;/p&gt;
    </info>
    <name>HTTP Response splitting vulnerability</name>
  </findingType>
  <findingType>
    <id>HRS_REQUEST_PARAMETER_TO_COOKIE</id>
    <artifact tool="FindBugs"
	      mnemonic="HRS_REQUEST_PARAMETER_TO_COOKIE">
    </artifact>
    <shortMessage>
      HTTP cookie formed from untrusted input
    </shortMessage>
    <info>
      &lt;p&gt; 
      This code constructs an HTTP Cookie using an untrusted HTTP parameter. 
      If this cookie is added to an HTTP response, 
      it will allow a HTTP response splitting vulnerability. 
      See &lt;a href="http://en.wikipedia.org/wiki/HTTP_response_splitting"&gt;
      http://en.wikipedia.org/wiki/HTTP_response_splitting&lt;/a&gt;
      for more information.
      &lt;/p&gt;
    </info>
    <name>HTTP cookie formed from untrusted input</name>
  </findingType>
  <findingType>
    <id>CN_IMPLEMENTS_CLONE_BUT_NOT_CLONEABLE</id>
    <artifact tool="FindBugs"
	      mnemonic="CN_IMPLEMENTS_CLONE_BUT_NOT_CLONEABLE">
    </artifact>
    <shortMessage>
      Class defines clone() but doesn't implement Cloneable
    </shortMessage>
    <info>
      &lt;p&gt; 
      This class defines a clone() method but the class doesn't implement Cloneable.
      There are some situations in which this is OK (e.g., you want to control how subclasses 
      can clone themselves), but just make sure that this is what you intended.
      &lt;/p&gt;
    </info>
    <name>Class defines clone() but doesn't implement Cloneable</name>
  </findingType>	
  <findingType>
    <id>DMI_CONSTANT_DB_PASSWORD</id>
    <artifact tool="FindBugs"
	      mnemonic="DMI_CONSTANT_DB_PASSWORD">
    </artifact>
    <shortMessage>
      Hardcoded constant database password
    </shortMessage>
    <info>
      &lt;p&gt; 
      This code creates a database connect using a hardcoded, 
      constant password. Anyone with access to either the source code
      or the compiled code can easily learn the password.
      &lt;/p&gt;
    </info>
    <name>Hardcoded constant database password</name>
  </findingType>
  <findingType>
    <id>DMI_EMPTY_DB_PASSWORD</id>
    <artifact tool="FindBugs"
	      mnemonic="DMI_EMPTY_DB_PASSWORD">
    </artifact>
    <shortMessage>
      Empty database password
    </shortMessage>
    <info>
      &lt;p&gt; 
      This code creates a database connect using a blank or empty password. 
      This indicates that the database is not protected by a password. 
      &lt;/p&gt;
    </info>
    <name>Empty database password</name>
  </findingType>
  <findingType>
    <id>DL_SYNCHRONIZATION_ON_BOOLEAN</id>
    <artifact tool="FindBugs"
	      mnemonic="DL_SYNCHRONIZATION_ON_BOOLEAN">
    </artifact>
    <shortMessage>
      Synchronization on Boolean could lead to deadlock
    </shortMessage>
    <info>
      &lt;p&gt; The code synchronizes on a boxed primitive constant, such as an Boolean.
      &lt;pre&gt;
      private static Boolean inited = Boolean.FALSE;
      ...
      synchronized(inited) { 
      if (!inited) {
      init();
      inited = BOOLEAN.TRUE;
      }
      }
      ...
      &lt;/pre&gt;
      &lt;/p&gt;
      &lt;p&gt; Since there normally exist only two Boolean objects, 
      this code could be synchronizing on the same object as other, unrelated code, 
      leading to unresponsiveness and possible deadlock &lt;/p&gt;			
    </info>
    <name>Synchronization on Boolean could lead to deadlock</name>
  </findingType>	
  <findingType>
    <id>DL_SYNCHRONIZATION_ON_BOXED_PRIMITIVE</id>
    <artifact tool="FindBugs"
	      mnemonic="DL_SYNCHRONIZATION_ON_BOXED_PRIMITIVE">
    </artifact>
    <shortMessage>
      Synchronization on boxed primitive value could lead to deadlock
    </shortMessage>
    <info>
      &lt;p&gt;
      The code synchronizes on a boxed primitive constant, such as an Integer.
      &lt;pre&gt;
      private static Integer count = 0;
      ...
      synchronized(count) { 
      count++;
      }
      ...
      &lt;/pre&gt;
      &lt;/p&gt;
      &lt;p&gt;Since Integer objects can be cached and shared,
      this code could be synchronizing on the same object as other, unrelated code, leading to unresponsiveness
      and possible deadlock 
      &lt;/p&gt;
    </info>
    <name>Synchronization on boxed primitive value could lead to deadlock</name>
  </findingType>
  <findingType>
    <id>DL_SYNCHRONIZATION_ON_UNSHARED_BOXED_PRIMITIVE</id>
    <artifact tool="FindBugs"
	      mnemonic="DL_SYNCHRONIZATION_ON_UNSHARED_BOXED_PRIMITIVE">
    </artifact>
    <shortMessage>
      Synchronization on boxed primitive values
    </shortMessage>
    <info>
      &lt;p&gt; 
      The code synchronizes on an apparently unshared boxed primitive, 
      such as an Integer.
      &lt;pre&gt;
      private static final Integer fileLock = new Integer(1);
      ...
      synchronized(fileLock) { 
      .. do something ..
      }
      ...
      &lt;/pre&gt;
      &lt;/p&gt;
      &lt;p&gt;It would be much better, in this code, to redeclare fileLock as
      &lt;pre&gt;
      private static final Object fileLock = new Object();
      &lt;/pre&gt;
      The existing code might be OK, but it is confusing and a 
      future refactoring, such as the "Remove Boxing" refactoring in IntelliJ,
      might replace this with the use of an intern'd Integer object shared 
      throughout the JVM, leading to very confusing behavior and potential deadlock.
      &lt;/p&gt;
    </info>
    <name>Synchronization on boxed primitive values</name>
  </findingType>
  <findingType>
    <id>WL_USING_GETCLASS_RATHER_THAN_CLASS_LITERAL</id>
    <artifact tool="FindBugs"
	      mnemonic="WL_USING_GETCLASS_RATHER_THAN_CLASS_LITERAL">
    </artifact>
    <shortMessage>
      Synchronization on getClass rather than class literal
    </shortMessage>
    <info>
      &lt;p&gt; 
      This instance method synchronizes on &lt;code&gt;this.getClass()&lt;/code&gt;. 
      If this class is subclassed,
      subclasses will synchronize on the class object for the subclass, 
      which isn't likely what was intended.
      For example, consider this code from &lt;code&gt;java.awt.Label&lt;/code&gt;:
      &lt;pre&gt;
      private static final String base = "label";
      private static int nameCounter = 0;
      String constructComponentName() {
      synchronized (getClass()) {
      return base + nameCounter++;
      }
      }
      &lt;/pre&gt;&lt;/p&gt;
      &lt;p&gt;Subclasses of &lt;code&gt;Label&lt;/code&gt; won't synchronize on the same subclass, 
      giving rise to a data race.
      Instead, this code should be synchronizing on &lt;code&gt;Label.class&lt;/code&gt;
      &lt;pre&gt;
      private static final String base = "label";
      private static int nameCounter = 0;
      String constructComponentName() {
      synchronized (Label.class) {
      return base + nameCounter++;
      }
      }
      &lt;/pre&gt;&lt;/p&gt;
      &lt;p&gt;Bug pattern contributed by Jason Mehrens
      &lt;/p&gt;
    </info>
    <name>Synchronization on getClass rather than class literal</name>
  </findingType>	
  <findingType>
    <id>ML_SYNC_ON_FIELD_TO_GUARD_CHANGING_THAT_FIELD</id>
    <artifact tool="FindBugs"
	      mnemonic="ML_SYNC_ON_FIELD_TO_GUARD_CHANGING_THAT_FIELD">
    </artifact>
    <shortMessage>
      Synchronization on field in futile attempt to guard that field
    </shortMessage>
    <info>
      &lt;p&gt; 
      This method synchronizes on a field in what appears to be an attempt
      to guard against simultaneous updates to that field. But guarding a field
      gets a lock on the referenced object, not on the field. This may not 
      provide the mutual exclusion you need, and other threads might 
      be obtaining locks on the referenced objects (for other purposes). An example
      of this pattern would be:

      &lt;p&gt;&lt;pre&gt;
      private Long myNtfSeqNbrCounter = new Long(0);
      private Long getNotificationSequenceNumber() {
      Long result = null;
      synchronized(myNtfSeqNbrCounter) {
      result = new Long(myNtfSeqNbrCounter.longValue() + 1);
      myNtfSeqNbrCounter = new Long(result.longValue());
      }
      return result;
      }
      &lt;/pre&gt;
      &lt;/p&gt;
    </info>
    <name>Synchronization on field in futile attempt to guard that field</name>
  </findingType>
  <findingType>
    <id>DLS_DEAD_LOCAL_STORE_IN_RETURN</id>
    <artifact tool="FindBugs"
	      mnemonic="DLS_DEAD_LOCAL_STORE_IN_RETURN">
    </artifact>
    <shortMessage>
      Useless assignment in return statement
    </shortMessage>
    <info>
      &lt;p&gt; 
      This statement assigns to a local variable in a return statement. 
      This assignment has no lasting effect. 
      Please verify that this statement does the right thing.
      &lt;/p&gt;
    </info>
    <name>Useless assignment in return statement</name>
  </findingType>

  <!-- For FB 1.3.4 -->
  <findingType>
    <id>XSS_REQUEST_PARAMETER_TO_SEND_ERROR</id>
    <artifact tool="FindBugs"
	      mnemonic="XSS_REQUEST_PARAMETER_TO_SEND_ERROR">
    </artifact>
    <shortMessage>
      Servlet reflected cross site scripting vulnerability
    </shortMessage>
    <info>
      &lt;p&gt; 
      This code directly writes an HTTP parameter to a Server error page 
      (using HttpServletResponse.sendError). Echoing this untrusted input allows
      for a reflected cross site scripting vulnerability. 
      See &lt;a href="http://en.wikipedia.org/wiki/Cross-site_scripting"&gt;
      http://en.wikipedia.org/wiki/Cross-site_scripting&lt;/a&gt;
      for more information.&lt;/p&gt;
      &lt;p&gt;FindBugs looks only for the most blatent, obvious cases of cross site scripting.
    </info>
    <name>Servlet reflected cross site scripting vulnerability</name>
  </findingType>
  <findingType>
    <id>SKIPPED_CLASS_TOO_BIG</id>
    <artifact tool="FindBugs"
	      mnemonic="SKIPPED_CLASS_TOO_BIG">
    </artifact>
    <shortMessage>
      Class too big for analysis
    </shortMessage>
    <info>
      &lt;p&gt; 
      This class is bigger than can be effectively handled, and was not fully analyzed for errors.
      &lt;/p&gt;
    </info>
    <name>Class too big for analysis</name>
  </findingType>
  <findingType>
    <id>EQ_COMPARING_CLASS_NAMES</id>
    <artifact tool="FindBugs"
	      mnemonic="EQ_COMPARING_CLASS_NAMES">
    </artifact>
    <shortMessage>
      equals() compares class names rather than class objects
    </shortMessage>
    <info>
      &lt;p&gt; 
      This method checks to see if two objects are the same class by checking to see if the names
      of their classes are equal. You can have different classes with the same name if they are loaded by
      different class loaders. Just check to see if the class objects are the same.
      &lt;/p&gt;
    </info>
    <name>Comparing Class Names</name>
  </findingType>
  <findingType>
    <id>EQ_UNUSUAL</id>
    <artifact tool="FindBugs"
	      mnemonic="EQ_UNUSUAL">
    </artifact>
    <shortMessage>
      Unusual equals() method
    </shortMessage>
    <info>
      &lt;p&gt; 
      This class doesn't do any of the patterns we recognize for checking that the type of the argument 
      is compatible with the type of the &lt;code&gt;this&lt;/code&gt; object. There might not be anything wrong with
      this code, but it is worth reviewing
      &lt;/p&gt;
    </info>
    <name>Unusual equals() method</name>
  </findingType>
  <findingType>
    <id>EQ_GETCLASS_AND_CLASS_CONSTANT</id>
    <artifact tool="FindBugs"
	      mnemonic="EQ_GETCLASS_AND_CLASS_CONSTANT">
    </artifact>
    <shortMessage>
      equals() method fails for subtypes
    </shortMessage>
    <info>
      &lt;p&gt; 
      This class has an equals method that will be broken if it is inherited by subclasses.
      It compares a class literal with the class of the argument (e.g., in class &lt;code&gt;Foo&lt;/code&gt;
      it might check if &lt;code&gt;Foo.class == o.getClass()&lt;/code&gt;).
      It is better to check  if  &lt;code&gt;this.getClass() == o.getClass()&lt;/code&gt;.
      &lt;/p&gt;
    </info>
    <name>equals() fails for subtypes</name>
  </findingType>
  <findingType>
    <id>EQ_ALWAYS_TRUE</id>
    <artifact tool="FindBugs"
	      mnemonic="EQ_ALWAYS_TRUE">
    </artifact>
    <shortMessage>
      equals() method always returns true
    </shortMessage>
    <info>
      &lt;p&gt; 
      This class defines an equals method that always returns true. This is imaginative, but not very smart.
      Plus, it means that the equals method is not symmetric.
      &lt;/p&gt;
    </info>
    <name>equals() always returns true</name>
  </findingType>
  <findingType>
    <id>EQ_ALWAYS_FALSE</id>
    <artifact tool="FindBugs"
	      mnemonic="EQ_ALWAYS_FALSE">
    </artifact>
    <shortMessage>
      equals() method always returns false
    </shortMessage>
    <info>
      &lt;p&gt; 
      This class defines an equals method that always returns false. 
      This means that an object is not equal to itself, and it is impossible to 
      create useful Maps or Sets of this class. More fundamentally, it means
      that equals() is not reflexive, one of the requirements of the equals method.&lt;/p&gt;
      &lt;p&gt;The likely intended semantics are object identity: that an object is equal to itself. 
      This is the behavior inherited from class &lt;code&gt;Object&lt;/code&gt;. If you need to override an 
      equals inherited from a different superclass, you can use:
      &lt;pre&gt;
      public boolean equals(Object o) { return this == o; }
      &lt;/pre&gt;
      &lt;/p&gt;
    </info>
    <name>equals() always returns false</name>
  </findingType>
  <findingType>
    <id>MSF_MUTABLE_SERVLET_FIELD</id>
    <artifact tool="FindBugs"
	      mnemonic="MSF_MUTABLE_SERVLET_FIELD">
    </artifact>
    <shortMessage>
      Mutable servlet field
    </shortMessage>
    <info>
      &lt;p&gt; 
      A web server generally only creates one instance of servlet or jsp class (i.e., treats
      the class as a Singleton), and will have multiple threads invoke methods on that instance to
      service multiple simultaneous requests.
      Thus, having a mutable instance field generally creates race conditions.
      &lt;/p&gt;
    </info>
    <name>Mutable servlet field</name>
  </findingType>
  <findingType>
    <id>SE_READ_RESOLVE_IS_STATIC</id>
    <artifact tool="FindBugs"
	      mnemonic="SE_READ_RESOLVE_IS_STATIC">
    </artifact>
    <shortMessage>
      readResolve() must not be declared as a static method.
    </shortMessage>
    <info>
      &lt;p&gt; 
      In order for the readResolve method to be recognized by the serialization
      mechanism, it must not be declared as a static method.
      &lt;/p&gt;
    </info>
    <name>Static readResolve() method</name>
  </findingType>
  <findingType>
    <id>SE_PRIVATE_READ_RESOLVE_NOT_INHERITED</id>
    <artifact tool="FindBugs"
	      mnemonic="SE_PRIVATE_READ_RESOLVE_NOT_INHERITED">
    </artifact>
    <shortMessage>
      private readResolve() not inherited by subclasses
    </shortMessage>
    <info>
      &lt;p&gt; 
      This class defines a private readResolve method. Since it is private, 
      it won't be inherited by subclasses.  This might be intentional and OK, 
      but should be reviewed to ensure it is what is intended.
      &lt;/p&gt;
    </info>
    <name>Private readResolve() not inherited</name>
  </findingType>
  <findingType>
    <id>RpC_REPEATED_CONDITIONAL_TEST</id>
    <artifact tool="FindBugs"	mnemonic="RpC_REPEATED_CONDITIONAL_TEST"/>
    <shortMessage>Repeated conditional tests</shortMessage>
    <info>
      <![CDATA[

<p>The code contains a conditional test is performed twice, one right after the other
(e.g., <code>x == 0 || x == 0</code>). Perhaps the second occurrence is intended to be something else
(e.g., <code>x == 0 || y == 0</code>). 
</p>

]]>
    </info>
    <name>Repeated conditional tests</name>
  </findingType>
  <findingType>
    <id>DMI_FUTILE_ATTEMPT_TO_CHANGE_MAXPOOL_SIZE_OF_SCHEDULED_THREAD_POOL_EXECUTOR</id>
    <artifact tool="FindBugs"	mnemonic="DMI_FUTILE_ATTEMPT_TO_CHANGE_MAXPOOL_SIZE_OF_SCHEDULED_THREAD_POOL_EXECUTOR"/>
    <shortMessage>Futile attempt to change max pool size of ScheduledThreadPoolExecutor</shortMessage>
    <info>
      <![CDATA[
	       
	       <p>(<a href="http://java.sun.com/javase/6/docs/api/java/util/concurrent/ScheduledThreadPoolExecutor.html">Javadoc</a>)
	       While ScheduledThreadPoolExecutor inherits from ThreadPoolExecutor, a few of the inherited tuning methods are not useful for it. In particular, because it acts as a fixed-sized pool using corePoolSize threads and an unbounded queue, adjustments to maximumPoolSize have no useful effect.
	       </p>


      ]]>
    </info>
    <name>Futile attempt to change max pool size of ScheduledThreadPoolExecutor</name>
  </findingType>
  <findingType>
    <id>DMI_SCHEDULED_THREAD_POOL_EXECUTOR_WITH_ZERO_CORE_THREADS</id>
    <artifact tool="FindBugs"	mnemonic="DMI_SCHEDULED_THREAD_POOL_EXECUTOR_WITH_ZERO_CORE_THREADS"/>
    <shortMessage>Creation of ScheduledThreadPoolExecutor with zero core threads</shortMessage>
    <info>
      <![CDATA[
	       
	       <p>(<a href="http://java.sun.com/javase/6/docs/api/java/util/concurrent/ScheduledThreadPoolExecutor.html#ScheduledThreadPoolExecutor(int)">Javadoc</a>)
	       A ScheduledThreadPoolExecutor with zero core threads will never execute anything; changes to the max pool size are ignored.
	       </p>


      ]]>
    </info>
    <name>Creation of ScheduledThreadPoolExecutor with zero core threads</name>
  </findingType>
  <findingType>
    <id>DMI_UNSUPPORTED_METHOD</id>
    <artifact tool="FindBugs"	mnemonic="DMI_UNSUPPORTED_METHOD"/>
    <shortMessage>Call to unsupported method</shortMessage>
    <info>
      <![CDATA[
	       
	       <p>All targets of this method invocation throw an UnsupportedOperationException.
	       </p>


      ]]>
    </info>
    <name>Call to unsupported method</name>
  </findingType>
  <findingType>
    <id>NP_DEREFERENCE_OF_READLINE_VALUE</id>
    <artifact tool="FindBugs"	mnemonic="NP_DEREFERENCE_OF_READLINE_VALUE"/>
    <shortMessage>Dereference of the result of readLine() without nullcheck</shortMessage>
    <info>
      <![CDATA[

<p> The result of invoking readLine() is dereferenced without checking to see if the result is null. If there are no more lines of text
to read, readLine() will return null and dereferencing that will generate a null pointer exception.
</p>

      ]]>
    </info>
    <name>Dereference of the result of readLine() without nullcheck</name>
  </findingType>
  <findingType>
    <id>EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS</id>
    <artifact tool="FindBugs"	mnemonic="EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS"/>
    <shortMessage>Equals checks for noncompatible operand</shortMessage>
    <info>
      <![CDATA[

<p> This equals method is checking to see if the argument is some incompatible type
(i.e., a class that is neither a supertype nor subtype of the class that defines
the equals method). For example, the Foo class might have an equals method
that looks like:

<p><code><pre>
public boolean equals(Object o) {
if (o instanceof Foo)
return name.equals(((Foo)o).name);
else if (o instanceof String)
return name.equals(o);
else return false;
</pre></code></p>

<p>This is considered bad practice, as it makes it very hard to implement an equals method that
is symmetric and transitive. Without those properties, very unexpected behavoirs are possible.
</p>

      ]]>
    </info>
    <name>Equals checks for noncompatible operand</name>
  </findingType>
  <findingType>
    <id>NP_PARAMETER_MUST_BE_NONNULL_BUT_MARKED_AS_NULLABLE</id>
    <artifact tool="FindBugs"	mnemonic="NP_PARAMETER_MUST_BE_NONNULL_BUT_MARKED_AS_NULLABLE"/>
    <shortMessage>Parameter must be nonnull but is marked as nullable</shortMessage>
    <info>
      <![CDATA[

<p> This parameter is always used in a way that requires it to be nonnull,
but the parameter is explicitly annotated as being Nullable. Either the use
of the parameter or the annotation is wrong.
</p>

      ]]>
    </info>
    <name>Parameter must be nonnull but is marked as nullable</name>
  </findingType>
  <findingType>
    <id>VA_FORMAT_STRING_BAD_CONVERSION</id>
    <artifact tool="FindBugs"	mnemonic="VA_FORMAT_STRING_BAD_CONVERSION"/>
    <shortMessage>The type of a supplied argument doesn't match format specifier</shortMessage>
    <info>
      <![CDATA[

<p>
One of the arguments is uncompatible with the corresponding format string specifier.
As a result, this will generate a runtime exception when executed.
For example, <code>String.format("%d", "1")</code> will generate an exception, since
the String "1" is incompatible with the format specifier %d.
</p>

      ]]>
    </info>
    <name>The type of a supplied argument doesn't match format specifier</name>
  </findingType>
  <findingType>
    <id>VA_FORMAT_STRING_BAD_CONVERSION_TO_BOOLEAN</id>
    <artifact tool="FindBugs"	mnemonic="VA_FORMAT_STRING_BAD_CONVERSION_TO_BOOLEAN"/>
    <shortMessage>Non-Boolean argument formatted using %b format specifier</shortMessage>
    <info>
      <![CDATA[

<p>
An argument not of type Boolean is being formatted with a %b format specifier. This won't throw an
exception; instead, it will print true for any nonnull value, and false for null.
This feature of format strings is strange, and may not be what you intended.
</p>

      ]]>
    </info>
    <name>Non-Boolean argument formatted using %b format specifier</name>
  </findingType>
  <findingType>
    <id>VA_FORMAT_STRING_BAD_CONVERSION_FROM_ARRAY</id>
    <artifact tool="FindBugs"	mnemonic="VA_FORMAT_STRING_BAD_CONVERSION_FROM_ARRAY"/>
    <shortMessage>Array formatted in useless way using format string</shortMessage>
    <info>
      <![CDATA[

<p>
One of the arguments being formatted with a format string is an array. This will be formatted
using a fairly useless format, such as [I@304282, which doesn't actually show the contents
of the array.
Consider wrapping the array using <code>Arrays.asList(...)</code> before handling it off to a formatted.
</p>

      ]]>
    </info>
    <name>Array formatted in useless way using format string</name>
  </findingType>
  <findingType>
    <id>VA_FORMAT_STRING_NO_PREVIOUS_ARGUMENT</id>
    <artifact tool="FindBugs"	mnemonic="VA_FORMAT_STRING_NO_PREVIOUS_ARGUMENT"/>
    <shortMessage>No previous argument for format string</shortMessage>
    <info>
      <![CDATA[

<p>
The format string specifies a relative index to request that the argument for the previous format specifier
be reused. However, there is no previous argument.
For example, 
</p>
<p><code>formatter.format("%&lt;s %s", "a", "b")</code>
</p>
<p>would throw a MissingFormatArgumentException when executed.
</p>

      ]]>
    </info>
    <name>No previous argument for format string</name>
  </findingType>
  <findingType>
    <id>VA_FORMAT_STRING_BAD_ARGUMENT</id>
    <artifact tool="FindBugs"	mnemonic="VA_FORMAT_STRING_BAD_ARGUMENT"/>
    <shortMessage>Format string placeholder incompatible with passed argument</shortMessage>
    <info>
      <![CDATA[

<p>
The format string placeholder is incompatible with the corresponding
argument. For example,
<code>
System.out.println("%d\n", "hello");
</code>
<p>The %d placeholder requires a numeric argument, but a string value is
passed instead. 
A runtime exception will occur when 
this statement is executed.
</p>

      ]]>
    </info>
    <name>Format string placeholder incompatible with passed argument</name>
  </findingType>
  <findingType>
    <id>VA_FORMAT_STRING_MISSING_ARGUMENT</id>
    <artifact tool="FindBugs"	mnemonic="VA_FORMAT_STRING_MISSING_ARGUMENT"/>
    <shortMessage>Format string references missing argument</shortMessage>
    <info>
      <![CDATA[

<p>
Not enough arguments are passed to satisfy a placeholder in the format string.
A runtime exception will occur when 
this statement is executed.
</p>

      ]]>
    </info>
    <name>Format string references missing argument</name>
  </findingType>
  <findingType>
    <id>VA_FORMAT_STRING_ILLEGAL</id>
    <artifact tool="FindBugs"	mnemonic="VA_FORMAT_STRING_ILLEGAL"/>
    <shortMessage>Illegal format string</shortMessage>
    <info>
      <![CDATA[

<p>
The format string is syntactically invalid, 
and a runtime exception will occur when 
this statement is executed.
</p>

      ]]>
    </info>
    <name>Illegal format string</name>
  </findingType>
  <findingType>
    <id>VA_FORMAT_STRING_EXTRA_ARGUMENTS_PASSED</id>
    <artifact tool="FindBugs"	mnemonic="VA_FORMAT_STRING_EXTRA_ARGUMENTS_PASSED"/>
    <shortMessage>More arguments are passed that are actually used in the format string</shortMessage>
    <info>
      <![CDATA[

<p>
A format-string method with a variable number of arguments is called,
but more arguments are passed than are actually used by the format string.
This won't cause a runtime exception, but the code may be silently omitting 
information that was intended to be included in the formatted string.
</p>

      ]]>
    </info>
    <name>More arguments are passed that are actually used in the format string</name>
  </findingType>
  <findingType>
    <id>BIT_ADD_OF_SIGNED_BYTE</id>
    <artifact tool="FindBugs"	mnemonic="BIT_ADD_OF_SIGNED_BYTE"/>
    <shortMessage>Bitwise add of signed byte value</shortMessage>
    <info>
      <![CDATA[

<p> Adds a byte value and a value which is known to the 8 lower bits clear.
Values loaded from a byte array are sign extended to 32 bits
before any any bitwise operations are performed on the value.
Thus, if <code>b[0]</code> contains the value <code>0xff</code>, and
<code>x</code> is initially 0, then the code 
<code>((x &lt;&lt; 8) + b[0])</code>  will sign extend <code>0xff</code>
to get <code>0xffffffff</code>, and thus give the value
<code>0xffffffff</code> as the result.
</p>

<p>In particular, the following code for packing a byte array into an int is badly wrong: </p>
<pre>
int result = 0;
for(int i = 0; i &lt; 4; i++) 
result = ((result &lt;&lt; 8) + b[i]);
</pre>

<p>The following idiom will work instead: </p>
<pre>
int result = 0;
for(int i = 0; i &lt; 4; i++) 
result = ((result &lt;&lt; 8) + (b[i] &amp; 0xff));
</pre>


      ]]>
    </info>
    <name>Bitwise add of signed byte value</name>
  </findingType>
  <findingType>
    <id>DMI_INVOKING_HASHCODE_ON_ARRAY</id>
    <artifact tool="FindBugs"	mnemonic="DMI_INVOKING_HASHCODE_ON_ARRAY"/>
    <shortMessage>Invocation of hashCode on an array</shortMessage>
    <info>
      <![CDATA[

<p>
The code invokes hashCode on an array. Calling hashCode on
an array returns the same value as System.identityHashCode, and ingores
the contents and length of the array. If you need a hashCode that
depends on the contents of an array <code>a</code>, 
use <code>java.util.Arrays.hashCode(a)</code>.

</p>

      ]]>
    </info>
    <name>Invocation of hashCode on an array</name>
  </findingType>
  <findingType>
    <id>DMI_USING_REMOVEALL_TO_CLEAR_COLLECTION</id>
    <artifact tool="FindBugs"	mnemonic="DMI_USING_REMOVEALL_TO_CLEAR_COLLECTION"/>
    <shortMessage>Don't use removeAll to clear a collection</shortMessage>
    <info>
      <![CDATA[
	       
	       <p> If you want to remove all elements from a collection <code>c</code>, use <code>c.clear</code>,
	       not <code>c.removeAll(c)</code>.
	       </p>
	       
      ]]>
    </info>
    <name>Don't use removeAll to clear a collection</name>
  </findingType>
  <findingType>
    <id>DMI_VACUOUS_SELF_COLLECTION_CALL</id>
    <artifact tool="FindBugs"	mnemonic="DMI_VACUOUS_SELF_COLLECTION_CALL"/>
    <shortMessage>Vacuous call to collections</shortMessage>
    <info>
      <![CDATA[
	       
	       <p> This call doesn't make sense. For any collection <code>c</code>, calling <code>c.containsAll(c)</code> should
	       always be true, and <code>c.retainAll(c)</code> should have no effect.
	       </p>
	       
      ]]>
    </info>
    <name>Vacuous call to collections</name>
  </findingType>
  <findingType>
    <id>DMI_COLLECTIONS_SHOULD_NOT_CONTAIN_THEMSELVES</id>
    <artifact tool="FindBugs"	mnemonic="DMI_COLLECTIONS_SHOULD_NOT_CONTAIN_THEMSELVES"/>
    <shortMessage>Collections should not contain themselves</shortMessage>
    <info>
      <![CDATA[
	       
	       <p> This call to a generic collection's method would only make sense if a collection contained 
	       itself (e.g., if <code>s.contains(s)</code> were true). This is unlikely to be true and would cause
	       problems if it were true (such as the computation of the hash code resulting in infinite recursion).
	       It is likely that the wrong value is being passed as a parameter.
	       </p>
	       
      ]]>
    </info>
    <name>Collections should not contain themselves</name>
  </findingType>
  <findingType>
    <id>TQ_EXPLICIT_UNKNOWN_SOURCE_VALUE_REACHES_NEVER_SINK</id>
    <artifact tool="FindBugs"	mnemonic="TQ_EXPLICIT_UNKNOWN_SOURCE_VALUE_REACHES_NEVER_SINK"/>
    <shortMessage>Explicit annotation inconsistent with use</shortMessage>
    <info>
      <![CDATA[
	       
	       <p>
	       A value is used in a way that requires it to be never be a value denoted by a type qualifier, but
	       there is an explicit annotation stating that it is not known where the value is prohibited from having that type qualifier.
	       Either the usage or the annotation is incorrect.
	       </p>
	       
      ]]>
    </info>
    <name>Explicit annotation inconsistent with use</name>
  </findingType>
  <findingType>
    <id>TQ_EXPLICIT_UNKNOWN_SOURCE_VALUE_REACHES_ALWAYS_SINK</id>
    <artifact tool="FindBugs"	mnemonic="TQ_EXPLICIT_UNKNOWN_SOURCE_VALUE_REACHES_ALWAYS_SINK"/>
    <shortMessage>Explicit annotation inconsistent with use</shortMessage>
    <info>
      <![CDATA[
	       
	       <p>
	       A value is used in a way that requires it to be always be a value denoted by a type qualifier, but
	       there is an explicit annotation stating that it is not known where the value is required to have that type qualifier.
	       Either the usage or the annotation is incorrect.
	       </p>
	       
      ]]>
    </info>
    <name>Explicit annotation inconsistent with use</name>
  </findingType>
  <findingType>
    <id>OBL_UNSATISFIED_OBLIGATION</id>
    <artifact tool="FindBugs"	mnemonic="OBL_UNSATISFIED_OBLIGATION"/>
    <shortMessage>Method may fail to clean up stream or resource</shortMessage>
    <info>
      <![CDATA[
	       
	       <p>
	       This method may fail to clean up (close, dispose of) a stream,
	       database object, or other
	       resource requiring an explicit cleanup operation.
	       </p>
	       
	       <p>
	       In general, if a method opens a stream or other resource,
	       the method should use a try/finally block to ensure that
	       the stream or resource is cleaned up before the method
	       returns.
	       </p>
	       
	       <p>
	       This bug pattern is essentially the same as the
	       OS_OPEN_STREAM and ODR_OPEN_DATABASE_RESOURCE
	       bug patterns, but is based on a different
	       (and hopefully better) static analysis technique.
	       We are interested is getting feedback about the
	       usefulness of this bug pattern.
	       To send feedback, either:
	       </p>
	       <ul>
	       <li>send email to findbugs@cs.umd.edu</li>
	       <li>file a bug report: <a href="http://findbugs.sourceforge.net/reportingBugs.html">http://findbugs.sourceforge.net/reportingBugs.html</a></li>
	       </ul>
	       
	       <p>
	       In particular,
	       the false-positive suppression heuristics for this
	       bug pattern have not been extensively tuned, so
	       reports about false positives are helpful to us.
	       </p>
	       
	       <p>
	       See Weimer and Necula, <i>Finding and Preventing Run-Time Error Handling Mistakes</i>, for
	       a description of the analysis technique.
	       </p>
	       
      ]]>
    </info>
    <name>Method may fail to clean up stream or resource</name>
  </findingType>
  <findingType>
    <id>JSure</id>
    <artifact tool="JSure"
	      mnemonic="JSure">
    </artifact>
    <shortMessage>
      TBD
    </shortMessage>
    <info>
      TBD
    </info>
    <name>JSure Issue</name>
  </findingType>
  <findingType>
    <id>ColorSecondPass_inferredColor</id> 
    <artifact tool="JSure" mnemonic="ColorSecondPass_inferredColor"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Inferred Color</name>
  </findingType>
  <findingType>
    <id>ColorSecondPass_inheritedColor</id> 
    <artifact tool="JSure"
	      mnemonic="ColorSecondPass_inheritedColor"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Inherited Color</name>
  </findingType>
  <findingType>
    <id>ColorSecondPass_inheritedTransparent</id> 
    <artifact tool="JSure"
	      mnemonic="ColorSecondPass_inheritedTransparent"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Inherited as Transparent</name>
  </findingType>
  <findingType>
    <id>ColorSecondPass_colorContextDrop</id>
    <artifact tool="JSure"
	      mnemonic="ColorSecondPass_colorContextDrop"/>
    <shortMessage>Establishes a constraint on the colors of threads that may execute the
    annotated method.</shortMessage>
    <info><![CDATA[
    Establishes a constraint on the colors of threads that may execute the
    annotated method. At analysis time the "Thread Coloring" analysis will
    enforce the constraint that the calling thread must always have a set of
    associated color bindings that satisfy the boolean expression.
    ]]></info>
    <name>@ColorContext</name>
  </findingType>
  <findingType>
    <id>ThreadEffectsAnalysis_noThreadsDrop</id> 
    <artifact tool="JSure"
	      mnemonic="ThreadEffectsAnalysis_noThreadsDrop"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>No Threads Started</name>
  </findingType>
  <findingType>
    <id>ThreadEffectsAnalysis_threadEffectDrop</id> 
    <artifact tool="JSure"
	      mnemonic="ThreadEffectsAnalysis_threadEffectDrop"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Illegal Thread Effects</name>
  </findingType>
  <findingType>
    <id>ThreadEffectsAnalysis_callPromiseDrop</id> 
    <artifact tool="JSure"
	      mnemonic="ThreadEffectsAnalysis_callPromiseDrop"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Call Will Not Start Threads</name>
  </findingType>
  <findingType>
    <id>ThreadEffectsAnalysis_callNotPromiseDrop</id> 
    <artifact tool="JSure"
	      mnemonic="ThreadEffectsAnalysis_callNotPromiseDrop"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Call May Start Threads</name>
  </findingType>
  <findingType>
    <id>LockAnalysis_ds_SynchronizedConstructorAssured</id>
    
    <artifact tool="JSure"
	      mnemonic="LockAnalysis_ds_SynchronizedConstructorAssured"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Single-threaded Constructor Assured</name>
  </findingType>
  <findingType>
    <id>LockAnalysis_ds_SynchronizedConstructorNotAssured</id>
    
    <artifact tool="JSure"
	      mnemonic="LockAnalysis_ds_SynchronizedConstructorNotAssured"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Single-threaded Constructor Not Assured</name>
  </findingType>
  <findingType>
    <id>LockAnalysis_ds_AggregationNeeded</id> 
    <artifact tool="JSure"
	      mnemonic="LockAnalysis_ds_AggregationNeeded"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Object Aggregation Needed</name>
  </findingType>
  <findingType>
    <id>LockAnalysis_ds_AggregationNeeded2</id> 
    <artifact tool="JSure"
	      mnemonic="LockAnalysis_ds_AggregationNeeded2"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Receiver Aggregation Needed</name>
  </findingType>
  <findingType>
    <id>LockAnalysis_ds_FieldAccessAssured</id> 
    <artifact tool="JSure"
	      mnemonic="LockAnalysis_ds_FieldAccessAssured"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Field Access Assured</name>
  </findingType>
  <findingType>
    <id>LockAnalysis_ds_FieldAccessAssuredAlternative</id>
    
    <artifact tool="JSure"
	      mnemonic="LockAnalysis_ds_FieldAccessAssuredAlternative"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Field Access Assured</name>
  </findingType>
  <findingType>
    <id>LockAnalysis_ds_FieldAccessNotAssured</id> 
    <artifact tool="JSure"
	      mnemonic="LockAnalysis_ds_FieldAccessNotAssured"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Field Access Not Assured</name>
  </findingType>
  <findingType>
    <id>LockAnalysis_ds_FieldAccessNotResolvable</id> 
    <artifact tool="JSure"
	      mnemonic="LockAnalysis_ds_FieldAccessNotResolvable"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Unresolvable Field Access</name>
  </findingType>
  <findingType>
    <id>LockAnalysis_ds_PreconditionsAssured</id> 
    <artifact tool="JSure"
	      mnemonic="LockAnalysis_ds_PreconditionsAssured"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Lock Precondition Assured</name>
  </findingType>
  <findingType>
    <id>LockAnalysis_ds_PreconditionsAssuredAlternative</id>
    <artifact tool="JSure"
	      mnemonic="LockAnalysis_ds_PreconditionsAssuredAlternative"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Lock Precondition Assured</name>
  </findingType>
  <findingType>
    <id>LockAnalysis_ds_PreconditionsNotAssured</id> 
    <artifact tool="JSure"
	      mnemonic="LockAnalysis_ds_PreconditionsNotAssured"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Lock Precondition Not Assured</name>
  </findingType>
  <findingType>
    <id>LockAnalysis_ds_PreconditionNotResolvable</id> 
    <artifact tool="JSure"
	      mnemonic="LockAnalysis_ds_PreconditionNotResolvable"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Unresolvable Lock Precondition</name>
  </findingType>
  <findingType>
    <id>LockAnalysis_ds_IndirectFieldAccessAssured</id> 
    <artifact tool="JSure"
	      mnemonic="LockAnalysis_ds_IndirectFieldAccessAssured"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Indirect Field Access Assured</name>
  </findingType>
  <findingType>
    <id>LockAnalysis_ds_IndirectFieldAccessAssuredAlternative</id>
    <artifact tool="JSure"
	      mnemonic="LockAnalysis_ds_IndirectFieldAccessAssuredAlternative"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Indirect Field Access Assured</name>
  </findingType>
  <findingType>
    <id>LockAnalysis_ds_IndirectFieldAccessNotAssured</id>
    <artifact tool="JSure"
	      mnemonic="LockAnalysis_ds_IndirectFieldAccessNotAssured"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Indirect Field Access Not Assured</name>
  </findingType>
  <findingType>
    <id>LockAnalysis_ds_ReturnAssured</id> 
    <artifact tool="JSure"
	      mnemonic="LockAnalysis_ds_ReturnAssured"/>
    p    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Return Statement Assured</name>
  </findingType>
  <findingType>
    <id>LockAnalysis_ds_ReturnNotAssured</id> 
    <artifact tool="JSure"
	      mnemonic="LockAnalysis_ds_ReturnNotAssured"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Return Statement Not Assured</name>
  </findingType>
  <findingType>
    <id>LockAnalysis_ds_SynchronizedMethodWarningDetails</id>
    <artifact tool="JSure"
	      mnemonic="LockAnalysis_ds_SynchronizedMethodWarningDetails"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Unidentified Lock: 'this'</name>
  </findingType>
  <findingType>
    <id>LockAnalysis_ds_SynchronizedStaticMethodWarningDetails</id>
    <artifact tool="JSure"
	      mnemonic="LockAnalysis_ds_SynchronizedStaticMethodWarningDetails"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Unidentified Lock: Class</name>
  </findingType>
  <findingType>
    <id>LockAnalysis_ds_SynchronizationUnused</id> 
    <artifact tool="JSure"
	      mnemonic="LockAnalysis_ds_SynchronizationUnused"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Unused Locks</name>
  </findingType>
  <findingType>
    <id>LockAnalysis_ds_NonfinalExpression</id> 
    <artifact tool="JSure"
	      mnemonic="LockAnalysis_ds_NonfinalExpression"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Non-final Lock Expression</name>
  </findingType>
  <findingType>
    <id>LockAnalysis_ds_UnidentifiableLock</id> 
    <artifact tool="JSure"
	      mnemonic="LockAnalysis_ds_UnidentifiableLock"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Unidentified Lock</name>
  </findingType>
  <findingType>
    <id>LockAnalysis_ds_RedundantSynchronized</id> 
    <artifact tool="JSure"
	      mnemonic="LockAnalysis_ds_RedundantSynchronized"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Redundant Synchronization</name>
  </findingType>
  <findingType>
    <id>LockAnalysis_ds_SyncedJUCLock</id> 
    <artifact tool="JSure"
	      mnemonic="LockAnalysis_ds_SyncedJUCLock"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Native Synchronization On JUC Lock</name>
  </findingType>
  <findingType>
    <id>LockAnalysis_ds_MasqueradingCall</id> 
    <artifact tool="JSure"
	      mnemonic="LockAnalysis_ds_MasqueradingCall"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Masquerading JUC Lock Call</name>
  </findingType>
  <findingType>
    <id>LockAnalysis_ds_MasqueradingCall2</id> 
    <artifact tool="JSure"
	      mnemonic="LockAnalysis_ds_MasqueradingCall2"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Masquerading JUC ReadWriteLock Call</name>
  </findingType>
  <findingType>
    <id>LockAnalysis_ds_JUCLockFields</id> 
    <artifact tool="JSure"
	      mnemonic="LockAnalysis_ds_JUCLockFields"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Fields Declared As JUC Locks</name>
  </findingType>
  <findingType>
    <id>LockAnalysis_ds_DeclaredJUCLockField</id> 
    <artifact tool="JSure"
	      mnemonic="LockAnalysis_ds_DeclaredJUCLockField"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Field Declared As JUC Lock</name>
  </findingType>
  <findingType>
    <id>UniquenessAssurance_uniquenessContraints1</id> 
    <artifact tool="JSure"
	      mnemonic="UniquenessAssurance_uniquenessContraints1"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Uniqueness Assured</name>
  </findingType>
  <findingType>
    <id>UniquenessAssurance_uniquenessContraints2</id> 
    <artifact tool="JSure"
	      mnemonic="UniquenessAssurance_uniquenessContraints2"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Uniqueness Not Assured</name>
  </findingType>
  <findingType>
    <id>UniquenessAssurance_uniqueReturnDrop</id> 
    <artifact tool="JSure"
	      mnemonic="UniquenessAssurance_uniqueReturnDrop"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Unique Return Value</name>
  </findingType>
  <findingType>
    <id>UniquenessAssurance_borrowedParametersDrop</id> 
    <artifact tool="JSure"
	      mnemonic="UniquenessAssurance_borrowedParametersDrop"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Borrowed Parameters</name>
  </findingType>
  <findingType>
    <id>UniquenessAssurance_uniqueParametersDrop</id> 
    <artifact tool="JSure"
	      mnemonic="UniquenessAssurance_uniqueParametersDrop"/>
    <shortMessage>TBD</shortMessage>
    <info>Unique Parameters</info>
    <name>TBD</name>
  </findingType>
  <findingType>
    <id>UniquenessAssurance_effectOfCallDrop</id> 
    <artifact tool="JSure"
	      mnemonic="UniquenessAssurance_effectOfCallDrop"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Method Call Effects</name>
  </findingType>
  <findingType>
    <id>UniquenessAssurance_dependencyDrop</id> 
    <artifact tool="JSure"
	      mnemonic="UniquenessAssurance_dependencyDrop"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Conservative Uniqueness Dependency</name>
  </findingType>
  <findingType>
    <id>UniquenessAssurance_error</id> 
    <artifact tool="JSure"
	      mnemonic="UniquenessAssurance_error"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Uniqueness Error</name>
  </findingType>
  <findingType>
    <id>UniquenessAssurance</id> 
    <artifact tool="JSure"
	      mnemonic="UniquenessAssurance"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Uniqueness Assurance</name>
  </findingType>
  <findingType>
    <id>BorrowedPromiseDrop</id> 
    <artifact tool="JSure"
	      mnemonic="BorrowedPromiseDrop"/>
    <shortMessage>Indicates that the parameter or receiver, in the case of an
    annotated method/constructor, does not receive any new aliases during
    execution of the method.</shortMessage>
    <info><![CDATA[
    Indicates that the parameter or receiver, in the case of an annotated
    method/constructor, does not receive any new aliases during execution of
    the method.  That is, <tt>@Unique</tt> values can be safely passed to the
    parameter or receiver with the guarantee that they will still be unique
    when the method returns.
    <p>
    It is an error to use this annotation on a method whose return type is
    primitive. It is an error to use this annotation on a parameter whose
    type is primitive.
    </p>
    ]]></info>
    <name>@Borrowed</name>
  </findingType>
  <findingType>
    <id>UniquePromiseDrop</id> 
    <artifact tool="JSure"
	      mnemonic="UniquePromiseDrop"/>
    <shortMessage>Indicates that the parameter, receiver, return value, or field is unique.</shortMessage>
    <info><![CDATA[
    Indicates that the parameter, receiver, return value, or field is unique.
    <p>
    It is an error to annotate a method return value if the return type is
    primitive. It is an error to annotate a parameter if the parameter's
    type is primitive.
    </p>
    ]]></info>
    <name>@Unique</name>
  </findingType>
  <findingType>
    <id>AggregatePromiseDrop</id> 
    <artifact tool="JSure"
	      mnemonic="AggregatePromiseDrop"/>
    <shortMessage>Declares that regions of the object referenced by this field
    are to be mapped or "aggregated" into regions of the object that contains
    the field.</shortMessage>
    <info><![CDATA[
    Declares that regions of the object referenced by this field are to be
    mapped or "aggregated" into regions of the object that contains the field.
    It is an error if the field is not also annotated with <tt>@Unique</tt>.
    ]]></info>
    <name>@Aggregate</name>
  </findingType>
  <findingType>
    <id>StartsPromiseDrop</id> 
    <artifact tool="JSure"
	      mnemonic="StartsPromiseDrop"/>
    <shortMessage>Indicates what threads, if any, are started, i.e., by
    Thread.start(), during the execution of the method or
    constructor.</shortMessage>
    <info><![CDATA[
    Indicates what threads, if any, are started, i.e., by
    <tt>Thread.start()</tt>, during the execution of the method or
    constructor. Presently this annotation has only one legal form,
    <tt>@Starts("nothing")</tt>, that indicates that the method/constructor
    does not cause any threads to be started.
    ]]></info>
    <name>@Starts</name>
  </findingType>
  <findingType>
    <id>RegionEffectsPromiseDrop</id> 
    <artifact tool="JSure"
	      mnemonic="RegionEffectsPromiseDrop"/>
    <shortMessage>Declares the regions that may be read or written during
    execution of this method or constructor.</shortMessage>
    <info><![CDATA[
    Declares the regions that may be read or written during execution of this
    method or constructor. Because writing implies the ability to read,
    regions that may be both read and written by the method only need to be
    declared in writes clause of the annotation.
    ]]></info>
    <name>@RegionEffects</name>
  </findingType>
  <findingType>
    <id>InRegionPromiseDrop</id> 
    <artifact tool="JSure"
	      mnemonic="InRegionPromiseDrop"/>
    <shortMessage>Indicates that the annotated field is mapped into the named
    abstract region.</shortMessage>
    <info><![CDATA[Indicates that the annotated field is mapped into the named abstract
    region.]]></info>
    <name>@InRegion</name>
  </findingType>
  <findingType>
    <id>RegionModel</id> 
    <artifact tool="JSure" mnemonic="RegionModel"/>
    <shortMessage>Declares a new abstract region of state for the annotated class.</shortMessage>
    <info><![CDATA[
    Declares a new abstract region of state for the annotated class.  To
    declare more than one region for a class use the <tt>@Regions</tt>
    annotation.  It is an error for a class to have both a
    <tt>@Regions</tt> and a <tt>@Region</tt> annotation.
    ]]></info>
    <name>@Region</name>
  </findingType>
  <findingType>
    <id>LockModel</id> 
    <artifact tool="JSure" mnemonic="LockModel"/>
    <shortMessage>Declare a new region lock in the annotated class.</shortMessage>
    <info><![CDATA[
    Declare a new region lock in the annotated class.  Creates a new named
    lock that associates a particular lock object with a region of the
    class. The region may only be accessed when the lock is held.
    <p>
    To declare more than one lock for a class use the <tt>@RegionLocks</tt>
    annotation.  It is an error for a class to have both a
    <tt>@RegionLocks</tt> and a <tt>@RegionLock</tt> annotation.
    </p>
    <p>The named lock is a Java object If the object's type
    implements<tt>java.util.concurrent.locks.Lock</tt> then the lock object
    must be used according to the protocol of the <tt>@Lock</tt> interface.
    Otherwise, the object must be used as a Java intrinsic lock, i.e.,
    with <tt>synchronized</tt> blocks.
    </p>
    ]]></info>
    <name>@RegionLock</name>
  </findingType>
  <findingType>
    <id>RequiresLockPromiseDrop</id> 
    <artifact tool="JSure"
	      mnemonic="RequiresLockPromiseDrop"/>
    <shortMessage>Declares that the method/constructor assumes that the caller
    holds the named locks.</shortMessage>
    <info><![CDATA[
    Declares that the method/constructor assumes that the caller holds the
    named locks.  Analysis of the method/constructor proceeds as if the named
    locks were held; call sites of the method are scrutinized to determine if
    the precondition is satisfied.
    <p>
    The list of locks is allowed to be empty, in which case it means that
    the method/constructor does not require any locks to be held by the
    caller.
    </p>
    ]]></info>
    <name>@RequiresLock</name>
  </findingType>
  <findingType>
    <id>SelfProtectedPromiseDrop</id> 
    <artifact tool="JSure"
	      mnemonic="SelfProtectedPromiseDrop"/>
    <shortMessage>Marker annotation that indicates that the annotated type
    protects itself.</shortMessage>
    <info><![CDATA[
    Marker annotation that indicates that the annotated type protects
    itself. That is, it is safe to call any two methods from the class
    simultaneously from different threads.  This annotation does not imply
    anything about how the class is implemented.  Of course, it also does not
    imply that a sequence of calls to methods of this class are atomic.  It is
    a the responsibility of the caller to insure that such call sequences
    execute atomically.  <i>This annotation is not checked</i>; rather it is
    used to quiet warnings that would otherwise be raised when accessing an
    object through a field protected by a lock.
    ]]></info>
    <name>@SelfProtected</name>
  </findingType>
  <findingType>
    <id>SingleThreadedPromiseDrop</id> 
    <artifact tool="JSure"
	      mnemonic="SingleThreadedPromiseDrop"/>
    <shortMessage>Marker annotation that indicates that the object created by
    the constructor is only operated on by the thread that invoked the
    constructor.</shortMessage>
    <info><![CDATA[
    Marker annotation that indicates that the object created by the
    constructor is only operated on by the thread that invoked the
    constructor.  This knowledge allows fields of the newly create object to
    be accessed without the normally required locking within the body of the
    constructor.
    ]]></info>
    <name>@SingleThreaded</name>
  </findingType>
  <findingType>
    <id>TransparentPromiseDrop</id> 
    <artifact tool="JSure"
	      mnemonic="TransparentPromiseDrop"/>
    <shortMessage>Indicates that the annotated method may be called from any
    thread color context.</shortMessage>
    <info><![CDATA[
    Indicates that the annotated method may be called from any thread color
    context. Semantically equivalent to <tt>@Color true</tt>.
    ]]></info>
    <name>@Transparent</name>
  </findingType>
  <findingType>
    <id>PromisePromiseDrop</id> 
    <artifact tool="JSure"
	      mnemonic="PromisePromiseDrop"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Scoped Promise</name>
  </findingType>
  <findingType>
    <id>LockAnalysis_ds_OnBehalfOfConstructor</id> 
    <artifact tool="JSure"
	      mnemonic="LockAnalysis_ds_OnBehalfOfConstructor"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Analyzed Initializers</name>
  </findingType>
  <findingType>
    <id>LockAnalysis_ds_FieldDeclaration</id> 
    <artifact tool="JSure"
	      mnemonic="LockAnalysis_ds_FieldDeclaration"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Field Declaration</name>
  </findingType>
  <findingType>
    <id>LockAnalysis_ds_HeldLock</id> 
    <artifact tool="JSure"
	      mnemonic="LockAnalysis_ds_HeldLock"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Intrinsic Lock Held</name>
  </findingType>
  <findingType>
    <id>LockAnalysis_ds_HeldJUCLock</id> 
    <artifact tool="JSure"
	      mnemonic="LockAnalysis_ds_HeldJUCLock"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>JUC Lock Held</name>
  </findingType>
  <findingType>
    <id>LockAnalysis_ds_PoisonedLockCall</id> 
    <artifact tool="JSure"
	      mnemonic="LockAnalysis_ds_PoisonedLockCall"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Inconsistent Matching Locks</name>
  </findingType>
  <findingType>
    <id>LockAnalysis_ds_NoMatchingUnlocks</id> 
    <artifact tool="JSure"
	      mnemonic="LockAnalysis_ds_NoMatchingUnlocks"/>
    <shortMessage>No Matching Unlocks</shortMessage>
    <info>TBD</info>
    <name>No Matching Unlocks</name>
  </findingType>
  <findingType>
    <id>LockAnalysis_ds_MatchingUnlock</id> 
    <artifact tool="JSure"
	      mnemonic="LockAnalysis_ds_MatchingUnlock"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Matching Unlock</name>
  </findingType>
  <findingType>
    <id>LockAnalysis_ds_PoisonedUnlockCall</id> 
    <artifact tool="JSure"
	      mnemonic="LockAnalysis_ds_PoisonedUnlockCall"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Inconsistent Matching Unlocks</name>
  </findingType>
  <findingType>
    <id>LockAnalysis_ds_NoMatchingLocks</id> 
    <artifact tool="JSure"
	      mnemonic="LockAnalysis_ds_NoMatchingLocks"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>No Matching Locks</name>
  </findingType>
  <findingType>
    <id>LockAnalysis_ds_MatchingLock</id> 
    <artifact tool="JSure"
	      mnemonic="LockAnalysis_ds_MatchingLock"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Matching Lock</name>
  </findingType>
  <findingType>
    <id>LockAnalysis_ds_AggregationEvidence</id> 
    <artifact tool="JSure"
	      mnemonic="LockAnalysis_ds_AggregationEvidence"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Aggregation Evidence</name>
  </findingType>
  
  <findingType>
    <id>EffectAssurance_msgUnaccountedFor</id> 
    <artifact tool="JSure"
	      mnemonic="EffectAssurance_msgUnaccountedFor"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Unaccounted Region Effects</name>
  </findingType>
  <findingType>
    <id>EffectAssurance_msgCheckedBy</id> 
    <artifact tool="JSure"
	      mnemonic="EffectAssurance_msgCheckedBy"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Checked Region Effects</name>
  </findingType>
  <findingType>
    <id>EffectAssurance_msgEmptyEffects</id> 
    <artifact tool="JSure"
	      mnemonic="EffectAssurance_msgEmptyEffects"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Empty Region Effects</name>
  </findingType>
  <findingType>
    <id>EffectAssurance_msgContructorRule</id> 
    <artifact tool="JSure"
	      mnemonic="EffectAssurance_msgContructorRule"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>Region Effects Checked By Constructor</name>
  </findingType>
  <findingType>
    <id>EmptyInitializer</id>
    <artifact tool="PMD"
	      mnemonic="EmptyInitializer">
    </artifact>
    <shortMessage>
      It is questionable to have an empty initializer.
    </shortMessage>
    <info>
      It is questionable to have an empty initializer.
    </info>
    <name>Empty Initializer</name>
  </findingType>
  <findingType>
    <id>AvoidNonConstructorMethodsWithClassName</id>
    <artifact tool="PMD"
	      mnemonic="AvoidNonConstructorMethodsWithClassName">
    </artifact>
    <shortMessage>
      It is very easy to confuse methods having the same name as
      their class with constructors. It is preferable to choose a
      different name for these methods.
    </shortMessage>
    <info>
      It is very easy to confuse methods having the same name as
      their class with constructors. It is preferable to choose a
      different name for these methods.
    </info>
    <name>Avoid Non-Constructor Methods With Class Name</name>
  </findingType>
  <findingType>
    <id>EmptyCatchBlock</id>
    <artifact tool="PMD" mnemonic="EmptyCatchBlock"></artifact>
    <shortMessage>
      Empty Catch Block finds instances where an exception is
      caught, but nothing is done. In most circumstances, this
      swallows an exception which should either be acted on or
      reported.
    </shortMessage>
    <info>
      Empty Catch Block finds instances where an exception is
      caught, but nothing is done. In most circumstances, this
      swallows an exception which should either be acted on or
      reported.
    </info>
    <name>Empty Catch Block</name>
  </findingType>
  <findingType>
    <id>EmptyIfStmt</id>
    <artifact tool="PMD" mnemonic="EmptyIfStmt"></artifact>
    <shortMessage>
      Empty If Statement finds instances where a condition is
      checked but nothing is done about it.
    </shortMessage>
    <info>
      Empty If Statement finds instances where a condition is
      checked but nothing is done about it.
    </info>
    <name>Empty If Statement</name>
  </findingType>
  <findingType>
    <id>EmptyWhileStmt</id>
    <artifact tool="PMD" mnemonic="EmptyWhileStmt"></artifact>
    <shortMessage>
      Empty While Statement finds all instances where a while
      statement does nothing. If it is a timing loop, then you
      should use Thread.sleep() for it; if it's a while loop that
      does a lot in the exit expression, rewrite it to make it
      clearer.
    </shortMessage>
    <info>
      Empty While Statement finds all instances where a while
      statement does nothing. If it is a timing loop, then you
      should use Thread.sleep() for it; if it's a while loop that
      does a lot in the exit expression, rewrite it to make it
      clearer.
    </info>
    <name>Empty While Statement</name>
  </findingType>
  <findingType>
    <id>EmptyTryBlock</id>
    <artifact tool="PMD" mnemonic="EmptyTryBlock"></artifact>
    <shortMessage>
      Avoid empty try blocks - what's the point?
    </shortMessage>
    <info>Avoid empty try blocks - what's the point?</info>
    <name>Empty Try Block</name>
  </findingType>
  <findingType>
    <id>EmptyFinallyBlock</id>
    <artifact tool="PMD" mnemonic="EmptyFinallyBlock"></artifact>
    <shortMessage>
      Avoid empty finally blocks - these can be deleted.
    </shortMessage>
    <info>Avoid empty finally blocks - these can be deleted.</info>
    <name>Empty Finally Block</name>
  </findingType>
  <findingType>
    <id>EmptySwitchStatements</id>
    <artifact tool="PMD" mnemonic="EmptySwitchStatements">
    </artifact>
    <shortMessage>Avoid empty switch statements.</shortMessage>
    <info>Avoid empty switch statements.</info>
    <name>Empty Switch Statements</name>
  </findingType>
  <findingType>
    <id>JumbledIncrementer</id>
    <artifact tool="PMD" mnemonic="JumbledIncrementer"></artifact>
    <shortMessage>
      Avoid jumbled loop incrementers - it's usually a mistake,
      and it's confusing even if it's what's intended.
    </shortMessage>
    <info>
      Avoid jumbled loop incrementers - it's usually a mistake,
      and it's confusing even if it's what's intended.
    </info>
    <name>Jumbled Incrementer</name>
  </findingType>
  <findingType>
    <id>ForLoopShouldBeWhileLoop</id>
    <artifact tool="PMD" mnemonic="ForLoopShouldBeWhileLoop">
    </artifact>
    <shortMessage>
      Some for loops can be simplified to while loops - this makes
      them more concise.
    </shortMessage>
    <info>
      Some for loops can be simplified to while loops - this makes
      them more concise.
    </info>
    <name>For Loop Should Be While Loop</name>
  </findingType>
  <findingType>
    <id>UnnecessaryConversionTemporary</id>
    <artifact tool="PMD"
	      mnemonic="UnnecessaryConversionTemporary">
    </artifact>
    <shortMessage>
      Avoid unnecessary temporaries when converting primitives to
      Strings
    </shortMessage>
    <info>
      Avoid unnecessary temporaries when converting primitives to
      Strings
    </info>
    <name>Unnecessary Conversion Temporary</name>
  </findingType>

  <findingType>
    <id>DoubleCheckedLocking</id>
    <shortMessage>
      Partially created objects can be returned by the Double
      Checked Locking pattern when used in Java. An optimizing JRE
      may assign a reference to the baz variable before it creates
      the object the reference is intended to point to. For more
      details see
      http://www.javaworld.com/javaworld/jw-02-2001/jw-0209-double.html.
    </shortMessage>
    <info>
      Partially created objects can be returned by the Double
      Checked Locking pattern when used in Java. An optimizing JRE
      may assign a reference to the baz variable before it creates
      the object the reference is intended to point to. For more
      details see
      http://www.javaworld.com/javaworld/jw-02-2001/jw-0209-double.html.
    </info>
    <name>Double Checked Locking</name>
  </findingType>
  
  <findingType>
    <id>ReturnFromFinallyBlock</id>
    <artifact tool="PMD" mnemonic="ReturnFromFinallyBlock">
    </artifact>
    <shortMessage>
      Avoid returning from a finally block - this can discard
      exceptions.
    </shortMessage>
    <info>
      Avoid returning from a finally block - this can discard
      exceptions.
    </info>
    <name>Return From Finally Block</name>
  </findingType>

  <findingType>
    <id>UnnecessaryReturn</id>
    <artifact tool="PMD" mnemonic="UnnecessaryReturn"></artifact>
    <shortMessage>Avoid unnecessary return statements</shortMessage>
    <info>Avoid unnecessary return statements</info>
    <name>Unnecessary Return</name>
  </findingType>
  <findingType>
    <id>EmptyStaticInitializer</id>
    <artifact tool="PMD" mnemonic="EmptyStaticInitializer">
    </artifact>
    <shortMessage>
      An empty static initializer was found.
    </shortMessage>
    <info>An empty static initializer was found.</info>
    <name>Empty Static Initializer</name>
  </findingType>
  <findingType>
    <id>UnconditionalIfStatement</id>
    <artifact tool="PMD" mnemonic="UnconditionalIfStatement">
    </artifact>
    <shortMessage>
      Do not use &quot;if&quot; statements that are always true or
      always false.
    </shortMessage>
    <info>
      Do not use &quot;if&quot; statements that are always true or
      always false.
    </info>
    <name>Unconditional If Statement</name>
  </findingType>
  <findingType>
    <id>EmptyStatementNotInLoop</id>
    <artifact tool="PMD" mnemonic="EmptyStatementNotInLoop">
    </artifact>
    <shortMessage>
      An empty statement (aka a semicolon by itself) that is not
      used as the sole body of a for loop or while loop is
      probably a bug. It could also be a double semicolon, which
      is useless and should be removed.
    </shortMessage>
    <info>
      An empty statement (aka a semicolon by itself) that is not
      used as the sole body of a for loop or while loop is
      probably a bug. It could also be a double semicolon, which
      is useless and should be removed.
    </info>
    <name>Empty Statement Not In Loop</name>
  </findingType>
  <findingType>
    <id>BooleanInstantiation</id>
    <artifact tool="PMD" mnemonic="BooleanInstantiation"></artifact>
    <shortMessage>
      Avoid instantiating Boolean objects; you can reference
      Boolean.TRUE, Boolean.FALSE, or call Boolean.valueOf()
      instead.
    </shortMessage>
    <info>
      Avoid instantiating Boolean objects; you can reference
      Boolean.TRUE, Boolean.FALSE, or call Boolean.valueOf()
      instead.
    </info>
    <name>Boolean Instantiation</name>
  </findingType>
  <findingType>
    <id>UnnecessaryFinalModifier</id>
    <artifact tool="PMD" mnemonic="UnnecessaryFinalModifier">
    </artifact>
    <shortMessage>
      When a class has the final modifier, all the methods are
      automatically final.
    </shortMessage>
    <info>
      When a class has the final modifier, all the methods are
      automatically final.
    </info>
    <name>Unnecessary Final Modifier</name>
  </findingType>
  <findingType>
    <id>CollapsibleIfStatements</id>
    <artifact tool="PMD" mnemonic="CollapsibleIfStatements">
    </artifact>
    <shortMessage>
      Sometimes two 'if' statements can be consolidated by
      separating their conditions with a boolean short-circuit
      operator.
    </shortMessage>
    <info>
      Sometimes two 'if' statements can be consolidated by
      separating their conditions with a boolean short-circuit
      operator.
    </info>
    <name>Collapsible If Statements</name>
  </findingType>
  <findingType>
    <id>UselessOverridingMethod</id>
    <artifact tool="PMD" mnemonic="UselessOverridingMethod">
    </artifact>
    <shortMessage>
      The overriding method merely calls the same method defined
      in a superclass
    </shortMessage>
    <info>
      The overriding method merely calls the same method defined
      in a superclass
    </info>
    <name>Useless Overriding Method</name>
  </findingType>
  <findingType>
    <id>ClassCastExceptionWithToArray</id>
    <artifact tool="PMD" mnemonic="ClassCastExceptionWithToArray">
    </artifact>
    <shortMessage>
      if you need to get an array of a class from your Collection,
      you should pass an array of the desidered class as the
      parameter of the toArray method. Otherwise you will get a
      ClassCastException.
    </shortMessage>
    <info>
      if you need to get an array of a class from your Collection,
      you should pass an array of the desidered class as the
      parameter of the toArray method. Otherwise you will get a
      ClassCastException.
    </info>
    <name>Class Cast Exception With To Array</name>
  </findingType>
  <findingType>
    <id>AvoidDecimalLiteralsInBigDecimalConstructor</id>
    <artifact tool="PMD"
	      mnemonic="AvoidDecimalLiteralsInBigDecimalConstructor">
    </artifact>
    <shortMessage>
      One might assume that &quot;new BigDecimal(.1)&quot; is
      exactly equal to .1, but it is actually equal to
      .1000000000000000055511151231257827021181583404541015625.
      This is so because .1 cannot be represented exactly as a
      double (or, for that matter, as a binary fraction of any
      finite length). Thus, the long value that is being passed in
      to the constructor is not exactly equal to .1, appearances
      notwithstanding.

      The (String) constructor, on the other hand, is perfectly
      predictable: 'new BigDecimal(&quot;.1&quot;)' is exactly
      equal to .1, as one would expect. Therefore, it is generally
      recommended that the (String) constructor be used in
      preference to this one.
    </shortMessage>
    <info>
      One might assume that &quot;new BigDecimal(.1)&quot; is
      exactly equal to .1, but it is actually equal to
      .1000000000000000055511151231257827021181583404541015625.
      This is so because .1 cannot be represented exactly as a
      double (or, for that matter, as a binary fraction of any
      finite length). Thus, the long value that is being passed in
      to the constructor is not exactly equal to .1, appearances
      notwithstanding.

      The (String) constructor, on the other hand, is perfectly
      predictable: 'new BigDecimal(&quot;.1&quot;)' is exactly
      equal to .1, as one would expect. Therefore, it is generally
      recommended that the (String) constructor be used in
      preference to this one.
    </info>
    <name>Avoid Decimal Literals In Big Decimal Constructor</name>
  </findingType>
  <findingType>
    <id>UselessOperationOnImmutable</id>
    <artifact tool="PMD" mnemonic="UselessOperationOnImmutable">
    </artifact>
    <shortMessage>
      An operation on an Immutable object (BigDecimal or
      BigInteger) won't change the object itself. The result of
      the operation is a new object. Therefore, ignoring the
      operation result is an error.
    </shortMessage>
    <info>
      An operation on an Immutable object (BigDecimal or
      BigInteger) won't change the object itself. The result of
      the operation is a new object. Therefore, ignoring the
      operation result is an error.
    </info>
    <name>Useless Operation On Immutable</name>
  </findingType>

  <findingType>
    <id>UnusedNullCheckInEquals</id>
    <artifact tool="PMD" mnemonic="UnusedNullCheckInEquals">
    </artifact>
    <shortMessage>
      After checking an object reference for null, you should
      invoke equals() on that object rather than passing it to
      another object's equals() method.
    </shortMessage>
    <info>
      After checking an object reference for null, you should
      invoke equals() on that object rather than passing it to
      another object's equals() method.
    </info>
    <name>Unused Null Check In Equals</name>
  </findingType>
  <findingType>
    <id>AvoidThreadGroup</id>
    <artifact tool="PMD" mnemonic="AvoidThreadGroup"></artifact>
    <shortMessage>
      Avoid using ThreadGroup; although it is intended to be used
      in a threaded environment it contains methods that are not
      thread safe.
    </shortMessage>
    <info>
      Avoid using ThreadGroup; although it is intended to be used
      in a threaded environment it contains methods that are not
      thread safe.
    </info>
    <name>Avoid Thread Group</name>
  </findingType>
  <findingType>
    <id>BrokenNullCheck</id>
    <artifact tool="PMD" mnemonic="BrokenNullCheck"></artifact>
    <shortMessage>
      The null check is broken since it will throw a
      NullPointerException itself. It is likely that you used ||
      instead of &amp;&amp; or vice versa.
    </shortMessage>
    <info>
      The null check is broken since it will throw a
      NullPointerException itself. It is likely that you used ||
      instead of &amp;&amp; or vice versa.
    </info>
    <name>Broken Null Check</name>
  </findingType>
  <findingType>
    <id>BigIntegerInstantiation</id>
    <artifact tool="PMD" mnemonic="BigIntegerInstantiation">
    </artifact>
    <shortMessage>
      Don't create instances of already existing BigInteger
      (BigInteger.ZERO, BigInteger.ONE) and for 1.5 on,
      BigInteger.TEN and BigDecimal (BigDecimal.ZERO,
      BigDecimal.ONE, BigDecimal.TEN)
    </shortMessage>
    <info>
      Don't create instances of already existing BigInteger
      (BigInteger.ZERO, BigInteger.ONE) and for 1.5 on,
      BigInteger.TEN and BigDecimal (BigDecimal.ZERO,
      BigDecimal.ONE, BigDecimal.TEN)
    </info>
    <name>Big Integer Instantiation</name>
  </findingType>
  <findingType>
    <id>AvoidUsingOctalValues</id>
    <artifact tool="PMD" mnemonic="AvoidUsingOctalValues">
    </artifact>
    <shortMessage>
      Integer literals should not start with zero. Zero means that
      the rest of literal will be interpreted as an octal value.
    </shortMessage>
    <info>
      Integer literals should not start with zero. Zero means that
      the rest of literal will be interpreted as an octal value.
    </info>
    <name>Avoid Using Octal Values</name>
  </findingType>
  <findingType>
    <id>IfStmtsMustUseBraces</id>
    <artifact tool="PMD" mnemonic="IfStmtsMustUseBraces"></artifact>
    <shortMessage>
      Avoid using if statements without using curly braces.
    </shortMessage>
    <info>
      Avoid using if statements without using curly braces.
    </info>
    <name>If Statements Must Use Braces</name>
  </findingType>
  <findingType>
    <id>WhileLoopsMustUseBraces</id>
    <artifact tool="PMD" mnemonic="WhileLoopsMustUseBraces">
    </artifact>
    <shortMessage>
      Avoid using 'while' statements without using curly braces.
    </shortMessage>
    <info>
      Avoid using 'while' statements without using curly braces.
    </info>
    <name>While Loops Must Use Braces</name>
  </findingType>
  <findingType>
    <id>IfElseStmtsMustUseBraces</id>
    <artifact tool="PMD" mnemonic="IfElseStmtsMustUseBraces">
    </artifact>
    <shortMessage>
      Avoid using if..else statements without using curly braces.
    </shortMessage>
    <info>
      Avoid using if..else statements without using curly braces.
    </info>
    <name>If Else Statements Must Use Braces</name>
  </findingType>
  <findingType>
    <id>ForLoopsMustUseBraces</id>
    <artifact tool="PMD" mnemonic="ForLoopsMustUseBraces">
    </artifact>
    <shortMessage>
      Avoid using 'for' statements without using curly braces.
    </shortMessage>
    <info>
      Avoid using 'for' statements without using curly braces.
    </info>
    <name>For Loops Must Use Braces</name>
  </findingType>

  <findingType>
    <id>CloneThrowsCloneNotSupportedException</id>
    <artifact tool="PMD"
	      mnemonic="CloneThrowsCloneNotSupportedException">
    </artifact>
    <shortMessage>
      The method clone() should throw a
      CloneNotSupportedException.
    </shortMessage>
    <info>
      The method clone() should throw a
      CloneNotSupportedException.
    </info>
    <name>Clone Throws Clone Not Supported Exception</name>
  </findingType>

  <findingType>
    <id>NPathComplexity</id>
    <artifact tool="PMD" mnemonic="NPathComplexity"></artifact>
    <shortMessage>
      The NPath complexity of a method is the number of acyclic
      execution paths through that method. A threshold of 200 is
      generally considered the point where measures should be
      taken to reduce complexity.
    </shortMessage>
    <info>
      The NPath complexity of a method is the number of acyclic
      execution paths through that method. A threshold of 200 is
      generally considered the point where measures should be
      taken to reduce complexity.
    </info>
    <name>NPath Complexity</name>
  </findingType>
  <findingType>
    <id>ExcessiveMethodLength</id>
    <artifact tool="PMD" mnemonic="ExcessiveMethodLength">
    </artifact>
    <shortMessage>
      Violations of this rule usually indicate that the method is
      doing too much. Try to reduce the method size by creating
      helper methods and removing any copy/pasted code.
    </shortMessage>
    <info>
      Violations of this rule usually indicate that the method is
      doing too much. Try to reduce the method size by creating
      helper methods and removing any copy/pasted code.
    </info>
    <name>Excessive Method Length</name>
  </findingType>
  <findingType>
    <id>ExcessiveParameterList</id>
    <artifact tool="PMD" mnemonic="ExcessiveParameterList">
    </artifact>
    <shortMessage>
      Long parameter lists can indicate that a new object should
      be created to wrap the numerous parameters. Basically, try
      to group the parameters together.
    </shortMessage>
    <info>
      Long parameter lists can indicate that a new object should
      be created to wrap the numerous parameters. Basically, try
      to group the parameters together.
    </info>
    <name>Excessive Parameter List</name>
  </findingType>
  <findingType>
    <id>ExcessiveClassLength</id>
    <artifact tool="PMD" mnemonic="ExcessiveClassLength"></artifact>
    <shortMessage>
      Long Class files are indications that the class may be
      trying to do too much. Try to break it down, and reduce the
      size to something manageable.
    </shortMessage>
    <info>
      Long Class files are indications that the class may be
      trying to do too much. Try to break it down, and reduce the
      size to something manageable.
    </info>
    <name>Excessive Class Length</name>
  </findingType>
  <findingType>
    <id>CyclomaticComplexity</id>
    <artifact tool="PMD" mnemonic="CyclomaticComplexity"></artifact>
    <shortMessage>
      Complexity is determined by the number of decision points in
      a method plus one for the method entry. The decision points
      are 'if', 'while', 'for', and 'case labels'. Generally, 1-4
      is low complexity, 5-7 indicates moderate complexity, 8-10
      is high complexity, and 11+ is very high complexity.
    </shortMessage>
    <info>
      Complexity is determined by the number of decision points in
      a method plus one for the method entry. The decision points
      are 'if', 'while', 'for', and 'case labels'. Generally, 1-4
      is low complexity, 5-7 indicates moderate complexity, 8-10
      is high complexity, and 11+ is very high complexity.
    </info>
    <name>Cyclomatic Complexity</name>
  </findingType>
  <findingType>
    <id>ExcessivePublicCount</id>
    <artifact tool="PMD" mnemonic="ExcessivePublicCount"></artifact>
    <shortMessage>
      A large number of public methods and attributes declared in
      a class can indicate the class may need to be broken up as
      increased effort will be required to thoroughly test it.
    </shortMessage>
    <info>
      A large number of public methods and attributes declared in
      a class can indicate the class may need to be broken up as
      increased effort will be required to thoroughly test it.
    </info>
    <name>Excessive Public Count</name>
  </findingType>
  <findingType>
    <id>TooManyFields</id>
    <artifact tool="PMD" mnemonic="TooManyFields"></artifact>
    <shortMessage>
      Classes that have too many fields could be redesigned to
      have fewer fields, possibly through some nested object
      grouping of some of the information. For example, a class
      with city/state/zip fields could instead have one Address
      field.
    </shortMessage>
    <info>
      Classes that have too many fields could be redesigned to
      have fewer fields, possibly through some nested object
      grouping of some of the information. For example, a class
      with city/state/zip fields could instead have one Address
      field.
    </info>
    <name>Too Many Fields</name>
  </findingType>
  <findingType>
    <id>NcssMethodCount</id>
    <artifact tool="PMD" mnemonic="NcssMethodCount"></artifact>
    <shortMessage>
      This rule uses the NCSS (Non Commenting Source Statements)
      algorithm to determine the number of lines of code for a
      given method. NCSS ignores comments, and counts actual
      statements. Using this algorithm, lines of code that are
      split are counted as one.
    </shortMessage>
    <info>
      This rule uses the NCSS (Non Commenting Source Statements)
      algorithm to determine the number of lines of code for a
      given method. NCSS ignores comments, and counts actual
      statements. Using this algorithm, lines of code that are
      split are counted as one.
    </info>
    <name>NCSS Method Count</name>
  </findingType>
  <findingType>
    <id>NcssTypeCount</id>
    <artifact tool="PMD" mnemonic="NcssTypeCount"></artifact>
    <shortMessage>
      This rule uses the NCSS (Non Commenting Source Statements)
      algorithm to determine the number of lines of code for a
      given type. NCSS ignores comments, and counts actual
      statements. Using this algorithm, lines of code that are
      split are counted as one.
    </shortMessage>
    <info>
      This rule uses the NCSS (Non Commenting Source Statements)
      algorithm to determine the number of lines of code for a
      given type. NCSS ignores comments, and counts actual
      statements. Using this algorithm, lines of code that are
      split are counted as one.
    </info>
    <name>NCSS Type Count</name>
  </findingType>
  <findingType>
    <id>NcssConstructorCount</id>
    <artifact tool="PMD" mnemonic="NcssConstructorCount"></artifact>
    <shortMessage>
      This rule uses the NCSS (Non Commenting Source Statements)
      algorithm to determine the number of lines of code for a
      given constructor. NCSS ignores comments, and counts actual
      statements. Using this algorithm, lines of code that are
      split are counted as one.
    </shortMessage>
    <info>
      This rule uses the NCSS (Non Commenting Source Statements)
      algorithm to determine the number of lines of code for a
      given constructor. NCSS ignores comments, and counts actual
      statements. Using this algorithm, lines of code that are
      split are counted as one.
    </info>
    <name>NCSS Constructor Count</name>
  </findingType>
  <findingType>
    <id>UnnecessaryConstructor</id>
    <artifact tool="PMD" mnemonic="UnnecessaryConstructor">
    </artifact>
    <shortMessage>
      This rule detects when a constructor is not necessary; i.e.,
      when there's only one constructor, it's public, has an empty
      body, and takes no arguments.
    </shortMessage>
    <info>
      This rule detects when a constructor is not necessary; i.e.,
      when there's only one constructor, it's public, has an empty
      body, and takes no arguments.
    </info>
    <name>Unnecessary Constructor</name>
  </findingType>
  <findingType>
    <id>NullAssignment</id>
    <artifact tool="PMD" mnemonic="NullAssignment"></artifact>
    <shortMessage>
      Assigning a &quot;null&quot; to a variable (outside of its
      declaration) is usually bad form. Some times, the assignment
      is an indication that the programmer doesn't completely
      understand what is going on in the code. NOTE: This sort of
      assignment may in rare cases be useful to encourage garbage
      collection. If that's what you're using it for, by all
      means, disregard this rule :-)
    </shortMessage>
    <info>
      Assigning a &quot;null&quot; to a variable (outside of its
      declaration) is usually bad form. Some times, the assignment
      is an indication that the programmer doesn't completely
      understand what is going on in the code. NOTE: This sort of
      assignment may in rare cases be useful to encourage garbage
      collection. If that's what you're using it for, by all
      means, disregard this rule :-)
    </info>
    <name>Null Assignment</name>
  </findingType>
  <findingType>
    <id>OnlyOneReturn</id>
    <artifact tool="PMD" mnemonic="OnlyOneReturn"></artifact>
    <shortMessage>
      A method should have only one exit point, and that should be
      the last statement in the method.
    </shortMessage>
    <info>
      A method should have only one exit point, and that should be
      the last statement in the method.
    </info>
    <name>Only One Return</name>
  </findingType>
  <findingType>
    <id>UnusedModifier</id>
    <artifact tool="PMD" mnemonic="UnusedModifier"></artifact>
    <shortMessage>
      Fields in interfaces are automatically public static final,
      and methods are public abstract. Classes or interfaces
      nested in an interface are automatically public and static
      (all nested interfaces are automatically static). For
      historical reasons, modifiers which are implied by the
      context are accepted by the compiler, but are superfluous.
    </shortMessage>
    <info>
      Fields in interfaces are automatically public static final,
      and methods are public abstract. Classes or interfaces
      nested in an interface are automatically public and static
      (all nested interfaces are automatically static). For
      historical reasons, modifiers which are implied by the
      context are accepted by the compiler, but are superfluous.
    </info>
    <name>Unused Modifier</name>
  </findingType>
  <findingType>
    <id>AssignmentInOperand</id>
    <artifact tool="PMD" mnemonic="AssignmentInOperand"></artifact>
    <shortMessage>
      Avoid assignments in operands; this can make code more
      complicated and harder to read.
    </shortMessage>
    <info>
      Avoid assignments in operands; this can make code more
      complicated and harder to read.
    </info>
    <name>Assignment In Operand</name>
  </findingType>
  <findingType>
    <id>AtLeastOneConstructor</id>
    <artifact tool="PMD" mnemonic="AtLeastOneConstructor">
    </artifact>
    <shortMessage>
      Each class should declare at least one constructor.
    </shortMessage>
    <info>Each class should declare at least one constructor.</info>
    <name>At Least One Constructor</name>
  </findingType>
  <findingType>
    <id>DontImportSun</id>
    <artifact tool="PMD" mnemonic="DontImportSun"></artifact>
    <shortMessage>
      Avoid importing anything from the 'sun.*' packages. These
      packages are not portable and are likely to change.
    </shortMessage>
    <info>
      Avoid importing anything from the 'sun.*' packages. These
      packages are not portable and are likely to change.
    </info>
    <name>Don't Import sun.* Packages</name>
  </findingType>
  <findingType>
    <id>SuspiciousOctalEscape</id>
    <artifact tool="PMD" mnemonic="SuspiciousOctalEscape">
    </artifact>
    <shortMessage>
      A suspicious octal escape sequence was found inside a String
      literal. The Java language specification (section 3.10.6)
      says an octal escape sequence inside a literal String shall
      consist of a backslash followed by:

      OctalDigit | OctalDigit OctalDigit | ZeroToThree OctalDigit
      OctalDigit

      Any octal escape sequence followed by non-octal digits can
      be confusing, e.g. &quot;\038&quot; is interpreted as the
      octal escape sequence &quot;\03&quot; followed by the
      literal character &quot;8&quot;.
    </shortMessage>
    <info>
      A suspicious octal escape sequence was found inside a String
      literal. The Java language specification (section 3.10.6)
      says an octal escape sequence inside a literal String shall
      consist of a backslash followed by:

      OctalDigit | OctalDigit OctalDigit | ZeroToThree OctalDigit
      OctalDigit

      Any octal escape sequence followed by non-octal digits can
      be confusing, e.g. &quot;\038&quot; is interpreted as the
      octal escape sequence &quot;\03&quot; followed by the
      literal character &quot;8&quot;.
    </info>
    <name>Suspicious Octal Escape</name>
  </findingType>
  <findingType>
    <id>CallSuperInConstructor</id>
    <artifact tool="PMD" mnemonic="CallSuperInConstructor">
    </artifact>
    <shortMessage>
      It is a good practice to call super() in a constructor. If
      super() is not called but another constructor (such as an
      overloaded constructor) is called, this rule will not report
      it.
    </shortMessage>
    <info>
      It is a good practice to call super() in a constructor. If
      super() is not called but another constructor (such as an
      overloaded constructor) is called, this rule will not report
      it.
    </info>
    <name>Call Super In Constructor</name>
  </findingType>
  <findingType>
    <id>UnnecessaryParentheses</id>
    <artifact tool="PMD" mnemonic="UnnecessaryParentheses">
    </artifact>
    <shortMessage>
      Sometimes expressions are wrapped in unnecessary
      parentheses, making them look like a function call.
    </shortMessage>
    <info>
      Sometimes expressions are wrapped in unnecessary
      parentheses, making them look like a function call.
    </info>
    <name>Unnecessary Parentheses</name>
  </findingType>
  <findingType>
    <id>SingularField</id>
    <artifact tool="PMD" mnemonic="SingularField"></artifact>
    <shortMessage>
      A field that's only used by one method could perhaps be
      replaced by a local variable.
    </shortMessage>
    <info>
      A field that's only used by one method could perhaps be
      replaced by a local variable.
    </info>
    <name>Singular Field</name>
  </findingType>
  <findingType>
    <id>DefaultPackage</id>
    <artifact tool="PMD" mnemonic="DefaultPackage"></artifact>
    <shortMessage>
      Use explicit scoping instead of the default package private
      level.
    </shortMessage>
    <info>
      Use explicit scoping instead of the default package private
      level.
    </info>
    <name>Default Package</name>
  </findingType>
  <findingType>
    <id>BooleanInversion</id>
    <artifact tool="PMD" mnemonic="BooleanInversion"></artifact>
    <shortMessage>
      Use bitwise inversion to invert boolean values - it's the
      fastest way to do this.
    </shortMessage>
    <info>
      Use bitwise inversion to invert boolean values - it's the
      fastest way to do this. See
      http://www.javaspecialists.co.za/archive/newsletter.do?issue=042&amp;locale=en_US
      for specific details
    </info>
    <name>Boolean Inversion</name>
  </findingType>
  <findingType>
    <id>DataflowAnomalyAnalysis</id>
    <artifact tool="PMD" mnemonic="DataflowAnomalyAnalysis">
    </artifact>
    <shortMessage>
      The dataflow analysis tracks local definitions,
      undefinitions and references to variables on different paths
      on the data flow. From those informations there can be found
      various problems.

      1. UR - Anomaly: There is a reference to a variable that was
      not defined before. This is a bug and leads to an error. 2.
      DU - Anomaly: A recently defined variable is undefined.
      These anomalies may appear in normal source text. 3. DD -
      Anomaly: A recently defined variable is redefined. This is
      ominous but don't have to be a bug.
    </shortMessage>
    <info>
      The dataflow analysis tracks local definitions,
      undefinitions and references to variables on different paths
      on the data flow. From those informations there can be found
      various problems.

      1. UR - Anomaly: There is a reference to a variable that was
      not defined before. This is a bug and leads to an error. 2.
      DU - Anomaly: A recently defined variable is undefined.
      These anomalies may appear in normal source text. 3. DD -
      Anomaly: A recently defined variable is redefined. This is
      ominous but don't have to be a bug.
    </info>
    <name>Dataflow Anomaly Analysis</name>
  </findingType>
  <findingType>
    <id>CouplingBetweenObjects</id>
    <artifact tool="PMD" mnemonic="CouplingBetweenObjects">
    </artifact>
    <shortMessage>
      This rule counts unique attributes, local variables and
      return types within an object. A number higher than
      specified threshold can indicate a high degree of coupling.
    </shortMessage>
    <info>
      This rule counts unique attributes, local variables and
      return types within an object. A number higher than
      specified threshold can indicate a high degree of coupling.
    </info>
    <name>Coupling Between Objects</name>
  </findingType>
  <findingType>
    <id>ExcessiveImports</id>
    <artifact tool="PMD" mnemonic="ExcessiveImports"></artifact>
    <shortMessage>
      A high number of imports can indicate a high degree of
      coupling within an object. Rule counts the number of unique
      imports and reports a violation if the count is above the
      user defined threshold.
    </shortMessage>
    <info>
      A high number of imports can indicate a high degree of
      coupling within an object. Rule counts the number of unique
      imports and reports a violation if the count is above the
      user defined threshold.
    </info>
    <name>Excessive Imports</name>
  </findingType>
  <findingType>
    <id>LooseCoupling</id>
    <artifact tool="PMD" mnemonic="LooseCoupling"></artifact>
    <shortMessage>
      Avoid using implementation types (i.e., HashSet); use the
      interface (i.e, Set) instead
    </shortMessage>
    <info>
      Avoid using implementation types (i.e., HashSet); use the
      interface (i.e, Set) instead
    </info>
    <name>Loose Coupling</name>
  </findingType>
  <findingType>
    <id>UseSingleton</id>
    <artifact tool="PMD" mnemonic="UseSingleton"></artifact>
    <shortMessage>
      If you have a class that has nothing but static methods,
      consider making it a Singleton. Note that this doesn't apply
      to abstract classes, since their subclasses may well include
      non-static methods. Also, if you want this class to be a
      Singleton, remember to add a private constructor to prevent
      instantiation.
    </shortMessage>
    <info>
      If you have a class that has nothing but static methods,
      consider making it a Singleton. Note that this doesn't apply
      to abstract classes, since their subclasses may well include
      non-static methods. Also, if you want this class to be a
      Singleton, remember to add a private constructor to prevent
      instantiation.
    </info>
    <name>Use Singleton</name>
  </findingType>
  <findingType>
    <id>SimplifyBooleanReturns</id>
    <artifact tool="PMD" mnemonic="SimplifyBooleanReturns">
    </artifact>
    <shortMessage>
      Avoid unnecessary if..then..else statements when returning a
      boolean.
    </shortMessage>
    <info>
      Avoid unnecessary if..then..else statements when returning a
      boolean.
    </info>
    <name>Simplify Boolean Returns</name>
  </findingType>
  <findingType>
    <id>SimplifyBooleanExpressions</id>
    <artifact tool="PMD" mnemonic="SimplifyBooleanExpressions">
    </artifact>
    <shortMessage>
      Avoid unnecessary comparisons in boolean expressions - this
      complicates simple code.
    </shortMessage>
    <info>
      Avoid unnecessary comparisons in boolean expressions - this
      complicates simple code.
    </info>
    <name>Simplify Boolean Expressions</name>
  </findingType>
  <findingType>
    <id>SwitchStmtsShouldHaveDefault</id>
    <artifact tool="PMD" mnemonic="SwitchStmtsShouldHaveDefault">
    </artifact>
    <shortMessage>
      Switch statements should have a default label.
    </shortMessage>
    <info>Switch statements should have a default label.</info>
    <name>Switch Statements Should Have Default</name>
  </findingType>
  <findingType>
    <id>AvoidDeeplyNestedIfStmts</id>
    <artifact tool="PMD" mnemonic="AvoidDeeplyNestedIfStmts">
    </artifact>
    <shortMessage>
      Deeply nested if..then statements are hard to read.
    </shortMessage>
    <info>Deeply nested if..then statements are hard to read.</info>
    <name>Avoid Deeply Nested If Statements</name>
  </findingType>
  <findingType>
    <id>AvoidReassigningParameters</id>
    <artifact tool="PMD" mnemonic="AvoidReassigningParameters">
    </artifact>
    <shortMessage>
      Reassigning values to parameters is a questionable practice.
      Use a temporary local variable instead.
    </shortMessage>
    <info>
      Reassigning values to parameters is a questionable practice.
      Use a temporary local variable instead.
    </info>
    <name>Avoid Reassigning Parameters</name>
  </findingType>
  <findingType>
    <id>SwitchDensity</id>
    <artifact tool="PMD" mnemonic="SwitchDensity"></artifact>
    <shortMessage>
      A high ratio of statements to labels in a switch statement
      implies that the switch statement is doing too much work.
      Consider moving the statements into new methods, or creating
      subclasses based on the switch variable.
    </shortMessage>
    <info>
      A high ratio of statements to labels in a switch statement
      implies that the switch statement is doing too much work.
      Consider moving the statements into new methods, or creating
      subclasses based on the switch variable.
    </info>
    <name>Switch Density</name>
  </findingType>
  <findingType>
    <id>ConstructorCallsOverridableMethod</id>
    <artifact tool="PMD"
	      mnemonic="ConstructorCallsOverridableMethod">
    </artifact>
    <shortMessage>
      Calling overridable methods during construction poses a risk
      of invoking methods on an incompletely constructed object
      and can be difficult to discern. It may leave the sub-class
      unable to construct its superclass or forced to replicate
      the construction process completely within itself, losing
      the ability to call super(). If the default constructor
      contains a call to an overridable method, the subclass may
      be completely uninstantiable. Note that this includes method
      calls throughout the control flow graph - i.e., if a
      constructor Foo() calls a private method bar() that calls a
      public method buz(), this denotes a problem.
    </shortMessage>
    <info>
      Calling overridable methods during construction poses a risk
      of invoking methods on an incompletely constructed object
      and can be difficult to discern. It may leave the sub-class
      unable to construct its superclass or forced to replicate
      the construction process completely within itself, losing
      the ability to call super(). If the default constructor
      contains a call to an overridable method, the subclass may
      be completely uninstantiable. Note that this includes method
      calls throughout the control flow graph - i.e., if a
      constructor Foo() calls a private method bar() that calls a
      public method buz(), this denotes a problem.
    </info>
    <name>Constructor Calls Overridable Method</name>
  </findingType>
  <findingType>
    <id>AccessorClassGeneration</id>
    <artifact tool="PMD" mnemonic="AccessorClassGeneration">
    </artifact>
    <shortMessage>
      Instantiation by way of private constructors from outside of
      the constructor's class often causes the generation of an
      accessor. A factory method, or non-privitization of the
      constructor can eliminate this situation. The generated
      class file is actually an interface. It gives the accessing
      class the ability to invoke a new hidden package scope
      constructor that takes the interface as a supplementary
      parameter. This turns a private constructor effectively into
      one with package scope, and is challenging to discern.
    </shortMessage>
    <info>
      Instantiation by way of private constructors from outside of
      the constructor's class often causes the generation of an
      accessor. A factory method, or non-privitization of the
      constructor can eliminate this situation. The generated
      class file is actually an interface. It gives the accessing
      class the ability to invoke a new hidden package scope
      constructor that takes the interface as a supplementary
      parameter. This turns a private constructor effectively into
      one with package scope, and is challenging to discern.
    </info>
    <name>Accessor Class Generation</name>
  </findingType>
  <findingType>
    <id>FinalFieldCouldBeStatic</id>
    <artifact tool="PMD" mnemonic="FinalFieldCouldBeStatic">
    </artifact>
    <shortMessage>
      If a final field is assigned to a compile-time constant, it
      could be made static, thus saving overhead in each object at
      runtime.
    </shortMessage>
    <info>
      If a final field is assigned to a compile-time constant, it
      could be made static, thus saving overhead in each object at
      runtime.
    </info>
    <name>Final Field Could Be Static</name>
  </findingType>
  <findingType>
    <id>CloseResource</id>
    <artifact tool="PMD" mnemonic="CloseResource"></artifact>
    <shortMessage>
      Ensure that resources (like Connection, Statement, and
      ResultSet objects) are always closed after use.
    </shortMessage>
    <info>
      Ensure that resources (like Connection, Statement, and
      ResultSet objects) are always closed after use.
    </info>
    <name>Close Resource</name>
  </findingType>
  <findingType>
    <id>NonStaticInitializer</id>
    <artifact tool="PMD" mnemonic="NonStaticInitializer"></artifact>
    <shortMessage>
      A nonstatic initializer block will be called any time a
      constructor is invoked (just prior to invoking the
      constructor). While this is a valid language construct, it
      is rarely used and is confusing.
    </shortMessage>
    <info>
      A nonstatic initializer block will be called any time a
      constructor is invoked (just prior to invoking the
      constructor). While this is a valid language construct, it
      is rarely used and is confusing.
    </info>
    <name>Non Static Initializer</name>
  </findingType>
  <findingType>
    <id>DefaultLabelNotLastInSwitchStmt</id>
    <artifact tool="PMD"
	      mnemonic="DefaultLabelNotLastInSwitchStmt">
    </artifact>
    <shortMessage>
      By convention, the default label should be the last label in
      a switch statement.
    </shortMessage>
    <info>
      By convention, the default label should be the last label in
      a switch statement.
    </info>
    <name>Default Label Not Last In Switch Statements</name>
  </findingType>
  <findingType>
    <id>NonCaseLabelInSwitchStatement</id>
    <artifact tool="PMD" mnemonic="NonCaseLabelInSwitchStatement">
    </artifact>
    <shortMessage>
      A non-case label (e.g. a named break/continue label) was
      present in a switch statement. This legal, but confusing. It
      is easy to mix up the case labels and the non-case labels.
    </shortMessage>
    <info>
      A non-case label (e.g. a named break/continue label) was
      present in a switch statement. This legal, but confusing. It
      is easy to mix up the case labels and the non-case labels.
    </info>
    <name>Non Case Label In Switch Statement</name>
  </findingType>
  <findingType>
    <id>OptimizableToArrayCall</id>
    <artifact tool="PMD" mnemonic="OptimizableToArrayCall">
    </artifact>
    <shortMessage>
      A call to Collection.toArray can use the Collection's size
      vs an empty Array of the desired type.
    </shortMessage>
    <info>
      A call to Collection.toArray can use the Collection's size
      vs an empty Array of the desired type.
    </info>
    <name>Optimizable To Array Call</name>
  </findingType>
  <findingType>
    <id>BadComparison</id>
    <artifact tool="PMD" mnemonic="BadComparison"></artifact>
    <shortMessage>
      Avoid equality comparisons with Double.NaN - these are
      likely to be logic errors.
    </shortMessage>
    <info>
      Avoid equality comparisons with Double.NaN - these are
      likely to be logic errors.
    </info>
    <name>Bad Comparison</name>
  </findingType>

  <findingType>
    <id>ConfusingTernary</id>
    <artifact tool="PMD" mnemonic="ConfusingTernary"></artifact>
    <shortMessage>
      In an &quot;if&quot; expression with an &quot;else&quot;
      clause, avoid negation in the test. For example, rephrase:
      if (x != y) diff(); else same(); as: if (x == y) same();
      else diff(); Most &quot;if (x != y)&quot; cases without an
      &quot;else&quot; are often return cases, so consistent use
      of this rule makes the code easier to read. Also, this
      resolves trivial ordering problems, such as &quot;does the
      error case go first?&quot; or &quot;does the common case go
      first?&quot;.
    </shortMessage>
    <info>
      In an &quot;if&quot; expression with an &quot;else&quot;
      clause, avoid negation in the test. For example, rephrase:
      if (x != y) diff(); else same(); as: if (x == y) same();
      else diff(); Most &quot;if (x != y)&quot; cases without an
      &quot;else&quot; are often return cases, so consistent use
      of this rule makes the code easier to read. Also, this
      resolves trivial ordering problems, such as &quot;does the
      error case go first?&quot; or &quot;does the common case go
      first?&quot;.
    </info>
    <name>Confusing Ternary</name>
  </findingType>
  <findingType>
    <id>InstantiationToGetClass</id>
    <artifact tool="PMD" mnemonic="InstantiationToGetClass">
    </artifact>
    <shortMessage>
      Avoid instantiating an object just to call getClass() on it;
      use the .class public member instead.
    </shortMessage>
    <info>
      Avoid instantiating an object just to call getClass() on it;
      use the .class public member instead.
    </info>
    <name>Instantiation To Get Class</name>
  </findingType>
  <findingType>
    <id>IdempotentOperations</id>
    <artifact tool="PMD" mnemonic="IdempotentOperations"></artifact>
    <shortMessage>
      Avoid idempotent operations - they are have no effect.
    </shortMessage>
    <info>
      Avoid idempotent operations - they are have no effect.
    </info>
    <name>Idempotent Operations</name>
  </findingType>
  <findingType>
    <id>SimpleDateFormatNeedsLocale</id>
    <artifact tool="PMD" mnemonic="SimpleDateFormatNeedsLocale">
    </artifact>
    <shortMessage>
      Be sure to specify a Locale when creating a new instance of
      SimpleDateFormat.
    </shortMessage>
    <info>
      Be sure to specify a Locale when creating a new instance of
      SimpleDateFormat.
    </info>
    <name>Simple Date Format Needs Locale</name>
  </findingType>
  <findingType>
    <id>ImmutableField</id>
    <artifact tool="PMD" mnemonic="ImmutableField"></artifact>
    <shortMessage>
      Identifies private fields whose values never change once
      they are initialized either in the declaration of the field
      or by a constructor. This aids in converting existing
      classes to immutable classes.
    </shortMessage>
    <info>
      Identifies private fields whose values never change once
      they are initialized either in the declaration of the field
      or by a constructor. This aids in converting existing
      classes to immutable classes.
    </info>
    <name>Immutable Field</name>
  </findingType>
  <findingType>
    <id>UseLocaleWithCaseConversions</id>
    <artifact tool="PMD" mnemonic="UseLocaleWithCaseConversions">
    </artifact>
    <shortMessage>
      When doing a String.toLowerCase()/toUpperCase() call, use a
      Locale. This avoids problems with certain locales, i.e.
      Turkish.
    </shortMessage>
    <info>
      When doing a String.toLowerCase()/toUpperCase() call, use a
      Locale. This avoids problems with certain locales, i.e.
      Turkish.
    </info>
    <name>Use Locale With Case Conversions</name>
  </findingType>
  <findingType>
    <id>AvoidProtectedFieldInFinalClass</id>
    <artifact tool="PMD"
	      mnemonic="AvoidProtectedFieldInFinalClass">
    </artifact>
    <shortMessage>
      Do not use protected fields in final classes since they
      cannot be subclassed. Clarify your intent by using private
      or package access modifiers instead.
    </shortMessage>
    <info>
      Do not use protected fields in final classes since they
      cannot be subclassed. Clarify your intent by using private
      or package access modifiers instead.
    </info>
    <name>Avoid Protected Field In Final Class</name>
  </findingType>
  <findingType>
    <id>AssignmentToNonFinalStatic</id>
    <artifact tool="PMD" mnemonic="AssignmentToNonFinalStatic">
    </artifact>
    <shortMessage>
      Identifies a possible unsafe usage of a static field.
    </shortMessage>
    <info>
      Identifies a possible unsafe usage of a static field.
    </info>
    <name>Assignment To Non Final Static</name>
  </findingType>
  <findingType>
    <id>MissingStaticMethodInNonInstantiatableClass</id>
    <artifact tool="PMD"
	      mnemonic="MissingStaticMethodInNonInstantiatableClass">
    </artifact>
    <shortMessage>
      A class that has private constructors and does not have any
      static methods or fields cannot be used.
    </shortMessage>
    <info>
      A class that has private constructors and does not have any
      static methods or fields cannot be used.
    </info>
    <name>Missing Static Method In Non Instantiatable Class</name>
  </findingType>
  <findingType>
    <id>AvoidSynchronizedAtMethodLevel</id>
    <artifact tool="PMD"
	      mnemonic="AvoidSynchronizedAtMethodLevel">
    </artifact>
    <shortMessage>
      Method level synchronization can backfire when new code is
      added to the method. Block-level synchronization helps to
      ensure that only the code that needs synchronization gets
      it.
    </shortMessage>
    <info>
      Method level synchronization can backfire when new code is
      added to the method. Block-level synchronization helps to
      ensure that only the code that needs synchronization gets
      it.
    </info>
    <name>Avoid Synchronized At Method Level</name>
  </findingType>
  <findingType>
    <id>MissingBreakInSwitch</id>
    <artifact tool="PMD" mnemonic="MissingBreakInSwitch"></artifact>
    <shortMessage>
      A switch statement without an enclosed break statement may
      be a bug.
    </shortMessage>
    <info>
      A switch statement without an enclosed break statement may
      be a bug.
    </info>
    <name>Missing Break In Switch</name>
  </findingType>

  <findingType>
    <id>AvoidInstanceofChecksInCatchClause</id>
    <artifact tool="PMD"
	      mnemonic="AvoidInstanceofChecksInCatchClause">
    </artifact>
    <shortMessage>
      Each caught exception type should be handled in its own
      catch clause.
    </shortMessage>
    <info>
      Each caught exception type should be handled in its own
      catch clause.
    </info>
    <name>Avoid instanceof Checks In Catch Clause</name>
  </findingType>
  <findingType>
    <id>AbstractClassWithoutAbstractMethod</id>
    <artifact tool="PMD"
	      mnemonic="AbstractClassWithoutAbstractMethod">
    </artifact>
    <shortMessage>
      The abstract class does not contain any abstract methods. An
      abstract class suggests an incomplete implementation, which
      is to be completed by subclasses implementing the abstract
      methods. If the class is intended to be used as a base class
      only (not to be instantiated direcly) a protected
      constructor can be provided prevent direct instantiation.
    </shortMessage>
    <info>
      The abstract class does not contain any abstract methods. An
      abstract class suggests an incomplete implementation, which
      is to be completed by subclasses implementing the abstract
      methods. If the class is intended to be used as a base class
      only (not to be instantiated direcly) a protected
      constructor can be provided prevent direct instantiation.
    </info>
    <name>Abstract Class Without Abstract Method</name>
  </findingType>
  <findingType>
    <id>SimplifyConditional</id>
    <artifact tool="PMD" mnemonic="SimplifyConditional"></artifact>
    <shortMessage>
      No need to check for null before an instanceof; the
      instanceof keyword returns false when given a null argument.
    </shortMessage>
    <info>
      No need to check for null before an instanceof; the
      instanceof keyword returns false when given a null argument.
    </info>
    <name>Simplify Conditional</name>
  </findingType>
  <findingType>
    <id>CompareObjectsWithEquals</id>
    <artifact tool="PMD" mnemonic="CompareObjectsWithEquals">
    </artifact>
    <shortMessage>
      Use equals() to compare object references; avoid comparing
      them with ==.
    </shortMessage>
    <info>
      Use equals() to compare object references; avoid comparing
      them with ==.
    </info>
    <name>Compare Objects With Equals</name>
  </findingType>
  <findingType>
    <id>PositionLiteralsFirstInComparisons</id>
    <artifact tool="PMD"
	      mnemonic="PositionLiteralsFirstInComparisons">
    </artifact>
    <shortMessage>
      Position literals first in String comparisons - that way if
      the String is null you won't get a NullPointerException,
      it'll just return false.
    </shortMessage>
    <info>
      Position literals first in String comparisons - that way if
      the String is null you won't get a NullPointerException,
      it'll just return false.
    </info>
    <name>Position Literals First In Comparisons</name>
  </findingType>
  <findingType>
    <id>UnnecessaryLocalBeforeReturn</id>
    <artifact tool="PMD" mnemonic="UnnecessaryLocalBeforeReturn">
    </artifact>
    <shortMessage>
      Avoid unnecessarily creating local variables
    </shortMessage>
    <info>Avoid unnecessarily creating local variables</info>
    <name>Unnecessary Local Before Return</name>
  </findingType>
  <findingType>
    <id>NonThreadSafeSingleton</id>
    <artifact tool="PMD" mnemonic="NonThreadSafeSingleton">
    </artifact>
    <shortMessage>
      Non-thread safe singletons can result in bad state changes.
      Eliminate static singletons if possible by instantiating the
      object directly. Static singletons are usually not needed as
      only a single instance exists anyway. Other possible fixes
      are to synchronize the entire method or to use an
      initialize-on-demand holder class (do not use the
      double-check idiom).

      See Effective Java, item 48.
    </shortMessage>
    <info>
      Non-thread safe singletons can result in bad state changes.
      Eliminate static singletons if possible by instantiating the
      object directly. Static singletons are usually not needed as
      only a single instance exists anyway. Other possible fixes
      are to synchronize the entire method or to use an
      initialize-on-demand holder class (do not use the
      double-check idiom).

      See Effective Java, item 48.
    </info>
    <name>Non Thread Safe Singleton</name>
  </findingType>
  <findingType>
    <id>UncommentedEmptyMethod</id>
    <artifact tool="PMD" mnemonic="UncommentedEmptyMethod">
    </artifact>
    <shortMessage>
      Uncommented Empty Method finds instances where a method does
      not contain statements, but there is no comment. By
      explicitly commenting empty methods it is easier to
      distinguish between intentional (commented) and
      unintentional empty methods.
    </shortMessage>
    <info>
      Uncommented Empty Method finds instances where a method does
      not contain statements, but there is no comment. By
      explicitly commenting empty methods it is easier to
      distinguish between intentional (commented) and
      unintentional empty methods.
    </info>
    <name>Uncommented Empty Method</name>
  </findingType>
  <findingType>
    <id>UncommentedEmptyConstructor</id>
    <artifact tool="PMD" mnemonic="UncommentedEmptyConstructor">
    </artifact>
    <shortMessage>
      Uncommented Empty Constructor finds instances where a
      constructor does not contain statements, but there is no
      comment. By explicitly commenting empty constructors it is
      easier to distinguish between intentional (commented) and
      unintentional empty constructors.
    </shortMessage>
    <info>
      Uncommented Empty Constructor finds instances where a
      constructor does not contain statements, but there is no
      comment. By explicitly commenting empty constructors it is
      easier to distinguish between intentional (commented) and
      unintentional empty constructors.
    </info>
    <name>Uncommented Empty Constructor</name>
  </findingType>
  <findingType>
    <id>AvoidConstantsInterface</id>
    <artifact tool="PMD" mnemonic="AvoidConstantsInterface">
    </artifact>
    <shortMessage>
      An interface should be used only to model a behaviour of a
      class: using an interface as a container of constants is a
      poor usage pattern.
    </shortMessage>
    <info>
      An interface should be used only to model a behaviour of a
      class: using an interface as a container of constants is a
      poor usage pattern.
    </info>
    <name>Avoid Constants Interface</name>
  </findingType>
  <findingType>
    <id>UnsynchronizedStaticDateFormatter</id>
    <artifact tool="PMD"
	      mnemonic="UnsynchronizedStaticDateFormatter">
    </artifact>
    <shortMessage>
      SimpleDateFormat is not synchronized. Sun recomends separate
      format instances for each thread. If multiple threads must
      access a static formatter, the formatter must be
      synchronized either on method or block level.
    </shortMessage>
    <info>
      SimpleDateFormat is not synchronized. Sun recomends separate
      format instances for each thread. If multiple threads must
      access a static formatter, the formatter must be
      synchronized either on method or block level.
    </info>
    <name>Unsynchronized Static Date Formatter</name>
  </findingType>
  <findingType>
    <id>PreserveStackTrace</id>
    <artifact tool="PMD" mnemonic="PreserveStackTrace"></artifact>
    <shortMessage>
      Throwing a new exception from a catch block without passing
      the original exception into the new Exception will cause the
      true stack trace to be lost, and can make it difficult to
      debug effectively.
    </shortMessage>
    <info>
      Throwing a new exception from a catch block without passing
      the original exception into the new Exception will cause the
      true stack trace to be lost, and can make it difficult to
      debug effectively.
    </info>
    <name>Preserve Stack Trace</name>
  </findingType>
  <findingType>
    <id>UseCollectionIsEmpty</id>
    <artifact tool="PMD" mnemonic="UseCollectionIsEmpty"></artifact>
    <shortMessage>
      The isEmpty() method on java.util.Collection is provided to
      see if a collection has any elements. Comparing the value of
      size() to 0 merely duplicates existing behavior.
    </shortMessage>
    <info>
      The isEmpty() method on java.util.Collection is provided to
      see if a collection has any elements. Comparing the value of
      size() to 0 merely duplicates existing behavior.
    </info>
    <name>Use Collection Is Empty</name>
  </findingType>


  <findingType>
    <id>FinalizeOverloaded</id>
    <artifact tool="PMD" mnemonic="FinalizeOverloaded"></artifact>
    <shortMessage>
      Methods named finalize() should not have parameters. It is
      confusing and probably a bug to overload finalize(). It will
      not be called by the VM.
    </shortMessage>
    <info>
      Methods named finalize() should not have parameters. It is
      confusing and probably a bug to overload finalize(). It will
      not be called by the VM.
    </info>
    <name>Finalize Overloaded</name>
  </findingType>

  <findingType>
    <id>DuplicateImports</id>
    <artifact tool="PMD" mnemonic="DuplicateImports"></artifact>
    <shortMessage>Avoid duplicate import statements.</shortMessage>
    <info>Avoid duplicate import statements.</info>
    <name>Duplicate Imports</name>
  </findingType>
  <findingType>
    <id>DontImportJavaLang</id>
    <artifact tool="PMD" mnemonic="DontImportJavaLang"></artifact>
    <shortMessage>
      Avoid importing anything from the package 'java.lang'. These
      classes are automatically imported (JLS 7.5.3).
    </shortMessage>
    <info>
      Avoid importing anything from the package 'java.lang'. These
      classes are automatically imported (JLS 7.5.3).
    </info>
    <name>Don't Import java.lang</name>
  </findingType>
  <findingType>
    <id>UnusedImports</id>
    <artifact tool="PMD" mnemonic="UnusedImports"></artifact>
    <shortMessage>Avoid unused import statements.</shortMessage>
    <info>Avoid unused import statements.</info>
    <name>Unused Imports</name>
  </findingType>
  <findingType>
    <id>ImportFromSamePackage</id>
    <artifact tool="PMD" mnemonic="ImportFromSamePackage">
    </artifact>
    <shortMessage>
      No need to import a type that lives in the same package.
    </shortMessage>
    <info>
      No need to import a type that lives in the same package.
    </info>
    <name>Import From Same Package</name>
  </findingType>
  <findingType>
    <id>UseProperClassLoader</id>
    <artifact tool="PMD" mnemonic="UseProperClassLoader"></artifact>
    <shortMessage>
      In J2EE getClassLoader() might not work as expected. Use
      Thread.currentThread().getContextClassLoader() instead.
    </shortMessage>
    <info>
      In J2EE getClassLoader() might not work as expected. Use
      Thread.currentThread().getContextClassLoader() instead.
    </info>
    <name>Use Proper Class Loader</name>
  </findingType>
  <findingType>
    <id>MDBAndSessionBeanNamingConvention</id>
    <artifact tool="PMD"
	      mnemonic="MDBAndSessionBeanNamingConvention">
    </artifact>
    <shortMessage>
      The EJB Specification state that any MessageDrivenBean or
      SessionBean should be suffixed by Bean.
    </shortMessage>
    <info>
      The EJB Specification state that any MessageDrivenBean or
      SessionBean should be suffixed by Bean.
    </info>
    <name>MDB And Session Bean Naming Convention</name>
  </findingType>
  <findingType>
    <id>RemoteSessionInterfaceNamingConvention</id>
    <artifact tool="PMD"
	      mnemonic="RemoteSessionInterfaceNamingConvention">
    </artifact>
    <shortMessage>
      Remote Home interface of a Session EJB should be suffixed by
      'Home'.
    </shortMessage>
    <info>
      Remote Home interface of a Session EJB should be suffixed by
      'Home'.
    </info>
    <name>Remote Session Interface Naming Convention</name>
  </findingType>
  <findingType>
    <id>LocalInterfaceSessionNamingConvention</id>
    <artifact tool="PMD"
	      mnemonic="LocalInterfaceSessionNamingConvention">
    </artifact>
    <shortMessage>
      The Local Interface of a Session EJB should be suffixed by
      'Local'.
    </shortMessage>
    <info>
      The Local Interface of a Session EJB should be suffixed by
      'Local'.
    </info>
    <name>Local Interface Session Naming Convention</name>
  </findingType>
  <findingType>
    <id>LocalHomeNamingConvention</id>
    <artifact tool="PMD" mnemonic="LocalHomeNamingConvention">
    </artifact>
    <shortMessage>
      The Local Home interface of a Session EJB should be suffixed
      by 'LocalHome'.
    </shortMessage>
    <info>
      The Local Home interface of a Session EJB should be suffixed
      by 'LocalHome'.
    </info>
    <name>Local Home Naming Convention</name>
  </findingType>
  <findingType>
    <id>RemoteInterfaceNamingConvention</id>
    <artifact tool="PMD"
	      mnemonic="RemoteInterfaceNamingConvention">
    </artifact>
    <shortMessage>
      Remote Interface of a Session EJB should NOT be suffixed.
    </shortMessage>
    <info>
      Remote Interface of a Session EJB should NOT be suffixed.
    </info>
    <name>Remote Interface Naming Convention</name>
  </findingType>
  <findingType>
    <id>BeanMembersShouldSerialize</id>
    <artifact tool="PMD" mnemonic="BeanMembersShouldSerialize">
    </artifact>
    <shortMessage>
      If a class is a bean, or is referenced by a bean directly or
      indirectly it needs to be serializable. Member variables
      need to be marked as transient, static, or have accessor
      methods in the class. Marking variables as transient is the
      safest and easiest modification. Accessor methods should
      follow the Java naming conventions, i.e.if you have a
      variable foo, you should provide getFoo and setFoo methods.
    </shortMessage>
    <info>
      If a class is a bean, or is referenced by a bean directly or
      indirectly it needs to be serializable. Member variables
      need to be marked as transient, static, or have accessor
      methods in the class. Marking variables as transient is the
      safest and easiest modification. Accessor methods should
      follow the Java naming conventions, i.e.if you have a
      variable foo, you should provide getFoo and setFoo methods.
    </info>
    <name>Bean Members Should Serialize</name>
  </findingType>
  <findingType>
    <id>MissingSerialVersionUID</id>
    <artifact tool="PMD" mnemonic="MissingSerialVersionUID">
    </artifact>
    <shortMessage>
      Classes that are serializable should provide a
      serialVersionUID field.
    </shortMessage>
    <info>
      Classes that are serializable should provide a
      serialVersionUID field.
    </info>
    <name>Missing Serial Version UID</name>
  </findingType>
  <findingType>
    <id>JUnitStaticSuite</id>
    <artifact tool="PMD" mnemonic="JUnitStaticSuite"></artifact>
    <shortMessage>
      The suite() method in a JUnit test needs to be both public
      and static.
    </shortMessage>
    <info>
      The suite() method in a JUnit test needs to be both public
      and static.
    </info>
    <name>JUnit Static Suite</name>
  </findingType>
  <findingType>
    <id>JUnitSpelling</id>
    <artifact tool="PMD" mnemonic="JUnitSpelling"></artifact>
    <shortMessage>
      Some JUnit framework methods are easy to misspell.
    </shortMessage>
    <info>Some JUnit framework methods are easy to misspell.</info>
    <name>JUnit Spelling</name>
  </findingType>
  <findingType>
    <id>JUnitAssertionsShouldIncludeMessage</id>
    <artifact tool="PMD"
	      mnemonic="JUnitAssertionsShouldIncludeMessage">
    </artifact>
    <shortMessage>
      JUnit assertions should include a message - i.e., use the
      three argument version of assertEquals(), not the two
      argument version.
    </shortMessage>
    <info>
      JUnit assertions should include a message - i.e., use the
      three argument version of assertEquals(), not the two
      argument version.
    </info>
    <name>JUnit Assertions Should Include Message</name>
  </findingType>
  <findingType>
    <id>JUnitTestsShouldIncludeAssert</id>
    <artifact tool="PMD" mnemonic="JUnitTestsShouldIncludeAssert">
    </artifact>
    <shortMessage>
      JUnit tests should include at least one assertion. This
      makes the tests more robust, and using assert with messages
      provide the developer a clearer idea of what the test does.
    </shortMessage>
    <info>
      JUnit tests should include at least one assertion. This
      makes the tests more robust, and using assert with messages
      provide the developer a clearer idea of what the test does.
    </info>
    <name>JUnit Tests Should Include Assert</name>
  </findingType>
  <findingType>
    <id>TestClassWithoutTestCases</id>
    <artifact tool="PMD" mnemonic="TestClassWithoutTestCases">
    </artifact>
    <shortMessage>
      Test classes end with the suffix Test. Having a non-test
      class with that name is not a good practice, since most
      people will assume it is a test case. Test classes have test
      methods named testXXX.
    </shortMessage>
    <info>
      Test classes end with the suffix Test. Having a non-test
      class with that name is not a good practice, since most
      people will assume it is a test case. Test classes have test
      methods named testXXX.
    </info>
    <name>Test Class Without Test Cases</name>
  </findingType>
  <findingType>
    <id>UnnecessaryBooleanAssertion</id>
    <artifact tool="PMD" mnemonic="UnnecessaryBooleanAssertion">
    </artifact>
    <shortMessage>
      A JUnit test assertion with a boolean literal is unnecessary
      since it always will eval to the same thing. Consider using
      flow control (in case of assertTrue(false) or similar) or
      simply removing statements like assertTrue(true) and
      assertFalse(false). If you just want a test to halt, use the
      fail method.
    </shortMessage>
    <info>
      A JUnit test assertion with a boolean literal is unnecessary
      since it always will eval to the same thing. Consider using
      flow control (in case of assertTrue(false) or similar) or
      simply removing statements like assertTrue(true) and
      assertFalse(false). If you just want a test to halt, use the
      fail method.
    </info>
    <name>Unnecessary Boolean Assertion</name>
  </findingType>
  <findingType>
    <id>UseAssertEqualsInsteadOfAssertTrue</id>
    <artifact tool="PMD"
	      mnemonic="UseAssertEqualsInsteadOfAssertTrue">
    </artifact>
    <shortMessage>
      This rule detects JUnit assertions in object equality. These
      assertions should be made by more specific methods, like
      assertEquals.
    </shortMessage>
    <info>
      This rule detects JUnit assertions in object equality. These
      assertions should be made by more specific methods, like
      assertEquals.
    </info>
    <name>Use Assert Equals Instead Of Assert True</name>
  </findingType>
  <findingType>
    <id>UseAssertSameInsteadOfAssertTrue</id>
    <artifact tool="PMD"
	      mnemonic="UseAssertSameInsteadOfAssertTrue">
    </artifact>
    <shortMessage>
      This rule detects JUnit assertions in object references
      equality. These assertions should be made by more specific
      methods, like assertSame, assertNotSame.
    </shortMessage>
    <info>
      This rule detects JUnit assertions in object references
      equality. These assertions should be made by more specific
      methods, like assertSame, assertNotSame.
    </info>
    <name>Use Assert Same Instead Of Assert True</name>
  </findingType>
  <findingType>
    <id>UseAssertNullInsteadOfAssertTrue</id>
    <artifact tool="PMD"
	      mnemonic="UseAssertNullInsteadOfAssertTrue">
    </artifact>
    <shortMessage>
      This rule detects JUnit assertions in object references
      equality. These assertions should be made by more specific
      methods, like assertNull, assertNotNull.
    </shortMessage>
    <info>
      This rule detects JUnit assertions in object references
      equality. These assertions should be made by more specific
      methods, like assertNull, assertNotNull.
    </info>
    <name>Use Assert Null Instead Of Assert True</name>
  </findingType>
  <findingType>
    <id>SimplifyBooleanAssertion</id>
    <artifact tool="PMD" mnemonic="SimplifyBooleanAssertion">
    </artifact>
    <shortMessage>
      Avoid negation in an assertTrue or assertFalse test. For
      example, rephrase: assertTrue(!expr); as: assertFalse(expr);
    </shortMessage>
    <info>
      Avoid negation in an assertTrue or assertFalse test. For
      example, rephrase: assertTrue(!expr); as: assertFalse(expr);
    </info>
    <name>Simplify Boolean Assertion</name>
  </findingType>
  <findingType>
    <id>UseCorrectExceptionLogging</id>
    <artifact tool="PMD" mnemonic="UseCorrectExceptionLogging">
    </artifact>
    <shortMessage>
      To make sure the full stacktrace is printed out, use the
      logging statement with 2 arguments: a String and a
      Throwable.
    </shortMessage>
    <info>
      To make sure the full stacktrace is printed out, use the
      logging statement with 2 arguments: a String and a
      Throwable.
    </info>
    <name>Use Correct Exception Logging</name>
  </findingType>
  <findingType>
    <id>ProperLogger</id>
    <artifact tool="PMD" mnemonic="ProperLogger"></artifact>
    <shortMessage>
      A logger should normally be defined private static final and
      have the correct class. Private final Log log; is also
      allowed for rare cases where loggers need to be passed
      around, with the restriction that the logger needs to be
      passed into the constructor.
    </shortMessage>
    <info>
      A logger should normally be defined private static final and
      have the correct class. Private final Log log; is also
      allowed for rare cases where loggers need to be passed
      around, with the restriction that the logger needs to be
      passed into the constructor.
    </info>
    <name>Proper Logger</name>
  </findingType>
  <findingType>
    <id>MoreThanOneLogger</id>
    <artifact tool="PMD" mnemonic="MoreThanOneLogger"></artifact>
    <shortMessage>
      Normally only one logger is used in each class.
    </shortMessage>
    <info>Normally only one logger is used in each class.</info>
    <name>More Than One Logger</name>
  </findingType>
  <findingType>
    <id>LoggerIsNotStaticFinal</id>
    <artifact tool="PMD" mnemonic="LoggerIsNotStaticFinal">
    </artifact>
    <shortMessage>
      In most cases, the Logger can be declared static and final.
    </shortMessage>
    <info>
      In most cases, the Logger can be declared static and final.
    </info>
    <name>Logger Is Not Static Final</name>
  </findingType>
  <findingType>
    <id>SystemPrintln</id>
    <artifact tool="PMD" mnemonic="SystemPrintln"></artifact>
    <shortMessage>
      System.(out|err).print is used, consider using a logger.
    </shortMessage>
    <info>
      System.(out|err).print is used, consider using a logger.
    </info>
    <name>Use of System Println</name>
  </findingType>
  <findingType>
    <id>AvoidPrintStackTrace</id>
    <artifact tool="PMD" mnemonic="AvoidPrintStackTrace"></artifact>
    <shortMessage>
      Avoid printStackTrace(); use a logger call instead.
    </shortMessage>
    <info>Avoid printStackTrace(); use a logger call instead.</info>
    <name>Avoid Print Stack Trace</name>
  </findingType>
  <findingType>
    <id>ReplaceVectorWithList</id>
    <artifact tool="PMD" mnemonic="ReplaceVectorWithList">
    </artifact>
    <shortMessage>
      Consider replacing Vector usages with the newer
      java.util.ArrayList if expensive threadsafe operation is not
      required.
    </shortMessage>
    <info>
      Consider replacing Vector usages with the newer
      java.util.ArrayList if expensive threadsafe operation is not
      required.
    </info>
    <name>Replace Vector With List</name>
  </findingType>
  <findingType>
    <id>ReplaceHashtableWithMap</id>
    <artifact tool="PMD" mnemonic="ReplaceHashtableWithMap">
    </artifact>
    <shortMessage>
      Consider replacing this Hashtable with the newer
      java.util.Map
    </shortMessage>
    <info>
      Consider replacing this Hashtable with the newer
      java.util.Map
    </info>
    <name>Replace Hashtable With Map</name>
  </findingType>
  <findingType>
    <id>ReplaceEnumerationWithIterator</id>
    <artifact tool="PMD"
	      mnemonic="ReplaceEnumerationWithIterator">
    </artifact>
    <shortMessage>
      Consider replacing this Enumeration with the newer
      java.util.Iterator
    </shortMessage>
    <info>
      Consider replacing this Enumeration with the newer
      java.util.Iterator
    </info>
    <name>Replace Enumeration With Iterator</name>
  </findingType>
  <findingType>
    <id>AvoidEnumAsIdentifier</id>
    <artifact tool="PMD" mnemonic="AvoidEnumAsIdentifier">
    </artifact>
    <shortMessage>
      Finds all places where 'enum' is used as an identifier.
    </shortMessage>
    <info>
      Finds all places where 'enum' is used as an identifier.
    </info>
    <name>Avoid Enum As Identifier</name>
  </findingType>
  <findingType>
    <id>AvoidAssertAsIdentifier</id>
    <artifact tool="PMD" mnemonic="AvoidAssertAsIdentifier">
    </artifact>
    <shortMessage>
      Finds all places where 'assert' is used as an identifier.
    </shortMessage>
    <info>
      Finds all places where 'assert' is used as an identifier.
    </info>
    <name>Avoid Assert As Identifier</name>
  </findingType>

  <findingType>
    <id>ByteInstantiation</id>
    <artifact tool="PMD" mnemonic="ByteInstantiation"></artifact>
    <shortMessage>
      In JDK 1.5, calling new Byte() causes memory allocation.
      Byte.valueOf() is more memory friendly.
    </shortMessage>
    <info>
      In JDK 1.5, calling new Byte() causes memory allocation.
      Byte.valueOf() is more memory friendly.
    </info>
    <name>Byte Instantiation</name>
  </findingType>
  <findingType>
    <id>ShortInstantiation</id>
    <artifact tool="PMD" mnemonic="ShortInstantiation"></artifact>
    <shortMessage>
      In JDK 1.5, calling new Short() causes memory allocation.
      Short.valueOf() is more memory friendly.
    </shortMessage>
    <info>
      In JDK 1.5, calling new Short() causes memory allocation.
      Short.valueOf() is more memory friendly.
    </info>
    <name>Short Instantiation</name>
  </findingType>
  <findingType>
    <id>LongInstantiation</id>
    <artifact tool="PMD" mnemonic="LongInstantiation"></artifact>
    <shortMessage>
      In JDK 1.5, calling new Long() causes memory allocation.
      Long.valueOf() is more memory friendly.
    </shortMessage>
    <info>
      In JDK 1.5, calling new Long() causes memory allocation.
      Long.valueOf() is more memory friendly.
    </info>
    <name>Long Instantiation</name>
  </findingType>
  <findingType>
    <id>JUnit4TestShouldUseBeforeAnnotation</id>
    <artifact tool="PMD"
	      mnemonic="JUnit4TestShouldUseBeforeAnnotation">
    </artifact>
    <shortMessage>
      In JUnit 3, the setUp method was used to set up all data
      entities required in running tests. JUnit 4 skips the setUp
      method and executes all methods annotated with @Before
      before all tests
    </shortMessage>
    <info>
      In JUnit 3, the setUp method was used to set up all data
      entities required in running tests. JUnit 4 skips the setUp
      method and executes all methods annotated with @Before
      before all tests
    </info>
    <name>JUnit4Test Should Use Before Annotation</name>
  </findingType>
  <findingType>
    <id>JUnit4TestShouldUseAfterAnnotation</id>
    <artifact tool="PMD"
	      mnemonic="JUnit4TestShouldUseAfterAnnotation">
    </artifact>
    <shortMessage>
      In JUnit 3, the tearDown method was used to clean up all
      data entities required in running tests. JUnit 4 skips the
      tearDown method and executes all methods annotated with
      @After after running each test
    </shortMessage>
    <info>
      In JUnit 3, the tearDown method was used to clean up all
      data entities required in running tests. JUnit 4 skips the
      tearDown method and executes all methods annotated with
      @After after running each test
    </info>
    <name>JUnit4Test Should Use After Annotation</name>
  </findingType>
  <findingType>
    <id>JUnit4TestShouldUseTestAnnotation</id>
    <artifact tool="PMD"
	      mnemonic="JUnit4TestShouldUseTestAnnotation">
    </artifact>
    <shortMessage>
      In JUnit 3, the framework executed all methods which started
      with the word test as a unit test. In JUnit 4, only methods
      annotated with the @Test annotation are executed.
    </shortMessage>
    <info>
      In JUnit 3, the framework executed all methods which started
      with the word test as a unit test. In JUnit 4, only methods
      annotated with the @Test annotation are executed.
    </info>
    <name>JUnit4Test Should Use Test Annotation</name>
  </findingType>
  <findingType>
    <id>JUnit4SuitesShouldUseSuiteAnnotation</id>
    <artifact tool="PMD"
	      mnemonic="JUnit4SuitesShouldUseSuiteAnnotation">
    </artifact>
    <shortMessage>
      In JUnit 3, test suites are indicated by the suite() method.
      In JUnit 4, suites are indicated through the
      @RunWith(Suite.class) annotation.
    </shortMessage>
    <info>
      In JUnit 3, test suites are indicated by the suite() method.
      In JUnit 4, suites are indicated through the
      @RunWith(Suite.class) annotation.
    </info>
    <name>JUnit4Suites Should Use Suite Annotation</name>
  </findingType>
  <findingType>
    <id>JUnitUseExpected</id>
    <artifact tool="PMD" mnemonic="JUnitUseExpected"></artifact>
    <shortMessage></shortMessage>
    <info></info>
    <name>JUnit Use Expected</name>
  </findingType>
  <findingType>
    <id>ShortVariable</id>
    <artifact tool="PMD" mnemonic="ShortVariable"></artifact>
    <shortMessage>
      Detects when a field, local, or parameter has a very short
      name.
    </shortMessage>
    <info>
      Detects when a field, local, or parameter has a very short
      name.
    </info>
    <name>Short Variable</name>
  </findingType>
  <findingType>
    <id>LongVariable</id>
    <artifact tool="PMD" mnemonic="LongVariable"></artifact>
    <shortMessage>
      Detects when a field, formal or local variable is declared
      with a long name.
    </shortMessage>
    <info>
      Detects when a field, formal or local variable is declared
      with a long name.
    </info>
    <name>Long Variable</name>
  </findingType>
  <findingType>
    <id>ShortMethodName</id>
    <artifact tool="PMD" mnemonic="ShortMethodName"></artifact>
    <shortMessage>
      Detects when very short method names are used.
    </shortMessage>
    <info>Detects when very short method names are used.</info>
    <name>Short Method Name</name>
  </findingType>
  <findingType>
    <id>AbstractNaming</id>
    <artifact tool="PMD" mnemonic="AbstractNaming"></artifact>
    <shortMessage>
      Abstract classes should be named 'AbstractXXX'.
    </shortMessage>
    <info>Abstract classes should be named 'AbstractXXX'.</info>
    <name>Abstract Naming</name>
  </findingType>
  <findingType>
    <id>AvoidDollarSigns</id>
    <artifact tool="PMD" mnemonic="AvoidDollarSigns"></artifact>
    <shortMessage>
      Avoid using dollar signs in variable/method/class/interface
      names.
    </shortMessage>
    <info>
      Avoid using dollar signs in variable/method/class/interface
      names.
    </info>
    <name>Avoid Dollar Signs</name>
  </findingType>
  <findingType>
    <id>MethodWithSameNameAsEnclosingClass</id>
    <artifact tool="PMD"
	      mnemonic="MethodWithSameNameAsEnclosingClass">
    </artifact>
    <shortMessage>
      Non-constructor methods should not have the same name as the
      enclosing class.
    </shortMessage>
    <info>
      Non-constructor methods should not have the same name as the
      enclosing class.
    </info>
    <name>Method With Same Name As Enclosing Class</name>
  </findingType>

  <findingType>
    <id>SuspiciousConstantFieldName</id>
    <artifact tool="PMD" mnemonic="SuspiciousConstantFieldName">
    </artifact>
    <shortMessage>
      A field name is all in uppercase characters, which in Sun's
      Java naming conventions indicate a constant. However, the
      field is not final.
    </shortMessage>
    <info>
      A field name is all in uppercase characters, which in Sun's
      Java naming conventions indicate a constant. However, the
      field is not final.
    </info>
    <name>Suspicious Constant Field Name</name>
  </findingType>

  <findingType>
    <id>AvoidFieldNameMatchingTypeName</id>
    <artifact tool="PMD"
	      mnemonic="AvoidFieldNameMatchingTypeName">
    </artifact>
    <shortMessage>
      It is somewhat confusing to have a field name matching the
      declaring class name. This probably means that type and or
      field names could be more precise.
    </shortMessage>
    <info>
      It is somewhat confusing to have a field name matching the
      declaring class name. This probably means that type and or
      field names could be more precise.
    </info>
    <name>Avoid Field Name Matching Type Name</name>
  </findingType>
  <findingType>
    <id>AvoidFieldNameMatchingMethodName</id>
    <artifact tool="PMD"
	      mnemonic="AvoidFieldNameMatchingMethodName">
    </artifact>
    <shortMessage>
      It is somewhat confusing to have a field name with the same
      name as a method. While this is totally legal, having
      information (field) and actions (method) is not clear
      naming.
    </shortMessage>
    <info>
      It is somewhat confusing to have a field name with the same
      name as a method. While this is totally legal, having
      information (field) and actions (method) is not clear
      naming.
    </info>
    <name>Avoid Field Name Matching Method Name</name>
  </findingType>
  <findingType>
    <id>NoPackage</id>
    <artifact tool="PMD" mnemonic="NoPackage"></artifact>
    <shortMessage>
      Detects when a class or interface does not have a package
      definition.
    </shortMessage>
    <info>
      Detects when a class or interface does not have a package
      definition.
    </info>
    <name>No Package</name>
  </findingType>
  <findingType>
    <id>PackageCase</id>
    <artifact tool="PMD" mnemonic="PackageCase"></artifact>
    <shortMessage>
      Detects when a package definition contains upper case
      characters.
    </shortMessage>
    <info>
      Detects when a package definition contains upper case
      characters.
    </info>
    <name>Package Case</name>
  </findingType>
  <findingType>
    <id>MisleadingVariableName</id>
    <artifact tool="PMD" mnemonic="MisleadingVariableName">
    </artifact>
    <shortMessage>
      Detects when a non-field has a name starting with 'm_'. This
      usually indicates a field and thus is confusing.
    </shortMessage>
    <info>
      Detects when a non-field has a name starting with 'm_'. This
      usually indicates a field and thus is confusing.
    </info>
    <name>Misleading Variable Name</name>
  </findingType>
  <findingType>
    <id>BooleanGetMethodName</id>
    <artifact tool="PMD" mnemonic="BooleanGetMethodName"></artifact>
    <shortMessage>
      Looks for methods named 'getX()' with 'boolean' as the
      return type. The convention is to name these methods
      'isX()'.
    </shortMessage>
    <info>
      Looks for methods named 'getX()' with 'boolean' as the
      return type. The convention is to name these methods
      'isX()'.
    </info>
    <name>Boolean Get Method Name</name>
  </findingType>
  <findingType>
    <id>LocalVariableCouldBeFinal</id>
    <artifact tool="PMD" mnemonic="LocalVariableCouldBeFinal">
    </artifact>
    <shortMessage>
      A local variable assigned only once can be declared final.
    </shortMessage>
    <info>
      A local variable assigned only once can be declared final.
    </info>
    <name>Local Variable Could Be Final</name>
  </findingType>
  <findingType>
    <id>MethodArgumentCouldBeFinal</id>
    <artifact tool="PMD" mnemonic="MethodArgumentCouldBeFinal">
    </artifact>
    <shortMessage>
      A method argument that is never assigned can be declared
      final.
    </shortMessage>
    <info>
      A method argument that is never assigned can be declared
      final.
    </info>
    <name>Method Argument Could Be Final</name>
  </findingType>
  <findingType>
    <id>AvoidInstantiatingObjectsInLoops</id>
    <artifact tool="PMD"
	      mnemonic="AvoidInstantiatingObjectsInLoops">
    </artifact>
    <shortMessage>
      Detects when a new object is created inside a loop
    </shortMessage>
    <info>Detects when a new object is created inside a loop</info>
    <name>Avoid Instantiating Objects In Loops</name>
  </findingType>
  <findingType>
    <id>UseArrayListInsteadOfVector</id>
    <artifact tool="PMD" mnemonic="UseArrayListInsteadOfVector">
    </artifact>
    <shortMessage>
      ArrayList is a much better Collection implementation than
      Vector.
    </shortMessage>
    <info>
      ArrayList is a much better Collection implementation than
      Vector.
    </info>
    <name>Use Array List Instead Of Vector</name>
  </findingType>
  <findingType>
    <id>SimplifyStartsWith</id>
    <artifact tool="PMD" mnemonic="SimplifyStartsWith"></artifact>
    <shortMessage>
      Since it passes in a literal of length 1, this call to
      String.startsWith can be rewritten using String.charAt(0) to
      save some time.
    </shortMessage>
    <info>
      Since it passes in a literal of length 1, this call to
      String.startsWith can be rewritten using String.charAt(0) to
      save some time.
    </info>
    <name>Simplify Starts With</name>
  </findingType>

  <findingType>
    <id>UseArraysAsList</id>
    <artifact tool="PMD" mnemonic="UseArraysAsList"></artifact>
    <shortMessage>
      The class java.util.Arrays has a &quot;asList&quot; method
      that should be use when you want to create a new List from
      an array of objects. It is faster than executing a loop to
      cpy all the elements of the array one by one
    </shortMessage>
    <info>
      The class java.util.Arrays has a &quot;asList&quot; method
      that should be use when you want to create a new List from
      an array of objects. It is faster than executing a loop to
      cpy all the elements of the array one by one
    </info>
    <name>Use Arrays As List</name>
  </findingType>
  <findingType>
    <id>AvoidArrayLoops</id>
    <artifact tool="PMD" mnemonic="AvoidArrayLoops"></artifact>
    <shortMessage>
      Instead of copying data between two arrays, use
      System.arraycopy method
    </shortMessage>
    <info>
      Instead of copying data between two arrays, use
      System.arraycopy method
    </info>
    <name>Avoid Array Loops</name>
  </findingType>
  <findingType>
    <id>UnnecessaryWrapperObjectCreation</id>
    <artifact tool="PMD"
	      mnemonic="UnnecessaryWrapperObjectCreation">
    </artifact>
    <shortMessage>
      Parsing method should be called directy instead.
    </shortMessage>
    <info>Parsing method should be called directy instead.</info>
    <name>Unnecessary Wrapper Object Creation</name>
  </findingType>
  <findingType>
    <id>AddEmptyString</id>
    <artifact tool="PMD" mnemonic="AddEmptyString"></artifact>
    <shortMessage>
      Finds empty string literals which are being added. This is
      an inefficient way to convert any type to a String.
    </shortMessage>
    <info>
      Finds empty string literals which are being added. This is
      an inefficient way to convert any type to a String.
    </info>
    <name>Add Empty String</name>
  </findingType>
  <findingType>
    <id>AvoidCatchingThrowable</id>
    <artifact tool="PMD" mnemonic="AvoidCatchingThrowable">
    </artifact>
    <shortMessage>
      This is dangerous because it casts too wide a net; it can
      catch things like OutOfMemoryError.
    </shortMessage>
    <info>
      This is dangerous because it casts too wide a net; it can
      catch things like OutOfMemoryError.
    </info>
    <name>Avoid Catching Throwable</name>
  </findingType>
  <findingType>
    <id>SignatureDeclareThrowsException</id>
    <artifact tool="PMD"
	      mnemonic="SignatureDeclareThrowsException">
    </artifact>
    <shortMessage>
      It is unclear which exceptions that can be thrown from the
      methods. It might be difficult to document and understand
      the vague interfaces. Use either a class derived from
      RuntimeException or a checked exception.
    </shortMessage>
    <info>
      It is unclear which exceptions that can be thrown from the
      methods. It might be difficult to document and understand
      the vague interfaces. Use either a class derived from
      RuntimeException or a checked exception.
    </info>
    <name>Signature Declare Throws Exception</name>
  </findingType>
  <findingType>
    <id>ExceptionAsFlowControl</id>
    <artifact tool="PMD" mnemonic="ExceptionAsFlowControl">
    </artifact>
    <shortMessage>
      Using Exceptions as flow control leads to GOTOish code and
      obscures true exceptions when debugging.
    </shortMessage>
    <info>
      Using Exceptions as flow control leads to GOTOish code and
      obscures true exceptions when debugging.
    </info>
    <name>Exception As Flow Control</name>
  </findingType>
  <findingType>
    <id>AvoidCatchingNPE</id>
    <artifact tool="PMD" mnemonic="AvoidCatchingNPE"></artifact>
    <shortMessage>
      Code should never throw NPE under normal circumstances. A
      catch block may hide the original error, causing other more
      subtle errors in its wake.
    </shortMessage>
    <info>
      Code should never throw NPE under normal circumstances. A
      catch block may hide the original error, causing other more
      subtle errors in its wake.
    </info>
    <name>Avoid Catching NullPointerException</name>
  </findingType>
  <findingType>
    <id>AvoidThrowingRawExceptionTypes</id>
    <artifact tool="PMD"
	      mnemonic="AvoidThrowingRawExceptionTypes">
    </artifact>
    <shortMessage>
      Avoid throwing certain exception types. Rather than throw a
      raw RuntimeException, Throwable, Exception, or Error, use a
      subclassed exception or error instead.
    </shortMessage>
    <info>
      Avoid throwing certain exception types. Rather than throw a
      raw RuntimeException, Throwable, Exception, or Error, use a
      subclassed exception or error instead.
    </info>
    <name>Avoid Throwing Raw Exception Types</name>
  </findingType>
  <findingType>
    <id>AvoidThrowingNullPointerException</id>
    <artifact tool="PMD"
	      mnemonic="AvoidThrowingNullPointerException">
    </artifact>
    <shortMessage>
      Avoid throwing a NullPointerException - it's confusing
      because most people will assume that the virtual machine
      threw it. Consider using an IllegalArgumentException
      instead; this will be clearly seen as a programmer-initiated
      exception.
    </shortMessage>
    <info>
      Avoid throwing a NullPointerException - it's confusing
      because most people will assume that the virtual machine
      threw it. Consider using an IllegalArgumentException
      instead; this will be clearly seen as a programmer-initiated
      exception.
    </info>
    <name>Avoid Throwing NullPointerException</name>
  </findingType>
  <findingType>
    <id>AvoidRethrowingException</id>
    <artifact tool="PMD" mnemonic="AvoidRethrowingException">
    </artifact>
    <shortMessage>
      Catch blocks that merely rethrow a caught exception only add
      to code size and runtime complexity.
    </shortMessage>
    <info>
      Catch blocks that merely rethrow a caught exception only add
      to code size and runtime complexity.
    </info>
    <name>Avoid Rethrowing Exception</name>
  </findingType>
  <findingType>
    <id>DoNotExtendJavaLangError</id>
    <artifact tool="PMD" mnemonic="DoNotExtendJavaLangError">
    </artifact>
    <shortMessage>
      Errors are system exceptions. Do not extend them.
    </shortMessage>
    <info>Errors are system exceptions. Do not extend them.</info>
    <name>Do Not Extend java.lang.Error</name>
  </findingType>
  <findingType>
    <id>AvoidDuplicateLiterals</id>
    <artifact tool="PMD" mnemonic="AvoidDuplicateLiterals">
    </artifact>
    <shortMessage>
      Code containing duplicate String literals can usually be
      improved by declaring the String as a constant field.
    </shortMessage>
    <info>
      Code containing duplicate String literals can usually be
      improved by declaring the String as a constant field.
    </info>
    <name>Avoid Duplicate Literals</name>
  </findingType>

  <findingType>
    <id>StringToString</id>
    <artifact tool="PMD" mnemonic="StringToString"></artifact>
    <shortMessage>
      Avoid calling toString() on String objects; this is
      unnecessary.
    </shortMessage>
    <info>
      Avoid calling toString() on String objects; this is
      unnecessary.
    </info>
    <name>Call to toString() on a String</name>
  </findingType>
  <findingType>
    <id>InefficientStringBuffering</id>
    <artifact tool="PMD" mnemonic="InefficientStringBuffering">
    </artifact>
    <shortMessage>
      Avoid concatenating non literals in a StringBuffer
      constructor or append().
    </shortMessage>
    <info>
      Avoid concatenating non literals in a StringBuffer
      constructor or append().
    </info>
    <name>Inefficient String Buffering</name>
  </findingType>
  <findingType>
    <id>UnnecessaryCaseChange</id>
    <artifact tool="PMD" mnemonic="UnnecessaryCaseChange">
    </artifact>
    <shortMessage>
      Using equalsIgnoreCase() is faster than using
      toUpperCase/toLowerCase().equals()
    </shortMessage>
    <info>
      Using equalsIgnoreCase() is faster than using
      toUpperCase/toLowerCase().equals()
    </info>
    <name>Unnecessary Case Change</name>
  </findingType>
  <findingType>
    <id>UseStringBufferLength</id>
    <artifact tool="PMD" mnemonic="UseStringBufferLength">
    </artifact>
    <shortMessage>
      Use StringBuffer.length() to determine StringBuffer length
      rather than using
      StringBuffer.toString().equals(&quot;&quot;) or
      StringBuffer.toString().length() ==.
    </shortMessage>
    <info>
      Use StringBuffer.length() to determine StringBuffer length
      rather than using
      StringBuffer.toString().equals(&quot;&quot;) or
      StringBuffer.toString().length() ==.
    </info>
    <name>Use String Buffer Length</name>
  </findingType>
  <findingType>
    <id>AppendCharacterWithChar</id>
    <artifact tool="PMD" mnemonic="AppendCharacterWithChar">
    </artifact>
    <shortMessage>
      Avoid concatenating characters as strings in
      StringBuffer.append.
    </shortMessage>
    <info>
      Avoid concatenating characters as strings in
      StringBuffer.append.
    </info>
    <name>Append Character With Char</name>
  </findingType>
  <findingType>
    <id>ConsecutiveLiteralAppends</id>
    <artifact tool="PMD" mnemonic="ConsecutiveLiteralAppends">
    </artifact>
    <shortMessage>
      Consecutively calling StringBuffer.append with String
      literals
    </shortMessage>
    <info>
      Consecutively calling StringBuffer.append with String
      literals
    </info>
    <name>Consecutive Literal Appends</name>
  </findingType>
  <findingType>
    <id>UseIndexOfChar</id>
    <artifact tool="PMD" mnemonic="UseIndexOfChar"></artifact>
    <shortMessage>
      Use String.indexOf(char) when checking for the index of a
      single character; it executes faster.
    </shortMessage>
    <info>
      Use String.indexOf(char) when checking for the index of a
      single character; it executes faster.
    </info>
    <name>Use Index Of Char</name>
  </findingType>
  <findingType>
    <id>InefficientEmptyStringCheck</id>
    <artifact tool="PMD" mnemonic="InefficientEmptyStringCheck">
    </artifact>
    <shortMessage>
      String.trim().length() is an inefficient way to check if a
      String is really empty, as it creates a new String object
      just to check its size. Consider creating a static function
      that loops through a string, checking
      Character.isWhitespace() on each character and returning
      false if a non-whitespace character is found.
    </shortMessage>
    <info>
      String.trim().length() is an inefficient way to check if a
      String is really empty, as it creates a new String object
      just to check its size. Consider creating a static function
      that loops through a string, checking
      Character.isWhitespace() on each character and returning
      false if a non-whitespace character is found.
    </info>
    <name>Inefficient Empty String Check</name>
  </findingType>
  <findingType>
    <id>InsufficientStringBufferDeclaration</id>
    <artifact tool="PMD"
	      mnemonic="InsufficientStringBufferDeclaration">
    </artifact>
    <shortMessage>
      Failing to pre-size a StringBuffer properly could cause it
      to re-size many times during runtime. This rule checks the
      characters that are actually passed into
      StringBuffer.append(), but represents a best guess
      &quot;worst case&quot; scenario. An empty StringBuffer
      constructor initializes the object to 16 characters. This
      default is assumed if the length of the constructor can not
      be determined.
    </shortMessage>
    <info>
      Failing to pre-size a StringBuffer properly could cause it
      to re-size many times during runtime. This rule checks the
      characters that are actually passed into
      StringBuffer.append(), but represents a best guess
      &quot;worst case&quot; scenario. An empty StringBuffer
      constructor initializes the object to 16 characters. This
      default is assumed if the length of the constructor can not
      be determined.
    </info>
    <name>Insufficient String Buffer Declaration</name>
  </findingType>
  <findingType>
    <id>UselessStringValueOf</id>
    <artifact tool="PMD" mnemonic="UselessStringValueOf"></artifact>
    <shortMessage>
      No need to call String.valueOf to append to a string; just
      use the valueOf() argument directly.
    </shortMessage>
    <info>
      No need to call String.valueOf to append to a string; just
      use the valueOf() argument directly.
    </info>
    <name>Useless String.valueOf</name>
  </findingType>
  <findingType>
    <id>StringBufferInstantiationWithChar</id>
    <artifact tool="PMD"
	      mnemonic="StringBufferInstantiationWithChar">
    </artifact>
    <shortMessage>
      StringBuffer sb = new StringBuffer('c'); The char will be
      converted into int to intialize StringBuffer size.
    </shortMessage>
    <info>
      StringBuffer sb = new StringBuffer('c'); The char will be
      converted into int to intialize StringBuffer size.
    </info>
    <name>String Buffer Instantiation With Char</name>
  </findingType>
  <findingType>
    <id>MethodReturnsInternalArray</id>
    <artifact tool="PMD" mnemonic="MethodReturnsInternalArray">
    </artifact>
    <shortMessage>
      Exposing internal arrays directly allows the user to modify
      some code that could be critical. It is safer to return a
      copy of the array.
    </shortMessage>
    <info>
      Exposing internal arrays directly allows the user to modify
      some code that could be critical. It is safer to return a
      copy of the array.
    </info>
    <name>Method Returns Internal Array</name>
  </findingType>
  <findingType>
    <id>ArrayIsStoredDirectly</id>
    <artifact tool="PMD" mnemonic="ArrayIsStoredDirectly">
    </artifact>
    <shortMessage>
      Constructors and methods receiving arrays should clone
      objects and store the copy. This prevents that future
      changes from the user affect the internal functionality.
    </shortMessage>
    <info>
      Constructors and methods receiving arrays should clone
      objects and store the copy. This prevents that future
      changes from the user affect the internal functionality.
    </info>
    <name>Array Is Stored Directly</name>
  </findingType>

  <findingType>
    <id>UnusedLocalVariable</id>
    <artifact tool="PMD" mnemonic="UnusedLocalVariable"></artifact>
    <shortMessage>
      Detects when a local variable is declared and/or assigned,
      but not used.
    </shortMessage>
    <info>
      Detects when a local variable is declared and/or assigned,
      but not used.
    </info>
    <name>Unused Local Variable</name>
  </findingType>
  <findingType>
    <id>UnusedPrivateMethod</id>
    <artifact tool="PMD" mnemonic="UnusedPrivateMethod"></artifact>
    <shortMessage>
      Unused Private Method detects when a private method is
      declared but is unused.
    </shortMessage>
    <info>
      Unused Private Method detects when a private method is
      declared but is unused.
    </info>
    <name>Unused Private Method</name>
  </findingType>
  <findingType>
    <id>UnusedFormalParameter</id>
    <artifact tool="PMD" mnemonic="UnusedFormalParameter">
    </artifact>
    <shortMessage>
      Avoid passing parameters to methods or constructors and then
      not using those parameters.
    </shortMessage>
    <info>
      Avoid passing parameters to methods or constructors and then
      not using those parameters.
    </info>
    <name>Unused Formal Parameter</name>
  </findingType>

  <findingType>
    <id>OverrideBothEqualsAndHashcode</id>
    <artifact tool="PMD" mnemonic="OverrideBothEqualsAndHashcode">
    </artifact>
    <shortMessage>
      Override both public boolean Object.equals(Object other),
      and public int Object.hashCode(), or override neither. Even
      if you are inheriting a hashCode() from a parent class,
      consider implementing hashCode and explicitly delegating to
      your superclass.
    </shortMessage>
    <info>
      Override both public boolean Object.equals(Object other),
      and public int Object.hashCode(), or override neither. Even
      if you are inheriting a hashCode() from a parent class,
      consider implementing hashCode and explicitly delegating to
      your superclass.
    </info>
    <name>Override Both Equals And Hashcode</name>
  </findingType>
  <!-- This finding type is no longer in use -->
  <findingType>
    <id>StringInstantiation</id>
    <shortMessage>
      Avoid instantiating String objects; this is usually
      unnecessary.
    </shortMessage>
    <info>
      Avoid instantiating String objects; this is usually
      unnecessary.
    </info>
    <name>String Instantiation</name>
  </findingType>
  
  <!-- For PMD 4.1 -->
  <findingType>
    <id>AvoidUsingHardCodedIP</id>
    <artifact tool="PMD"
	      mnemonic="AvoidUsingHardCodedIP">
    </artifact>
    <shortMessage>Avoid using hard-coded IP address</shortMessage>
    <info>

      &lt;p&gt; An application with hard coded IP may become impossible to deploy in some cases. 
      It never hurts to externalize IP addresses. &lt;/p&gt;
      
      &lt;p&gt; . &lt;/p&gt;

    </info>
    <name>Avoid Using Hardcoded IP Addresses</name>
  </findingType>	
  <findingType>
    <id>CheckResultSet</id>
    <artifact tool="PMD"
	      mnemonic="CheckResultSet">
    </artifact>
    <shortMessage>Check the return values from methods on ResultSet</shortMessage>
    <info> &lt;p&gt; Always check the return value from calling 
    ResultSet.{next,previous,first,last}.  If the return value is 'false', 
    the developer should deal with it. &lt;/p&gt;
    </info>
    <name>Check Return Values from ResultSet Methods</name>
  </findingType>		
  <findingType>
    <id>AvoidFinalLocalVariable</id>
    <artifact tool="PMD"
	      mnemonic="AvoidFinalLocalVariable">
    </artifact>
    <shortMessage>
      Avoid using final local variables 
    </shortMessage>
    <info>

      &lt;p&gt; Instead, use fields. &lt;/p&gt;

    </info>
    <name>Avoid Final Local Variables</name>
  </findingType>	
  <findingType>
    <id>AvoidUsingShortType</id>
    <artifact tool="PMD"
	      mnemonic="AvoidUsingShortType">
    </artifact>
    <shortMessage>
      Avoid using the "short" type
    </shortMessage>
    <info>

      &lt;p&gt; Java uses the short type to reduce memory usage, not to optimize
      calculation. On the contrary, the JVM does not has any arithmetic capabilities
      with the "short" type, so it must convert the short into int, then do the proper 
      calculation and then convert int back to short. Therefore, use of the "short" type
      may actually take more time
      &lt;/p&gt;

    </info>
    <name>Avoid Using Short Type</name>
  </findingType>	
  <findingType>
    <id>AvoidUsingVolatile</id>
    <artifact tool="PMD"
	      mnemonic="AvoidUsingVolatile">
    </artifact>
    <shortMessage>
      Avoid using "volatile" fields
    </shortMessage>
    <info>

      &lt;p&gt; The 'volatile' keyword is generally used to fine tune a concurrent Java 
      application, and therefore, requires a expert knowledge of the Java Memory Model. 
      Moreover, it is often misused. Therefore, the 'volatile'	keyword should not be used
      for maintenance purposes and portability. 
      &lt;/p&gt;

    </info>
    <name>Avoid Using Volatile Fields</name>
  </findingType>	
  <findingType>
    <id>AvoidUsingNativeCode</id>
    <artifact tool="PMD"
	      mnemonic="AvoidUsingNativeCode">
    </artifact>
    <shortMessage>
      Avoid using native code
    </shortMessage>
    <info>

      &lt;p&gt; 
      The JVM and Java language allows for a wide range of functionality, so it should be
      very rare to have to rely on non-Java code, and in particular, on the 
      Java Native Interface (JNI).  Since the use of JNI often makes an application 
      less portable, and harder to maintain, it is not recommended. &lt;/p&gt;

    </info>
    <name>Avoid Using Native Code</name>
  </findingType>	
  <findingType>
    <id>AvoidAccessibilityAlteration</id>
    <artifact tool="PMD"
	      mnemonic="AvoidAccessibilityAlteration">
    </artifact>
    <shortMessage>
      Avoid changing class/method accessibility at runtime
    </shortMessage>
    <info>

      &lt;p&gt; 		
      Methods in java.lang.reflect, such as getDeclaredConstructors(), 
      getDeclaredConstructor(Class[]) and setAccessible(), allow someone to alter, 
      at runtime, the accessibility of fields, classes, or methods, even if they 
      are private. &lt;/p&gt;

    </info>
    <name>Avoid Changing Class/Method Accessibility At Runtime</name>
  </findingType>	
  <findingType>
    <id>ClassWithOnlyPrivateConstructorsShouldBeFinal</id>
    <artifact tool="PMD"
	      mnemonic="ClassWithOnlyPrivateConstructorsShouldBeFinal">
    </artifact>
    <shortMessage>
      A class which only has private constructors should be final
    </shortMessage>
    <info>

      &lt;p&gt; A class with only private constructors should be final, 
      unless the private constructor is called by a inner class. &lt;/p&gt;

    </info>
    <name>Class With Only Private Constructors Should Be Final</name>
  </findingType>	
  <findingType>
    <id>EmptyMethodInAbstractClassShouldBeAbstract</id>
    <artifact tool="PMD"
	      mnemonic="EmptyMethodInAbstractClassShouldBeAbstract">
    </artifact>
    <shortMessage>
      An empty method in an abstract class should instead be abstract
    </shortMessage>
    <info>

      &lt;p&gt; An empty method in an abstract class should instead be abstract,
      as developer may rely on this empty implementation, rather than code an 
      appropriate one. 
      &lt;/p&gt;

    </info>
    <name>Empty Method In Abstract Class Should Be Abstract</name>
  </findingType>	
  <findingType>
    <id>TooManyStaticImports</id>
    <artifact tool="PMD"
	      mnemonic="TooManyStaticImports">
    </artifact>
    <shortMessage>
      Too many static imports may lead to messy code
    </shortMessage>
    <info>

      &lt;p&gt; If you overuse the static import feature, it can make your program
      unreadable and unmaintainable, polluting its namespace with all the static 
      members you import.  Readers of your code (including you, a few months after
      you wrote it) will not know which class a static member comes from (Sun 1.5 
      Language Guide). 
      &lt;/p&gt;

    </info>
    <name>Too Many Static Imports</name>
  </findingType>	
  <findingType>
    <id>DoNotCallSystemExit</id>
    <artifact tool="PMD"
	      mnemonic="DoNotCallSystemExit">
    </artifact>
    <shortMessage>
      System.exit() should not be used in J2EE/JEE apps
    </shortMessage>
    <info>

      &lt;p&gt; Web applications should not call System.exit(), 
      since only the web container or the application server should stop the JVM. &lt;/p&gt;

    </info>
    <name>Do Not Call System.exit()</name>
  </findingType>	
  <findingType>
    <id>StaticEJBFieldShouldBeFinal</id>
    <artifact tool="PMD"
	      mnemonic="StaticEJBFieldShouldBeFinal">
    </artifact>
    <shortMessage>
      EJB's shouldn't have non-final static fields
    </shortMessage>
    <info>

      &lt;p&gt; According to the J2EE specification (p.494), an EJB should not have
      any static fields with write access. However, static read-only fields are allowed. 
      This ensures proper behavior, especially when instances are distributed by the 
      container on several JREs.. &lt;/p&gt;

    </info>
    <name>Static EJB Fields Should Be Final</name>
  </findingType>	
  <findingType>
    <id>DoNotUseThreads</id>
    <artifact tool="PMD"
	      mnemonic="DoNotUseThreads">
    </artifact>
    <shortMessage>
      To be J2EE-compliant, a web app should not use any threads
    </shortMessage>
    <info>

      &lt;p&gt; The J2EE specification explicitly forbid use of threads. &lt;/p&gt;

    </info>
    <name>Do Not Use Threads</name>
  </findingType>	

  <!-- For PMD 4.2 -->
  <findingType>
    <id>AvoidMultipleUnaryOperators</id>
    <artifact tool="PMD" mnemonic="AvoidMultipleUnaryOperators">
    </artifact>
    <shortMessage>Avoid using multiple unary operators</shortMessage>
    <info>
      &lt;p&gt; Using multiple unary operators may be a bug, and/or is confusing.  
      Check that the usage is not a bug, or consider simplifying the expression.
      For more info, see http://pmd.sourceforge.net/rules/basic.html#AvoidMultipleUnaryOperators
      &lt;/p&gt;
    </info>
    <name>Avoid Using Multiple Unary Operators</name>
  </findingType>	
  <findingType>
    <id>TooManyMethods</id>
    <artifact tool="PMD" mnemonic="TooManyMethods">
    </artifact>
    <shortMessage>Class has too many methods</shortMessage>
    <info>
      &lt;p&gt; A class with too many methods is probably a good suspect for refactoring,
      in order to reduce its complexity and find a way to have more fine grained objects.
      &lt;/p&gt;
    </info>
    <name>Avoid Classes with Too Many Methods</name>
  </findingType>		
  <findingType>
    <id>AbstractClassWithoutAnyMethod</id>
    <artifact tool="PMD" mnemonic="AbstractClassWithoutAnyMethod">
    </artifact>
    <shortMessage>No abstract methods in abstract class</shortMessage>
    <info>
      &lt;p&gt; If the abstract class does not provides any methods, 
      it may be just a data container
      that is not to be instantiated. In this case, it's probably
      better to use a private or a protected constructor in order to 
      prevent instantiation than make the class misleadingly abstract.
      . &lt;/p&gt;
    </info>
    <name>No Abstract Methods in Abstract Class</name>
  </findingType>				
  <findingType>
    <id>TooFewBranchesForASwitchStatement</id>
    <artifact tool="PMD" mnemonic="TooFewBranchesForASwitchStatement">
    </artifact>
    <shortMessage>Avoid using hard-coded IP address</shortMessage>
    <info>
      &lt;p&gt; Switch statements are designed complex branches, and allow branches
      to share treatment. Using a switch for only 2	branches is ill advised, as 
      switches are not as easy to understand as if statements. In this case, it's most likely
      is a good idea to use a if statement instead, at least to increase code readability. 
      &lt;/p&gt;
    </info>
    <name>Avoid Switch Statements with Only A Few Branches</name>
  </findingType>					  	
  <findingType>
    <id>DoNotThrowExceptionInFinally</id>
    <artifact tool="PMD" mnemonic="DoNotThrowExceptionInFinally">
    </artifact>
    <shortMessage>Avoid throwing Exceptions in 'finally' clauses</shortMessage>
    <info>
      &lt;p&gt; Throwing exceptions in a finally block is confusing. 
      It may mask exceptions or a defect of the code, as well as make
      it also render code cleanup unstable.
      Note: This is a PMD implementation of the Lint4j rule "A throw in a finally block" 
      &lt;/p&gt;
    </info>
    <name>Avoid Throwing Exceptions In Finally Clauses</name>
  </findingType>				  	
  <findingType>
    <id>AvoidStringBufferField</id>
    <artifact tool="PMD" mnemonic="AvoidStringBufferField">
    </artifact>
    <shortMessage>Avoid keeping StringBuffers as a field</shortMessage>
    <info>
      &lt;p&gt; StringBuffers can grow quite a lot, and so may become a source of memory leaks 
      (if the owning class has a long life time). &lt;/p&gt;
    </info>
    <name>Avoid StringBuffer-typed Fields</name>
  </findingType>
</findingTypes>
