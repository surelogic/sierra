<?xml version="1.0" encoding="UTF-8"?>
<findingTypes>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <!-- NOTES:                                                                        -->
  <!-- o No whitespace in "name" or "shortMessage" tags                              -->
  <!-- o Sentence case in "name" tags                                                -->
  <!-- o Sentences in "shortMessage" tags (no HTML)                                  -->
  <!-- o Use CDATA for "info" tags with HTML; do NOT indent CDATA sections           -->
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DuplicatedCode</id>
    <artifact tool="CPD" mnemonic="DuplicatedCode"/>
    <name>Suspected duplicated code</name>
    <shortMessage>Duplicated code often causes problems in long-term maintenance, due to flaws being fixed in one copy, but not the other.</shortMessage>
    <info><![CDATA[<p>This is often due to copy-and-paste programming, and it
often causes problems in long-term maintenance, due to flaws being
fixed in one copy, but not the other.</p>

<p>Consider refactoring this duplicated code into a single
method.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DMI_VACUOUS_CALL_TO_EASYMOCK_METHOD</id>
    <artifact tool="FindBugs" mnemonic="DMI_VACUOUS_CALL_TO_EASYMOCK_METHOD"/>
    <name>Useless/vacuous call to EasyMock method</name>
    <shortMessage>Useless/vacuous call to EasyMock method.</shortMessage>
    <info>
<![CDATA[<p>This call doesn't pass any objects to the EasyMock method,
so the call doesn't do anything.</p>

<p>EasyMock provides Mock Objects for interfaces in JUnit tests by
generating them on the fly using Java's proxy mechanism.  For more
information please visit <a
href="http://www.easymock.org/">www.easymock.org</a>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>HE_SIGNATURE_DECLARES_HASHING_OF_UNHASHABLE_CLASS</id>
    <artifact tool="FindBugs" mnemonic="HE_SIGNATURE_DECLARES_HASHING_OF_UNHASHABLE_CLASS"/>
    <name>Signature declares use of unhashable class in hashed construct</name>
    <shortMessage>Signature declares use of unhashable class in hashed construct.</shortMessage>
    <info>
<![CDATA[<p> A method, field or class declares a generic signature
where a non-hashable class is used in context where a hashable class
is required.  A class that declares an <code>equals()</code> method
but inherits a <code>hashCode()</code> method from
<code>java.lang.Object</code> is unhashable, since it doesn't fulfill
the requirement that equal objects have equal hash codes.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>GC_UNCHECKED_TYPE_IN_GENERIC_CALL</id>
    <artifact tool="FindBugs" mnemonic="GC_UNCHECKED_TYPE_IN_GENERIC_CALL"/>
    <name>Unchecked type in generic call</name>
    <shortMessage>Unchecked type in a generic call.  This could be a type mismatch that the compiler is not able to detect.</shortMessage>
    <info>
<![CDATA[<p>This call to a generic collection method passes an
argument of compile type <code>Object</code> where a specific type
from the generic type parameters is expected.  Thus, neither the
standard Java type system nor static analysis can provide useful
information on whether the object being passed as a parameter is of an
appropriate type.</p>

<p>An example of this finding is shown in the code snippet below.</p>

<pre>
final Object o = "1";
Set&lt;Integer&gt; intSet = new HashSet&lt;Integer&gt;();
intSet.remove(o);
</pre>

<p>In this case the call to remove <code>o</code> from the set
compiles because the <code>remove()</code> method takes an argument of
type <code>Object</code> rather than of the generic type (for
backwards compatibility).  In this example the call to
<code>remove()</code> can be safely deleted.  In general, it is
recommended to examine the finding and determine if it has identified
a type mismatch that the compiler was not able to report.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SW_SWING_METHODS_INVOKED_IN_SWING_THREAD</id>
    <artifact tool="FindBugs" mnemonic="SW_SWING_METHODS_INVOKED_IN_SWING_THREAD"/>
    <name>Swing methods should be invoked in Swing thread</name>
    <shortMessage>Certain Swing methods need to be invoked in the Swing event dispatch thread.</shortMessage>
    <info>
<![CDATA[<p>(<a
href="http://java.sun.com/developer/JDCTechTips/2003/tt1208.html#1">From
JDC Tech Tips</a>): The Swing methods <code>show()</code>,
<code>setVisible()</code>, and <code>pack()</code> will create the
associated peer for the frame. With the creation of the peer, the
system creates the event dispatch thread. This makes things
problematic because the event dispatch thread could be notifying
listeners while pack and validate are still processing. This situation
could result in two threads going through the Swing component-based
GUI&mdash;it's a serious flaw that could result in deadlocks or other
related threading issues. A pack call causes components to be
realized. As they are being realized (that is, not necessarily
visible), they could trigger listener notification on the event
dispatch thread.</p>

<p>Recommendations for thread safety have changed slightly since this
article was written. It is now recommended that you use
<code>invokeLater()</code> to create the GUI on the event-dispatching
thread, rather than constructing the GUI on the main thread.  So the
below code violates this recommendation.</p>

<pre>
import javax.swing.JButton;
import javax.swing.JFrame;

public class GUI extends JFrame {

  public GUI() {
    super("GUI");
    setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
    final JButton button = new JButton("Hello, Swing!");
    add(button);
    pack();
  }

  public static void main(String[] args) {
    final GUI gui = new GUI();
    gui.setVisible(true);
 }
}
</pre>

<p>At issue is the construction of the Swing objects and the call to
<code>setVisible()</code> in the main thread.  The below code fixes
the program by moving these actions onto the event dispatch
thread using the <code>invokeLater()</code> method.</p>

<pre>
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.SwingUtilities;

public class GUI extends JFrame {

  public GUI() {
    super("GUI");
    setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
    final JButton button = new JButton("Hello, Swing!");
    add(button);
    pack();
  }

  public static void main(String[] args) {
    SwingUtilities.invokeLater(new Runnable() {
      @Override public void run() {
        final GUI gui = new GUI();
        gui.setVisible(true);
      }
    });
  }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>IL_INFINITE_LOOP</id>
    <artifact tool="FindBugs" mnemonic="IL_INFINITE_LOOP">
    </artifact>
    <name>Caught infinite loop</name>
    <shortMessage>An apparent infinite loop that doesn't seem to have a way to terminate.</shortMessage>
    <info>
<![CDATA[<p>This loop doesn't seem to have a way to terminate (other
than by perhaps throwing an exception).</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>IL_INFINITE_RECURSIVE_LOOP</id>
    <artifact tool="FindBugs"
	      mnemonic="IL_INFINITE_RECURSIVE_LOOP">
    </artifact>
    <name>Caught infinite recursive loop</name>
    <shortMessage>An apparent infinite recursive loop that could result in a stack overflow.</shortMessage>
    <info>
<![CDATA[<p>This method unconditionally invokes itself. This would
seem to indicate an infinite recursive loop that will result in a
stack overflow.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>IL_CONTAINER_ADDED_TO_ITSELF</id>
    <artifact tool="FindBugs"
	      mnemonic="IL_CONTAINER_ADDED_TO_ITSELF">
    </artifact>
    <name>Container added to itself</name>
    <shortMessage>A container is added to itself, computing its hash code could throw a StackOverflowException.</shortMessage>
    <info>
<![CDATA[<p>A container is added to itself. As a result, computing the
hash code via <code>hashCode()</code> will throw a
StackOverflowException.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>VO_VOLATILE_REFERENCE_TO_ARRAY</id>
    <artifact tool="FindBugs"
	      mnemonic="VO_VOLATILE_REFERENCE_TO_ARRAY">
    </artifact>
    <name>Volatile reference to array</name>
    <shortMessage>A volatile reference to an array doesn't treat the array elements as volatile.  This could indicate a race condition.</shortMessage>
    <info>
<![CDATA[<p>This declares a volatile reference to an array, which
might not be what you want. With a volatile reference to an array,
reads and writes of the reference to the array are treated as
volatile, but the array elements are non-volatile. To get volatile
array elements, you will need to use one of the atomic array classes
in java.util.concurrent (provided in Java 5.0).<p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UI_INHERITANCE_UNSAFE_GETRESOURCE</id>
    <artifact tool="FindBugs"
	      mnemonic="UI_INHERITANCE_UNSAFE_GETRESOURCE"/>
    <name>Unsafe inheritance of the getResource method</name>
    <shortMessage>Usage of the getResource method may be unsafe if class is extended.</shortMessage>
    <info>
<![CDATA[<p>Calling <code>this.getClass().getResource(...)</code>
could give results other than expected if this class is extended by a
class in another package.</p>

<p>To prohibit extension of this class it can be declared to be
final.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NP_SYNC_AND_NULL_CHECK_FIELD</id>
    <artifact tool="FindBugs"
	      mnemonic="NP_SYNC_AND_NULL_CHECK_FIELD"/>
    <name>Synchronize and subsequent null check on the same field</name>
    <shortMessage>Synchronize and subsequent null check on the same field could indicate that a NullPointerException may be thrown.</shortMessage>
    <info>
<![CDATA[<p>This field is not likely to be <code>null</code> because
it is currently synchronized on. If the field is <code>null</code>
when it is synchronized then a <code>NullPointerException</code> will
be thrown and the subsequent check would be pointless.</p>

<p>This finding might indicated a muddled design or a lack of
understanding of Java semantics.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AM_CREATES_EMPTY_ZIP_FILE_ENTRY</id>
    <artifact tool="FindBugs"
	      mnemonic="AM_CREATES_EMPTY_ZIP_FILE_ENTRY"/>
    <name>Creates empty Zip file entry</name>
    <shortMessage>Creates an empty Zip file entry</shortMessage>
    <info>
<![CDATA[<p>The code calls <code>putNextEntry()</code>, immediately
followed by a call to <code>closeEntry()</code>.  This results in an
empty ZipFile entry. The contents of the entry should be written to
the ZipFile between the calls to <code>putNextEntry()</code> and
<code>closeEntry()</code>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AM_CREATES_EMPTY_JAR_FILE_ENTRY</id>
    <artifact tool="FindBugs"
	      mnemonic="AM_CREATES_EMPTY_JAR_FILE_ENTRY">
    </artifact>
    <name>Creates empty Jar file entry</name>
    <shortMessage>Creates an empty Jar file entry</shortMessage>
    <info>
<![CDATA[<p>The code calls <code>putNextEntry()</code>, immediately
followed by a call to <code>closeEntry()</code>.  This results in an
empty JarFile entry. The contents of the entry should be written to
the JarFile between the calls to <code>putNextEntry()</code> and
<code>closeEntry()</code>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>IMSE_DONT_CATCH_IMSE</id>
    <artifact tool="FindBugs" mnemonic="IMSE_DONT_CATCH_IMSE"/>
    <name>Avoid catching IllegalMonitorStateException</name>
    <shortMessage>Dubious code that is catching IllegalMonitorStateException may be masking a design flaw in your code.</shortMessage>
    <info>
<![CDATA[<p><code>IllegalMonitorStateException</code> is generally
only thrown in case of a design flaw in your code&mdash;calling wait
or notify on an object you do not hold a lock on.</p>

<p>It is recommended that this catch be removed from your code and the
design flaw fixed.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>FL_MATH_USING_FLOAT_PRECISION</id>
    <artifact tool="FindBugs"
	      mnemonic="FL_MATH_USING_FLOAT_PRECISION"/>
    <name>Avoid using float type for math operations</name>
    <shortMessage>Method performs math using floating point precision, consider using double precision instead.</shortMessage>
    <info>
<![CDATA[<p>The method performs math operations using floating point
precision. Floating point precision is very imprecise.  For example,
16777216.0f + 1.0f = 16777216.0f.</p>

<p>Consider using double precision math instead. To do this change
<code>float</code> type variables to <code>double</code> type
variables and avoid the <code>f</code> prefix on floating point
constants.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>CN_IDIOM</id>
    <artifact tool="FindBugs" mnemonic="CN_IDIOM"/>
    <artifact tool="PMD" mnemonic="CloneMethodMustImplementCloneable"/>
    <name>Clone method must implement Cloneable</name>
    <shortMessage>This class implements Cloneable but does not define or use clone method.</shortMessage>
    <info>
<![CDATA[<p>This class implements the <code>Cloneable</code> interface
but does not define or use the <code>clone()</code> method.  A class
that implements <code>Cloneable</code> is expected to provide a
properly functioning public <code>clone()</code> method.</p>

<p>The method <code>clone()</code> should only be implemented if the
class implements the <code>Cloneable</code> interface with the
exception of a final method that only throws
<code>CloneNotSupportedException</code>.</p>

<p>Overall it is considered bad practice to use the extralinguistic
clone mechanism (reference Bloch's <i>Effective Java</i> (second
edition) item 11).  A copy constructor is one alternative
approach.</p>

<pre>
public MyClass(MyClass o) { ... }
</pre>

<p> A copy factory is another alternative approach.</p>

<pre>
public static MyClass newInstance(MyClass o) { ... }
</pre>

<p>Either one of these alternatives is considered better practice in
modern Java programs.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>CN_IDIOM_NO_SUPER_CALL</id>
    <artifact tool="FindBugs" mnemonic="CN_IDIOM_NO_SUPER_CALL"/>
    <artifact tool="PMD" mnemonic="ProperCloneImplementation"/>
    <name>No super.clone() call in clone method</name>
    <shortMessage>This non-final class defines a clone method that does not call super.clone().</shortMessage>
    <info>
<![CDATA[<p>This non-final class defines a <code>clone()</code> method
that does not call <code>super.clone()</code>. If this class, which we
will call <code>A</code>, is extended by a subclass <code>B</code>,
and the subclass <code>B</code> calls <code>super.clone()</code>, then
it is likely that <code>B</code>'s <code>clone()</code> method will
return an object of type <code>A</code>, which violates the contract
for <code>clone()</code>.</p>

<p>If all <code>clone()</code> methods call
<code>super.clone()</code>, then they are guaranteed to use
<code>Object.clone()</code>, which always returns an object of the
correct type.</p>

<p>Overall it is considered bad practice to use the extralinguistic
clone mechanism (reference Bloch's <i>Effective Java</i> (second
edition) item 11).  A copy constructor is one alternative
approach.</p>

<pre>
public MyClass(MyClass o) { ... }
</pre>

<p> A copy factory is another alternative approach.</p>

<pre>
public static MyClass newInstance(MyClass o) { ... }
</pre>

<p>Either one of these alternatives is considered better practice in
modern Java programs.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NM_FUTURE_KEYWORD_USED_AS_IDENTIFIER</id>
    <artifact tool="FindBugs" mnemonic="NM_FUTURE_KEYWORD_USED_AS_IDENTIFIER"/>
    <artifact tool="FindBugs" mnemonic="NM_FUTURE_KEYWORD_USED_AS_MEMBER_IDENTIFIER"/>
    <artifact tool="PMD" mnemonic="AvoidAssertAsIdentifier"/>
    <artifact tool="PMD" mnemonic="AvoidEnumAsIdentifier"/>
    <name>Use of a future keyword as identifier</name>
    <shortMessage>Use of an identifier that is a keyword in later versions of Java.</shortMessage>
    <info>
<![CDATA[<p>This identifier is a word that is reserved as a keyword in
later versions of Java, and your code will need to be changed in order
for it to compile in later versions of Java. It is recommended that
you change this identifier as soon as possible.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DE_MIGHT_DROP</id>
    <artifact tool="FindBugs" mnemonic="DE_MIGHT_DROP"/>
    <name>Method might drop an exception</name>
    <shortMessage>Method might drop an exception.</shortMessage>
    <info>
<![CDATA[<p>This method might drop an exception that may indicate a
serious problem has occurred in the running program. In general,
exceptions should be handled or reported in some way, or they should
be thrown out of the method.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DE_MIGHT_IGNORE</id>
    <artifact tool="FindBugs" mnemonic="DE_MIGHT_IGNORE"/>
    <name>Method might ignore an exception</name>
    <shortMessage>Method might ignore an exception.</shortMessage>
    <info>
<![CDATA[<p>This method might ignore an exception that my indicate a
serious problem has occurred in the running program. In general,
exceptions should be handled or reported in some way, or they should
be thrown out of the method.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DP_DO_INSIDE_DO_PRIVILEGED</id>
    <artifact tool="FindBugs" mnemonic="DP_DO_INSIDE_DO_PRIVILEGED"/>
    <artifact tool="FindBugs" mnemonic="DP_DO_INSIDE_DO_PRIVILEDGED"/>
    <name>Method requires security permission check</name>
    <shortMessage>Method is invoked that should be only be invoked inside a doPrivileged block.</shortMessage>
    <info>
<![CDATA[<p>This code invokes a method that requires a security
permission check. If this code will be granted security permissions,
but might be invoked by code that does not have security permissions,
then the invocation needs to occur inside a <code>doPrivileged</code>
block.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED</id>
    <artifact tool="FindBugs" mnemonic="DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED"/>
    <artifact tool="FindBugs" mnemonic="DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEDGED"/>
    <name>Classloader creation requires security permission check</name>
    <shortMessage>Classloaders should only be created inside a doPrivileged block.</shortMessage>
    <info>
<![CDATA[<p>This code creates a classloader, which requires a security
manager. If this code will be granted security permissions, but might
be invoked by code that does not have security permissions, then the
classloader creation needs to occur inside a <code>doPrivileged</code>
block.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>JCIP_FIELD_ISNT_FINAL_IN_IMMUTABLE_CLASS</id>
    <artifact tool="FindBugs" mnemonic="JCIP_FIELD_ISNT_FINAL_IN_IMMUTABLE_CLASS"/>
    <name>Field isn't final in an immutable class</name>
    <shortMessage>Fields that are declared within an immutable class should be final.</shortMessage>
    <info>
<![CDATA[<p>This class is annotated with the
<code>net.jcip.annotations.Immutable</code> annotation, and the rules
for that annotation require that all fields are final.  This class is
in violation of those rules.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DMI_THREAD_PASSED_WHERE_RUNNABLE_EXPECTED</id>
    <artifact tool="FindBugs" mnemonic="DMI_THREAD_PASSED_WHERE_RUNNABLE_EXPECTED"/>
    <name>Thread passed where Runnable is expected</name>
    <shortMessage>A Thread object has been passed as a parameter to a method where a Runnable is expected.</shortMessage>
    <info>
<![CDATA[<p>A Thread object is passed as a parameter to a method where
a Runnable is expected. This is unusual, and may indicate a logic
error or cause unexpected behavior.</p>

<p>Consider changing the type of the object to not be a Thread.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DMI_COLLECTION_OF_URLS</id>
    <artifact tool="FindBugs" mnemonic="DMI_COLLECTION_OF_URLS"/>
    <name>Avoid collections of URLs</name>
    <shortMessage>Maps and sets of URLs can be horrible performance hogs.</shortMessage>
    <info>
<![CDATA[ <p>This method or field is or uses a <code>Map</code> or
<code>Set</code> of URLs. Since both the equals and hashCode methods of
URL perform domain name resolution, this can result in a big
performance hit. See <a
href="http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html">http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html</a>
for more information. Consider using <code>java.net.URI</code>
instead.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DMI_BLOCKING_METHODS_ON_URL</id>
    <artifact tool="FindBugs" mnemonic="DMI_BLOCKING_METHODS_ON_URL"/>
    <name>Blocking methods on URL</name>
    <shortMessage>The equals and hashCode methods of URL are blocking.  This could result in a big performance hit.</shortMessage>
    <info>
<![CDATA[<p>The equals and hashCode method of URL perform domain name
resolution, this can result in a big performance hit. See <a
href="http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html">Michael
Scharf's Blog entry</a> on this topic for more information.</p>

<p>Consider using <code>java.net.URI</code> instead.  When using URI
objects in your code it is straightforward to convert one to a URL
object as shown in the code below.  This might be necessary to use the
object with some libraries and frameworks.</p>

<pre>
try {
  URI uri = new URI("http://www.surelogic.com");
  URL url = uri.toURL();
  assert uri.getHost().equals(url.getHost());
} catch (Exception e) {
  // handle URL and URI exceptions
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DMI_ANNOTATION_IS_NOT_VISIBLE_TO_REFLECTION</id>
    <artifact tool="FindBugs" mnemonic="DMI_ANNOTATION_IS_NOT_VISIBLE_TO_REFLECTION"/>
    <name>Annotation is not visible to reflection</name>
    <shortMessage>Can't use reflection to check for presence of annotation with default retention.</shortMessage>
    <info>
<![CDATA[<p>Unless an annotation has itself been annotated with a
<code>@Retention</code> other than the default of source-only
retention, the annotation isn't retained in the classfile and can't be
observed using reflection, i.e., using the
<code>isAnnotationPresent</code> method.</p>

<p>The standard annotation <code>@SuppressWarnings</code> is not
retained in the classfile, however <code>@Deprecated</code> is as
shown in the code below.</p>

<pre>
@Documented
@Retention(RetentionPolicy.RUNTIME)
public @interface Deprecated {}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DM_EXIT</id>
    <artifact tool="FindBugs" mnemonic="DM_EXIT"/>
    <artifact tool="PMD" mnemonic="DoNotCallSystemExit"/>
    <name>Avoid calling System.exit()</name>
    <shortMessage>Calling System.exit() may make it difficult for your code to be invoked by other code.</shortMessage>
    <info>
<![CDATA[<p>Invoking <code>System.exit()</code> shuts down the
entire Java virtual machine. This should only been done when it is
appropriate. Such calls make it hard or impossible for your code to be
invoked by other code. Consider throwing a
<code>RuntimeException</code> instead.</p>

<p>It is prohibited for any EJB to invoke this call and shutdown the
container (reference section 21.1.2 of the EJB 3.0
Specification).</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DM_RUN_FINALIZERS_ON_EXIT</id>
    <artifact tool="FindBugs" mnemonic="DM_RUN_FINALIZERS_ON_EXIT"/>
    <name>Avoid the dangerous runFinalizersOnExit() method</name>
    <shortMessage>Calling dangerous method runFinalizersOnExit() could result in erratic behavior or deadlock.</shortMessage>
    <info>
<![CDATA[<p><em>Never call System.runFinalizersOnExit or
Runtime.runFinalizersOnExit for any reason: they are among the most
dangerous methods in the Java libraries.</em> &mdash; Joshua Bloch
(reference Bloch's <i>Effective Java</i> (second edition) item 7)</p>

<p>Calling <code>runFinalizersOnExit</code> is inherently unsafe.  It
may result in finalizers being called on live objects while other
threads are concurrently manipulating those objects, resulting in
erratic behavior or deadlock.</p>

<p>Any Java program which depends upon finalizers, or a programmer who
thinks of them as similar to C++ destructors, is headed for serious
trouble. Work to avoid the use of finalizers in your code for
non-memory resources.  In Java, <code>try-finally</code> blocks should
be used for this purpose.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DM_STRING_CTOR</id>
    <artifact tool="FindBugs" mnemonic="DM_STRING_CTOR"/>
    <artifact tool="PMD" mnemonic="StringInstantiation"/>
    <artifact tool="FindBugs" mnemonic="DM_STRING_VOID_CTOR"/>
    <name>Use of inefficient String constructor</name>
    <shortMessage>Use of String constructor wastes memory and is inefficient.</shortMessage>
    <info>
<![CDATA[<p>Using the <code>java.lang.String(String)</code>
constructor wastes memory because the object so constructed will be
functionally indistinguishable from the <code>String</code> passed as
a parameter. Just use the argument <code>String</code> directly.  For
example, <code>new String("Hi")</code> is replaced with
<code>"Hi"</code> and <code>new String(s)</code> is replaced with
<code>s</code>.</p>

<p>Avoid instantiating String objects; this is usually unnecessary.</p>

<p>Creating a new <code>java.lang.String</code> object using the
no-argument constructor wastes memory because the object so created
will be functionally indistinguishable from the empty string constant
<code>""</code> Java guarantees that identical string constants will
be represented by the same <code>String</code> object. Therefore, you
should just use the empty string constant directly.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DM_STRING_TOSTRING</id>
    <artifact tool="FindBugs" mnemonic="DM_STRING_TOSTRING"/>
    <artifact tool="PMD" mnemonic="StringToString"/>
    <name>Avoid calling toString() on a String</name>
    <shortMessage>Method invokes the toString() method on a String.</shortMessage>
    <info>
<![CDATA[<p>Calling <code>String.toString()</code> is just a redundant
operation. Just use the String directly.  For example,
<code>s.toString()</code> is replaced with <code>s</code>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DM_GC</id>
    <artifact tool="FindBugs" mnemonic="DM_GC"></artifact>
    <artifact tool="PMD" mnemonic="DoNotCallGarbageCollectionExplicitly"/>
    <name>Avoid explicit garbage collection</name>
    <shortMessage>Explicit garbage collection is being invoked which is extremely dubious except in benchmarking code.</shortMessage>
    <info>
<![CDATA[<p>This code explicitly invokes garbage collection. Except
for use in benchmarking, this is very dubious.  It is recommended that
these calls be removed from your program.</p>

<p>In the past, situations where people have explicitly invoked the
garbage collector in routines such as close or finalize methods has
led to huge performance black holes. Garbage collection can be
expensive. Any situation that forces hundreds or thousands of garbage
collections will bring the machine to a crawl.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DM_BOOLEAN_CTOR</id>
    <artifact tool="FindBugs" mnemonic="DM_BOOLEAN_CTOR"/>
    <artifact tool="PMD" mnemonic="BooleanInstantiation"/>
    <name>Inefficient boolean constructor</name>
    <shortMessage>Method invokes inefficient Boolean constructor; use Boolean.valueOf(...) instead.</shortMessage>
    <info>
<![CDATA[<p>Creating new instances of <code>java.lang.Boolean</code>
wastes memory, since <code>Boolean</code> objects are immutable and
there are only two useful values of this type. Use the
<code>Boolean.valueOf()</code> method, <code>Boolean.TRUE</code> or
<code>Boolean.FALSE</code>, or autoboxing if you are using Java 1.5 or
above to create <code>Boolean</code> objects instead.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DM_NUMBER_CTOR</id>
    <artifact tool="FindBugs" mnemonic="DM_NUMBER_CTOR"/>
    <artifact tool="FindBugs" mnemonic="DM_FP_NUMBER_CTOR"/>
    <artifact tool="PMD" mnemonic="IntegerInstantiation"/>
    <artifact tool="PMD" mnemonic="ByteInstantiation"/>
    <artifact tool="PMD" mnemonic="LongInstantiation"/>
    <artifact tool="PMD" mnemonic="ShortInstantiation"/>
    <name>Inefficient number constructor</name>
    <shortMessage>This code invokes inefficient number constructor. Use static valueOf instead.</shortMessage>
    <info>
<![CDATA[<p>Using <code>new Integer(int)</code> (or any number
constructor such as <code>new Double(double)</code>) is guaranteed to
always result in a new object whereas
<code>Integer.valueOf(int)</code> allows caching of values to be done
by the compiler, class library, or JVM.  Using of cached values avoids
object allocation and the code will be faster.</p>

<p>For the integer numbers, values between -128 and 127 are guaranteed
to have corresponding cached instances and using
<code>valueOf()</code> is approximately 3.5 times faster than using
the constructor. For values outside the constant range the performance
of both styles is the same.</p>

<p>Unless the class must be compatible with JVMs predating Java 1.5,
use either autoboxing or the <code>valueOf()</code> method when
creating instances of <code>Double</code>, <code>Float</code>,
<code>Long</code>, <code>Integer</code>, <code>Short</code>,
<code>Character</code>, and <code>Byte</code>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DM_STRING_EMPTY_EQUALS</id>
    <artifact tool="FindBugs" mnemonic="DM_STRING_EMPTY_EQUALS"/>
    <name>Use length() or isEmpty() to check if a String is empty</name>
    <shortMessage>Method invokes inefficient String.equals(""); use String.length() == 0 instead.</shortMessage>
    <info>
<![CDATA[<p>An object is compared to the empty String object using the
equals() method here. Checking that the String object's length is zero
may be faster, and removes String constants from the class file.
Change <code>s.equals("")</code> or <code>"".equals(s)</code> to
<code>s.length() == 0</code></p>

<p>If you are using JDK 1.6 or above an <code>isEmpty()</code> method
was added to the String class which will directly answer the query.
Thus in the example above use <code>s.isEmpty()</code>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DM_CONVERT_CASE</id>
    <artifact tool="FindBugs" mnemonic="DM_CONVERT_CASE"/>
    <artifact tool="PMD" mnemonic="UseLocaleWithCaseConversions"/>
    <name>Use Locale parameterized versions of toUpperCase() and toLowerCase() methods</name>
    <shortMessage>Consider using the Locale parameterized version of the invoked method.</shortMessage>
    <info>
<![CDATA[<p>A String is being converted to upper or lowercase, using
the platform's default encoding. This may result in improper
conversions when used with international characters. Consider using
the below versions instead.</p>

<pre>
String.toUpperCase(Locale)
String.toLowerCase(Locale)
</pre>

<p>One instance where this might be an issue is conversion of local
insensitive strings. To obtain correct results for locale insensitive
strings, use <code>toUpperCase(Locale.ENGLISH)</code>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>BX_UNBOXED_AND_COERCED_FOR_TERNARY_OPERATOR</id>
    <artifact tool="FindBugs" mnemonic="BX_UNBOXED_AND_COERCED_FOR_TERNARY_OPERATOR"/>
    <name>Unboxed and coerced for ternary operator</name>
    <shortMessage>A primitive value is unboxed and coerced for use with the ternary operator.</shortMessage>
    <info>
<![CDATA[<p>A wrapped primitive value is unboxed and converted to
another primitive type as part of the evaluation of a conditional
ternary operator (the <code> b ? e1 : e2</code> operator). The
semantics of Java mandate that if <code>e1</code> and <code>e2</code>
are wrapped numeric values, the values are unboxed and
converted/coerced to their common type (e.g, if <code>e1</code> is of
type <code>Integer</code> and <code>e2</code> is of type
<code>Float</code>, then <code>e1</code> is unboxed, converted to a
floating point value, and boxed. See JLS Section 15.25.</p>

<p>This behavior can be unexpected and can be a source of subtle
bugs.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>BX_BOXING_IMMEDIATELY_UNBOXED</id>
    <artifact tool="FindBugs" mnemonic="BX_BOXING_IMMEDIATELY_UNBOXED"/>
    <name>Boxing immediately unboxed</name>
    <shortMessage>A primitive value is boxed and then immediately unboxed.</shortMessage>
    <info>
<![CDATA[<p>A primitive is boxed, and then immediately unboxed.  This
probably is due to a manual boxing in a place where an unboxed value
is required, thus forcing the compiler to immediately undue the work
of the boxing.</p>

<p>This change may improve program performance.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>BX_BOXING_IMMEDIATELY_UNBOXED_TO_PERFORM_COERCION</id>
    <artifact tool="FindBugs" mnemonic="BX_BOXING_IMMEDIATELY_UNBOXED_TO_PERFORM_COERCION"/>
    <name>Boxing immediately unboxed to perform coercion</name>
    <shortMessage>A primitive value is boxed then unboxed to perform primitive coercion.</shortMessage>
    <info>
<![CDATA[<p>A primitive boxed value constructed and then immediately
converted into a different primitive type (e.g., <code>new
Double(d).intValue()</code>). Just perform direct primitive coercion
(e.g., <code>(int) d</code>).</p>

<p>This change may improve program performance.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DM_BOXED_PRIMITIVE_TOSTRING</id>
    <artifact tool="FindBugs" mnemonic="DM_BOXED_PRIMITIVE_TOSTRING"/>
    <artifact tool="PMD" mnemonic="UnnecessaryConversionTemporary"/>
    <name>Boxed primitive used just to call toString()</name>
    <shortMessage>Method allocates a boxed primitive just to call toString.</shortMessage>
    <info>
<![CDATA[<p>A boxed primitive is allocated just to call toString(). It
is more effective to just use the static form of <code>toString</code>
on each wrapper type which takes the primitive value. So,</p>

<table>
      <tr><th>Replace...</th><th>With this...</th></tr>
      <tr><td>new Integer(1).toString()</td><td>Integer.toString(1)</td></tr>
      <tr><td>new Long(1).toString()</td><td>Long.toString(1)</td></tr>
      <tr><td>new Float(1.0).toString()</td><td>Float.toString(1.0)</td></tr>
      <tr><td>new Double(1.0).toString()</td><td>Double.toString(1.0)</td></tr>
      <tr><td>new Byte(1).toString()</td><td>Byte.toString(1)</td></tr>
      <tr><td>new Short(1).toString()</td><td>Short.toString(1)</td></tr>
      <tr><td>new Boolean(true).toString()</td><td>Boolean.toString(true)</td></tr>
</table>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DM_NEW_FOR_GETCLASS</id>
    <artifact tool="FindBugs" mnemonic="DM_NEW_FOR_GETCLASS"/>
    <name>Avoid allocating an object to obtain the class object</name>
    <shortMessage>Method allocates an object, only to get the class object.  Use .class property of the class instead.</shortMessage>
    <info>
 <![CDATA[<p>This method allocates an object just to call
 <code>getClass()</code> on it, in order to retrieve the class object
 for it. It is simpler to just access the <code>.class</code> property
 of the class.</p>

<p>For example, change <code>(new Foo()).getClass()</code> to
<code>Foo.class</code>.]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DM_MONITOR_WAIT_ON_CONDITION</id>
    <artifact tool="FindBugs" mnemonic="DM_MONITOR_WAIT_ON_CONDITION"/>
    <name>Monitor wait() on a util concurrent Condition object</name>
    <shortMessage>Monitor wait() called on a util concurrent Condition object, use await() instead.</shortMessage>
    <info>
<![CDATA[<p>This method calls <code>wait()</code> on a
<code>java.util.concurrent.locks.Condition</code> object.  Waiting for
a <code>Condition</code> should be done using one of the
<code>await()</code> methods defined by the <code>Condition</code>
interface.</p>

<p>This is highly confusing code that can lead to subtle concurrency
bugs.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>RV_01_TO_INT</id>
    <artifact tool="FindBugs" mnemonic="RV_01_TO_INT"></artifact>
    <name>Random value from 0 and 1 is to coerced to int</name>
    <shortMessage>A random value from 0 to 1 is coerced to the integer 0.  This is probably not the desired behavior. Consider fixing with the Random.nextInt method.</shortMessage>
    <info>
<![CDATA[<p>A random value from 0 to 1 is being coerced to the
integer value 0.  This is probably not the desired behavior.</p>

</p>You probably wanted to multiply the random value by something
before coercing it to an integer.  It is highly recommended that the
<code>nextInt</code> method (of the <code>Random</code> class) be used
for this purpose because it avoid several tricky implementation issues
(for more information see its method documentation).</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DM_NEXTINT_VIA_NEXTDOUBLE</id>
    <artifact tool="FindBugs" mnemonic="DM_NEXTINT_VIA_NEXTDOUBLE"/>
    <name>Use nextInt() not nextDouble() to generate a random integer</name>
    <shortMessage>Use the nextInt() method of Random rather than nextDouble() to generate a random integer.</shortMessage>
    <info>
<![CDATA[<p>If <code>r</code> is a <code>java.util.Random</code>
object, you can generate a random number from 0 to <code>n</code>-1
using <code>r.nextInt(n)</code> Rather than using
<code>(int)(r.nextDouble() * n)</code>.</p>

<p>It is highly recommended that the <code>nextInt</code> method be
used for this purpose because it avoid several tricky implementation
issues (for more information see its method documentation).</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE</id>
    <artifact tool="FindBugs" mnemonic="SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE"/>
    <name>Nonconstant String passed to execute() may be vulnerable to SQL injection</name>
    <shortMessage>A Nonconstant string passed to execute() method on an SQL statement.  This may be vulnerable to SQL injection.</shortMessage>
    <info>
<![CDATA[<p>The method invokes the execute method on an SQL statement
with a <code>String</code> that seems to be dynamically
generated. Consider using a prepared statement instead. It is more
efficient and less vulnerable to SQL injection attacks.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING</id>
    <artifact tool="FindBugs" mnemonic="SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING"/>
    <name>Prepared statement generated from nonconstant String may be vulnerable to SQL injection</name>
    <shortMessage>A prepared statement is generated from a nonconstant String.  This may be vulnerable to SQL injection.</shortMessage>
    <info>
<![CDATA[<p>The code creates an SQL prepared statement from a
nonconstant <code>String</code>. If unchecked, tainted data from a
user is used in building this <code>String</code>, SQL injection could
be used to make the prepared statement do something unexpected and
undesirable.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DM_USELESS_THREAD</id>
    <artifact tool="FindBugs" mnemonic="DM_USELESS_THREAD"/>
    <name>Useless Thread</name>
    <shortMessage>A thread was created using the default empty run() method.  Delete this thread.</shortMessage>
    <info>
<![CDATA[<p>This method creates a thread without specifying a run
method either by deriving from (i.e., subclassing) the
<code>Thread</code> class, or by passing a <code>Runnable</code>
object. This thread, then, does nothing but waste time.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DC_DOUBLECHECK</id>
    <artifact tool="FindBugs" mnemonic="DC_DOUBLECHECK"/>
    <artifact tool="PMD" mnemonic="DoubleCheckedLocking"/>
    <name>Double-checked locking</name>
    <shortMessage>Possible instance of double-check locking on a field.</shortMessage>
    <info>
<![CDATA[<p>This method may contain an instance of double-checked
locking. This idiom is not correct according to the semantics of the
Java memory model.</p>

<p>For more detailed information on this problem and how to correct
it, see the web page <a
href="http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html"
>http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html</a>
as well as <a
href="http://www.javaworld.com/javaworld/jw-02-2001/jw-0209-double.html"
>http://www.javaworld.com/javaworld/jw-02-2001/jw-0209-double.html</a>
.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>FI_FINALIZER_NULLS_FIELDS</id>
    <artifact tool="FindBugs" mnemonic="FI_FINALIZER_NULLS_FIELDS"/>
    <name>Finalizer nulls fields</name>
    <shortMessage>Finalizer nulls fields which does not aid garbage collection.</shortMessage>
    <info>
<![CDATA[<p>This finalizer <code>null</code>s out fields. This is
usually an error, as it does not aid garbage collection, and the
object is going to be garbage collected anyway.</p>

<p>It is recommended to try to remove all finalizers from your
program.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>FI_FINALIZER_ONLY_NULLS_FIELDS</id>
    <artifact tool="FindBugs" mnemonic="FI_FINALIZER_ONLY_NULLS_FIELDS"/>
    <name>Finalizer only nulls out fields</name>
    <shortMessage>Finalizer only nulls out fields. This finalize method should be removed.</shortMessage>
    <info>
<![CDATA[<p>This finalizer does nothing except <code>null</code> out
fields. This is completely pointless, and requires that the object be
garbage collected, finalized, and then garbage collected again. You
should just remove the finalize method.</p>

<p>It is recommended to try to remove all finalizers from your
program.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>FI_PUBLIC_SHOULD_BE_PROTECTED</id>
    <artifact tool="FindBugs" mnemonic="FI_PUBLIC_SHOULD_BE_PROTECTED"/>
    <artifact tool="PMD" mnemonic="FinalizeShouldBeProtected"/>
    <name>Finalize method should be protected</name>
    <shortMessage>Finalizer method should be declared to be protected, not public. Other classes can call public methods. Change the visibility or remove it.</shortMessage>
    <info>
<![CDATA[<p>A class's <code>finalize()</code> method should have
protected access, not public.</p>

If you override <code>finalize()</code>, make it protected. If you
make it public, other classes may call it.</p>

<p>It is recommended to try to remove all finalizers from your
program.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>FI_EMPTY</id>
    <artifact tool="FindBugs" mnemonic="FI_EMPTY"/>
    <artifact tool="PMD" mnemonic="EmptyFinalizer"/>
    <name>Empty finalizer block</name>
    <shortMessage>Empty finalizer should be removed</shortMessage>
    <info>
<![CDATA[<p>Empty <code>finalize()</code> methods are useless, so they
should be deleted.</p>

<p>It is recommended to try to remove all finalizers from your
program.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>FI_NULLIFY_SUPER</id>
    <artifact tool="FindBugs" mnemonic="FI_NULLIFY_SUPER"/>
    <name>Finalizer nullifies superclass finalizer</name>
    <shortMessage>Finalizer nullifies superclass finalizer.  Consider removing this method.</shortMessage>
    <info>
<![CDATA[<p>This empty <code>finalize()</code> method explicitly
negates the effect of any finalizer defined by its superclass. Any
finalizer actions defined for the superclass will not be
performed. Unless this is intended, delete this method.</p>

<p>It is recommended to try to remove all finalizers from your
program.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>FI_USELESS</id>
    <artifact tool="FindBugs" mnemonic="FI_USELESS"/>
    <artifact tool="PMD" mnemonic="FinalizeOnlyCallsSuperFinalize"/>
    <name>Finalize() only calls super.finalize()</name>
    <shortMessage>Finalizer does nothing but call its superclass finalizer.  Consider removing this method.</shortMessage>
    <info>
<![CDATA[<p>The only thing this <code>finalize()</code> method does
is call the superclass's <code>finalize()</code> method, making it
redundant. Delete this method.</p>

<p>It is recommended to try to remove all finalizers from your
program.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>FI_MISSING_SUPER_CALL</id>
    <artifact tool="FindBugs" mnemonic="FI_MISSING_SUPER_CALL"/>
    <artifact tool="PMD" mnemonic="FinalizeDoesNotCallSuperFinalize"/>
    <name>Finalize() does not call super.finalize()</name>
    <shortMessage>Finalizer does not call the superclass finalizer as its last operation.  Add a call to super.finalize() to this method.</shortMessage>
    <info>
<![CDATA[<p>This <code>finalize()</code> method does not make a call
to its superclass's <code>finalize()</code> method. So, any finalizer
actions defined for the superclass will not be performed.</p>

<p>To fix this problem add a call to
<code>super.finalize()</code>. Note that this method's last action
should be the call to <code>super.finalize()</code>.</p>

<p>It is recommended to try to remove all finalizers from your
program.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>FI_EXPLICIT_INVOCATION</id>
    <artifact tool="FindBugs" mnemonic="FI_EXPLICIT_INVOCATION"/>
    <artifact tool="PMD" mnemonic="AvoidCallingFinalize"/>
    <name>Avoid calling finalize() explicitly</name>
    <shortMessage>Explicit invocation of finalizer found. This is almost always a bug.</shortMessage>
    <info>
<![CDATA[<p>This method contains an explicit invocation of the
<code>finalize()</code> method on an object. Because finalizer methods
are supposed to be executed once, and only by the VM, this is a bad
idea.</p>

<p>If a connected set of objects becomes finalizable, then the VM will
invoke the <code>finalize()</code> method on all the finalizable
objects, possibly at the same time in different threads. Thus, it is a
particularly bad idea, in the <code>finalize()</code> method for a
class X, to invoke <code>finalize()</code> on objects referenced by X,
because they may already be getting finalized in a separate
thread.</p>

<p>It is recommended to try to remove all finalizers from your
program.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EQ_DONT_DEFINE_EQUALS_FOR_ENUM</id>
    <artifact tool="FindBugs" mnemonic="EQ_DONT_DEFINE_EQUALS_FOR_ENUM"/>
    <name>Don't define equals() for enum</name>
    <shortMessage>Covariant equals() method defined for enum.  This is a bad practice.</shortMessage>
    <info>
<![CDATA[<p>This class defines an enumeration, and equality on
enumerations are defined using object identity. Defining a covariant
equals method for an enumeration value is exceptionally bad practice,
since it would likely result in having two different enumeration
values that compare as equals using the covariant enum method, and as
not equal when compared normally. Don't do it.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EQ_SELF_USE_OBJECT</id>
    <artifact tool="FindBugs" mnemonic="EQ_SELF_USE_OBJECT"/>
    <artifact tool="FindBugs" mnemonic="EQ_SELF_NO_OBJECT"/>
    <artifact tool="FindBugs" mnemonic="EQ_ABSTRACT_SELF"/>
    <artifact tool="FindBugs" mnemonic="EQ_OTHER_USE_OBJECT"/>
    <name>Equals() defined that does not override Object.equals</name>
    <shortMessage>Covariant equals() method defined, Object.equals(Object) inherited.</shortMessage>
    <info>
<![CDATA[<p>This class defines a covariant version of the
<code>equals()</code> method, but inherits the normal
<code>equals(Object)</code> method defined in the base
<code>java.lang.Object</code> class. The class probably intended to
define a non-covariant version of <code>equals()</code> and use the
<code>@Override</code> tag if using JDK 1.5 or above as shown in the
code below.  In addition, to correctly override the
<code>equals</code> method in <code>java.lang.Object</code>, the
parameter must have the type <code>java.lang.Object</code>.</p>

<pre>
@Override public boolean equals(Object obj) {
  // implementation (don't forget to override hashCode as well!)
}
</pre>

<p>If this was not the intent of the class, then the method should be
renamed something other than <code>equals</code> to avoid
confusion.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EQ_OVERRIDING_EQUALS_NOT_SYMMETRIC</id>
    <artifact tool="FindBugs" mnemonic="EQ_OVERRIDING_EQUALS_NOT_SYMMETRIC"/>
    <name>Equals() override is not symmetric</name>
    <shortMessage>Method overrides equals() in superclass and may not be symmetric.</shortMessage>
    <info>
<![CDATA[<p>This class defines an equals method that overrides an
equals method in a superclass. Both equals methods methods use
<code>instanceof</code> in the determination of whether two objects
are equals. This is fraught with peril, since it is important that the
equals method is symmetrical (in other words, <code>a.equals(b) ==
b.equals(a)</code>). If B is a subtype of A, and A's equals method
checks that the argument is an instanceof A, and B's equals method
checks that the argument is an instanceof B, it is quite likely that
the equivalence relation defined by these methods is not
symmetric.</p>

<p>See Bloch's <i>Effective Java</i> (second edition) item 8 for
(much) more information.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>HSC_HUGE_SHARED_STRING_CONSTANT</id>
    <artifact tool="FindBugs" mnemonic="HSC_HUGE_SHARED_STRING_CONSTANT"/>
    <name>Huge shared string constant</name>
    <shortMessage>Huge string constants are duplicated across multiple class files.</shortMessage>
    <info>
<![CDATA[<p>A large String constant is duplicated across multiple
class files. This is likely because a final field is initialized to a
String constant, and the Java language mandates that all references to
a final field from other classes be inlined into that classfile.</p>

<p>See <a
href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6447475">JDK
bug 6447475</a> for a description of an occurrence of this bug in the
JDK and how resolving it reduced the size of the JDK by 1
megabyte.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NP_ARGUMENT_MIGHT_BE_NULL</id>
    <artifact tool="FindBugs" mnemonic="NP_ARGUMENT_MIGHT_BE_NULL"/>
    <name>Argument might be null</name>
    <shortMessage>Method does not check for a null argument.</shortMessage>
    <info>
<![CDATA[<p>A parameter to this method has been identified as a value
that should always be checked to see whether or not it is
<code>null</code>, but it is being dereferenced without a preceding
null check.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT</id>
    <artifact tool="FindBugs" mnemonic="NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT"/>
    <artifact tool="FindBugs" mnemonic="NP_DOES_NOT_HANDLE_NULL"/>
    <name>Equals() should handle null argument</name>
    <shortMessage>This equals() method does not check for null argument.  This contract violation should be fixed.</shortMessage>
    <info>
<![CDATA[<p>This implementation of <code>equals(Object)</code>
violates the contract defined by
<code>java.lang.Object.equals()</code> because it does not check for
<code>null</code> being passed as the argument. By the defined
contract, all <code>equals()</code> methods should return false if
passed a <code>null</code> value.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>CO_SELF_NO_OBJECT</id>
    <artifact tool="FindBugs" mnemonic="CO_SELF_NO_OBJECT"/>
    <artifact tool="FindBugs" mnemonic="CO_ABSTRACT_SELF"/>
    <name>Covariant compareTo() method</name>
    <shortMessage>Covariant compareTo() method defined.</shortMessage>
    <info>
<![CDATA[<p>This class defines a covariant version of
<code>compareTo()</code>. To correctly implement (or override if an
implementation is provided by a superclass) the
<code>compareTo()</code> method in the <code>Comparable</code>
interface, the parameter of <code>compareTo()</code> must have type
<code>java.lang.Object</code>.</p>

<p>If this was not the intent of the class, then the method should be
renamed something other than <code>compareTo</code> to avoid
confusion.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>HE_USE_OF_UNHASHABLE_CLASS</id>
    <artifact tool="FindBugs" mnemonic="HE_USE_OF_UNHASHABLE_CLASS"/>
    <name>Use of unhashable class</name>
    <shortMessage>Use of class without a hashCode() method in a hashed data structure.</shortMessage>
    <info>
<![CDATA[<p>A class defines an <code>equals(Object)</code> method but
not a <code>hashCode()</code> method, and thus doesn't fulfill the
requirement that equal objects have equal hash codes. An instance of
this class is used in a hash data structure, making the need to fix
this problem of highest importance.]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>HE_HASHCODE_NO_EQUALS</id>
    <artifact tool="FindBugs" mnemonic="HE_HASHCODE_NO_EQUALS"/>
    <artifact tool="FindBugs" mnemonic="HE_HASHCODE_USE_OBJECT_EQUALS"/>
    <name>Defines hashCode() but inherits equals()</name>
    <shortMessage>Class defines hashCode() but inherits equals().</shortMessage>
    <info>
<![CDATA[<p>This class defines a <code>hashCode()</code> method but
inherits its <code>equals()</code> method from
<code>java.lang.Object</code> (which defines equality by comparing
object references). Although this will probably satisfy the contract
that equal objects must have equal hashcodes, it is probably not what
was intended by overriding the <code>hashCode()</code>
method. Overriding <code>hashCode()</code> typically implies that the
object's identity is based on criteria more complicated than simple
reference equality.</p>

<p>If you don't think instances of this class will ever be inserted
into a HashMap/Hashtable, the recommended <code>hashCode</code>
implementation to use is:</p>

<pre>
@Override public int hashCode() {
  assert false : "hashCode not designed";
  return 42; // any arbitrary constant will do
}
</pre>

<p>Note however, that some Java IDEs, such as Eclipse, will generate a
reasonable equals and hashcode for you.</p>

<p>Override both <code>public boolean Object.equals(Object
other)</code>, and <code>public int Object.hashCode()</code>, or
override neither. Even if you are inheriting a <code>hashCode</code>
method from a parent class, consider implementing
<code>hashCode</code> and explicitly delegating to your
superclass.</p>

<p>For more information on this topic please reference items 8 and 9
of Bloch's <i>Effective Java</i> (second edition).</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EQ_COMPARETO_USE_OBJECT_EQUALS</id>
    <artifact tool="FindBugs" mnemonic="EQ_COMPARETO_USE_OBJECT_EQUALS"/>
    <name>Defines compareTo() but uses Object.equals()</name>
    <shortMessage>Class defines a compareTo(...) method but uses Object.equals().</shortMessage>
    <info>
<![CDATA[<p>This class defines a <code>compareTo(...)</code> method
but inherits its <code>equals</code> method from
<code>java.lang.Object</code>. Generally, the <code>compareTo</code>
method should return zero if and only if <code>equals</code> returns
true. If this is violated, weird and unpredictable failures will occur
in classes such as <code>PriorityQueue</code>. In Java 5 the
<code>remove</code> method of <code>PriorityQueue</code> uses the
<code>compareTo</code> method, while in Java 6 it uses the
<code>equals</code> method.

<p>From the Javadoc for the <code>compareTo</code> method in the
<code>Comparable</code> interface:</p>

<blockquote> It is strongly recommended, but not strictly required
that <code>(x.compareTo(y)==0) == (x.equals(y))</code>. Generally
speaking, any class that implements the Comparable interface and
violates this condition should clearly indicate this fact. The
recommended language is &quot;Note: this class has a natural ordering
that is inconsistent with equals.&quot;</blockquote>

<p>For more information on this topic please reference item 12 of
Bloch's <i>Effective Java</i> (second edition).</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>HE_EQUALS_NO_HASHCODE</id>
    <artifact tool="FindBugs" mnemonic="HE_EQUALS_NO_HASHCODE"/>
    <artifact tool="FindBugs" mnemonic="HE_EQUALS_USE_HASHCODE"/>
    <name>Defines equals() but inherits hashCode()</name>
    <shortMessage>Class defines equals() but inherits hashCode().</shortMessage>
    <info>
<![CDATA[<p> This class overrides <code>equals(Object)</code>, but
does not override <code>hashCode()</code>, and inherits the
implementation of <code>hashCode()</code> from
<code>java.lang.Object</code>.  The implementation of
<code>hashCode</code> in <code>java.lang.Object</code> returns the
identity hash code, an arbitrary value assigned to the object by the
VM).  Therefore, the class is likely to violate the invariant that
equal objects must have equal hashcodes.</p>

<p>If you don't think instances of this class will ever be inserted
into a HashMap/Hashtable, the recommended <code>hashCode</code>
implementation to use is:</p>

<pre>
@Override public int hashCode() {
  assert false : "hashCode not designed";
  return 42; // any arbitrary constant will do
}
</pre>

<p>Note however, that some Java IDEs, such as Eclipse, will generate a
reasonable equals and hashcode for you.</p>

<p>Override both <code>public boolean Object.equals(Object
other)</code>, and <code>public int Object.hashCode()</code>, or
override neither. Even if you are inheriting a <code>hashCode</code>
method from a parent class, consider implementing
<code>hashCode</code> and explicitly delegating to your
superclass.</p>

<p>For more information on this topic please reference items 8 and 9
of Bloch's <i>Effective Java</i> (second edition).</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>HE_INHERITS_EQUALS_USE_HASHCODE</id>
    <artifact tool="FindBugs" mnemonic="HE_INHERITS_EQUALS_USE_HASHCODE"/>
    <name>Inherits equals() but uses hashCode()</name>
    <shortMessage>Class inherits equals() but uses Object.hashCode().</shortMessage>
    <info>
<![CDATA[<p>This class inherits <code>equals(Object)</code> from an
abstract superclass, and <code>hashCode()</code> from
<code>java.lang.Object</code> The implementation of
<code>hashCode</code> in <code>java.lang.Object</code> returns the
identity hash code, an arbitrary value assigned to the object by the
VM).  Therefore, the class is likely to violate the invariant that
equal objects must have equal hashcodes.</p>

<p>If you don't think instances of this class will ever be inserted
into a HashMap/Hashtable, the recommended <code>hashCode</code>
implementation to use is:</p>

<pre>
public int hashCode() {
  assert false : &quot;hashCode not designed&quot;;
  return 42; // any arbitrary constant will do
}
</pre>

<p>Note however, that some Java IDEs, such as Eclipse, will generate a
reasonable equals and hashcode for you.</p>

<p>Override both <code>public boolean Object.equals(Object
other)</code>, and <code>public int Object.hashCode()</code>, or
override neither. Even if you are inheriting a <code>hashCode</code>
method from a parent class, consider implementing
<code>hashCode</code> and explicitly delegating to your
superclass.</p>

<p>For more information on this topic please reference items 8 and 9
of Bloch's <i>Effective Java</i> (second edition).</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ES_COMPARING_STRINGS_WITH_EQ</id>
    <artifact tool="FindBugs" mnemonic="ES_COMPARING_STRINGS_WITH_EQ"/>
    <artifact tool="FindBugs" mnemonic="ES_COMPARING_PARAMETER_STRING_WITH_EQ"/>
    <artifact tool="PMD" mnemonic="UseEqualsToCompareStrings"/>				
    <name>String comparison with == or !=</name>
    <shortMessage>Suspicious comparison of String objects using == or !=.</shortMessage>
    <info>
<![CDATA[<p>This code compares <code>java.lang.String</code> objects
for reference equality using the == or != operators. Unless both
strings are constants in a source file or have been interned using the
<code>String.intern()</code> method, the same string value may be
represented by two different String objects.  In short, only very
specialized code should use == or != operators on strings as this is
unusual and can create subtle bugs in your code.</p>

<p>This is even worse if the string is a parameter. Requiring callers
to pass only String constants or interned strings to a method is
unnecessarily fragile, and rarely leads to measurable performance
gains.</p>

<p>Consider using the <code>equals(Object)</code> method instead.  For
example, change <code>s1 == s2</code> with <code>s1.equals(s2)</code>
where you are sure that <code>s1</code> is non-null.</p>

<p>If you are comparing a constant string to any other string always
call <code>equals</code> on the constant as this avoids any possibility
of a <code>NullPointerException</code>.  For example, use
<code>"hello".equals(s1)</code> rather than
<code>s1.equals("hello")</code>.]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>IS_FIELD_NOT_GUARDED</id>
    <artifact tool="FindBugs" mnemonic="IS_FIELD_NOT_GUARDED"/>
    <name>Annotated field is not guarded</name>
    <shortMessage>Annotated field is not guarded against concurrent access.</shortMessage>
    <info>
<![CDATA[<p>This field is annotated with
<code>net.jcip.annotations.GuardedBy</code>, but can be accessed in a
way that seems to violate the annotation.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>IS2_INCONSISTENT_SYNC</id>
    <artifact tool="FindBugs" mnemonic="IS2_INCONSISTENT_SYNC"/>
    <artifact tool="FindBugs" mnemonic="IS_INCONSISTENT_SYNC"/>
    <name>Inconsistent field synchronization</name>
    <shortMessage>Inconsistent synchronization of fields.  Possible race condition detected.</shortMessage>
    <info>
<![CDATA[<p>The fields of this class appear to be accessed
inconsistently with respect to synchronization. This bug report
indicates that the bug pattern detector judged that</p>

<ol>
<li> The class contains a mix of locked and unlocked accesses,</li>
<li> At least one locked access was performed by one of the class's own methods, and</li>
<li> The number of unsynchronized field accesses (reads and writes) was no more than one third of all accesses, with writes being weighed twice as high as reads</li>
</ol>

<p>A typical bug matching this bug pattern is forgetting to
synchronize one of the methods in a class that is intended to be
thread-safe.</p>

<p>Note that there are various sources of inaccuracy in this
detector; for example, the detector cannot statically detect all
situations in which a lock is held.  Also, even when the detector is
accurate in distinguishing locked versus unlocked accesses, the code in
question may still be correct.</p>

<p>To address this issue you must determine what the programmer
intended with respect to concurrency policy design intent and ensure
that this class faithfully implements that intent.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NN_NAKED_NOTIFY</id>
    <artifact tool="FindBugs" mnemonic="NN_NAKED_NOTIFY"/>
    <name>Naked notify()</name>
    <shortMessage>Naked notify(), no apparent change has been made to mutable object state.</shortMessage>
    <info>
<![CDATA[<p> A call to <code>notify()</code> or
<code>notifyAll()</code> was made without any (apparent) accompanying
modification to mutable object state. In general, calling a notify
method on a monitor is done because some condition another thread is
waiting for has become true. However, for the condition to be
meaningful, it must involve a heap object that is visible to both
threads.</p>

<p>This bug does not necessarily indicate an error, since the change
to mutable object state may have taken place in a method which then
called the method containing the notification.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>MS_EXPOSE_REP</id>
    <artifact tool="FindBugs" mnemonic="MS_EXPOSE_REP"/>
    <artifact tool="PMD" mnemonic="MethodReturnsInternalArray"/>
    <name>Exposing a mutable array</name>
    <shortMessage>Public static method may expose internal representation by returning a mutable array.</shortMessage>
    <info>
<![CDATA[<p>A public static method returns a reference to an array
that is part of the static state of the class. Any code that calls
this method can freely modify the underlying array.  If the array is
accessed by untrusted code, and unchecked changes to the mutable array
would compromise security or other important properties, you will need
to do something different.</p>

<p>One possible fix is to return a copy of the array.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EI_EXPOSE_REP</id>
    <artifact tool="FindBugs" mnemonic="EI_EXPOSE_REP"/>
    <name>Exposing a mutable object</name>
    <shortMessage>May expose internal representation by returning a reference to a mutable object.</shortMessage>
    <info>
<![CDATA[<p>Returning a reference to a mutable object value stored in
one of the object's fields exposes the internal representation of the
object. If instances are accessed by untrusted code, and unchecked
changes to the mutable object would compromise security or other
important properties, you will need to do something different.</p>

<p>Returning a new copy of the object is better approach in many
situations.</p> ]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EI_EXPOSE_REP2</id>
    <artifact tool="FindBugs" mnemonic="EI_EXPOSE_REP2"/>
    <name>Exposing a mutable object by reference</name>
    <shortMessage>May expose internal representation by incorporating a reference to a mutable object.</shortMessage>
    <info>
<![CDATA[<p>This code stores a reference to an externally mutable
object into the internal representation of the object. If instances
are accessed by untrusted code, and unchecked changes to the mutable
object would compromise security or other important properties, you
will need to do something different.</p>

<p>Storing a copy of the object is better approach in many
situations.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EI_EXPOSE_STATIC_REP2</id>
    <artifact tool="FindBugs" mnemonic="EI_EXPOSE_STATIC_REP2"/>
    <name>Exposing mutable state via a static field</name>
    <shortMessage>May expose internal static state by storing a mutable object into a static field.</shortMessage>
    <info>
<![CDATA[<p>This code stores a reference to an externally mutable
object into a static field. If unchecked changes to the mutable object
would compromise security or other important properties, you will need
to do something different.</p>

<p>Storing a copy of the object is better approach in many
situations.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>RU_INVOKE_RUN</id>
    <artifact tool="FindBugs" mnemonic="RU_INVOKE_RUN"/>
    <name>Invokes run() on a thread</name>
    <shortMessage>Invokes run() on a thread, it is likely that this code intended to invoke start() instead.</shortMessage>
    <info>
<![CDATA[<p>This method explicitly invokes <code>run()</code> on an
object. In general, classes implement the <code>Runnable</code>
interface because they are going to have their <code>run()</code>
method invoked in a new thread, in which case
<code>Thread.start()</code> is the right method to call.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SP_SPIN_ON_FIELD</id>
    <artifact tool="FindBugs" mnemonic="SP_SPIN_ON_FIELD"/>
    <name>Spinning on a field read</name>
    <shortMessage>This method spins in a loop which reads a field.  This may be changed into an infinite loop by the compiler.</shortMessage>
    <info>
<![CDATA[<p>This method spins in a loop which reads a field.  The
compiler may legally hoist the read out of the loop, turning the code
into an infinite loop.</p>

<p>The class should be changed so it uses proper synchronization,
likely including wait and notify calls.  Also consider the use of the
classes in <code>java.util.concurrent</code> and
<code>java.util.concurrent.atomic</code>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NS_DANGEROUS_NON_SHORT_CIRCUIT</id>
    <artifact tool="FindBugs" mnemonic="NS_DANGEROUS_NON_SHORT_CIRCUIT"/>
    <name>Dangerous use of non-short-circuit logic</name>
    <shortMessage>Potentially dangerous use of non-short-circuit logic.</shortMessage>
    <info>
<![CDATA[<p>This code seems to be using non-short-circuit logic, i.e.,
<code>&</code> or <code>|</code>, rather than short-circuit logic,
i.e., <code>&&</code> or <code>||</code>. In addition, it seem
possible that, depending on the value of the left hand side, you might
not want to evaluate the right hand side (because it would have side
effects, could cause an exception or could be expensive.</p>

<p>Non-short-circuit logic causes both sides of the expression to be
evaluated even when the result can be inferred from knowing the
left-hand side. This can be less efficient and can result in errors if
the left-hand side guards cases when evaluating the right-hand side
can generate an error.</p>

<p>It is considered best practice to use short-circuit logic in most
expressions.  Document exceptions in the code with clear reasons why
the exception is required.</p>

<p>See <a
href="http://java.sun.com/docs/books/jls/third_edition/html/expressions.html#15.22.2">the
Java Language Specification</a> for further details.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NS_NON_SHORT_CIRCUIT</id>
    <artifact tool="FindBugs" mnemonic="NS_NON_SHORT_CIRCUIT"/>
    <name>Questionable use of non-short-circuit logic</name>
    <shortMessage>Questionable use of non-short-circuit logic.</shortMessage>
    <info>
<![CDATA[<p>This code seems to be using non-short-circuit logic, i.e.,
<code>&</code> or <code>|</code>, rather than short-circuit logic,
i.e., <code>&&</code> or <code>||</code>.</p>

<p>Non-short-circuit logic causes both sides of the expression to be
evaluated even when the result can be inferred from knowing the
left-hand side. This can be less efficient and can result in errors if
the left-hand side guards cases when evaluating the right-hand side
can generate an error.</p>

<p>It is considered best practice to use short-circuit logic in most
expressions.  Document exceptions in the code with clear reasons why
the exception is required.</p>

<p>See <a
href="http://java.sun.com/docs/books/jls/third_edition/html/expressions.html#15.22.2">the
Java Language Specification</a> for further details.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>TLW_TWO_LOCK_WAIT</id>
    <artifact tool="FindBugs" mnemonic="TLW_TWO_LOCK_WAIT"/>
    <name>Two lock wait()</name>
    <shortMessage>Wait with two locks held.  Only one lock released by the wait.</shortMessage>
    <info>
<![CDATA[<p>Waiting on a monitor while two locks are held may cause
deadlock. Performing a wait only releases the lock on the object being
waited on, not any other locks.</p>

<p>This not necessarily a bug, but is worth examining closely
especially if there is also a warning about a two lock notify.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>TLW_TWO_LOCK_NOTIFY</id>
    <artifact tool="FindBugs" mnemonic="TLW_TWO_LOCK_NOTIFY"/>
    <name>Two lock notify()</name>
    <shortMessage>Notify with two locks held.</shortMessage>
    <info>
<![CDATA[<p>The code calls <code>notify()</code> or
<code>notifyAll()</code> while two locks are held. If this
notification is intended to wake up a <code>wait()</code> that is
holding the same locks, it may deadlock, since the wait will only give
up one lock and the notify will be unable to get both locks, and thus
the notify will not succeed.</p>

<p>If there is also a warning about a two lock wait, the probably of a
bug is quite high.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UW_UNCOND_WAIT</id>
    <artifact tool="FindBugs" mnemonic="UW_UNCOND_WAIT"/>
    <name>Unconditional wait()</name>
    <shortMessage>Unconditional wait could cause your code to hang</shortMessage>
    <info>
<![CDATA[<p>This method contains a call to
<code>java.lang.Object.wait()</code> which is not guarded by
conditional control flow. The code should verify that condition it
intends to wait for is not already satisfied before calling wait.  The
reason for this is that when you invoke <code>wait</code> any previous
notifications (i.e., those made in the past) will be ignored and your
program could hang.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UR_UNINIT_READ</id>
    <artifact tool="FindBugs" mnemonic="UR_UNINIT_READ"/>
    <name>Uninitialized field read</name>
    <shortMessage>Uninitialized read of a field within a constructor.</shortMessage>
    <info>
<![CDATA[<p>This constructor reads a field which has not yet been
assigned a value. This issue is often caused when the programmer
mistakenly uses the field instead of one of the constructor's
parameters.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UG_SYNC_SET_UNSYNC_GET</id>
    <artifact tool="FindBugs" mnemonic="UG_SYNC_SET_UNSYNC_GET"/>
    <name>Synchronized setter unsynchronized getter</name>
    <shortMessage>Unsynchronized get method with a corresponding synchronized set method. This may cause incorrect program behavior.</shortMessage>
    <info>
<![CDATA[<p>This class contains similarly-named get and set methods
where the set method is synchronized and the get method is not. This
may result in incorrect behavior at runtime, as callers of the get
method will not necessarily see a consistent state for the object. The
get method should be made synchronized.</p>

<p>This situation is caused because of the Java Memory Model which
requires that the program provide for reliable communication between
threads as well as for mutual exclusion.  See <a
href="http://java.sun.com/docs/books/jls/third_edition/html/memory.html#17.4">the
Java Language Specification</a> for further details.  In addition,
please reference Bloch's <i>Effective Java</i> item 66.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>IC_INIT_CIRCULARITY</id>
    <artifact tool="FindBugs" mnemonic="IC_INIT_CIRCULARITY"/>
    <name>Initialization circularity</name>
    <shortMessage>Initialization circularity between two classes should be removed.</shortMessage>
    <info>
<![CDATA[<p> A circularity was detected in the static initializers of
the two classes referenced by the bug instance. Many kinds of
unexpected behavior may arise from such circularity.  It is
recommended that this implementation be changed to avoid
circularity.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION</id>
    <artifact tool="FindBugs" mnemonic="IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION"/>
    <name>Superclass uses subclass during initialization</name>
    <shortMessage>Superclass uses subclass during initialization.</shortMessage>
    <info>
<![CDATA[<p>During the initialization of a class, the class makes an
active use of a subclass. That subclass will not yet be initialized at
the time of this use. For example, in the following code,
<code>foo</code> will be <code>null</code>.</p>

<pre>
public class CircularClassInitialization {

  static class InnerClassSingleton extends CircularClassInitialization {
    static InnerClassSingleton singleton = new InnerClassSingleton();
  }

  static CircularClassInitialization foo = InnerClassSingleton.singleton; // will be null
}
</pre>

<p>This finding probably indicates a muddled implementation or a
misunderstanding of the details of how Java instantiates
objects.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>IT_NO_SUCH_ELEMENT</id>
    <artifact tool="FindBugs" mnemonic="IT_NO_SUCH_ELEMENT"/>
    <name>Next() must throw NoSuchElementException</name>
    <shortMessage>The next() method implementation in this class should throw NoSuchElementException exception when there are no more elements to return.</shortMessage>
    <info>
<![CDATA[<p>This class implements the <code>java.util.Iterator</code>
interface. However, its <code>next()</code> method is not capable of
throwing <code>java.util.NoSuchElementException</code>.</p>

<p>The <code>next()</code> method should be changed so it throws
<code>NoSuchElementException</code> if is called when there are no
more elements to return.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DL_SYNCHRONIZATION_ON_SHARED_CONSTANT</id>
    <artifact tool="FindBugs" mnemonic="DL_SYNCHRONIZATION_ON_SHARED_CONSTANT"/>
    <name>Synchronization on a shared constant</name>
    <shortMessage>Synchronization on a shared constant could lead to deadlock.</shortMessage>
    <info>
<![CDATA[<p>The code synchronizes on a shared primitive constant, such
as an interned String.</p>

<pre>
private static String LOCK = "LOCK";
...
synchronized(LOCK) { ...}
...
</pre>

<p>Such constants an interned and shared across all other classes
loaded by the JVM. Thus, this could is locking on something that other
code might also be locking. This could result in very strange and hard
to diagnose blocking and deadlock behavior.</p>

<p>For further information please see <a
href="http://www.javalobby.org/java/forums/t96352.html">http://www.javalobby.org/java/forums/t96352.html</a>
and <a
href="http://jira.codehaus.org/browse/JETTY-352">http://jira.codehaus.org/browse/JETTY-352</a>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ESync_EMPTY_SYNC</id>
    <artifact tool="FindBugs" mnemonic="ESync_EMPTY_SYNC"/>
    <artifact tool="PMD" mnemonic="EmptySynchronizedBlock"/>
    <name>Empty synchronized block</name>
    <shortMessage>Empty synchronized block should be removed</shortMessage>
    <info>
<![CDATA[<p>The code contains an empty synchronized block:</p>

<pre>
synchronized(o) {}
</pre>

<p>Empty synchronized blocks are far more subtle and hard to use
correctly than most people recognize, and empty synchronized blocks
are almost never a better solution than less contrived solutions, for
example, use of the util concurrent library.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ML_SYNC_ON_UPDATED_FIELD</id>
    <artifact tool="FindBugs" mnemonic="ML_SYNC_ON_UPDATED_FIELD"/>
    <name>Synchronize on updated field</name>
    <shortMessage>Method synchronizes on an updated field.  This is likely to be incorrect.</shortMessage>
    <info>
<![CDATA[<p>This method synchronizes on an object references from a
mutable field. This is unlikely to have useful semantics, since
different threads may be synchronizing on different objects.</p>

<p>Multiple threads must synchronize on the same object to allow
shared data to be safely read and written.  It is therefore
recommended that all locks be final fields or <code>this</code> or a
static class (e.g., <code>MyClass.class</code>).</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>MS_OOI_PKGPROTECT</id>
    <artifact tool="FindBugs" mnemonic="MS_OOI_PKGPROTECT"/>
    <name>Field should be out of interface and package protected</name>
    <shortMessage>Field should should be moved out of an interface and made package protected to avoid malicious mutation.</shortMessage>
    <info>
<![CDATA[<p>A final static field that is defined in an interface
references a mutable object such as an array or
<code>Hashtable</code>. This mutable object could be changed by
malicious code or by accident from another package.</p>

<p>To solve this, the field needs to be moved to a class and made
package protected to avoid this vulnerability.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>MS_FINAL_PKGPROTECT</id>
    <artifact tool="FindBugs" mnemonic="MS_FINAL_PKGPROTECT"/>
    <name>Field should be final and package protected</name>
    <shortMessage>Field should be both made both final and package protected to avoid malicious mutation.</shortMessage>
    <info>
<![CDATA[<p>A mutable static field could be changed by malicious code
or by accident from another package.</p>

<p>The field could be made package protected and/or made final to
avoid this vulnerability.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>MS_SHOULD_BE_FINAL</id>
    <artifact tool="FindBugs" mnemonic="MS_SHOULD_BE_FINAL"/>
    <name>Field should be final</name>
    <shortMessage>Field is not final but it should be to avoid malicious mutation.</shortMessage>
    <info>
<![CDATA[<p>A mutable static field could be changed by malicious code
or by accident from another package.</p>

<p>The field should be made final to avoid this vulnerability.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>MS_PKGPROTECT</id>
    <artifact tool="FindBugs" mnemonic="MS_PKGPROTECT"></artifact>
    <name>Field should be packaged protected</name>
    <shortMessage>Field should be made package protected to avoid malicious mutation.</shortMessage>
    <info>
<![CDATA[<p>A mutable static field could be changed by malicious code
or by accident.</p>

<p>The field could be made package protected to avoid this
vulnerability.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>MS_MUTABLE_HASHTABLE</id>
    <artifact tool="FindBugs" mnemonic="MS_MUTABLE_HASHTABLE"/>
    <name>Field is a mutable Hashtable</name>
    <shortMessage>Field is a mutable Hashtable that may be accessible by malicious code.</shortMessage>
    <info>
<![CDATA[<p>A final static field references a <code>Hashtable</code>
and can be accessed by malicious code or by accident from another
package. This code can freely modify the contents of the
<code>Hashtable</code>.</p>

<p>It is recommended that you consider replacing this
<code>Hashtable</code> with a <code>Map</code> implementation, such as
<code>HashMap</code>.]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>MS_MUTABLE_ARRAY</id>
    <artifact tool="FindBugs" mnemonic="MS_MUTABLE_ARRAY"/>
    <name>Field is a mutable array</name>
    <shortMessage>Field is a mutable array that may be accessible by malicious code.</shortMessage>
    <info>
<![CDATA[<p>A final static field references an array and can be
accessed by malicious code or by accident from another package. This
code can freely modify the contents of the array.</p>

<p>Consider encapsulating this field by reducing its visibility.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>MS_CANNOT_BE_FINAL</id>
    <artifact tool="FindBugs" mnemonic="MS_CANNOT_BE_FINAL"/>
    <name>Field cannot be final</name>
    <shortMessage>Field isn't final and can't be protected from malicious code.</shortMessage>
    <info>
<![CDATA[<p>A mutable static field could be changed by malicious code
or by accident from another package.  Unfortunately, the way the field
is used doesn't allow any easy fix to this problem.</p>

<p>Consider encapsulating this field by reducing its visibility.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>IA_AMBIGUOUS_INVOCATION_OF_INHERITED_OR_OUTER_METHOD</id>
    <artifact tool="FindBugs" mnemonic="IA_AMBIGUOUS_INVOCATION_OF_INHERITED_OR_OUTER_METHOD"/>
    <name>Ambiguous invocation of inherited or outer method</name>
    <shortMessage>Ambiguous invocation of either an inherited or outer method.</shortMessage>
    <info>
<![CDATA[<p>An inner class is invoking a method that could be resolved
to either a inherited method or a method defined in an outer class. By
the Java semantics, it will be resolved to invoke the inherited
method, but this may not be want you intend.</p>

<p>If you really intend to invoke the inherited method, invoke it by
invoking the method on <code>super</code>, for example, invoke
<code>super.foo(17)</code>, and thus it will be clear to other readers
of your code that you want to invoke the inherited method, not the
method in the outer class.</p>

<p>You may also want to consider renaming one or both of the methods
to avoid the confusion altogether.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NM_CLASS_NAMING_CONVENTION</id>
    <artifact tool="FindBugs" mnemonic="NM_CLASS_NAMING_CONVENTION"/>
    <artifact tool="PMD" mnemonic="ClassNamingConventions"/>
    <name>Class naming convention violation</name>
    <shortMessage>Class names should start with an upper case letter.</shortMessage>
    <info>
<![CDATA[<p>Class names should be nouns, in mixed case with the first
letter of each internal word capitalized. Try to keep your class names
simple and descriptive. Use whole words&mdash;avoid acronyms and
abbreviations.  Unless, of course, the abbreviation is much more
widely used than the long form, such as URL or HTML, it is recommended
that you use mixed case.  For example, <code>MyUrlClass</code> or
<code>HttpServlet</code>.</p>

<p>Class names should always begin with an upper case
character.</p>

<p>For further information, please reference Bloch's <i>Effective
Java</i> (second edition) item 56.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NM_METHOD_NAMING_CONVENTION</id>
    <artifact tool="FindBugs" mnemonic="NM_METHOD_NAMING_CONVENTION"/>
    <artifact tool="PMD" mnemonic="MethodNamingConventions"/>
    <name>Method naming convention violation</name>
    <shortMessage>Method names should start with an lower case letter.</shortMessage>
    <info>
<![CDATA[<p>Methods should be verbs, in mixed case with the first
letter lowercase, with the first letter of each internal word
capitalized.</p>

<p>Method names should always begin with a lower case character, and
should not contain underscores.</p>

<p>For further information, please reference Bloch's <i>Effective
Java</i> (second edition) item 56.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NM_FIELD_NAMING_CONVENTION</id>
    <artifact tool="FindBugs" mnemonic="NM_FIELD_NAMING_CONVENTION"/>
    <artifact tool="PMD" mnemonic="VariableNamingConventions"/>
    <name>Field naming convention violation</name>
    <shortMessage>Field names should start with an lower case letter.</shortMessage>
    <info>
<![CDATA[<p>Names of fields that are not final should be in mixed case
with a lowercase first letter and the first letters of subsequent
words capitalized.</p>

<p>Final variables that should be fully capitalized and non-final
variables should not include underscores.</p>

<p>For further information, please reference Bloch's <i>Effective
Java</i> (second edition) item 56.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NM_VERY_CONFUSING</id>
    <artifact tool="FindBugs" mnemonic="NM_VERY_CONFUSING"/>
    <name>Very confusing method names</name>
    <shortMessage>Very confusing method names, consider renaming one or both methods.</shortMessage>
    <info>
<![CDATA[<p>The referenced methods have names that differ only by
capitalization or the packages of their parameters. This is very
confusing because if the capitalization and parameter package names
were identical then one of the methods would override the other.</p>

<p>Consider renaming one or both methods to clarify their
differences.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NM_VERY_CONFUSING_INTENTIONAL</id>
    <artifact tool="FindBugs" mnemonic="NM_VERY_CONFUSING_INTENTIONAL"/>
    <name>Very confusing intentional method names</name>
    <shortMessage>Very confusing (but intentional) method names, consider trying to eliminate one of them.</shortMessage>
    <info>
<![CDATA[<p>The referenced methods have names that differ only by
capitalization or the packages of their parameters. This is very
confusing because if the capitalization were identical then one of the
methods would override the other.</p>

<p>From the existence of other methods, it seems that the existence of
both of these methods is intentional, but is sure is confusing. You
should try hard to eliminate one of them, unless you are forced to
have both due to frozen APIs.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NM_CONFUSING</id>
    <artifact tool="FindBugs" mnemonic="NM_CONFUSING"/>
    <name>Confusing method names</name>
    <shortMessage>Confusing method names, consider renaming one or both methods.</shortMessage>
    <info>
<![CDATA[<p>The referenced methods have names that differ only by
capitalization.</p>

<p>Consider renaming one or both methods to clarify their
differences.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NM_METHOD_CONSTRUCTOR_CONFUSION</id>
    <artifact tool="FindBugs" mnemonic="NM_METHOD_CONSTRUCTOR_CONFUSION"/>
    <artifact tool="PMD" mnemonic="MethodWithSameNameAsEnclosingClass"/>
    <name>Method versus constructor confusion</name>
    <shortMessage>Apparent method versus constructor confusion. Was this method intended to be a constructor?</shortMessage>
    <info>
<![CDATA[<p>This regular method has the same name as the class it is
defined in. It is likely that this was intended to be a
constructor.</p>

<p>If it was intended to be a constructor, remove the declaration of a
void return value. If you had accidentally defined this method, realized
the mistake, defined a proper constructor but can't get rid of this
method due to backwards compatibility, deprecate the method.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SuspiciousHashcodeMethodName</id>
    <artifact tool="FindBugs" mnemonic="NM_LCASE_HASHCODE"/>
    <artifact tool="PMD" mnemonic="SuspiciousHashcodeMethodName"/>
    <name>Suspicious hashcode() method name</name>
    <shortMessage>Class defines hashcode(); should it be hashCode()?</shortMessage>
    <info>
<![CDATA[<p>This class defines a method called
<code>hashcode</code>. This method does not override the
<code>hashCode</code> method in <code>java.lang.Object</code>, which
is probably what was intended.</p>

<p>The method name and return type are suspiciously close to
<code>hashCode</code>, which may mean you are intending to override
the <code>hashCode</code> method.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NM_LCASE_TOSTRING</id>
    <artifact tool="FindBugs" mnemonic="NM_LCASE_TOSTRING"/>
    <name>Suspicious tostring() method name</name>
    <shortMessage>Class defines tostring(); should it be toString()?</shortMessage>
    <info>
<![CDATA[<p>This class defines a method called
<code>tostring</code>. This method does not override the
<code>toString</code> method in <code>java.lang.Object</code>, which
is probably what was intended.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NM_BAD_EQUAL</id>
    <artifact tool="FindBugs" mnemonic="NM_BAD_EQUAL"/>
    <artifact tool="PMD" mnemonic="SuspiciousEqualsMethodName"/>
    <name>Suspicious equal() method name</name>
    <shortMessage>Class defines equal(); should it be equals()?</shortMessage>
    <info>
<![CDATA[<p>This class defines a method
<code>equal(Object)</code>. This method does not override the
<code>equals(Object)</code> method in <code>java.lang.Object</code>,
which is probably what was intended.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NM_CLASS_NOT_EXCEPTION</id>
    <artifact tool="FindBugs" mnemonic="NM_CLASS_NOT_EXCEPTION"/>
    <name>Class not an exception</name>
    <shortMessage>Class is not derived from an Exception, even though it is named as such.</shortMessage>
    <info>
<![CDATA[<p>This class is not derived from another exception, but ends
with <tt>Exception</tt>. This will be confusing to users of this
class.</p>

<p>Consider renaming this class to clarify this code.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>RR_NOT_CHECKED</id>
    <artifact tool="FindBugs" mnemonic="RR_NOT_CHECKED"/>
    <name>Read() return value not checked</name>
    <shortMessage>Method ignores results of one of the variants of the java.io.InputStream read() method.</shortMessage>
    <info>
<![CDATA[<p>This method ignores the return value of one of the
variants of <code>java.io.InputStream.read()</code> which can return
multiple bytes. If the return value is not checked, the caller will
not be able to correctly handle the case where fewer bytes were read
than the caller requested.</p>

<p>This is a particularly insidious kind of bug, because in many
programs, reads from input streams usually do read the full amount of
data requested, causing the program to fail only sporadically.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SR_NOT_CHECKED</id>
    <artifact tool="FindBugs" mnemonic="SR_NOT_CHECKED"/>
    <name>Skip() return value not checked</name>
    <shortMessage>Method ignores results of one of the variants of the java.io.InputStream skip() method.</shortMessage>
    <info>
<![CDATA[<p>This method ignores the return value of
<code>java.io.InputStream.skip()</code> which can skip multiple
bytes. If the return value is not checked, the caller will not be able
to correctly handle the case where fewer bytes were skipped than the
caller requested.</p>

<p>This is a particularly insidious kind of bug, because in many
programs, skips from input streams usually do skip the full amount of
data requested, causing the program to fail only sporadically. With
Buffered streams, however, <code>skip()</code> will only skip data in
the buffer, and will routinely fail to skip the requested number of
bytes.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SE_READ_RESOLVE_MUST_RETURN_OBJECT</id>
    <artifact tool="FindBugs" mnemonic="SE_READ_RESOLVE_MUST_RETURN_OBJECT"/>
    <name>ReadResolve() method must declare a return type of Object</name>
    <shortMessage>The readResolve() method must be declared with a return type of Object.</shortMessage>
    <info>
<![CDATA[<p>In order for the <code>readResolve()</code> method to be
recognized by the serialization mechanism it must declare a return
type of <code>java.lang.Object</code>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SE_TRANSIENT_FIELD_OF_NONSERIALIZABLE_CLASS</id>
    <artifact tool="FindBugs" mnemonic="SE_TRANSIENT_FIELD_OF_NONSERIALIZABLE_CLASS"/>
    <name>Transient field in a non-serializable class</name>
    <shortMessage>Transient field in a class that is not Serializable.</shortMessage>
    <info>
<![CDATA[<p>The field is marked as transient, but the class isn't
<code>Serializable</code>, so marking it as transient has absolutely
no effect.</p>

<p>This may be leftover marking from a previous version of the code in
which the class was transient, or it may indicate a misunderstanding
of how serialization works.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SE_TRANSIENT_FIELD_NOT_RESTORED</id>
    <artifact tool="FindBugs" mnemonic="SE_TRANSIENT_FIELD_NOT_RESTORED"/>
    <name>Suspicious transient field</name>
    <shortMessage>Transient field that isn't set by deserialization.</shortMessage>
    <info>
<![CDATA[<p>This class contains a field that is updated at multiple
places in the class, thus it seems to be part of the state of the
class. However, since the field is marked as transient and not set in
<code>readObject</code> or <code>readResolve</code>, it will contain
the default value in any deserialized instance of the class.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SE_METHOD_MUST_BE_PRIVATE</id>
    <artifact tool="FindBugs" mnemonic="SE_METHOD_MUST_BE_PRIVATE"/>
    <name>Serialization method must be private</name>
    <shortMessage>Method must be declared to be private in order for serialization to work.</shortMessage>
    <info>
<![CDATA[<p>This class implements the <code>Serializable</code>
interface, and defines a method for custom
serialization/deserialization. But since that method isn't declared
private, it will be silently ignored by the
serialization/deserialization API.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SE_NO_SUITABLE_CONSTRUCTOR_FOR_EXTERNALIZATION</id>
    <artifact tool="FindBugs" mnemonic="SE_NO_SUITABLE_CONSTRUCTOR_FOR_EXTERNALIZATION"/>
    <name>No suitable constructor for externalization</name>
    <shortMessage>Class is Externalizable but it doesn't define a void constructor so it will fail at runtime.</shortMessage>
    <info>
<![CDATA[<p>This class implements the <code>Externalizable</code>
interface, but does not define a void constructor. When
<code>Externalizable</code> objects are deserialized, they first need
to be constructed by invoking the void constructor. Because this class
does not have one, serialization and deserialization will fail at
runtime.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SE_NO_SUITABLE_CONSTRUCTOR</id>
    <artifact tool="FindBugs" mnemonic="SE_NO_SUITABLE_CONSTRUCTOR"/>
    <name>No suitable constructor for serialization</name>
    <shortMessage>Class is Serializable but its superclass doesn't define a void constructor so it will fail at runtime.</shortMessage>
    <info>
<![CDATA[<p> This class implements the <code>Serializable</code>
interface and its superclass does not. When such an object is
deserialized, the fields of the superclass need to be initialized by
invoking the void constructor of the superclass. Since the superclass
does not have one, serialization and deserialization will fail at
runtime.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SE_NO_SERIALVERSIONID</id>
    <artifact tool="FindBugs" mnemonic="SE_NO_SERIALVERSIONID"/>
    <artifact tool="PMD" mnemonic="MissingSerialVersionUID"/>
    <name>No serialVersionUID field defined for serialization</name>
    <shortMessage>Class is Serializable, but it doesn't define a serialVersionUID field.</shortMessage>
    <info>
<![CDATA[<p>This class implements the <code>Serializable</code>
interface, but does not define a <code>serialVersionUID</code>
field.</p>

<p>A change as simple as adding a reference to a <code>.class</code>
object will add synthetic fields to the class, which will
unfortunately change the implicit serialVersionUID.  For example,
adding a reference to <code>String.class</code> will generate a static
field <code>class$java$lang$String</code>.</p>

<p>Also, different source code to bytecode compilers may use different
naming conventions for synthetic variables generated for references to
class objects or inner classes.  To ensure interoperability of
<code>Serializable</code> across versions, consider adding an explicit
<code>serialVersionUID</code> field.</p>

<p>This field can be generated within some Java IDEs. For example the
below <code>serialVersionUID</code> field was generated by
Eclipse.</p>

<pre>
public final class FutureDatabaseException extends Exception {
  ...
  private static final long serialVersionUID = 6446502447505736644L;
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SE_COMPARATOR_SHOULD_BE_SERIALIZABLE</id>
    <artifact tool="FindBugs" mnemonic="SE_COMPARATOR_SHOULD_BE_SERIALIZABLE"/>
    <name>Comparator should be Serializable</name>
    <shortMessage>Comparator doesn't implement Serializable.</shortMessage>
    <info>
<![CDATA[<p>This class implements the <code>Comparator</code>
interface. You should consider whether or not it should also implement
the <code>Serializable</code> interface. If a comparator is used to
construct an ordered collection such as a <code>TreeMap</code>, then
the <code>TreeMap</code> will be serializable only if the comparator
is also serializable.</p>

<p>As most comparators have little or no state, making them
serializable is generally easy and good defensive programming.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SF_SWITCH_FALLTHROUGH</id>
    <artifact tool="FindBugs" mnemonic="SF_SWITCH_FALLTHROUGH"/>
    <artifact tool="PMD" mnemonic="MissingBreakInSwitch"/>
    <name>Switch fallthrough</name>
    <shortMessage>Switch statement found where one case falls through to the next case.  Did you forget a break or return?</shortMessage>
    <info>
<![CDATA[<p>This method contains a switch statement where one case
branch will fall through to the next case. Usually you need to end
this case with a break or return.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH</id>
    <artifact tool="FindBugs" mnemonic="SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH"/>
    <name>Dead store due to switch fallthrough</name>
    <shortMessage>Dead store due to switch statement fallthrough.  Did you forget a break or return?</shortMessage>
    <info>
<![CDATA[<p>A value stored in the previous switch case is overwritten
here due to a switch fall through. It is likely that you forgot to put
a break or return at the end of the previous case.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>WS_WRITEOBJECT_SYNC</id>
    <artifact tool="FindBugs" mnemonic="WS_WRITEOBJECT_SYNC"/>
    <name>Suspicious writeObject() is the only synchronized method</name>
    <shortMessage>Suspicious that the writeObject() method is synchronized but nothing else is.</shortMessage>
    <info>
<![CDATA[<p>This class has a <code>writeObject()</code> method which
is synchronized; however, no other method of the class is
synchronized.  Check that the concurrency policy of this class is
implemented correctly.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>RS_READOBJECT_SYNC</id>
    <artifact tool="FindBugs" mnemonic="RS_READOBJECT_SYNC"/>
    <name>Suspicious synchronized readObject() method</name>
    <shortMessage>Suspicious that the readObject() method is synchronized, it probably does not need to be.</shortMessage>
    <info>
<![CDATA[<p>This serializable class defines a
<code>readObject()</code> which is synchronized. By definition, an
object created by deserialization is only reachable by one thread, and
thus there is no need for <code>readObject()</code> to be
synchronized.</p>

<p>If the <code>readObject()</code> method itself is causing the
object to become visible to another thread, that is an example of very
dubious coding style.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SE_NONSTATIC_SERIALVERSIONID</id>
    <artifact tool="FindBugs" mnemonic="SE_NONSTATIC_SERIALVERSIONID"/>
    <name>Non-static serialVersionUID field</name>
    <shortMessage>The serialVersionUID field is not static, but it should be.</shortMessage>
    <info>
<![CDATA[<p>This class defines a <code>serialVersionUID</code> field
that is not static.</p>

<p>The field should be made static if it is intended to specify the
version UID for purposes of serialization. If it is not intended for
this purpose it should probably be renamed to avoid confusion.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SE_NONFINAL_SERIALVERSIONID</id>
    <artifact tool="FindBugs" mnemonic="SE_NONFINAL_SERIALVERSIONID"/>
    <name>Non-final serialVersionUID field</name>
    <shortMessage>The serialVersionUID is not final, but it should be.</shortMessage>
    <info>
<![CDATA[<p>This class defines a <code>serialVersionUID</code> field
that is not final.</p>

<p>The field should be made final if it is intended to specify the
version UID for purposes of serialization. If it is not intended for
this purpose it should probably be renamed to avoid confusion.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SE_NONLONG_SERIALVERSIONID</id>
    <artifact tool="FindBugs" mnemonic="SE_NONLONG_SERIALVERSIONID"/>
    <name>Non-long serialVersionUID field</name>
    <shortMessage>serialVersionUID is not of type long, but it should be.</shortMessage>
    <info>
<![CDATA[<p>This class defines a <code>serialVersionUID</code> field
that is not long.</p>

<p>The field should be made long if it is intended to specify the
version UID for purposes of serialization. If it is not intended for
this purpose it should probably be renamed to avoid confusion.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SE_BAD_FIELD</id>
    <artifact tool="FindBugs" mnemonic="SE_BAD_FIELD"/>
    <name>Bad field in a serializable class</name>
    <shortMessage>Non-transient, non-serializable instance field in a serializable class.  This class could fail at runtime.</shortMessage>
    <info>
<![CDATA[<p>This <code>Serializable</code> class defines a
non-primitive instance field which is neither <code>transient</code>,
<code>Serializable</code>, or <code>java.lang.Object</code>, and does
not appear to implement the <code>Externalizable</code> interface or
the <code>readObject()</code> and <code>writeObject()</code>
methods.</p>

<p>Objects of this class will not be deserialized correctly if a
non-Serializable object is stored in this field.  Consider fixing this
implementation so that it can be statically checked.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SE_BAD_FIELD_INNER_CLASS</id>
    <artifact tool="FindBugs" mnemonic="SE_BAD_FIELD_INNER_CLASS"/>
    <name>Serializable inner class inside a non-serializable class</name>
    <shortMessage>Non-serializable class has a serializable inner class.  This class could fail at runtime.</shortMessage>
    <info>
<![CDATA[<p>This Serializable class is an inner class of a
non-serializable class. Thus, attempts to serialize it will also
attempt to serialize the instance of the outer class with which it is
associated, leading to a runtime error.</p>

<p>If possible, making the inner class a static inner class should
solve the problem. Making the outer class serializable might also
work, but that would mean serializing an instance of the inner class
would always also serialize the instance of the outer class, which is
often not what you really want.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SE_INNER_CLASS</id>
    <artifact tool="FindBugs" mnemonic="SE_INNER_CLASS"/>
    <name>Serializable inner class</name>
    <shortMessage>Serializable inner class will also serialize the associated outer instance.  Is this intended?</shortMessage>
    <info>
<![CDATA[<p>This Serializable class is an inner class. Any attempt to
serialize it will also serialize the associated outer instance. The
outer instance is serializable, so this won't fail, but it might
serialize a lot more data than intended.</p>

<p>If possible, declaring the inner class to be static might be what
you want to do to avoid this issue.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SE_BAD_FIELD_STORE</id>
    <artifact tool="FindBugs" mnemonic="SE_BAD_FIELD_STORE"/>
    <name>Non-serializable value stored into a serializable field</name>
    <shortMessage>Non-serializable value stored into instance field of a serializable class.</shortMessage>
    <info>
<![CDATA[<p>A non-serializable value is stored into a non-transient
field of a serializable class.  This may cause the class to fail at
runtime when it is serialized.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SC_START_IN_CTOR</id>
    <artifact tool="FindBugs" mnemonic="SC_START_IN_CTOR"/>
    <name>Thread start() call in constructor</name>
    <shortMessage>This constructor invokes Thread.start() which is highly dubious.</shortMessage>
    <info>
<![CDATA[<p>The constructor starts a thread. This is likely to be
wrong if the class is ever extended/subclassed, since the thread will
be started before the subclass constructor is started.  This practice
can also cause subtle race conditions.</p>

<p>Consider moving the thread start into a separate method, such as an
<code>init</code> method.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SS_SHOULD_BE_STATIC</id>
    <artifact tool="FindBugs" mnemonic="SS_SHOULD_BE_STATIC"/>
    <artifact tool="PMD" mnemonic="FinalFieldCouldBeStatic"/>
    <name>Should field be static</name>
    <shortMessage>This field is initialized to a compile-time static value.  Should this field be static?</shortMessage>
    <info>
<![CDATA[<p>This class contains an instance final field that is
initialized to a compile-time static value. Consider making the field
static.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UUF_UNUSED_FIELD</id>
    <artifact tool="FindBugs" mnemonic="UUF_UNUSED_FIELD"/>
    <artifact tool="PMD" mnemonic="UnusedPrivateField"/>
    <name>Unused field</name>
    <shortMessage>This field is never used.</shortMessage>
    <info>
<![CDATA[<p>This field is never used. Consider removing it from the
class.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>URF_UNREAD_FIELD</id>
    <artifact tool="FindBugs" mnemonic="URF_UNREAD_FIELD"/>
    <name>Unread field</name>
    <shortMessage>This field is never read.</shortMessage>
    <info>
<![CDATA[<p>This field is never read. Consider removing it from the
class.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>QF_QUESTIONABLE_FOR_LOOP</id>
    <artifact tool="FindBugs" mnemonic="QF_QUESTIONABLE_FOR_LOOP"/>
    <name>Questionable for loop</name>
    <shortMessage>Complicated, subtle or wrong increment in for loop.</shortMessage>
    <info>
<![CDATA[<p>Are you sure this for loop is incrementing the correct
variable? It appears that another variable is being initialized and
checked by the for loop.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UWF_NULL_FIELD</id>
    <artifact tool="FindBugs" mnemonic="UWF_NULL_FIELD"/>
    <name>Null-only field</name>
    <shortMessage>This field is always null. Check for errors or remove the field if it is useless.</shortMessage>
    <info>
<![CDATA[<p>All writes to this field are the constant value
<code>null</code>, and thus all reads of the field will return
<code>null</code>. It is highly likely that there is something muddled
about this code. Check for errors, or remove the field if it is
useless.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UWF_UNWRITTEN_FIELD</id>
    <artifact tool="FindBugs" mnemonic="UWF_UNWRITTEN_FIELD"/>
    <artifact tool="FindBugs" mnemonic="NP_UNWRITTEN_FIELD"/>
    <name>Unwritten field</name>
    <shortMessage>This field is never written to. All reads of it will return the default value. Is this intended?</shortMessage>
    <info>
<![CDATA[<p>This field is never written to. All reads of it will
return the default value. Check for errors (e.g., should this field
have been initialized?), or remove it if it is useless.</p>

<p>If this field is an object reference, i.e., not of a primitive
type, then it will be <code>null</code> and dereferencing it will
throw a <code>NullPointerException</code>.]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD</id>
    <artifact tool="FindBugs" mnemonic="ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD"/>
    <name>Write to a static from an instance method</name>
    <shortMessage>Write to a static field from an instance method. Is this intended?</shortMessage>
    <info>
<![CDATA[<p>This instance method writes to a static field.  This is
tricky to get correct if multiple instances of this class are being
manipulated, and generally bad practice.  Also check that this write
has not created a race condition.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NP_LOAD_OF_KNOWN_NULL_VALUE</id>
    <artifact tool="FindBugs" mnemonic="NP_LOAD_OF_KNOWN_NULL_VALUE"/>
    <name>Load of a known null value</name>
    <shortMessage>The variable referenced at this point is known to be null. Is this a mistake?</shortMessage>
    <info>
<![CDATA[<p>The variable referenced at this point is known to be
<code>null</code> due to an earlier check against
<code>null</code>. Although this is valid, it might be a mistake</p>

<p>Perhaps you intended to refer to a different variable, or perhaps
the earlier check to see if the variable is <code>null</code> should
have been a check to see if it was non-null.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NP_IMMEDIATE_DEREFERENCE_OF_READLINE</id>
    <artifact tool="FindBugs" mnemonic="NP_IMMEDIATE_DEREFERENCE_OF_READLINE"/>
    <artifact tool="FindBugs" mnemonic="NP_DEREFERENCE_OF_READLINE_VALUE"/>
    <name>Dereference of readLine() result</name>
    <shortMessage>This code dereferences the result of a call to readLine(). This code may throw a NullPointerException.</shortMessage>
    <info>
<![CDATA[<p>The result of invoking <code>readLine()</code> is
immediately dereferenced by this code. If there are no more lines of
text to read, <code>readLine()</code> method will return
<code>null</code> and dereferencing that will throw a
<code>NullPointerException</code>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SIC_INNER_SHOULD_BE_STATIC</id>
    <artifact tool="FindBugs" mnemonic="SIC_INNER_SHOULD_BE_STATIC"/>
    <artifact tool="FindBugs" mnemonic="SIC_INNER_SHOULD_BE_STATIC_ANON"/>
    <artifact tool="FindBugs" mnemonic="SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS"/>
    <name>Inner class should be static</name>
    <shortMessage>This inner class should be declared to be static.</shortMessage>
    <info>
<![CDATA[<p>This class is an inner class, but does not use its
embedded reference to the object which created it. This reference
makes instances of the inner class larger, and may keep the reference
to the creator object alive longer than necessary.  If possible, the
class should be made static.</p>

<p>If the inner class is anonymous then it will need to be named to be
declared to be <code>static</code>.  This is because anonymous inner
classes cannot be marked as <code>static</code>.</p>

<p>If a reference to the outer object is required during construction
of the inner instance, the inner class will need to be refactored so
as to pass a reference to the outer instance to the constructor for
the inner class (after construction the outer instance reference
should no longer be needed).</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NP_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR</id>
    <artifact tool="FindBugs" mnemonic="NP_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR"/>
    <artifact tool="FindBugs" mnemonic="UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR"/>
    <name>Field not initialized in constructor</name>
    <shortMessage>This code reads a field that is not initialized in any constructor.</shortMessage>
    <info>
<![CDATA[<p>This is a read of a field is never initialized within any
constructor, and is therefore could be <code>null</code> after the
object is initialized. If this field is dereferenced it could cause a
<code>NullPointerException</code> to be thrown.</p>

<p>This might be a coding error, or else the class containing the
field is written in a way that depends upon methods being called in
some specific order (perhaps a little bit dodgy, but not necessarily
wrong).</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>WA_NOT_IN_LOOP</id>
    <artifact tool="FindBugs" mnemonic="WA_NOT_IN_LOOP"></artifact>
    <name>Wait() outside loop</name>
    <shortMessage>This call to wait() is not in loop. Are you sure the condition waited for is true?</shortMessage>
    <info>
<![CDATA[<p>This method contains a call to
<code>java.lang.Object.wait()</code> which is not in a loop.  If the
monitor is used for multiple conditions, the condition the caller
intended to wait for might not be the one that actually
occurred.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>WA_AWAIT_NOT_IN_LOOP</id>
    <artifact tool="FindBugs" mnemonic="WA_AWAIT_NOT_IN_LOOP"/>
    <name>Await() outside loop</name>
    <shortMessage>This call to Condition.await() is not in a loop.  Are you sure the condition waited for is true?</shortMessage>
    <info>
<![CDATA[<p>This method contains a call to
<code>java.util.concurrent.Condition.await()</code> (or variants)
which is not in a loop. If the object is used for multiple conditions,
the condition the caller intended to wait for might not be the one
that actually occurred.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NO_NOTIFY_NOT_NOTIFYALL</id>
    <artifact tool="FindBugs" mnemonic="NO_NOTIFY_NOT_NOTIFYALL"/>
    <artifact tool="PMD" mnemonic="UseNotifyAllInsteadOfNotify"/>
    <name>Use notifyAll() not notify()</name>
    <shortMessage>Consider using notifyAll() rather than notify().</shortMessage>
    <info>
<![CDATA[<p>This method calls <code>notify()</code> rather than
<code>notifyAll()</code>. Java monitors are often used for multiple
conditions. Calling <code>notify()</code> only wakes up one thread,
meaning that the thread woken up might not be the one waiting for the
condition that the caller just satisfied.</p>

<p>The thread chosen is arbitrary (i.e., it is <i>not</i> the first
thread that waited); thus it's usually safer to call
<code>notifyAll()</code> instead.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>RV_CHECK_FOR_POSITIVE_INDEXOF</id>
    <artifact tool="FindBugs" mnemonic="RV_CHECK_FOR_POSITIVE_INDEXOF"/>
    <name>Avoid check for positive indexOf()</name>
    <shortMessage>Method checks to see if result of String.indexOf() is positive rather than negative.</shortMessage>
    <info>
<![CDATA[<p>The method invokes <code>String.indexOf</code> and checks
to see if the result is positive or non-positive. It is much more
typical to check to see if the result is negative or non-negative.
The reason for this is that a result of 0 indicates that the substring
occurs at the beginning of the String&mdash;not that it was not
found. The result is positive only if the substring checked for occurs
at some place other than at the beginning of the String.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>RV_DONT_JUST_NULL_CHECK_READLINE</id>
    <artifact tool="FindBugs" mnemonic="RV_DONT_JUST_NULL_CHECK_READLINE"/>
    <name>Line read by readLine() ignored</name>
    <shortMessage>Method discards the result of readLine() after checking if it is non-null. Is it intended to throw away the line just read?</shortMessage>
    <info>
<![CDATA[<p>The value returned by <code>readLine()</code> is discarded
after checking to see if it is non-null. In almost all situations, if
the result is non-null, you will want to use that non-null value
because it represents the line that was read. Note that calling
<code>readLine</code> again will give you a different line.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>RV_RETURN_VALUE_IGNORED</id>
    <artifact tool="FindBugs" mnemonic="RV_RETURN_VALUE_IGNORED"/>
    <artifact tool="FindBugs" mnemonic="RV_RETURN_VALUE_IGNORED2"/>
    <name>Immutable object return value ignored</name>
    <shortMessage>This code ignores the return value of an immutable object.  Is this a mistake?</shortMessage>
    <info>
<![CDATA[<p>The return value of this method should be checked.  One
common cause of this warning is to invoke a method on an immutable
object, thinking that it updates the object. For example, in the
following code fragment,</p>

<pre>
String dateString = getHeaderField(name);
dateString.trim();
</pre>

<p>the programmer seems to be thinking that the <code>trim()</code>
method will update the String referenced by
<code>dateString</code>. But since Strings are immutable, the
<code>trim()</code> function returns a new String value, which is
being ignored here. The code should be corrected to: </p>

<pre>
String dateString = getHeaderField(name);
dateString = dateString.trim();
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NP_ALWAYS_NULL</id>
    <artifact tool="FindBugs" mnemonic="NP_ALWAYS_NULL"></artifact>
    <name>Null dereference</name>
    <shortMessage>A null pointer is dereferenced here which will throw a NullPointerException at runtime.</shortMessage>
    <info>
<![CDATA[<p>A <code>null</code> pointer is dereferenced here.  This
will lead to a <code>NullPointerException</code> being thrown when the
code is executed.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NP_STORE_INTO_NONNULL_FIELD</id>
    <artifact tool="FindBugs" mnemonic="NP_STORE_INTO_NONNULL_FIELD"/>
    <name>Store into a @NonNull field</name>
    <shortMessage>Store of a possible null value into field annotated with @NonNull.</shortMessage>
    <info>
<![CDATA[<p>A value that could be <code>null</code> is stored into a
field that has been annotated @NonNull.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NP_ALWAYS_NULL_EXCEPTION</id>
    <artifact tool="FindBugs" mnemonic="NP_ALWAYS_NULL_EXCEPTION"/>
    <artifact tool="FindBugs" mnemonic="NP_NULL_ON_SOME_PATH_EXCEPTION"/>
    <name>Null dereference on exceptional path</name>
    <shortMessage>This code has a null pointer dereference on an exceptional path.</shortMessage>
    <info>
<![CDATA[<p>A pointer which is <code>null</code> on an exception path
is dereferenced here. This will lead to a
<code>NullPointerException</code> being thrown when the code is
executed. Note that because the analysis currently does not prune
infeasible exception paths, this may be a false warning.</p>

<p>Also note that the analysis considers the default case of a
<code>switch</code> statement to be an exception path, since the
default case is often infeasible.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NP_NULL_ON_SOME_PATH</id>
    <artifact tool="FindBugs" mnemonic="NP_NULL_ON_SOME_PATH">
    </artifact>
    <name>Null dereference on some path</name>
    <shortMessage>This code may dereference a null pointer and throw a NullPointerException.</shortMessage>
    <info>
<![CDATA[<p>A reference value dereferenced here might be
<code>null</code> at runtime. This may lead to a
<code>NullPointerException</code> being thrown when the code is
executed.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE</id>
    <artifact tool="FindBugs" mnemonic="NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE"/>
    <name>Null dereference on some path from return</name>
    <shortMessage>This code may dereference a null pointer and throw a NullPointerException due to return value of a called method.</shortMessage>
    <info>
<![CDATA[<p>A reference value which is <code>null</code> on some
exception control path is dereferenced here. This may lead to a
<code>NullPointerException</code> when the code is executed.</p>

<p>The value may be <code>null</code> because it was returned from a
method which is known to return possibly-null values.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NP_NULL_PARAM_DEREF_NONVIRTUAL</id>
    <artifact tool="FindBugs" mnemonic="NP_NULL_PARAM_DEREF_NONVIRTUAL"/>
    <artifact tool="FindBugs" mnemonic="NP_NULL_PARAM_DEREF_ALL_TARGETS_DANGEROUS"/>
    <artifact tool="FindBugs" mnemonic="NP_NULL_PARAM_DEREF"/>
    <name>Null dereference of paramenter</name>
    <shortMessage>A method call passes null for an unconditionally dereferenced parameter. This may result in a NullPointerException being thrown if this code is executed.</shortMessage>
    <info>
<![CDATA[<p>A possibly-<code>null</code> value is passed to a method
which unconditionally dereferences it. This may result in a
<code>NullPointerException</code> being thrown at runtime if this code
is executed.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NP_NONNULL_PARAM_VIOLATION</id>
    <artifact tool="FindBugs" mnemonic="NP_NONNULL_PARAM_VIOLATION"/>
    <name>NonNull parameter violation</name>
    <shortMessage>This method call passes null to a non-null parameter.</shortMessage>
    <info>
<![CDATA[<p>This method passes a <code>null</code> value as the
parameter of a method which must be non-null. Either this parameter has
been explicitly annotated as @NonNull, or the analysis has determined that
this parameter is always dereferenced.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NP_NONNULL_RETURN_VIOLATION</id>
    <artifact tool="FindBugs" mnemonic="NP_NONNULL_RETURN_VIOLATION"/>
    <name>NonNull return violation</name>
    <shortMessage>This method may return null, but its return value is declared @NonNull.</shortMessage>
    <info>
<![CDATA[<p>This method may return a <code>null</code> value, but the
method (or a superclass method which it overrides) is declared to
return @NonNull.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NP_CLONE_COULD_RETURN_NULL</id>
    <artifact tool="FindBugs" mnemonic="NP_CLONE_COULD_RETURN_NULL"/>
    <name>Clone() may return null</name>
    <shortMessage>This clone method may return null. This violates the contract for clone.</shortMessage>
    <info>
<![CDATA[<p>This clone method seems to return <code>null</code> in
some circumstances.  This violates the contract for clone because it
is never allowed to return a <code>null</code> value.</p>

<p>If you are convinced this path is unreachable, throw an
<code>AssertionError</code> instead of returning
<code>null</code>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NP_TOSTRING_COULD_RETURN_NULL</id>
    <artifact tool="FindBugs" mnemonic="NP_TOSTRING_COULD_RETURN_NULL"/>
    <name>ToString() may return null</name>
    <shortMessage>This toString() method may return null.  This could cause other code to break and is a bad coding practice.</shortMessage>
    <info>
<![CDATA[<p>This <code>toString()</code> method seems to return
<code>null</code> in some circumstances. A liberal reading of the
specification could be interpreted as allowing this, but it is
probably a very bad idea because it could cause other code to break.</p>

<p>It is suggested that you return the empty string or some other
appropriate string rather than <code>null</code>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NP_GUARANTEED_DEREF</id>
    <artifact tool="FindBugs" mnemonic="NP_GUARANTEED_DEREF"/>
    <name>Null dereference guaranteed on branch</name>
    <shortMessage>A null value is guaranteed to be dereferenced. This may result in a NullPointerException being thrown if this code is executed.</shortMessage>
    <info>
<![CDATA[<p>There is a statement or branch that if executed guarantees
that a value is <code>null</code> at this point, and that value that
is guaranteed to be dereferenced (except on forward paths involving
runtime exceptions). This may result in a
<code>NullPointerException</code> being thrown at runtime.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH</id>
    <artifact tool="FindBugs" mnemonic="NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH"/>
    <name>Null dereference guaranteed on exceptional path</name>
    <shortMessage>A null value is guaranteed to be dereferenced on an exception path. This may result in a NullPointerException being thrown if this code is executed.</shortMessage>
    <info>
<![CDATA[<p>There is a statement or branch on an exception path that
if executed guarantees that a value is <code>null</code> at this
point, and that value that is guaranteed to be dereferenced (except on
forward paths involving runtime exceptions). This may result in a
<code>NullPointerException</code> being thrown at runtime.</p></p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SI_INSTANCE_BEFORE_FINALS_ASSIGNED</id>
    <artifact tool="FindBugs" mnemonic="SI_INSTANCE_BEFORE_FINALS_ASSIGNED"/>
    <name>Instance constructed before static finals assigned</name>
    <shortMessage>This static initializer creates an instance before all static final fields have been assigned.  This could cause errors if the constructors expect the final static fields to have been assigned.</shortMessage>
    <info>
<![CDATA[<p>The class's static initializer creates an instance of the
class before all of the static final fields are assigned.</p>

<p>This could cause subtle behavior problems if the constructors rely
upon the final static field to have been assigned.  It is recommended
that this static initializer block be moved below the field
declarations to avoid this problem.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>PZLA_PREFER_ZERO_LENGTH_ARRAYS</id>
    <artifact tool="FindBugs" mnemonic="PZLA_PREFER_ZERO_LENGTH_ARRAYS"/>
    <artifact tool="PMD" mnemonic="ReturnEmptyArrayRatherThanNull"/>
    <name>Return zero length arrays instead of null</name>
    <shortMessage>Consider returning a zero length array rather than null.</shortMessage>
    <info>
<![CDATA[<p>It is nearly always a better design to return a length
zero array rather than a <code>null</code> reference to indicate that
there are no results (i.e., an empty list of results). This way, no
explicit check for null is needed by clients of the method.</p>

<p>For example, change code similar to</p>

<pre>
public String[] getArrayOfStrings() {
  // do something
  return null;
}
</pre>

<p>to</p>

<pre>
public String[] getArrayOfStrings() {
  // do something
  return new String[0];
}
</pre>

<p>This can be placed into a constant because you only need one
zero-length array for each type.</p>

<p>On the other hand, using <code>null</code> to indicate "there is no
answer to this question", then it is probably appropriate. For
example, <code>File.listFiles()</code> returns an empty list if given
a directory containing no files, and returns <code>null</code> if the
file is not a directory.</p>

<p>For more information see Bloch's <i>Effective Java</i> (second
edition) item 43.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UCF_USELESS_CONTROL_FLOW</id>
    <artifact tool="FindBugs" mnemonic="UCF_USELESS_CONTROL_FLOW"/>
    <artifact tool="FindBugs" mnemonic="UCF_USELESS_CONTROL_FLOW_NEXT_LINE"/>
    <name>Useless control flow</name>
    <shortMessage>The code appears to have useless control flow. Is this intentional or is it a mistake?</shortMessage>
    <info>
<![CDATA[<p>This method contains a useless control flow statement,
where control flow continues onto the same place regardless of whether
or not the branch is taken. For example, this can be caused by having
an empty statement block for an <code>if</code> statement</p>

<pre>
if (argv.length == 0) {
  // TODO: handle this case
}
</pre>

<p>or by inadvertently using an empty statement as the body of an
<code>if</code> statement</p>

<pre>
if (argv.length == 1);
  System.out.println("I always run, regardless of indentation" + argv[0]);
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE</id>
    <artifact tool="FindBugs" mnemonic="RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE"/>
    <artifact tool="PMD" mnemonic="MisplacedNullCheck"/>
    <name>Null check of previously dereferenced value</name>
    <shortMessage>This null check would have previously thrown a NullPointerException if the value is null. Either the check is redundant or the previous dereference is erroneous.</shortMessage>
    <info>
<![CDATA[<p>A value is checked here to see whether it is
<code>null</code>, but this value can't be <code>null</code> because
it was previously dereferenced and if it were <code>null</code> then a
<code>NullPointerException</code> would have been thrown at the
earlier dereference.</p>

<p>Essentially, this code and the previous dereference disagree as to
whether this value is allowed to be <code>null</code>. Either the
check is redundant or the previous dereference is erroneous. Clearly
some fix to the code is necessary.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE</id>
    <artifact tool="FindBugs" mnemonic="RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE"/>
    <name>Redundant null check of null value</name>
    <shortMessage>This code contains a redundant null check of a value known to be null. This check can be removed.</shortMessage>
    <info>
<![CDATA[<p>This method contains a redundant check of a known null
value against the constant null. The redundant check can be removed
from the code.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE</id>
    <artifact tool="FindBugs" mnemonic="RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE"/>
    <name>Redundant null check of non-null value</name>
    <shortMessage>This code contains a redundant null check of a value known to be non-null. This check can be removed.</shortMessage>
    <info>
<![CDATA[<p>This method contains a redundant check of a known non-null
value against the constant null. The redundant check can be removed
from the code.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>RCN_REDUNDANT_COMPARISON_TWO_NULL_VALUES</id>
    <artifact tool="FindBugs" mnemonic="RCN_REDUNDANT_COMPARISON_TWO_NULL_VALUES"/>
    <name>Redundant comparison of two null values</name>
    <shortMessage>This method contains a redundant comparison of two references known to both be definitely null. Fix this muddled code.</shortMessage>
    <info>
<![CDATA[<p>This method contains a redundant comparison of two
references known to both be definitely <code>null</code>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>RCN_REDUNDANT_COMPARISON_OF_NULL_AND_NONNULL_VALUE</id>
    <artifact tool="FindBugs" mnemonic="RCN_REDUNDANT_COMPARISON_OF_NULL_AND_NONNULL_VALUE"/>
    <name>Redundant comparison of a null and a non-null value</name>
    <shortMessage>This method contains a redundant comparison of a reference known to be non-null with another reference known to be null. Fix this muddled code.</shortMessage>
    <info>
<![CDATA[<p>This method contains a redundant comparison of a reference
known to be non-<code>null</code> with another reference known to be
<code>null</code>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UL_UNRELEASED_LOCK</id>
    <artifact tool="FindBugs" mnemonic="UL_UNRELEASED_LOCK"/>
    <artifact tool="FindBugs" mnemonic="UL_UNRELEASED_LOCK_EXCEPTION_PATH"/>
    <name>Unreleased util concurrent lock</name>
    <shortMessage>This method does not release a util concurrent dynamic lock on all paths.</shortMessage>
    <info>
<![CDATA[<p>This method acquires a <code>java.util.concurrent</code>
lock, but does not release it on all paths (exceptional or
unexceptional) out of the method. In general, the correct idiom for
using a util concurrent lock is</p>

<pre>
Lock l = ...;
l.lock();
try {
  // do something
} finally {
  l.unlock();
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>RC_REF_COMPARISON</id>
    <artifact tool="FindBugs" mnemonic="RC_REF_COMPARISON"/>
    <name>Suspicious reference comparison</name>
    <shortMessage>This code contains a suspicious reference comparison. Should it be using equals() instead?</shortMessage>
    <info>
<![CDATA[<p>This method compares two reference values using the == or
!= operator, where the correct way to compare instances of this type
is generally with the <code>equals()</code> method. Examples of
classes which should generally not be compared by reference are
<code>java.lang.Integer</code>, <code>java.lang.Float</code>,
etc.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EC_UNRELATED_TYPES</id>
    <artifact tool="FindBugs" mnemonic="EC_UNRELATED_TYPES"/>
    <artifact tool="FindBugs" mnemonic="EC_UNRELATED_INTERFACES"/>
    <artifact tool="FindBugs" mnemonic="EC_UNRELATED_CLASS_AND_INTERFACE"/>
    <name>Avoid calling equals() on unrelated types</name>
    <shortMessage>This code calls equals() comparing two different and unrelated types. Fix this muddled code.</shortMessage>
    <info>
<![CDATA[<p>This method calls <code>equals()</code> on two references
of different class types with no common subclasses.  Therefore, the
objects being compared are unlikely to be members of the same class at
runtime (unless some application classes were not analyzed, or dynamic
class loading can occur at runtime).</p>

<p>According to the contract of <code>equals()</code>, objects of
different classes should always compare as unequal; therefore,
according to the contract defined by
<code>java.lang.Object.equals(Object)</code>, the result of this
comparison will always be false at runtime.</p>

<p>This finding may signpost muddled code that may contain subtle
errors.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EC_NULL_ARG</id>
    <artifact tool="FindBugs" mnemonic="EC_NULL_ARG"/>
    <artifact tool="PMD" mnemonic="EqualsNull"/>
    <name>Avoid calling equals() with a null argument</name>
    <shortMessage>This code calls equals() with a null argument.</shortMessage>
    <info>
<![CDATA[<p>This method calls <code>equals(Object)</code>, passing a
<code>null</code> value as the argument. According to the contract of
the <code>java.lang.Object.equals(Object)</code> method, this call
should always return false.</p>
      
<p>This finding may signpost muddled code that may contain subtle
errors. Inexperienced programmers sometimes confuse comparison
concepts and use <code>equals()</code> to check for a
<code>null</code> reference.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>MWN_MISMATCHED_WAIT</id>
    <artifact tool="FindBugs" mnemonic="MWN_MISMATCHED_WAIT"/>
    <name>Mismatched wait()</name>
    <shortMessage>This code calls wait() without obviously holding a lock on the object. This could throw IllegalMonitorStateException at runtime.</shortMessage>
    <info>
<![CDATA[<p>This method calls <code>Object.wait()</code> without
obviously holding a lock on the object. Calling <code>wait()</code>
without a lock held will result in an
<code>IllegalMonitorStateException</code> being thrown at
runtime.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>MWN_MISMATCHED_NOTIFY</id>
    <artifact tool="FindBugs" mnemonic="MWN_MISMATCHED_NOTIFY"/>
    <name>Mismatched notify()</name>
    <shortMessage>This code calls notify() or notifyAll() without obviously holding a lock on the object. This could throw IllegalMonitorStateException at runtime.</shortMessage>
    <info>
<![CDATA[<p>This method calls <code>Object.notify()</code> or
<code>Object.notifyAll()</code> without obviously holding a lock on
the object. Calling <code>notify()</code> or </code>notifyAll()</code>
without a lock held will result in an
<code>IllegalMonitorStateException</code> being thrown at
runtime.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SA_SELF_ASSIGNMENT</id>
    <artifact tool="FindBugs" mnemonic="SA_LOCAL_SELF_ASSIGNMENT"/>
    <artifact tool="FindBugs" mnemonic="SA_FIELD_SELF_ASSIGNMENT"/>
    <artifact tool="PMD" mnemonic="IdempotentOperations"/>
    <name>Self assignment</name>
    <shortMessage>This code assigns a variable or field to itself. This may indicate a logic error or a typo.</shortMessage>
    <info>
<![CDATA[<p>This method contains a self assignment of a local variable
or field. For example, the below code self assigns a local
variable.</p>

<pre>
public void foo() {
  int x = 3;
  x = x;
}
</pre>

<p>The below code self assigns a field.</p>

<pre>
int x;

public void foo() {
  x = x;
}
</pre>

<p>Such assignments are useless, and may indicate a logic error or
typo.  One common case where this highlights a logic error is when a
parameter masks a field and it appears the parameter is being assigned
to the field but, sadly, the parameter is being assigned to itself.
An example of this mistake is shown below.</p>

<pre>
int x;

public void foo(int x) {
  x = x;
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SA_DOUBLE_ASSIGNMENT</id>
    <artifact tool="FindBugs" mnemonic="SA_LOCAL_DOUBLE_ASSIGNMENT"/>
    <artifact tool="FindBugs" mnemonic="SA_FIELD_DOUBLE_ASSIGNMENT"/>
    <name>Double assignment</name>
    <shortMessage>This code contains a double assignment of a variable or field. This may indicate a logic error or a typo.</shortMessage>
    <info>
<![CDATA[<p> This method contains a double assignment of a local
variable or a field.  For example, the below code double assigns a
local variable.</p>

<pre>
public void foo() {
  int x, y;
  x = x = 17;
}
</pre>

<p>The below code double assigns a field.</p>

<pre>
private int x, y;

public void foo() {
  x = x = 17;
}
</pre>

 <p>Assigning to a local variable or a field twice is useless, and may
 indicate a logic error or typo.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SA_LOCAL_SELF_COMPUTATION</id>
    <artifact tool="FindBugs" mnemonic="SA_LOCAL_SELF_COMPUTATION"/>
    <artifact tool="FindBugs" mnemonic="SA_FIELD_SELF_COMPUTATION"/>
    <name>Nonsensical computation</name>
    <shortMessage>This code performs a nonsensical self computation involving a field (e.g., x &amp; x). Is this intentional?</shortMessage>
    <info>
<![CDATA[<p>This method performs a nonsensical computation of a field
or local variable with another reference to the same field or local
variable (e.g., x&amp;x or x-x). Because of the nature of the
computation, this operation doesn't seem to make sense, and may
indicate a typo or a logic error. Please double check that the
computation is intended.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SA_LOCAL_SELF_COMPARISON</id>
    <artifact tool="FindBugs" mnemonic="SA_LOCAL_SELF_COMPARISON"/>
    <artifact tool="FindBugs" mnemonic="SA_FIELD_SELF_COMPARISON"/>
    <name>Self comparison</name>
    <shortMessage>This code compares a field or local variable with itself. Is this intentional?</shortMessage>
    <info>
<![CDATA[<p>This method compares a field or local variable with
itself, and may indicate a typo or a logic error. Make sure that you
are comparing the right things.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DMI_LONG_BITS_TO_DOUBLE_INVOKED_ON_INT</id>
    <artifact tool="FindBugs" mnemonic="DMI_LONG_BITS_TO_DOUBLE_INVOKED_ON_INT"/>
    <name>Double.longBitsToDouble() invoked on an int</name>
    <shortMessage>This code invokes Double.longBitsToDouble() passing an int argument which is unlikely to give the intended result.</shortMessage>
    <info>
<![CDATA[<p>The <code>Double.longBitsToDouble</code> method is
invoked, but a 32-bit int value is passed as an argument. This
almost certainly is not intended and is unlikely to give the
intended result due to the primitive widening conversion which will take
place.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DMI_RANDOM_USED_ONLY_ONCE</id>
    <artifact tool="FindBugs" mnemonic="DMI_RANDOM_USED_ONLY_ONCE"/>
    <name>Random used only once</name>
    <shortMessage>This code creates a Random object but only uses it once.</shortMessage>
    <info>
<![CDATA[<p>This code creates a <code>java.util.Random</code> object,
uses it to generate one random number, and then discards the
object. This produces mediocre quality random numbers and is
inefficient. If possible, rewrite the code so that the object is
created once and saved, and each time a new random number is required
invoke a method on the existing <code>Random</code> object to obtain
it.</p>

<p>If it is important that the generated random numbers not be
guessable, you <em>must</em> not create a new <code>Random</code>
instance for each random number; the values are too easily
guessable. You should strongly consider using a
<code>java.security.SecureRandom</code> instead (and avoid allocating
a new <code>SecureRandom</code> for each random number needed). </p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>RV_ABSOLUTE_VALUE_OF_RANDOM_INT</id>
    <artifact tool="FindBugs" mnemonic="RV_ABSOLUTE_VALUE_OF_RANDOM_INT"/>
    <name>Absolute value of random int</name>
    <shortMessage>Bad attempt to compute absolute value of signed 32-bit random integer. Use Random.nextInt(int) instead.</shortMessage>
    <info>
<![CDATA[<p>This code generates a random signed integer and then
computes the absolute value of that random integer. If the number
returned by the random number generator is
<code>Integer.MIN_VALUE</code>, then the result will be negative as
well because <code>Math.abs(Integer.MIN_VALUE) ==
Integer.MIN_VALUE</code>).</p>

<p>This problem can be avoided by passing a value into the
<code>nextInt</code> method. For example, if you have</p>

<pre>
final Random r = new Random();
</pre>

<p>then change code like this that can generate all positive
<code>int</code>s as well as <code>Integer.MIN_VALUE</code></p>

<pre>
// Bad! not always non-negative
int i = Math.abs(r.nextInt());
</pre>

<p>to</p>

<pre>
int i = r.nextInt(Integer.MAX_VALUE);
</pre>

<p>which will generate a value between 0 (inclusive) and
<code>Integer.MAX_VALUE</code> (exclusive).  It you want a positive
value (not including zero) use<p>

<pre>
int i = r.nextInt(Integer.MAX_VALUE) + 1;
</pre>

<p>which will generate a value between 1 (inclusive) and
<code>Integer.MAX_VALUE</code> (inclusive).</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>RV_ABSOLUTE_VALUE_OF_HASHCODE</id>
    <artifact tool="FindBugs" mnemonic="RV_ABSOLUTE_VALUE_OF_HASHCODE"/>
    <name>Absolute value of hashCode()</name>
    <shortMessage>Bad attempt to compute absolute value of signed 32-bit hashcode.</shortMessage>
    <info>
<![CDATA[<p>This code generates a hashcode and then computes the
absolute value of that hashcode. If the hashcode is
<code>Integer.MIN_VALUE</code> (which is possible), then the result
will be negative as well because <code>Math.abs(Integer.MIN_VALUE) ==
Integer.MIN_VALUE</code>.</p>

<p>It is likely that this is not what the code intended to do. It
likely expects the resulting <code>int</code> value to be
non-negative. If this is the case then the case where the hashcode
returned is <code>Integer.MIN_VALUE</code> must be considered.  For
example, you would change</p>

<pre>
// Bad! not always non-negative
int i = Math.abs(o.hashCode());
</pre>

<p>to</p>

<pre>
int i;
int hash = o.hashcode();
if (hash == Integer.MIN_VALUE) {
  i = 0; // or any non-negative value you like, maybe Integer.MAX_VALUE
} else {
  i = Math.abs(hash);
}
</pre>

<p>or create a utility method that does this for you.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>RV_REM_OF_RANDOM_INT</id>
    <artifact tool="FindBugs" mnemonic="RV_REM_OF_RANDOM_INT"/>
    <name>Remainder of a random int</name>
    <shortMessage>Remainder of 32-bit signed random integer. Use Random.nextInt(int) instead.</shortMessage>
    <info>
<![CDATA[<p>This code generates a random signed integer and then
computes the remainder of that value modulo another value. Since the
random number can be negative, the result of the remainder operation
can also be negative. Be sure this is intended, and strongly consider
using the <code>Random.nextInt(int)</code> method instead.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>RV_REM_OF_HASHCODE</id>
    <artifact tool="FindBugs" mnemonic="RV_REM_OF_HASHCODE"/>
    <name>Remainder of hashCode()</name>
    <shortMessage>Remainder of hashCode() could be negative</shortMessage>
    <info>
<![CDATA[<p>This code computes a hashcode, and then computes the
remainder of that value modulo another value. Since the resulting
hashcode can be negative, the result of the remainder operation can
also be negative.</p>

<p> Assuming you want to ensure that the result of your computation is
nonnegative, you may need to change your code. If you know the divisor
is a power of 2, you can use a bitwise <i>and</i> operator instead.  For example, instead of using</p>

<pre>
x.hashCode() % n
</pre>

<p>use</p>

<pre>
x.hashCode() & (n-1)
</pre>

<p>This is probably faster than computing the remainder as well. If
you don't know that the divisor is a power of 2, take the absolute
value of the result of the remainder operation. For example, use</p>

<pre>
Math.abs(x.hashCode() % n)
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE</id>
    <artifact tool="FindBugs" mnemonic="INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE"/>
    <name>Bad comparison with a nonnegative value</name>
    <shortMessage>Bad comparison of nonnegative value with negative constant.</shortMessage>
    <info>
<![CDATA[<p>This code compares a value that is guaranteed to be
non-negative with a negative constant.  This comparison will always be
false. Check that this code is correct and consider removing this
comparison.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>INT_BAD_COMPARISON_WITH_SIGNED_BYTE</id>
    <artifact tool="FindBugs" mnemonic="INT_BAD_COMPARISON_WITH_SIGNED_BYTE"/>
    <name>Bad comparison with a signed byte</name>
    <shortMessage>Bad comparison of a signed byte with a value outside its range.</shortMessage>
    <info>
<![CDATA[<p>Signed bytes can only have a value in the range -128 to
127. Comparing a signed byte with a value outside that range is
vacuous and likely to be incorrect. Check that this code is correct
and consider removing this comparison.</p>

</p>To convert a signed byte <code>b</code> to an unsigned value in
the range 0..255, use</p>

<pre>
0xff & b
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>INT_VACUOUS_COMPARISON</id>
    <artifact tool="FindBugs" mnemonic="INT_VACUOUS_COMPARISON"/>
    <name>Vacuous comparison with an int</name>
    <shortMessage>Vacuous comparison of an integer value.</shortMessage>
    <info>
<![CDATA[<p>There is an integer comparison that always returns the
same value. For example, the expression</p>

<pre>
x &lt;= Integer.MAX_VALUE
</pre>

<p>will always be true. Check that this code is correct and consider
removing this comparison.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>INT_BAD_REM_BY_1</id>
    <artifact tool="FindBugs" mnemonic="INT_BAD_REM_BY_1"/>
    <name>Suspicious modulo 1</name>
    <shortMessage>Integer remainder modulo 1 always results in 0. Is this what was intended?</shortMessage>
    <info>
<![CDATA[<p>Any expression <code>(exp % 1)</code> is guaranteed to
always return zero. Did you mean <code>(exp &amp; 1)</code> or
</code>(exp % 2)</code> instead?</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>BIT_IOR_OF_SIGNED_BYTE</id>
    <artifact tool="FindBugs" mnemonic="BIT_IOR_OF_SIGNED_BYTE"/>
    <name>Suspicious bitwise or of signed byte</name>
    <shortMessage>Suspicious bitwise or of a signed byte value.</shortMessage>
    <info>
<![CDATA[<p>Loads a value from a byte array and performs a bitwise or
with that value. Values loaded from a byte array are sign extended to
32 bits before any any bitwise operations are performed on the
value. Thus, if <code>b[0]</code> contains the value
<code>0xff</code>, and <code>x</code> is initially 0, then the code
<code>((x &lt;&lt; 8) | b[0])</code> will sign extend <code>0xff</code> to
get <code>0xffffffff</code>, and thus give the value
<code>0xffffffff</code> as the result.</p>

<p>In particular, the following code for packing a byte array into an
int is badly wrong:</p>

<pre>
int result = 0;
for(int i = 0; i < 4; i++)
  result = ((result &lt;&lt; 8) | b[i]);
</pre>

<p>The following idiom will work instead:</p>

<pre>
int result = 0;
for(int i = 0; i < 4; i++)
  result = ((result &lt;&lt; 8) | (b[i] & 0xff));
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>BIT_AND</id>
    <artifact tool="FindBugs" mnemonic="BIT_AND"/>
    <name>Incompatible bit masks: and</name>
    <shortMessage>Incompatible bit masks are always unequal.</shortMessage>
    <info>
<![CDATA[<p>This method compares an expression of the form <code>(a
&amp; C)</code> to <code>D</code>, which will always compare unequal
due to the specific values of constants <code>C</code> and
<code>D</code>. This may indicate a logic error or typo. Check that
this code is correct and consider removing this comparison.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>BIT_AND_ZZ</id>
    <artifact tool="FindBugs" mnemonic="BIT_AND_ZZ"/>
    <name>Incompatible bit masks and zero</name>
    <shortMessage>Check to see if ((...) &amp; 0) == 0 which is always true.</shortMessage>
    <info>
<![CDATA[<p>This method compares an expression of the form <code>(a
&amp; 0)</code> to <code>0</code>, which will always compare
equal. This may indicate a logic error or typo. Check that this code
is correct and consider removing this comparison.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>BIT_IOR</id>
    <artifact tool="FindBugs" mnemonic="BIT_IOR"/>
    <name>Incompatible bit masks: or</name>
    <shortMessage>Incompatible bit masks are always unequal.</shortMessage>
    <info>
<![CDATA[<p>This method compares an expression of the form <code>(a |
C)</code> to <code>D</code>. which will always compare unequal due to
the specific values of constants <code>C</code> and
<code>D</code>. This may indicate a logic error or typo. Check that this code
is correct and consider removing this comparison.</p>

<p>Typically, this issue occurs because the code wants to perform a
membership test in a bit set, but uses the bitwise or operator
(&quot;|&quot;) instead of the bitwise and operator
(&quot;&amp;&quot;).</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LI_LAZY_INIT</id>
    <artifact tool="FindBugs" mnemonic="LI_LAZY_INIT_INSTANCE"/>
    <artifact tool="FindBugs" mnemonic="LI_LAZY_INIT_STATIC"/>
    <name>Incorrect lazy initialization</name>
    <shortMessage>Incorrect lazy initialization of a field.</shortMessage>
    <info>
<![CDATA[<p>This method contains an unsynchronized lazy
initialization of a non-volatile field. Because the compiler or
processor may reorder instructions, threads are not guaranteed to see
a completely initialized object, if the method can be called by
multiple threads.</p>

<p>You can make the field volatile to correct the problem. For more
information, please see the <a
href="http://www.cs.umd.edu/~pugh/java/memoryModel/">Java Memory Model
web site</a>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>JLM_JSR166_LOCK_MONITORENTER</id>
    <artifact tool="FindBugs" mnemonic="JLM_JSR166_LOCK_MONITORENTER"/>
    <name>Suspicious util concurrent Lock monitor use</name>
    <shortMessage>Suspicions intrinsic synchronization performed on a java.util.concurrent Lock object. This is probably a mistake.</shortMessage>
    <info>
<![CDATA[<p>This method performs synchronization on an
implementation of <code>java.util.concurrent.locks.Lock</code>.  You
should use the <code>lock()</code> and <code>unlock()</code> methods
instead.  For example, change</p>

<pre>
Lock l = ...;
synchronized (l) { // Bad!
  // access the resource protected by this lock.
}
</pre>

<p>to</p>

<pre>
Lock l = ...;
l.lock();
try {
  // access the resource protected by this lock
} finally {
  l.unlock();
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UPM_UNCALLED_PRIVATE_METHOD</id>
    <artifact tool="FindBugs" mnemonic="UPM_UNCALLED_PRIVATE_METHOD"/>
    <artifact tool="PMD" mnemonic="UnusedPrivateMethod"/>
    <name>Uncalled private method</name>
    <shortMessage>This private method is unused. Consider removing the method.</shortMessage>
    <info>
<![CDATA[<p>This private method is never called. Although it is
possible that the method is invoked through reflection, it is more
likely that the method is never used, and should be removed.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UMAC_UNCALLABLE_METHOD_OF_ANONYMOUS_CLASS</id>
    <artifact tool="FindBugs" mnemonic="UMAC_UNCALLABLE_METHOD_OF_ANONYMOUS_CLASS"/>
    <name>Uncallable method in an anonymous class</name>
    <shortMessage>Uncallable method defined in anonymous class. Should this method be overriding another method?</shortMessage>
    <info>
<![CDATA[<p>This anonymous class defines a method that is not directly
invoked and does not override a method in a superclass. Since methods
in other classes cannot directly invoke methods declared in an
anonymous class, it appears that this method is uncallable.</p>

<p>The method might simply be dead code, but it is also possible that
the method is intended to override a method declared in a superclass,
and due to an typo or other error the method does not, in fact,
override the method it is intended to.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ODR_OPEN_DATABASE_RESOURCE_EXCEPTION_PATH</id>
    <artifact tool="FindBugs" mnemonic="ODR_OPEN_DATABASE_RESOURCE_EXCEPTION_PATH"/>
    <name>Open database resource exception path</name>
    <shortMessage>This method may fail to close a database resource on exception.  Move the close to a finally block.</shortMessage>
    <info>
<![CDATA[<p>The method creates a database resource (such as a database
connection or row set), does not assign it to any fields, pass it to
other methods, or return it, and does not appear to close the object
on all exceptional paths out of the method.</p>

<p>Failure to close database resources on all paths out of a method
may result in poor performance, and could cause the application to
have problems communicating with the database.</p>

<p>To fix this use a <code>finally</code> block. For example, see the
code below.<p>

<pre>
Connection connection = dataSource.getConnection();
try {
  Statement statement = connection.createStatement();
  try {
    ResultSet resultSet = statement.executeQuery(”some query”);
    try {
      // Do stuff with the result set.
    } finally {
      resultSet.close();
    }
  } finally {
    statement.close();
  }
} finally {
  connection.close();
}</pre>

<p>Note that there are some helpful utilities provided by the <a
href="http://commons.apache.org/dbutils/">Apache Commons DbUtils</a>
project that may be useful in your program.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UseStringBufferForStringAppends</id>
    <artifact tool="FindBugs" mnemonic="SBSC_USE_STRINGBUFFER_CONCATENATION"/>
    <artifact tool="PMD" mnemonic="UseStringBufferForStringAppends"/>
    <name>Use StringBuffer for String appends</name>
    <shortMessage>This method concatenates Strings using + in a loop. Consider using StringBuffer to improve performance.</shortMessage>
    <info>
<![CDATA[<p>The method seems to be building a <code>String</code>
using concatenation in a loop. In each iteration, the
<code>String</code> is converted to a
<code>StringBuffer/StringBuilder</code>, appended to, and converted
back to a <code>String</code> by the compiler. This can lead to a cost
quadratic in the number of iterations, as the growing string is
recopied in each iteration.</p>

<p>Better performance can be obtained by using a <code>StringBuffer</code> (or
<code>StringBuilder</code> in Java 1.5) explicitly.</p>

<p>For example, consider changing</p>

<pre>
String s = "";
 for (int i = 0; i &lt; field.length; ++i) {
  s = s + field[i]; // Bad!
}
</pre>

<p>to</p>

<pre>
final StringBuilder buf = new StringBuilder();
for (int i = 0; i &lt; field.length; ++i) {
  buf.append(field[i]);
}
String s = buf.toString();
</pre>

<p>Also avoid using <code>+=</code> for appending strings.</p>

<p>If you are using JDK 1.5 or above it is strongly recommended that
you use <code>StringBuilder</code> rather than
<code>StringBuffer</code>. In most cases the use of
<code>StringBuilder</code> will improve code performance by avoid
unnecessary synchronization.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ITA_INEFFICIENT_TO_ARRAY</id>
    <artifact tool="FindBugs" mnemonic="ITA_INEFFICIENT_TO_ARRAY"/>
    <artifact tool="PMD" mnemonic="ClassCastExceptionWithToArray"/>
    <artifact tool="PMD" mnemonic="OptimizableToArrayCall"/>
    <name>Questionable use of toArray()</name>
    <shortMessage>Method uses toArray() with no argument or a zero-length array argument. The no argument call may result in a ClassCastException.</shortMessage>
    <info>
<![CDATA[<p>This method uses the <code>toArray()</code> method of a
collection derived class, and passes nothing or a zero-length
prototype array argument.</p>

<p>It is more efficient to use <code>myCollection.toArray(new
Foo[myCollection.size()])</code> If the array passed in is big enough
to store all of the elements of the collection, then it is populated
and returned directly. This avoids the need to create a second array
(by reflection) to return as the result.</p>

<p>If you need to get an array of a class from a
<code>Collection</code>, you should pass an array of the desired class
as the parameter of the <code>toArray</code> method. Otherwise you
will get a <code>ClassCastException</code>.</p>

<pre>
import java.util.ArrayList;
import java.util.Collection;

public class Test {
  public static void main(String[] args) {
    Collection c = new ArrayList();
    Integer obj = new Integer(1);
    c.add(obj);

    // this would trigger the rule (and throw a ClassCastException if executed)
    Integer[] a = (Integer[])c.toArray();

    // this wouldn't trigger the rule
    Integer[] b = (Integer[])c.toArray(new Integer[c.size()]);
  }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>IJU_ASSERT_METHOD_INVOKED_FROM_RUN_METHOD</id>
    <artifact tool="FindBugs" mnemonic="IJU_ASSERT_METHOD_INVOKED_FROM_RUN_METHOD"/>
    <name>Suspicious JUnit assertion within Runnable.run()</name>
    <shortMessage>A JUnit assertion in run method in another thread will not be noticed by JUnit. Are you trying to test concurrent code?</shortMessage>
    <info>
<![CDATA[<p>A JUnit assertion is performed in a run method. This is
suspicious if the code is running in another thread.</p>

<p>Failed JUnit assertions just result in exceptions being
thrown. Thus, if this exception occurs in a thread other than the
thread that invokes the test method, the exception will terminate the
thread but not result in the test failing.</p>

<p>One approach to fix this problem is to save up the test failures
encountered in the second thread (e.g., in a collection or some other
scheme) and after the thread has completed report the problems in the
JUnit thread.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>IJU_SETUP_NO_SUPER</id>
    <artifact tool="FindBugs" mnemonic="IJU_SETUP_NO_SUPER"/>
    <name>SetUp() does not call super.setUp()</name>
    <shortMessage>JUnit TestCase implements setUp but doesn't call super.setUp().</shortMessage>
    <info>
<![CDATA[<p>This class is a JUnit <code>TestCase</code> and implements
the <code>setUp</code> method. The <code>setUp</code> method should
call <code>super.setUp()</code>, but in this case it doesn't.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>IJU_TEARDOWN_NO_SUPER</id>
    <artifact tool="FindBugs" mnemonic="IJU_TEARDOWN_NO_SUPER"/>
    <name>TearDown() does not call super.tearDown()</name>
    <shortMessage>TestCase implements tearDown but doesn't call super.tearDown().</shortMessage>
    <info>
<![CDATA[<p>This class is a JUnit <code>TestCase</code> and implements
the <code>tearDown</code> method. The <code>tearDown</code> method
should call </code>super.tearDown()</code>, but in this case it
doesn't.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>IJU_SUITE_NOT_STATIC</id>
    <artifact tool="FindBugs" mnemonic="IJU_SUITE_NOT_STATIC"/>
    <artifact tool="PMD" mnemonic="JUnitStaticSuite"/>
    <name>TestCase suite is not static</name>
    <shortMessage>TestCase implements a non-static suite method.</shortMessage>
    <info>
<![CDATA[<p>This class is a JUnit <code>TestCase</code> and implements
the <code>suite()</code> method. The <code>suite</code> method should
be declared to be <code>static</code>, but isn't.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>IJU_BAD_SUITE_METHOD</id>
    <artifact tool="FindBugs" mnemonic="IJU_BAD_SUITE_METHOD"/>
    <name>Bad suite() method signature</name>
    <shortMessage>TestCase declares a bad suite() method. Its signature appears to be wrong.</shortMessage>
    <info>
<![CDATA[<p>This class is a JUnit <code>TestCase</code> and defines a
<code>suite()</code> method. However, the <code>suite</code> method
needs to be declared as either</p>

<pre>
public static junit.framework.Test suite()
</pre>

<p>or</p>

<pre>
public static junit.framework.TestSuite suite()
</pre>

<p>In this case the <code>suite()</code> method matches neither of
these two signatures.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>IJU_NO_TESTS</id>
    <artifact tool="FindBugs" mnemonic="IJU_NO_TESTS"/>
    <name>TestCase with no tests</name>
    <shortMessage>This TestCase has no tests.</shortMessage>
    <info>
<![CDATA[<p>This class is a JUnit TestCase but has not implemented any
test methods.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>BOA_BADLY_OVERRIDDEN_ADAPTER</id>
    <artifact tool="FindBugs" mnemonic="BOA_BADLY_OVERRIDDEN_ADAPTER"/>
    <name>Badly overridden adapter</name>
    <shortMessage>Class overrides a method implemented in super class adapter wrongly.</shortMessage>
    <info>
<![CDATA[<p>This method intends to override a method found in a parent
class, where that class is an Adapter that implements a listener
defined in the <code>java.awt.event</code> or <code>javax.swing.event</code> package, however,
it does not override the intended method. As a result, this method
will not get called when the event occurs.</p>

<p>Consider fixing this method's signature and adding the
<code>@Override</code> annotation to it.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>BRSA_BAD_RESULTSET_ACCESS</id>
    <artifact tool="FindBugs" mnemonic="BRSA_BAD_RESULTSET_ACCESS"/>
    <artifact tool="FindBugs" mnemonic="SQL_BAD_RESULTSET_ACCESS"/>
    <name>Bad ResultSet access</name>
    <shortMessage>This code attempts to access a ResultSet field with a index of 0. This is always a mistake.</shortMessage>
    <info>
<![CDATA[<p>A call to <code>get</code><i>x</i> or
<code>update</code><i>x</i> methods of a <code>ResultSet</code> was
made where the field index is 0. Because <code>ResultSet</code> field indexes
start at 1, this is always a mistake.</p>

<p>For example, the code below is wrong and will always throw an
<code>SQLException</code>.</p>

<pre>
ResultSet rs = ...
rs.getInt(0);
</pre>

<p>It is recommended that this index be changed to start at 1.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SQL_BAD_PREPARED_STATEMENT_ACCESS</id>
    <artifact tool="FindBugs" mnemonic="SQL_BAD_PREPARED_STATEMENT_ACCESS"/>
    <name>Bad PreparedStatement access</name>
    <shortMessage>This code attempts to access a PreparedStatement parameter with index 0. This is always a mistake.</shortMessage>
    <info>
<![CDATA[<p>A call to a <code>set</code><i>x</i> method of a
<code>PreparedStatement</code> was made where the parameter index is
0. Because <code>PreparedSatement</code> parameter indexes start at 1,
this is always a mistake.</p>

<p>For example, the code below is wrong and will always throw an <code>SQLException</code>.</p>

<pre>
PreparedStatement ps = ...
int value = ...
ps.setInt(0, value);
</pre>

<p>It is recommended that this index be changed to start at 1.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SIO_SUPERFLUOUS_INSTANCEOF</id>
    <artifact tool="FindBugs" mnemonic="SIO_SUPERFLUOUS_INSTANCEOF"/>
    <artifact tool="FindBugs" mnemonic="BC_VACUOUS_INSTANCEOF"/>
    <name>Superfluous instanceof</name>
    <shortMessage>Unnecessary type check done using instanceof operator. This check can be removed from the code.</shortMessage>
    <info>
<![CDATA[<p>This code performs a type check using the
<code>instanceof</code> operator where it can be statically determined
that the object is of the type requested.</p>

<p>For example, the code below should be changed from</p>

<pre>
public Place getPlace(String name) {
  assert (name != null);
  Place result = getPlaceByName(name);
  if (result instanceof Place)  // Bad!
    return (Place) result;
  else
    return null;
}
</pre>

<p>to</p>

<pre>
public Place getPlace(String name) {
  assert (name != null);
  return getPlaceByName(name);
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>BAC_BAD_APPLET_CONSTRUCTOR</id>
    <artifact tool="FindBugs" mnemonic="BAC_BAD_APPLET_CONSTRUCTOR"/>
    <name>Bad Applet constructor</name>
    <shortMessage>Bad Applet constructor relies on uninitialized AppletStub. Move this logic into init().</shortMessage>
    <info>
<![CDATA[<p>This constructor calls methods in the parent
<code>Applet</code> that rely on the <code>AppletStub</code>. Since
the <code>AppletStub</code> isn't initialized until the
<code>init()</code> method of this applet is called, these methods
will not perform correctly.</p>

<p>It is recommended that this logic be moved from this constructor to
the <code>init()</code> method.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EC_ARRAY_AND_NONARRAY</id>
    <artifact tool="FindBugs" mnemonic="EC_ARRAY_AND_NONARRAY"/>
    <name>Nonsensical comparison of array and non-array</name>
    <shortMessage>This code is using equals() to compare an array with a non-array. This comparison will always be false.</shortMessage>
    <info>
<![CDATA[<p>This method invokes the <code>equals(Object o)</code>
method to compare an array with a reference that doesn't seem to be an
array. If things being compared are of different types, they are
guaranteed to be unequal and this comparison is almost certainly an
error.</p>

<p>In the case where they are both arrays (i.e., the analysis is
wrong), the equals method on arrays only determines if the two arrays
are the same object (i.e., it just does <code>==</code>). To compare
the contents of the arrays, use the
<code>java.util.Arrays.equals(Object[], Object[])</code> method
instead. For example, consider changing</p>

<pre>
if (array1.equals(array2)) {
  // do something
}
</pre>

<p>to</p>

<pre>
if (Arrays.equals(array1, array2)) {
  // do something
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EC_BAD_ARRAY_COMPARE</id>
    <artifact tool="FindBugs" mnemonic="EC_BAD_ARRAY_COMPARE"/>
    <name>Suspicious array comparison</name>
    <shortMessage>This code is using equals() to compare two arrays, which in this case is equivalent to using ==.  Consider using Arrays.equals() instead.</shortMessage>
    <info>
<![CDATA[<p>This method invokes the <code>equals(Object o)</code>
method on an array. Since arrays do not override the equals method of
<code>Object</code>, calling equals on an array is the same as
comparing their addresses (i.e., using <code>==</code>). To compare
the contents of the arrays, use the
<code>java.util.Arrays.equals(Object[], Object[])</code> method
instead. For example, consider changing</p>

<pre>
if (array1.equals(array2)) {
  // do something
}
</pre>

<p>to</p>

<pre>
if (Arrays.equals(array1, array2)) {
  // do something
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>STI_INTERRUPTED_ON_CURRENTTHREAD</id>
    <artifact tool="FindBugs" mnemonic="STI_INTERRUPTED_ON_CURRENTTHREAD"/>
    <name>Unnecessary use of currentThread() to call interrupted()</name>
    <shortMessage>Unnecessary use of Thread.currentThread() simply to call interrupted().  Change to Thread.interrupted().</shortMessage>
    <info>
<![CDATA[<p>This code invokes the <code>Thread.currentThread()</code>
method just to call the <code>interrupted()</code> method. Because
<code>interrupted()</code> is a <code>static</code> method, is more
simple and clear to use <code>Thread.interrupted()</code> in your
code.</p>

<p>For example, consider changing</p>

<pre>
if (Thread.currentThread().interrupted()) { // Bad!
  // do something
}
</pre>

<p>to</p>

<pre>
if (Thread.interrupted()) {
  // do something
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>STI_INTERRUPTED_ON_UNKNOWNTHREAD</id>
    <artifact tool="FindBugs" mnemonic="STI_INTERRUPTED_ON_UNKNOWNTHREAD"/>
    <name>Suspicious interrupted() call on an unknown Thread</name>
    <shortMessage>This code invokes the static Thread.interrupted() method on an unknown Thread instance. This is likely not doing what the programmer intended.</shortMessage>
    <info>
<![CDATA[<p>This method invokes the <code>interrupted()</code> method
on a <code>Thread</code> object that does not appear to be the current
thread. Because the <code>interrupted()</code> method is static, and
is defined to always test whether the current thread has been
interrupted this code is suspicious. Check that this finding is not
signposting an error.</p>

<p>If it is intended to test if the current thread has been
interrupted, then change code like</p>

<pre>
Thread other = ...
if (other.interrupted()) { // Bad!
  // do something
}
</pre>

<p>to</p>

<pre>
if (Thread.interrupted()) {
  // do something
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN</id>
    <artifact tool="FindBugs" mnemonic="IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN"/>
    <name>Dead parameter is overwritten</name>
    <shortMessage>A parameter that is dead upon entry (i.e., it is never read) to a method is overwritten. Does this code mistakenly believe that a write to the parameter will be conveyed back to the caller?</shortMessage>
    <info>
<![CDATA[<p>The initial value of this parameter is ignored, but the
parameter is overwritten here. This often indicates a mistaken belief
by the programmer that the write to the parameter will be conveyed
back to the caller.</p>

<p>For example, the below program will print <code>3</code> (not <code>4</code>).</p>

<pre>
public class Foo {

  public static void main(String[] args) {
    int i = 3;
    muddled(i);
    System.out.println(i);
  }

  public static void muddled(int i) {
    i = 4;
  }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DLS_DEAD_LOCAL_STORE</id>
    <artifact tool="FindBugs" mnemonic="DLS_DEAD_LOCAL_STORE"/>
    <name>Dead local store</name>
    <shortMessage>Dead store to a local variable. Is something wrong with this code's logic?</shortMessage>
    <info>
<![CDATA[<p>This instruction assigns a value to a local variable, but
the value is not read by any subsequent instruction. Often, this
indicates an error, because the computed value is never used.</p>

<p>Note that Sun's javac compiler often generates dead stores for
final local variables. Because FindBugs analysis done on bytecode,
there is no easy way to eliminate these false positives.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DLS_DEAD_LOCAL_STORE_OF_NULL</id>
    <artifact tool="FindBugs" mnemonic="DLS_DEAD_LOCAL_STORE_OF_NULL"/>
    <name>Dead local store of null</name>
    <shortMessage>Dead store of null to local variable. Is something wrong with this code's logic?</shortMessage>
    <info>
<![CDATA[<p>This code stores <code>null</code> into a local variable,
and this stored value is not subsequently read. This store may have
been introduced in assist the garbage collector, but as of Java SE
6.0, this is no longer needed or useful.  Consider removing this
assignment.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>MF_METHOD_MASKS_FIELD</id>
    <artifact tool="FindBugs" mnemonic="MF_METHOD_MASKS_FIELD"/>
    <name>Method variable masks a field</name>
    <shortMessage>This method defines a variable name that obscures a field with the same name. Is this intended.</shortMessage>
    <info>
<![CDATA[<p>This method defines a local variable with the same name as
a field defined in this class or a superclass. This may cause the
method to read an uninitialized value from the field, leave the field
uninitialized, or both.  Consider changing either the variable name or
the field name to avoid masking.</p>

<p>For example, the below code is broken</p>

<pre>
class Foo {
  private int height;
  private int weight;

  public void setHeight(int height) {
    height = height; // Bad! self-assignment
  }

  public void setWeight(int weight) {
    weight = weight; // Bad! self-assignment
  }
}
</pre>

<p>because it assigns the parameter to the method to itself. To fix it
remove the masking or qualify with <code>this</code>.</p>

<pre>
class Foo {
  private int height;
  private int weight;

  public void setHeight(int value) {
    height = value;
  }

  public void setWeight(int weight) {
    this.weight = weight;
  }
}
</pre>

<p>Note that a naming convention on fields may used to avoid
masking. For example all fields could be prefixed with <code>f_</code>
or <code>m_</code> to clarify the name is a field.  For example, see
the example below.</p>

<pre>
class Foo {
  private int f_height;
  private int f_weight;

  public void setHeight(int height) {
    f_height = height;
  }

  public void setWeight(int weight) {
    f_weight = weight;
  }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>MF_CLASS_MASKS_FIELD</id>
    <artifact tool="FindBugs" mnemonic="MF_CLASS_MASKS_FIELD">
    </artifact>
    <name>Class masks a superclass field</name>
    <shortMessage>This class defines field that masks a superclass field. This can be confusing.</shortMessage>
    <info>
<![CDATA[<p>This class defines a field with the same name as a visible
instance field in a superclass. This is confusing, and may indicate an
error if methods update or access one of the fields when they intended
to work with the other.</p>

<p>For example, consider the below code which masks the
<code>foo</code> field.</p>

<pre>
class A {
  protected int foo;
}

class B extends A {
  protected int foo;
  void setFoo(int value) {
    foo = value; // Bad! writes B.foo not A.foo which may be confusing
  }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>WMI_WRONG_MAP_ITERATOR</id>
    <artifact tool="FindBugs" mnemonic="WMI_WRONG_MAP_ITERATOR"/>
    <name>Inefficient Map iteration</name>
    <shortMessage>Inefficient use of keySet() iterator instead of entrySet() iterator.</shortMessage>
    <info>
<![CDATA[<p>This method accesses the value of a <code>Map</code>
entry, using a key that was retrieved from a <code>keySet()</code>
iterator. It is more efficient to use an iterator on the
<code>entrySet()</code> of the map, and to thus avoid the
<code>Map.get(key)</code> lookup for each key in the map.</p>

<p>For example, if you have</p>

<pre>
Map&lt;String, Integer&gt; nameToCount = new HashMap<String, Integer>();
</pre>

<p>then you should replace code that looks like</p>

<pre>
for (final String key : nameToCount.keySet()) {
  final Integer value = nameToCount.get(key);
  // do something with 'key' and 'value'
}
</pre>

<p>with the more efficient</p>

<pre>
for (Map.Entry&lt;String, Integer&gt; entry : nameToCount.entrySet()) {
  final String key = entry.getKey();
  final Integer value = entry.getValue();
  // do something with 'key' and 'value'
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ISC_INSTANTIATE_STATIC_CLASS</id>
    <artifact tool="FindBugs" mnemonic="ISC_INSTANTIATE_STATIC_CLASS"/>
    <name>Needless instantiation of a static-only class</name>
    <shortMessage>This code needlessly instantiates a class that only supplies static methods. Remove this instantiation and access the static methods using the class name.</shortMessage>
    <info>
<![CDATA[<p>This class allocates an object that is based on a class
that only supplies <code>static</code> methods. This object does not
need to be created, just access the <code>static</code> methods
directly using the class name as a qualifier.</p>

<p>In addition, a private constructor should probably be added to the
class with only <code>static</code> methods so that this needless
instantiation will cause a compiler error.</p>

<p>For example, consider the below class that contains only a single
<code>static</code> method.</p>

<pre>
package com.surelogic;

public class SimpleLogger {
  public static void log(String s) {
    System.out.println(s);
  }
}
</pre>

<p>You should change</p>

<pre>
SimpleLogger log = new SimpleLogger(); // Bad!
log.log("Starting up...");
</pre>

<p>to</p>

<pre>
SimpleLogger.log("Starting up...");
</pre>

<p>If this is deemed too lengthy then a static import can be used to shorten the calls.  Just add</p>

<pre>
import static com.surelogic.SimpleLogger.log;
</pre>

<p>to the compilation unit using the logger and now</p>

<pre>
log("Starting up...");
</pre>

<p>will work.</p>

<p>In addition, consider changing the <code>SimpleLogger</code> class to</p>

<pre>
package com.surelogic;

public class SimpleLogger {
  public static void log(String s) {
    System.out.println(s);
  }

  private SimpleLogger() {
    // no instances
  }
}
</pre>

<p>to avoid this type of problem appearing again in future code.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>REC_CATCH_EXCEPTION</id>
    <artifact tool="FindBugs" mnemonic="REC_CATCH_EXCEPTION"/>
    <name>Suspicious catch of Exception</name>
    <shortMessage>Exception is caught when Exception is not thrown. This may mask potential problems.</shortMessage>
    <info>
<![CDATA[<p>This method uses a <code>try-catch</code> block that
catches <code>Exception</code> objects, but <code>Exception</code> is
not thrown within the try block, and <code>RuntimeException</code> is
not explicitly caught. This may signpost muddled exception handling
that could mask potential problems.</p>

<p>It is a common bug pattern to say</p>

<pre>
try {
  // do something
} catch (Exception e) {
  // handle some problem
}
</pre>

<p>as a shorthand for catching a number of types of exception each of
whose catch blocks is identical, but this construct also accidentally
catches <code>RuntimeException</code> as well, masking potential
bugs.</p>

<p>Examine this code carefully as it is suspicious.  Are all
<code>RuntimeException</code>s being handled by this code?</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>FE_TEST_IF_EQUAL_TO_NOT_A_NUMBER</id>
    <artifact tool="FindBugs" mnemonic="FE_TEST_IF_EQUAL_TO_NOT_A_NUMBER"/>
    <artifact tool="PMD" mnemonic="BadComparison"/>
    <name>Doomed test for equality to NaN</name>
    <shortMessage>Doomed test for equality to NaN.  Did you mean to use Double.isNaN() or Float.isNaN()?</shortMessage>
    <info>
<![CDATA[<p>This code checks to see if a floating point value is equal
to the special <i>Not A Number</i> (NaN) value (e.g., <code>if (x ==
Double.NaN)</code>). However, because of the special semantics of
<code>NaN</code>, no value is equal to <code>Nan</code>, including
<code>NaN</code>. Thus, <code>x == Double.NaN</code> always evaluates
to false.</p>

<p>To check to see if a value contained in <code>x</code> is the
special Not A Number value, use <code>Double.isNaN(x)</code> (or
<code>Float.isNaN(x)</code> if <code>x</code> is floating point
precision).</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>FE_FLOATING_POINT_EQUALITY</id>
    <artifact tool="FindBugs" mnemonic="FE_FLOATING_POINT_EQUALITY"/>
    <name>Suspicious floating-point equality</name>
    <shortMessage>Test for floating-point equality. This test may not produce the expected result.</shortMessage>
    <info>
<![CDATA[<p>This operation compares two floating-point values for
equality. Because floating-point calculations may involve rounding,
calculated float and double values may not be accurate.</p>

<p>For values that must be precise, such as monetary values, consider
using a fixed-precision type such as <code>BigDecimal</code>.</p>

<p>For values that need not be precise, consider comparing for
equality within some range, for example:

<pre>if (Math.abs(x - y) &lt; .0000001) {
  // do something
}
</pre>

<p>Please see the <a
href="http://java.sun.com/docs/books/jls/third_edition/html/typesValues.html#4.2.4">Java
Language Specification section 4.2.4</a> for further details.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UM_UNNECESSARY_MATH</id>
    <artifact tool="FindBugs" mnemonic="UM_UNNECESSARY_MATH"/>
    <name>Unnecessary math</name>
    <shortMessage>Method calls static Math class method on a constant value.</shortMessage>
    <info>
<![CDATA[<p>This method uses a static method from <code>java.lang.Math</code> on a
constant value. This method's result in this case, can be determined
statically, and is faster and sometimes more accurate to just use the
constant. Methods detected are:</p>

<table>
  <tr><th>Method</th><th>Parameter</th></tr>
  <tr><td>abs</td><td>-any-</td></tr>
  <tr><td>acos</td><td>0.0 or 1.0</td></tr>
  <tr><td>asin</td><td>0.0 or 1.0</td></tr>
  <tr><td>atan</td> <td>0.0 or 1.0</td></tr>
  <tr><td>atan2</td><td>0.0</td></tr>
  <tr><td>cbrt</td><td>0.0 or 1.0</td></tr>
  <tr><td>ceil</td><td>-any-</td></tr>
  <tr><td>cos</td><td>0.0</td></tr>
  <tr><td>cosh</td><td>0.0</td></tr>
  <tr><td>exp</td><td>0.0 or 1.0</td></tr>
  <tr><td>expm1</td><td>0.0</td></tr>
  <tr><td>floor</td><td>-any-</td></tr>
  <tr><td>log</td><td>0.0 or 1.0</td></tr>
  <tr><td>log10</td><td>0.0 or 1.0</td></tr>
  <tr><td>rint</td><td>-any-</td></tr>
  <tr><td>round</td><td>-any-</td></tr>
  <tr><td>sin</td><td>0.0</td></tr>
  <tr><td>sinh</td><td>0.0</td></tr>
  <tr><td>sqrt</td><td>0.0 or 1.0</td></tr>
  <tr><td>tan</td><td>0.0</td></tr>
  <tr><td>tanh</td><td>0.0</td></tr>
  <tr><td>toDegrees</td><td>0.0 or 1.0</td></tr>
  <tr><td>toRadians</td><td>0.0</td></tr>
</table>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>CD_CIRCULAR_DEPENDENCY</id>
    <artifact tool="FindBugs" mnemonic="CD_CIRCULAR_DEPENDENCY"/>
    <name>Circular dependency</name>
    <shortMessage>Circular dependencies among classes detected. This signposts a poor design or implementation.</shortMessage>
    <info>
<![CDATA[<p>This class has a circular dependency with other
classes. This makes building these classes difficult, as each is
dependent on the other to build correctly. Consider using interfaces
to break the hard dependency.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>RI_REDUNDANT_INTERFACES</id>
    <artifact tool="FindBugs" mnemonic="RI_REDUNDANT_INTERFACES"/>
    <name>Redundant interfaces</name>
    <shortMessage>This class implements the same interface as its superclass. Consider removing the redundant implements from this class.</shortMessage>
    <info>
<![CDATA[<p>This class declares that it implements an interface that
is also implemented by a superclass. This is redundant, once a
superclass implements an interface, all subclasses by default also
implement the interface.  Therefore, you can remove this redundant
statement.</p>

<p>This issue may point out that the inheritance hierarchy has changed
since this class was created, and consideration should be made about
which class should implement the interface.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>MTIA_SUSPECT_STRUTS_INSTANCE_FIELD</id>
    <artifact tool="FindBugs" mnemonic="MTIA_SUSPECT_STRUTS_INSTANCE_FIELD"/>
    <name>Suspect Struts instance field</name>
    <shortMessage>This class extends the Struts Action class and uses instance variables. This is likely to problematic.</shortMessage>
    <info>
<![CDATA[<p>This class extends from a Struts <code>Action</code>
class, and uses a instance member variable. Since only one instance of
a struts <code>Action</code> class is created by the Struts framework,
and used in a multithreaded way, this paradigm is highly discouraged
and most likely problematic. Consider removing these fields.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>MTIA_SUSPECT_SERVLET_INSTANCE_FIELD</id>
    <artifact tool="FindBugs" mnemonic="MTIA_SUSPECT_SERVLET_INSTANCE_FIELD"/>
    <name>Suspect Servlet instance field</name>
    <shortMessage>This class extends Servlet class and uses instance variables. This is likely to be problematic.</shortMessage>
    <info>
<![CDATA[<p>This class extends from a <code>Servlet</code> class, and
uses a instance member variable. Since only one instance of a
<code>Servlet</code> class is created by the container, and used in a
multithreaded way, this paradigm is highly discouraged and most likely
problematic. Consider removing these fields.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>PS_PUBLIC_SEMAPHORES</id>
    <artifact tool="FindBugs" mnemonic="PS_PUBLIC_SEMAPHORES"/>
    <name>Public semaphores</name>
    <shortMessage>Class exposes synchronization and semaphores in its public interface.</shortMessage>
    <info>
<![CDATA[<p>This class uses synchronization along with
<code>wait()</code>, <code>notify()</code> or <code>notifyAll()</code>
on itself (the <code>this</code> reference).  Client classes that use
this class, may, in addition, use an instance of the class as a
synchronizing object. Because two classes are using the same object
for synchronization, multithreaded correctness is suspect. You should
not synchronize nor call semaphore methods on a public
reference. Consider using a internal private member variable to
control synchronization.  For example, consider changing</p>

<pre>
public class Foo {

  public synchronized void log(String s) {
    // do something
  }
	
  public int generate() {
    synchronized (this) {
      // do something
    }
    return 4;
  }
}
</pre>

<p>to</p>

<pre>
public class Foo {
	
  private final Object lock = new Object();

  public void log(String s) {
    synchronized (lock) {
      // do something
    }
  }
	
  public int generate() {
    synchronized (lock) {
      // do something
    }
    return 4;
  }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ICAST_INTEGER_MULTIPLY_CAST_TO_LONG</id>
    <artifact tool="FindBugs" mnemonic="ICAST_INTEGER_MULTIPLY_CAST_TO_LONG"/>
    <name>Integer multiplication result cast to long</name>
    <shortMessage>This code casts the result of integer multiplication to a long. This might overflow.</shortMessage>
    <info>
<![CDATA[<p>This code performs integer multiply and then converts
the result to a long, as in:</p>

<pre>
long convertDaysToMilliseconds(int days) {
  return 1000 * 3600 * 24 * days; // Bad! int values may overflow
}
</pre>

<p>If the multiplication is done using <code>long</code> arithmetic,
you can avoid the possibility that the result will overflow. To do
this change at least one of the values to a <code>long</code>. For
example, you could fix the above code by making the <code>int</code>
literal 1000 a <code>long</code> literal as shown below.</p>

<pre>
long convertDaysToMilliseconds(int days) {
  return 1000L * 3600 * 24 * days;
}
</pre>

<p>or</p>

<pre>
static final long MILLISECONDS_PER_DAY = 24L * 3600 * 1000;

long convertDaysToMilliseconds(int days) {
  return days * MILLISECONDS_PER_DAY;
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ICAST_INT_CAST_TO_FLOAT_PASSED_TO_ROUND</id>
    <artifact tool="FindBugs" mnemonic="ICAST_INT_CAST_TO_FLOAT_PASSED_TO_ROUND"/>
    <name>Int cast to a float then passed to Math.round()</name>
    <shortMessage>This code casts an int value to a float value and then passes this value to Math.round(). It is likely that this is not what was intended.</shortMessage>
    <info>
<![CDATA[<p>This code converts an <code>int</code> value to a
<code>float</code> precision floating-point number and then passes the
result to the <code>Math.round()</code> function, which returns the
<code>int</code>/<code>long</code> closest to the argument. This
operation should always be a no-op, since the converting an integer to
a <code>float</code> should give a number with no fractional part.</p>

<p>It is likely that the operation that generated the value to be
passed to <code>Math.round()</code> was intended to be performed using
floating-point arithmetic. Check this code carefully for
errors.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ICAST_INT_CAST_TO_DOUBLE_PASSED_TO_CEIL</id>
    <artifact tool="FindBugs" mnemonic="ICAST_INT_CAST_TO_DOUBLE_PASSED_TO_CEIL"/>
    <name>Int cast to a double then passed to Math.ceil()</name>
    <shortMessage>This code casts an int value to a double value and then passes this value to Math.ceil(). It is likely that this is not what was intended.</shortMessage>
    <info>
<![CDATA[<p>This code converts an <code>int</code> value to a
<code>double</code> precision floating-point number and then passes
the result to the <code>Math.ceil()</code> function, which rounds a
<code>double</code> to the next higher integer value. This operation
should always be a no-op, since the converting an integer to a
<code>double</code> should give a number with no fractional part.</p>

<p>It is likely that the operation that generated the value to be
passed to <code>Math.ceil()</code> was intended to be performed using
double precision floating-point arithmetic.  Check this code carefully
for errors.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ICAST_IDIV_CAST_TO_DOUBLE</id>
    <artifact tool="FindBugs" mnemonic="ICAST_IDIV_CAST_TO_DOUBLE"/>
    <name>Integer division result cast to a floating-point type</name>
    <shortMessage>The result of integer division is cast to a double or float. Should floating-point division have been done instead?</shortMessage>
    <info>
<![CDATA[<p>This code casts the result of an integer division
operation to a <code>double</code> or <code>float</code>. Doing
division on integers truncates the result to the integer value closest
to zero.</p>

<p>The fact that the result was cast to a <code>double</code> suggests
that this precision should have been used for the division
operation. What was probably meant was to cast one or both of the
operands to double <em>before</em> performing the division. Here is an
example:</p>

<pre>
int x = 2; int y = 5;

double value1 = x / y;          // Bad! yields 0.0

double value2 = x / (double) y; // Right! yields 0.4
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION</id>
    <artifact tool="FindBugs" mnemonic="J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION"/>
    <name>Store of non-serializable Object into HttpSession</name>
    <shortMessage>This code appears to be storing a non-serializable object into an HttpSession. This may cause an error if the session is passivated.</shortMessage>
    <info>
<![CDATA[<p>This code seems to be storing a non-serializable object
into an <code>HttpSession</code>. If this session is passivated or
migrated, an error will result. Consider making this object
serializable.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DMI_NONSERIALIZABLE_OBJECT_WRITTEN</id>
    <artifact tool="FindBugs" mnemonic="DMI_NONSERIALIZABLE_OBJECT_WRITTEN"/>
    <name>Store of non-serializable Object</name>
    <shortMessage>This code appears to be writing a non-serializable object to an ObjectOutput instance. This may throw an IOException.</shortMessage>
    <info>
<![CDATA[<p>This code seems to be passing a non-serializable object to
the <code>ObjectOutput.writeObject()</code> method. If the object is,
indeed, non-serializable, an error will result. Consider making this
object serializable.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>VA_PRIMITIVE_ARRAY_PASSED_TO_OBJECT_VARARG</id>
    <artifact tool="FindBugs" mnemonic="VA_PRIMITIVE_ARRAY_PASSED_TO_OBJECT_VARARG"/>
    <name>Primitive array passed to a vararg</name>
    <shortMessage>Primitive array passed to function expecting a variable number of object arguments. The array will become one argument which may not be what was intended.</shortMessage>
    <info>
<![CDATA[<p>This code passes a primitive array to a function that
takes a variable number of object arguments. This creates an array of
length one to hold the primitive array and passes it to the
function. Check this code and ensure that this behavior is
intentional.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS</id>
    <artifact tool="FindBugs" mnemonic="BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS"/>
    <name>Equals() should work for all arguments</name>
    <shortMessage>An equals method should not assume anything about the type of its argument. This code appears to be making assumptions.</shortMessage>
    <info>
<![CDATA[<p>The <code>equals(Object o)</code> method shouldn't make
any assumptions about the type of <code>o</code>. It should simply
return false if <code>o</code> is not the same type as
<code>this</code>. For example, examine the below code.</p>

<pre>
class Foo {
  @Override public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null) return false;
    if (getClass() != o.getClass()) return false;  // <-- type check
    Foo other = (Foo) o;
    // check semantic equality of 'this' and 'other'
    ...
  }
  ...
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>BC_BAD_CAST_TO_ABSTRACT_COLLECTION</id>
    <artifact tool="FindBugs" mnemonic="BC_BAD_CAST_TO_ABSTRACT_COLLECTION"/>
    <name>Questionable Collection cast</name>
    <shortMessage>Questionable cast to List, Set, or Map from Collection. Do you need to do this?</shortMessage>
    <info>
<![CDATA[<p>This code casts a <code>Collection</code> to a more
specific type such as <code>List</code>, <code>Set</code>, or
<code>Map</code>. Ensure that you are guaranteed that the object is of
the type you are casting to. If all you need is to be able to iterate
through a <code>Collection</code>, you don't need to cast it to a
<code>Set</code> or <code>List</code>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>BC_IMPOSSIBLE_CAST_PRIMITIVE_ARRAY</id>
    <artifact tool="FindBugs" mnemonic="BC_IMPOSSIBLE_CAST_PRIMITIVE_ARRAY"/>
    <name>Impossible cast primitive array</name>
    <shortMessage>This code contains an impossible cast involving a primitive array. It will always throw a ClassCastException.</shortMessage>
    <info>
<![CDATA[<p>This cast will always throw a
<code>ClassCastException</code>. This code needs to be fixed.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>BC_IMPOSSIBLE_CAST</id>
    <artifact tool="FindBugs" mnemonic="BC_IMPOSSIBLE_CAST"/>
    <name>Impossible cast</name>
    <shortMessage>Impossible cast will always throw a ClassCastException. Fix this code.</shortMessage>
    <info>
<![CDATA[<p>This cast will always throw a
<code>ClassCastException</code>. This code needs to be fixed.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NP_NULL_INSTANCEOF</id>
    <artifact tool="FindBugs" mnemonic="NP_NULL_INSTANCEOF"/>
    <artifact tool="FindBugs" mnemonic="BC_NULL_INSTANCEOF"/>
    <name>Suspicious instanceof null</name>
    <shortMessage>This code checks to see if a known null value an instance of a type. This will always return false. Is this code broken?</shortMessage>
    <info>
<![CDATA[<p>This <code>instanceof</code> test will always return
false, because the value being checked is guaranteed to be
<code>null</code>.</p>

<p>Although this is legal code, make sure it isn't an indication of
some misunderstanding or some other logic error. It is also recommended
that you consider removing the check.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>BC_IMPOSSIBLE_INSTANCEOF</id>
    <artifact tool="FindBugs" mnemonic="BC_IMPOSSIBLE_INSTANCEOF"/>
    <name>Impossible instanceof</name>
    <shortMessage>This code contains an instanceof test that will always return false. Is this code broken?</shortMessage>
    <info>
<![CDATA[<p>This <code>instanceof</code> test will always return
false.</p>

<p>Although this is legal code, make sure it isn't an indication of
some misunderstanding or some other logic error. It is also recommended
that you consider removing the check.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>BC_UNCONFIRMED_CAST</id>
    <artifact tool="FindBugs" mnemonic="BC_UNCONFIRMED_CAST"/>
    <name>Unconfirmed cast</name>
    <shortMessage>Unchecked/unconfirmed cast</shortMessage>
    <info>
<![CDATA[<p>This cast is unchecked, and not all instances of the type
casted from can be cast to the type it is being cast to. Ensure that
your program logic ensures that this cast will not fail, perhaps by
adding an <code>instanceof</code> check.</p>

<pre>
if (o instanceof MyClass) {
  final MyClass mc = (MyClass) o;
  // do something
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>BC_BAD_CAST_TO_CONCRETE_COLLECTION</id>
    <artifact tool="FindBugs" mnemonic="BC_BAD_CAST_TO_CONCRETE_COLLECTION"/>
    <name>Questionable cast to a concrete collection</name>
    <shortMessage>This code contains a questionable cast to concrete collection.</shortMessage>
    <info>
<![CDATA[<p>This code casts an abstract collection type, such as
<code>Collection</code>, <code>List</code>, or <code>Set</code>, to a
specific concrete implementation type, such as <code>ArrayList</code>
or <code>HashSet</code>. This might not be correct, and it may make
your code fragile, since it makes it harder to switch to other
concrete implementations at a future point.</p>

<p>It is recommended that you try to remove this cast from your
code. Unless you have a sound reason to do so, just interact with the
abstract collection type.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>RE_POSSIBLE_UNINTENDED_PATTERN</id>
    <artifact tool="FindBugs" mnemonic="RE_POSSIBLE_UNINTENDED_PATTERN"/>
    <name>Suspicious regex pattern</name>
    <shortMessage>"." is used as a regular expression. Is this what you intended?</shortMessage>
    <info>
<![CDATA[<p>A <code>String</code> function is being invoked and
<code>"."</code> is being passed to a parameter that takes a regular
expression as an argument. Is this what you intended?</p>

<p>For example</p>

<pre>
String r = s.replaceAll(&quot;.&quot;, &quot;/&quot;);
</pre>

<p>will return a <code>String</code> in which <em>every</em> character
has been replaced by a <code>/</code> character.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>RE_BAD_SYNTAX_FOR_REGULAR_EXPRESSION</id>
    <artifact tool="FindBugs" mnemonic="RE_BAD_SYNTAX_FOR_REGULAR_EXPRESSION"/>
    <name>Bad syntax for regex</name>
    <shortMessage>This code uses an invalid regular expression. It will always throw a PatternSyntaxException.</shortMessage>
    <info>
<![CDATA[<p>This code uses a regular expression that is invalid
according to the syntax for regular expressions.  This statement will
throw a <code>PatternSyntaxException</code> when executed. Please fix
this code.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>RE_CANT_USE_FILE_SEPARATOR_AS_REGULAR_EXPRESSION</id>
    <artifact tool="FindBugs" mnemonic="RE_CANT_USE_FILE_SEPARATOR_AS_REGULAR_EXPRESSION"/>
    <name>Bad use of File.separator for regex</name>
    <shortMessage>This code uses File.separator for a regular expression. This will fail on Windows platforms.</shortMessage>
    <info>
<![CDATA[<p>The code here uses <code>File.separator</code> where a
regular expression is required. This will fail on Windows platforms,
where the <code>File.separator</code> is a backslash, which is
interpreted in a regular expression as an escape character.  To fix
this, on Windows, you need to use two backslashs in a row&mdash;not
just one.</p>

<p>One approach to fixing this is to create a constant<p>

<pre>
public static final String regExSeparator = File.separatorChar == '\\' ? "\\\\" : File.separator;
</pre>

<p>which you use instead of <code>File.separator</code>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DLS_OVERWRITTEN_INCREMENT</id>
    <artifact tool="FindBugs" mnemonic="DLS_OVERWRITTEN_INCREMENT"/>
    <name>Overwritten increment</name>
    <shortMessage>This code preforms an increments operation and then immediately overwrites it. Is this a mistake?</shortMessage>
    <info>
<![CDATA[<p>This code performs an increment operation (e.g.,
<code>i++</code>) and then immediately overwrites it. For example,</p>

<pre>
i = i++;
</pre>

<p>immediately overwrites the incremented value with
the original value.</p>

<p>This is probably not what was intended.  Most likely this code
should be <code>i++</code> (alone) or <code>i = i + 1</code>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ICAST_QUESTIONABLE_UNSIGNED_RIGHT_SHIFT</id>
    <artifact tool="FindBugs" mnemonic="ICAST_QUESTIONABLE_UNSIGNED_RIGHT_SHIFT"/>
    <name>Questionable unsigned right shift</name>
    <shortMessage>Unsigned right shift cast to short/byte.</shortMessage>
    <info>
<![CDATA[<p>The code performs an unsigned right shift, whose result is
then cast to a short or byte, which discards the upper bits of the
result. Since the upper bits are discarded, there may be no difference
between a signed and unsigned right shift (depending upon the size of
the shift).</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ICAST_BAD_SHIFT_AMOUNT</id>
    <artifact tool="FindBugs" mnemonic="ICAST_BAD_SHIFT_AMOUNT"/>
    <name>Bad shift amount</name>
    <shortMessage>This code performs an integer shift by an amount not in the range 0..31.</shortMessage>
    <info>
<![CDATA[<p>The code performs an integer shift by a constant amount
outside the range 0..31. The effect of this is to use the lower 5 bits
of the integer value to decide how much to shift by. This probably
isn't want was expected, and it at least confusing.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>IM_MULTIPLYING_RESULT_OF_IREM</id>
    <artifact tool="FindBugs" mnemonic="IM_MULTIPLYING_RESULT_OF_IREM"/>
    <name>Multiplying result of an int remainder</name>
    <shortMessage>Integer multiply of result of an integer remainder operation. Is this a mistake?</shortMessage>
    <info>
<![CDATA[<p>The code multiplies the result of an integer remaining by
an integer constant. Be sure you don't have your operator precedence
confused. For example</p>

<pre>
i % 60 * 1000
</pre>

<p>is</p>

<pre>
(i % 60) * 1000
</pre>

<p>not</p>

<pre>
i % (60 * 1000)
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DMI_INVOKING_TOSTRING_ON_ARRAY</id>
    <artifact tool="FindBugs" mnemonic="DMI_INVOKING_TOSTRING_ON_ARRAY"/>
    <artifact tool="FindBugs" mnemonic="DMI_INVOKING_TOSTRING_ON_ANONYMOUS_ARRAY"/>
    <name>Invoking toString() on array</name>
    <shortMessage>Invocation of toString() on an array produces a useless result. Did you mean to use Arrays.toString()?</shortMessage>
    <info>
<![CDATA[<p>The code invokes <code>toString()</code> on an array, which will generate
a fairly useless result such as <code>[C@16f0472</code>.  Consider
using the <code>Arrays.toString()</code> method to convert the array
into a readable String that also shows the contents of the array.</p>

<p>For more information on this issue see puzzle 12 of Bloch and
Gafter's <i>Java Puzzlers</i>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>IM_AVERAGE_COMPUTATION_COULD_OVERFLOW</id>
    <artifact tool="FindBugs" mnemonic="IM_AVERAGE_COMPUTATION_COULD_OVERFLOW"/>
    <name>Average computation could overflow</name>
    <shortMessage>This code contains a computation that could overflow.</shortMessage>
    <info>
<![CDATA[<p>This code computes the average of two integers using
either division or signed right shift, and then uses the result as the
index of an array. If the values being averaged are very large, this
can overflow (resulting in the computation of a negative average).</p>

<p>Assuming that the result is intended to be nonnegative, you can use
an unsigned right shift instead. In other words, rather that using</p>

<pre>
(low + high) / 2
</pre>

<p>use</p>

<pre>
(low + high) &gt;&gt;&gt; 1
</pre>

<p>This bug exists in many earlier implementations of binary search
and merge sort.  Martin Buchholz <a
href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6412541">found
and fixed it</a> in the JDK libraries, and Joshua Bloch <a
href="http://googleresearch.blogspot.com/2006/06/extra-extra-read-all-about-it-nearly.html">widely
publicized the bug pattern</a>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>IM_BAD_CHECK_FOR_ODD</id>
    <artifact tool="FindBugs" mnemonic="IM_BAD_CHECK_FOR_ODD"/>
    <name>Bad check for odd</name>
    <shortMessage>This code performs a check for oddness that won't work for negative values.</shortMessage>
    <info>
<![CDATA[<p>The code uses <code>x % 2 == 1</code> to check to see if a
value is odd, but this won't work for negative numbers.  For example,
<code>(-5) % 2 == -1</code> (not <code>1</code>). If this code is trying to check for
oddness, consider using

<pre>
x &amp; 1 == 1
</pre>

<p>or</p>

<pre>
x % 2 != 0
</pre>

<p>both of which avoid this issue.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DMI_HARDCODED_ABSOLUTE_FILENAME</id>
    <artifact tool="FindBugs" mnemonic="DMI_HARDCODED_ABSOLUTE_FILENAME"/>
    <name>Hardcoded absolute filename</name>
    <shortMessage>This code contains a hard coded reference to an absolute pathname. This can make your code difficult to deploy.</shortMessage>
    <info>
<![CDATA[<p>This code constructs a File object using a hard coded to
an absolute pathname. For example</p>

<pre>
new File("/home/dannyc/workspace/j2ee/src/share/com/sun/enterprise/deployment");
</pre>

<p>This can strongly tie the code the environment it is developed
within and make it more difficult to deploy.  Consider moving this
file reference into a properties file or use some other more flexible
scheme.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DMI_BAD_MONTH</id>
    <artifact tool="FindBugs" mnemonic="DMI_BAD_MONTH"/>
    <name>Bad month value</name>
    <shortMessage>Bad constant value for month passed. This is likely a typo or a bug.</shortMessage>
    <info>
<![CDATA[<p>This code passes a constant month value outside the
expected range of 0..11 to a method.  Please fix this code.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DMI_USELESS_SUBSTRING</id>
    <artifact tool="FindBugs" mnemonic="DMI_USELESS_SUBSTRING"/>
    <name>Useless substring(0)</name>
    <shortMessage>This code calls substring(0), which returns the original value. It may signpost a typo or a bug.</shortMessage>
    <info>
<![CDATA[<p>This code invokes <code>substring(0)</code> on a
<code>String</code>, which returns the original value. This is likely
a mistake and this code should be examined carefully for logic
errors.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DMI_CALLING_NEXT_FROM_HASNEXT</id>
    <artifact tool="FindBugs" mnemonic="DMI_CALLING_NEXT_FROM_HASNEXT"/>
    <name>Never call next() from hasNext()</name>
    <shortMessage>The hasNext() method in this code invokes next() which is almost certainly wrong.</shortMessage>
    <info>
<![CDATA[<p>In this iterator implementation the <code>hasNext()</code>
method invokes the <code>next()</code> method.  This is almost
certainly wrong, since the <code>hasNext()</code> method is not
supposed to change the state of the iterator, and the
<code>next()</code> method is supposed to change the state of the
iterator.</p>

<p>Please examine the specification for an iterator and fix this
code.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidCallingSleepWithLockHeld</id>
    <artifact tool="FindBugs" mnemonic="SWL_SLEEP_WITH_LOCK_HELD"/>
    <name>Avoid sleeping with a lock held</name>
    <shortMessage>This code calls Thread.sleep() with a lock held which may impact performance and scalability.</shortMessage>
    <info>
<![CDATA[<p>This code appears to call <code>Thread.sleep()</code> with
a lock held.  This may result in very poor performance and
scalability, or a deadlock, since other threads may be waiting to
acquire the lock.</p>

<p>If you must hold a lock, it is a much better idea to call
<code>wait()</code> on the lock, which releases the lock and allows
other threads to run. In addition consider using the classes in the
<code>java.util.concurrent</code> package.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DB_DUPLICATE_BRANCHES</id>
    <artifact tool="FindBugs" mnemonic="DB_DUPLICATE_BRANCHES"/>
    <name>Duplicate branches</name>
    <shortMessage>This code uses the same logic for two branches. Is this a coding mistake?</shortMessage>
    <info>
<![CDATA[<p>This method uses the same code to implement two branches
of a conditional branch. Check this logic carefully to ensure that
this isn't a coding mistake.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DB_DUPLICATE_SWITCH_CLAUSES</id>
    <artifact tool="FindBugs" mnemonic="DB_DUPLICATE_SWITCH_CLAUSES"/>
    <name>Duplicate switch clauses</name>
    <shortMessage>This code uses the same logic for two switch clauses. Is this a coding mistake?</shortMessage>
    <info>
<![CDATA[<p>This method uses the same code to implement two clauses of
a switch statement. This could be a case of duplicate code, but it
might also indicate a coding mistake.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>IMA_INEFFICIENT_MEMBER_ACCESS</id>
    <artifact tool="FindBugs" mnemonic="IMA_INEFFICIENT_MEMBER_ACCESS"/>
    <name>Inefficient member access</name>
    <shortMessage>Method accesses a private member variable of owning class. This may be inefficient.</shortMessage>
    <info>
<![CDATA[<p>This method of an inner class reads from or writes to a
private member variable of the owning class, or calls a private method
of the owning class. The compiler must generate a special method to
access this private member, causing this code to be less
efficient. Relaxing the protection of the member variable or method
will allow the compiler to treat this as a normal access.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>XFB_XML_FACTORY_BYPASS</id>
    <artifact tool="FindBugs" mnemonic="XFB_XML_FACTORY_BYPASS"/>
    <name>XML factory bypass</name>
    <shortMessage>This code directly allocates a specific implementation of and XML interface. Should you be using a factory?</shortMessage>
    <info>
<![CDATA[<p> This method allocates a specific implementation of an XML
interface. It is preferable to use the supplied factory classes to
create these objects so that the implementation can be changed at
runtime. See </p>

<ul>
  <li>javax.xml.parsers.DocumentBuilderFactory</li>
  <li>javax.xml.parsers.SAXParserFactory</li>
  <li>javax.xml.transform.TransformerFactory</li>
  <li>org.w3c.dom.Document.create<i>X</i></li>
</ul>

<p>for details.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>USM_USELESS_ABSTRACT_METHOD</id>
    <artifact tool="FindBugs" mnemonic="USM_USELESS_ABSTRACT_METHOD"/>
    <name>Useless abstract method</name>
    <shortMessage>Abstract method is already defined in an implemented interface. Remove this method.</shortMessage>
    <info>
<![CDATA[<p>This abstract method is already defined in an interface
that is implemented by this abstract class. This method can be
removed, as it provides no additional value.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>CI_CONFUSED_INHERITANCE</id>
    <artifact tool="FindBugs" mnemonic="CI_CONFUSED_INHERITANCE"/>
    <name>Confused inheritance</name>
    <shortMessage>Class is final but declares at least one protected field.</shortMessage>
    <info>
<![CDATA[<p>This class is declared to be <code>final</code>, but it
declares fields to be <code>protected</code>. Since the class is
<code>final</code>, it can not be subclassed, and the use of
<code>protected</code> is confusing.</p>

<p>The access modifier for the field should be changed to
<code>private</code> or <code>public</code> to represent the actual
intended use for the field.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>QBA_QUESTIONABLE_BOOLEAN_ASSIGNMENT</id>
    <artifact tool="FindBugs" mnemonic="QBA_QUESTIONABLE_BOOLEAN_ASSIGNMENT"/>
    <name>Questionable boolean assignment</name>
    <shortMessage>This code assigns boolean literal in boolean expression. Is this a mistake? Did you mean ==?</shortMessage>
    <info>
<![CDATA[<p>This method assigns a literal boolean value (true or
false) to a boolean variable inside an <code>if</code> or
<code>while</code> expression. Most probably this is a mistake and the
code was supposed to be a boolean comparison using <code>==</code>,
not an assignment using <code>=</code>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>VR_UNRESOLVABLE_REFERENCE</id>
    <artifact tool="FindBugs" mnemonic="VR_UNRESOLVABLE_REFERENCE"/>
    <name>Unresolvable reference</name>
    <shortMessage>This class makes reference to unresolvable class or method.</shortMessage>
    <info>
<![CDATA[<p>This class makes a reference to a class or method that can
not be resolved using against the libraries it is being analyzed
with. This may be caused if the analysis was not told about the
program's entire classpath.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>GC_UNRELATED_TYPES</id>
    <artifact tool="FindBugs" mnemonic="GC_UNRELATED_TYPES"/>
    <name>Unrelated types</name>
    <shortMessage>No relationship between a generic parameter and this method argument.</shortMessage>
    <info>
<![CDATA[<p>This call to a generic container's method contains an
argument with a different class type from that of the container's
parameter. Therefore, it is unlikely that the container contains any
objects with the same type as the method argument used here.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidStaticCalendar</id>
    <artifact tool="FindBugs" mnemonic="STCAL_STATIC_CALENDAR_INSTANCE"/>
    <artifact tool="FindBugs" mnemonic="STCAL_INVOKE_ON_STATIC_CALENDAR_INSTANCE"/>
    <name>Avoid static Calendar instances</name>
    <shortMessage>This code contains a static Calendar instance. This may cause erratic behavior in your application.</shortMessage>
    <info>
<![CDATA[<p><code>Calendar</code> instances are inherently unsafe for
multithreaded use. Sharing a single instance across thread boundaries
without proper synchronization will result in erratic behavior of the
application. Under JDK 1.4 problems seem to surface less often than
under Java 5 where you will probably see random
<code>ArrayIndexOutOfBoundsExceptions</code> or
<code>IndexOutOfBoundsExceptions</code> in
<code>sun.util.calendar.BaseCalendar.getCalendarDateFromFixedDate()</code>.</p>

<p>You may also experience serialization problems.</p>

<p>Using an instance field is recommended.</p>

<p>For more information on this issue please see <a
href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6231579">Sun
bug #6231579</a> and <a
href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6178997">Sun
bug #6178997</a>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>STCAL_STATIC_SIMPLE_DATE_FORMAT_INSTANCE</id>
    <artifact tool="FindBugs" mnemonic="STCAL_STATIC_SIMPLE_DATE_FORMAT_INSTANCE"/>
    <artifact tool="FindBugs" mnemonic="STCAL_INVOKE_ON_STATIC_DATE_FORMAT_INSTANCE"/>
    <artifact tool="PMD" mnemonic="UnsynchronizedStaticDateFormatter"/>
    <name>Avoid static SimpleDateFormat instances</name>
    <shortMessage>This code contains a static SimpleDateFormat instance. This may cause erratic behavior in your application.</shortMessage>
    <info>
<![CDATA[<p>As the Javadoc states, <code>DateFormat</code> objects are
inherently unsafe for multithreaded use. Sharing a single instance
across thread boundaries without proper synchronization will result in
erratic behavior of the application.</p>

<p>You may also experience serialization problems.</p>

<p>Using an instance field is recommended.</p>

<p>For more information about this issue see <a
href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6231579">Sun
Bug #6231579</a> and <a
href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6178997">Sun
Bug #6178997</a>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DoesntOverrideEquals</id>
    <artifact tool="FindBugs" mnemonic="EQ_DOESNT_OVERRIDE_EQUALS"/>
    <name>Doesn't override equals()</name>
    <shortMessage>This class doesn't override equals in its superclass. Is this a mistake?</shortMessage>
    <info>
<![CDATA[<p>This class extends a class that defines an
<code>equals</code> method.  The class adds fields, but doesn't define
an <code>equals</code> method itself. Thus, equality on instances of
this class will ignore the identity of the subclass and the added
fields.</p>

<p>Be sure this is what is intended, and that you don't need to
override the <code>equals</code> method. Even if you don't need to
override the equals method, consider overriding it anyone to document
the fact that the equals method for the subclass just return the
result of invoking <code>super.equals(o)</code>.</p>

<p>For more information see Bloch's <i>Effective Java</i> (second
edition) items 8 and 9.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SameSimpleNameAsInterface</id>
    <artifact tool="FindBugs" mnemonic="NM_SAME_SIMPLE_NAME_AS_INTERFACE"/>
    <artifact tool="FindBugs" mnemonic="NM_SAME_SIMPLE_NAME_AS_SUPERCLASS"/>
    <name>Avoid same simple name as interface/class</name>
    <shortMessage>Class names shouldn't shadow the simple name of implemented interfaces or extended classes. This can be confusing.</shortMessage>
    <info>
<![CDATA[<p>This class/interface has a simple name that is identical
to that of an implemented/extended interface/class, except that the
interface/class is in a different package. For example</p>

<pre>
package org.alpha;

class Foo extends org.beta.Foo implements org.gamma.Foo {
  ...
}
</pre>

<p>This can be exceptionally confusing, create lots of situations in
which you have to look at import statements to resolve references, and
creates many opportunities to accidentally define methods that do not
override methods in their superclasses.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>WrongPackage</id>
    <artifact tool="FindBugs" mnemonic="NM_WRONG_PACKAGE"/>
    <artifact tool="FindBugs" mnemonic="NM_WRONG_PACKAGE_INTENTIONAL"/>
    <name>No override due to wrong package for a parameter</name>
    <shortMessage>Method doesn't override a method in a superclass due to the wrong package for parameter. Is this a mistake?</shortMessage>
    <info>
<![CDATA[<p>The method in the subclass doesn't override a similar
method in a superclass because the type of a parameter doesn't exactly
match the type of the corresponding parameter in the superclass. For
example, if you have</p>

<pre>
import org.alpha.Foo;

public class A {
  public int f(Foo x) {
    return 17;
  }
}
</pre>

<p>and</p>

<pre>
import org.beta.Foo;

public class B extends A {
  public int f(Foo x) { // Bad!
    return 42;
  }
}
</pre>

<p>The <code>f(Foo)</code> method defined in class <code>B</code>
doesn't override the <code>f(Foo)</code> method defined in class
<code>A</code>, because the argument types are <code>Foo</code>'s from
different packages.</p>

<p>In JDK 1.5 or above it is possible to have the compiler warn about
this problem by annotating the <code>f(Foo)</code> method in
<code>B</code> with @Override.  The below would not compile due to
this issue.</p>

<pre>
import org.beta.Foo;

public class B extends A {
  @Override public int f(Foo x) {
    return 42;
  }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ReturnValueIgnoredBadPractice</id>
    <artifact tool="FindBugs" mnemonic="RV_RETURN_VALUE_IGNORED_BAD_PRACTICE"/>
    <name>Ignored return value</name>
    <shortMessage>This code ignores the return value of a invoked method. This is a bad practice. Did the method accomplish what it was suppose to?</shortMessage>
    <info>
<![CDATA[<p>This method returns a value that is not checked.  For
example, the <code>File.delete()</code> method returns
<code>false</code> if the file could not be successfully deleted
rather than throwing an Exception. If you don't check the result,
you won't notice if the method invocation signals unexpected behavior
by returning an atypical return value.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ExceptionNotThrown</id>
    <artifact tool="FindBugs" mnemonic="RV_EXCEPTION_NOT_THROWN"/>
    <name>Exception not thrown</name>
    <shortMessage>Exception created and dropped rather than thrown. Did you forget to throw the exception?</shortMessage>
    <info>
<![CDATA[<p>This code creates an exception (or error) object, but
doesn't do anything with it. For example, something like </p>

<pre>
if (x < 0) {
  new IllegalArgumentException("x must be nonnegative");
}
</pre>

<p>In this type of situation, it was probably the intent of the
programmer to throw the created exception.  For example</p>

<pre>
if (x < 0) {
  throw new IllegalArgumentException("x must be nonnegative");
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UnrelatedTypesUsingPointerEquality</id>
    <artifact tool="FindBugs" mnemonic="EC_UNRELATED_TYPES_USING_POINTER_EQUALITY"/>
    <name>Unrelated types compared using ==</name>
    <shortMessage>This code appears to be using pointer equality to compare different types. Is this a logic error?</shortMessage>
    <info>
<![CDATA[<p>This method uses using pointer equality to compare two
references that seem to be of different types. The result of this
comparison will always be <code>false</code> at runtime.</p>

<p>Examine this code carefully for logic errors.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>BitSignedCheck</id>
    <artifact tool="FindBugs" mnemonic="BIT_SIGNED_CHECK"/>
    <artifact tool="FindBugs" mnemonic="BIT_SIGNED_CHECK_HIGH_BIT"/>
    <name>Signed check of bitwise operation</name>
    <shortMessage>This code checks for the sign of bitwise operation. Consider using != 0 instead.</shortMessage>
    <info>
<![CDATA[<p>This code uses an expression such as</p>

<pre>
((event.detail &amp; SWT.SELECTED) &gt; 0)
</pre>

<p>Using bit arithmetic and then comparing the result with the
greater-than operator can lead to unexpected results.  The result
depends on the value of SWT.SELECTED. If SWT.SELECTED is a negative
number, then this code may not behave as expected. Even when
SWT.SELECTED is not negative, it is good practice to use</p>

<pre>
((event.detail &amp; SWT.SELECTED) != 0)
</pre>

<p>instead of <code>&gt; 0</code>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LazyInitUpdateStatic</id>
    <artifact tool="FindBugs" mnemonic="LI_LAZY_INIT_UPDATE_STATIC"/>
    <name>Lazy initialization and update of a static field</name>
    <shortMessage>Incorrect lazy initialization and update of static field. This code may not be safe.</shortMessage>
    <info>
<![CDATA[<p>This method contains an unsynchronized lazy initialization
of a static field. After the field is set, the object stored into that
location is further accessed.  The setting of the field is visible to
other threads as soon as it is set. If the further accesses in the
method that set the field serve to initialize the object, then you
have a <em>very serious</em> multithreading bug, unless something else
prevents any other thread from accessing the stored object until it is
fully initialized.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DeadStoreOfClassLiteral</id>
    <artifact tool="FindBugs" mnemonic="DLS_DEAD_STORE_OF_CLASS_LITERAL"/>
    <name>Dead store of class literal</name>
    <shortMessage>Dead store of a class literal. Are you trying to force class initialization?</shortMessage>
    <info>
<![CDATA[<p>This instruction assigns a class literal to a variable and
then never uses it. The behavior of this code differs in Java 1.4 and
in Java 5. In Java 1.4 and earlier, a reference to
<code>Foo.class</code> would force the static initializer for
<code>Foo</code> to be executed, if it has not been executed
already. In Java 5 and later, it does not.</p>

<p>For more information please see Sun's <a
href="http://java.sun.com/j2se/1.5.0/compatibility.html#literal">article
on Java SE compatibility</a> for more details and examples, and
suggestions on how to force class initialization in Java 5.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AlwaysValueUsedWhereNeverRequired</id>
    <artifact tool="FindBugs" mnemonic="TQ_ALWAYS_VALUE_USED_WHERE_NEVER_REQUIRED"/>
    <name>Always value used where never required</name>
    <shortMessage>A value annotated as carrying a type qualifier is used where a value that must not carry that qualifier is required.</shortMessage>
    <info>
<![CDATA[<p>A value specified as carrying a type qualifier annotation
is consumed in a location or locations requiring that the value not
carry that annotation.</p>

<p>More precisely, a value annotated with a type qualifier specifying
<code>when=ALWAYS</code> is guaranteed to reach a use or uses where the same type
qualifier specifies <code>when=NEVER</code>.</p>

<p>For example, say that <code>@NonNegative</code> is a nickname for
the type qualifier annotation
<code>@Negative(when=When.NEVER)</code>. The following code will
generate this warning because the return statement requires a
<code>@NonNegative</code> value, but receives one that is marked as <code>@Negative</code>.</p>

<pre>
public @NonNegative Integer example(@Negative Integer value) {
  return value;
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NeverValueUsedWhereAlwaysRequired</id>
    <artifact tool="FindBugs" mnemonic="TQ_NEVER_VALUE_USED_WHERE_ALWAYS_REQUIRED"/>
    <name>Never value used where always required</name>
    <shortMessage>A value annotated as never carrying a type qualifier is used where a value carrying that qualifier is required.</shortMessage>
    <info>
<![CDATA[<p>A value specified as not carrying a type qualifier
annotation is guaranteed to be consumed in a location or locations
requiring that the value does carry that annotation.</p>

<p>More precisely, a value annotated with a type qualifier specifying
<code>when=NEVER</code> is guaranteed to reach a use or uses where the
same type qualifier specifies <code>when=ALWAYS</code>.</p>

<p>For example, say that <code>@NonNegative</code> is a nickname for
the type qualifier annotation
<code>@Negative(when=When.NEVER)</code>. The following code will
generate this warning because the return statement requires a
<code>@Negative</code> value, but receives one that is marked as <code>@NonNegative</code>.</p>

<pre>
public @Negative Integer example(@NonNegative Integer value) {
  return value;
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>MaybeSourceValueReachesAlwaysSink</id>
    <artifact tool="FindBugs" mnemonic="TQ_MAYBE_SOURCE_VALUE_REACHES_ALWAYS_SINK"/>
    <name>Maybe source value reaches always sink</name>
    <shortMessage>A value that might not carry a type qualifier reaches a use requiring that type qualifier.</shortMessage>
    <info>
<![CDATA[<p>A value that might not carry a type qualifier annotation
reaches a use which requires that annotation.</p>

<p>For example, consider the following method:</p>

<pre>
public @Untainted Object mustReturnUntainted(Object unknown) {
  return unknown;
}
</pre>

<p>The <code>mustReturnUntainted</code> method is required to return a
value carrying the <code>@Untainted</code> annotation, but a value not
known to carry that annotation is returned.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>MaybeSourceValueReachesNeverSink</id>
    <artifact tool="FindBugs" mnemonic="TQ_MAYBE_SOURCE_VALUE_REACHES_NEVER_SINK"/>
    <name>Maybe source value reaches never sink</name>
    <shortMessage>An unknown value reaches a use which forbids values carrying type qualifier annotation.</shortMessage>
    <info>
<![CDATA[<p>A value which might carry a type qualifier annotation
reaches a use which forbids values carrying that annotation.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>BooleanMethodReturnsNull</id>
    <artifact tool="FindBugs" mnemonic="NP_BOOLEAN_RETURN_NULL"/>
    <name>Boolean-typed method returns null</name>
    <shortMessage>A method with Boolean return type returns an explicit null value. This is a poor practice.</shortMessage>
    <info>
<![CDATA[<p>This method seems to be able to return
<code>null</code>. This is considered a bad practice because it can be
invoked as though it returned a value of type <code>boolean</code>,
and the compiler will insert automatic unboxing of the
<code>Boolean</code> value. If a <code>null</code> value is returned,
a <code>NullPointerException</code> will be thrown when unboxing
occurs.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AppendingToObjectOutputStream</id>
    <artifact tool="FindBugs" mnemonic="IO_APPENDING_TO_OBJECT_OUTPUT_STREAM"/>
    <name>Suspicious attempt to append to an ObjectOutputStream</name>
    <shortMessage>This code appears to be trying to append to an ObjectOutputStream. This may not work, check this code carefully.</shortMessage>
    <info>
<![CDATA[<p>This code opens a file in append mode and then wraps the
result in an <code>ObjectOutputStream</code>.  This approach does not
allow you to append to an existing object output stream stored in the
file. If you want to be able to append to an existing object output
stream, you need to keep the object output stream open.</p>

<p>The only situation in which opening a file in append mode and then
writing an object output stream could work is if on reading the file
you plan to open it in random access mode and seek to the byte offset
where the append started.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>FormatStringArgsMismatch</id>
    <artifact tool="FindBugs" mnemonic="VA_FORMAT_STRING_ARG_MISMATCH"/>
    <name>Mismatch of format string arguments and placeholder</name>
    <shortMessage>The number of format-string arguments does not correspond to number of placeholders. Is this a coding error?</shortMessage>
    <info>
<![CDATA[<p>This code calls a format-string method with a variable
number of arguments, but the number of arguments passed does not match
with the number of <code>%</code> placeholders in the format string.
This is probably not what the author intended. Examine this code
carefully and fix the mistake.</p> ]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>HttpParameterWrittenToServlet</id>
    <artifact tool="FindBugs" mnemonic="XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER"/>
    <name>Servlet cross-site scripting vulnerability</name>
    <shortMessage>HTTP parameter directly written to Servlet output. This could create a security vulnerability.</shortMessage>
    <info>
<![CDATA[<p>This code directly writes an HTTP parameter to Servlet
output, which may create the possibility for a cross-site scripting
vulnerability.</p>

<p>Please see <a
href="http://en.wikipedia.org/wiki/Cross-site_scripting">http://en.wikipedia.org/wiki/Cross-site_scripting</a>
for more information about this vulnerability.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>HttpParameterWrittenToJSP</id>
    <artifact tool="FindBugs" mnemonic="XSS_REQUEST_PARAMETER_TO_JSP_WRITER"/>
    <name>JSP cross-site scripting vulnerability</name>
    <shortMessage>An HTTP parameter directly written to JSP output. This could create a security vulnerability.</shortMessage>
    <info>
<![CDATA[<p>This code directly writes an HTTP parameter to JSP output,
which may create the possibility for a cross-site scripting vulnerability.</p>

<p>Please see <a
href="http://en.wikipedia.org/wiki/Cross-site_scripting">http://en.wikipedia.org/wiki/Cross-site_scripting</a>
for more information about this vulnerability.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EqualsDoesntOverrideInherited</id>
    <artifact tool="FindBugs" mnemonic="EQ_OTHER_NO_OBJECT"/>
    <name>Equals() doesn't override inherited equals(Object)</name>
    <shortMessage>This code defines an equals() method that doesn't override the inherited equals(Object) method. Is this a mistake?</shortMessage>
    <info>
<![CDATA[<p>This class defines an <code>equals()</code> method, that
doesn't override the normal <code>equals(Object)</code> method defined
by <code>java.lang.Object</code>. Instead, it inherits an
<code>equals(Object)</code> method from a superclass.  The class
should probably define a <code>boolean equals(Object)</code>
method.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NP_NULL_ON_SOME_PATH_MIGHT_BE_INFEASIBLE</id>
    <artifact tool="FindBugs" mnemonic="NP_NULL_ON_SOME_PATH_MIGHT_BE_INFEASIBLE"/>
    <name>Possible null dereference on an infeasible path</name>
    <shortMessage>This code contains a null pointer dereference on path that seems infeasible. Check that this code is correct.</shortMessage>
    <info>
<![CDATA[<p>There is a branch of statements that, <em>if
executed</em>, guarantees that a <code>null</code> value will be
dereferenced, which would generate a <code>NullPointerException</code>
when the code is executed.</p>

</p>Of course, the problem might be that the branch or statement is
infeasible and that the null pointer exception can't ever be executed;
deciding that is beyond the ability of the analysis. Due to the fact
that this value had been previously tested for nullness, this is a
definite possibility.</p>]]>
    </info>
  </findingType>	
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>HRS_REQUEST_PARAMETER_TO_HTTP_HEADER</id>
    <artifact tool="FindBugs" mnemonic="HRS_REQUEST_PARAMETER_TO_HTTP_HEADER"/>
    <name>HTTP response splitting vulnerability</name>
    <shortMessage>This code takes an HTTP parameter and writes it directly to the HTTP header output. This could create a security vulnerability.</shortMessage>
    <info>
<![CDATA[<p>This code directly writes an HTTP parameter to an HTTP
header, which allows for a HTTP response splitting vulnerability.</p>

<p>Please see <a
href="http://en.wikipedia.org/wiki/HTTP_response_splitting">
http://en.wikipedia.org/wiki/HTTP_response_splitting</a> for more
information about this issue.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>HRS_REQUEST_PARAMETER_TO_COOKIE</id>
    <artifact tool="FindBugs" mnemonic="HRS_REQUEST_PARAMETER_TO_COOKIE"/>
    <name>HTTP cookie formed from untrusted input</name>
    <shortMessage>This code forms an HTTP cookie formed from untrusted input. This could create a security vulnerability.</shortMessage>
    <info>
<![CDATA[<p>This code constructs an HTTP cookie using an untrusted
HTTP parameter. If this cookie is added to an HTTP response, it will
allow a HTTP response splitting vulnerability.</p>

<p>Please see <a
href="http://en.wikipedia.org/wiki/HTTP_response_splitting">
http://en.wikipedia.org/wiki/HTTP_response_splitting</a> for more
information about this issue.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>CN_IMPLEMENTS_CLONE_BUT_NOT_CLONEABLE</id>
    <artifact tool="FindBugs" mnemonic="CN_IMPLEMENTS_CLONE_BUT_NOT_CLONEABLE"/>
    <name>Class defines clone but does not implement Cloneable</name>
    <shortMessage>This class defines clone() but doesn't implement Cloneable. Is this intended?</shortMessage>
    <info>
<![CDATA[<p>This class defines a <code>clone()</code> method but does
not implement <code>Cloneable</code>. There are some situations in
which this is OK (e.g., you want to control how subclasses can clone
themselves), but just make sure that this is what you intended.</p>]]>
    </info>
  </findingType>	
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DMI_CONSTANT_DB_PASSWORD</id>
    <artifact tool="FindBugs" mnemonic="DMI_CONSTANT_DB_PASSWORD"/>
    <name>Hardcoded database password</name>
    <shortMessage>This code uses a hardcoded constant password to connect to a database. Is this database secured?</shortMessage>
    <info>
<![CDATA[<p>This code creates a database connection using a hardcoded,
constant password. Anyone with access to either the source code or the
compiled code can easily learn the password. Check this code carefully
as it may indicate a security problem with this code and its runtime
environment.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DMI_EMPTY_DB_PASSWORD</id>
    <artifact tool="FindBugs" mnemonic="DMI_EMPTY_DB_PASSWORD"/>
    <name>Empty database password</name>
    <shortMessage>This code uses an empty password to connect to a database. Is this database secured?</shortMessage>
    <info>
<![CDATA[<p>This code creates a database connection using a blank or
empty password. This may indicate that the database is not protected
by a password. Check this code carefully as it may indicate a security
problem with this code and its runtime environment.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DL_SYNCHRONIZATION_ON_BOOLEAN</id>
    <artifact tool="FindBugs" mnemonic="DL_SYNCHRONIZATION_ON_BOOLEAN"/>
    <name>Synchronization on Boolean could deadlock</name>
    <shortMessage>Synchronization on a Boolean value could lead to deadlock.</shortMessage>
    <info>
<![CDATA[<p>This code code synchronizes on a boxed primitive constant,
such as an Boolean.</p>

<pre>
private static Boolean inited = Boolean.FALSE;
...
public void m() {
  ...
  synchronized(inited) { // Bad!
    if (!inited) {
      init();
      inited = BOOLEAN.TRUE;
    }
  }
}
</pre>

<p>Since there normally exist only two <code>Boolean</code> objects,
this code could be synchronizing on the same object as other,
unrelated code, leading to unresponsiveness and possible deadlock.</p>

<p>For the example code above it is highly recommended that an
<code>AtomicBoolean</code> from the
<code>java.util.concurrent.atomic</code> package be used. For
example,<p>

<pre>
import java.util.concurrent.atomic.AtomicBoolean;

private final AtomicBoolean inited = new AtomicBoolean(false);
...
public void m() {
  ...		
  if (inited.compareAndSet(false, true)) {
    init();
  }
}
</pre>]]>
    </info>
  </findingType>	
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DL_SYNCHRONIZATION_ON_BOXED_PRIMITIVE</id>
    <artifact tool="FindBugs" mnemonic="DL_SYNCHRONIZATION_ON_BOXED_PRIMITIVE"/>
    <name>Synchronization on boxed primitive value could lead to deadlock</name>
    <shortMessage>This code synchronizes on boxed primitive value. This could lead to deadlock. Consider using a util concurrent atomic type instead.</shortMessage>
    <info>
<![CDATA[<p>The code synchronizes on a boxed primitive constant, such
as an Integer.

<pre>
private static Integer count = 0;
...
void m() {
  synchronized(count) { 
    count++;
  }
  ...
}
</pre>

<p>Since Integer objects can be cached and shared, this code could be
synchronizing on the same object as other, unrelated code, leading to
unresponsiveness and possible deadlock.</p>

<p>Consider using one of the atomic types provided by the package
<code>java.util.concurrent.atomic</code>. For example, using
<code>AtomicInteger</code> the above code would become</p>

<pre>
private final AtomicInteger count = new AtomicInteger(0);
...
void m() {
  final int incrementedCount = count.incrementAndGet();
  ...
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DL_SYNCHRONIZATION_ON_UNSHARED_BOXED_PRIMITIVE</id>
    <artifact tool="FindBugs" mnemonic="DL_SYNCHRONIZATION_ON_UNSHARED_BOXED_PRIMITIVE">
    </artifact>
    <name>Avoid synchronization on boxed primitive values</name>
    <shortMessage>This code synchronizes on boxed primitive values. It is recommended that this type of code be avoided.</shortMessage>
    <info>
<![CDATA[<p>The code synchronizes on an apparently unshared boxed
primitive, such as an Integer.</p>

<pre>
private static final Integer fileLock = new Integer(1);
...
void m() {
  synchronized(fileLock) { 
    // do something
  }
  ...
}
</pre>

<p>It would be much better, in this code, to redeclare
<code>fileLock</code> as</p>

<pre>
private static final Object fileLock = new Object();
</pre>

<p>The existing code might be OK, but it is confusing and a future
refactoring, such as the "Remove Boxing" refactoring in IntelliJ,
might replace this with the use of an intern'd Integer object shared
throughout the JVM, leading to very confusing behavior and the
potential for deadlock.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>WL_USING_GETCLASS_RATHER_THAN_CLASS_LITERAL</id>
    <artifact tool="FindBugs" mnemonic="WL_USING_GETCLASS_RATHER_THAN_CLASS_LITERAL"/>
    <name>Synchronization on getClass() rather than a class literal</name>
    <shortMessage>This code uses synchronization on getClass (the dynamic class) rather than a class literal. This can create a data race if the class is subclassed.</shortMessage>
    <info>
<![CDATA[<p>This instance method synchronizes on
<code>this.getClass()</code>.  If this class is subclassed, subclasses
will synchronize on the class object for the subclass, which isn't
likely what was intended.  For example, consider this code from
<code>java.awt.Label</code>:</p>

<pre>
private static final String base = "label";
private static int nameCounter = 0;

String constructComponentName() {
  synchronized (getClass()) {
    return base + nameCounter++;
  }
}
</pre>

<p>Subclasses of <code>Label</code> won't synchronize on the same
subclass, giving rise to a data race.  Instead, this code should be
synchronizing on <code>Label.class</code></p>

<pre>
private static final String base = "label";
private static int nameCounter = 0;

String constructComponentName() {
  synchronized (Label.class) {
    return base + nameCounter++;
  }
}
</pre>

<p>In general, it is almost always a bad idea to synchronize on the
dynamic class of an object.</p>]]>
    </info>
  </findingType>	
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ML_SYNC_ON_FIELD_TO_GUARD_CHANGING_THAT_FIELD</id>
    <artifact tool="FindBugs" mnemonic="ML_SYNC_ON_FIELD_TO_GUARD_CHANGING_THAT_FIELD"/>
    <name>Synchronization on field in futile attempt to guard that field</name>
    <shortMessage>Synchronization on a mutable field in a futile attempt to guard that field. This code is likely not thread safe.</shortMessage>
    <info>
<![CDATA[<p>This method synchronizes on a mutable field in what
appears to be a misguided attempt to guard against simultaneous
updates to that field. But guarding a field gets a lock on the
referenced object, not on the field. This may not provide the mutual
exclusion you need, and other threads might be obtaining locks on the
referenced objects (for other purposes). An example of this pattern
would be:

<pre>
private Long myNtfSeqNbrCounter = new Long(0);
private Long getNotificationSequenceNumber() {
  Long result = null;
  synchronized(myNtfSeqNbrCounter) {
    result = new Long(myNtfSeqNbrCounter.longValue() + 1);
    myNtfSeqNbrCounter = new Long(result.longValue());
  }
  return result;
}
</pre>

<p>One approach to fixing this problem is to create an immutable object to lock on. For example</p>

<pre>
private Long myNtfSeqNbrCounter = new Long(0);
private final Object myNtfSeqNbrCounterLock = new Object();

private Long getNotificationSequenceNumber() {
  Long result = null;
  synchronized(myNtfSeqNbrCounterLock) {
    result = new Long(myNtfSeqNbrCounter.longValue() + 1);
    myNtfSeqNbrCounter = new Long(result.longValue());
  }
  return result;
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DLS_DEAD_LOCAL_STORE_IN_RETURN</id>
    <artifact tool="FindBugs" mnemonic="DLS_DEAD_LOCAL_STORE_IN_RETURN"/>
    <name>Useless assignment in return statement</name>
    <shortMessage>This code contains a useless assignment in a return statement. Is this a mistake?</shortMessage>
    <info>
<![CDATA[<p>This statement assigns to a local variable in a
<code>return</code> statement.  This assignment has no lasting effect.
Please verify that this statement does the right thing as this could
signpost a bug.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>XSS_REQUEST_PARAMETER_TO_SEND_ERROR</id>
    <artifact tool="FindBugs" mnemonic="XSS_REQUEST_PARAMETER_TO_SEND_ERROR"/>
    <name>Servlet reflected cross-site scripting vulnerability</name>
    <shortMessage>This Servlet seems to have a cross-site scripting vulnerability. This should be examined carefully and eliminated.</shortMessage>
    <info>
<![CDATA[<p>This code directly writes an HTTP parameter to a server
error page using <code>HttpServletResponse.sendError</code>. Echoing this
untrusted input allows for a reflected cross-site scripting
vulnerability.</p>

<p>For more information please see <a
href="http://en.wikipedia.org/wiki/Cross-site_scripting">
http://en.wikipedia.org/wiki/Cross-site_scripting</a>.</p>

<p>This analysis looks only for the most blatant, obvious
cases of cross-site scripting.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SKIPPED_CLASS_TOO_BIG</id>
    <artifact tool="FindBugs" mnemonic="SKIPPED_CLASS_TOO_BIG"/>
    <name>Class too big for analysis</name>
    <shortMessage>This class is too big for analysis. It could not be checked by FindBugs.</shortMessage>
    <info>
<![CDATA[<p>This class is bigger than can be effectively handled, and
was not fully analyzed for errors by FindBugs.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EQ_COMPARING_CLASS_NAMES</id>
    <artifact tool="FindBugs" mnemonic="EQ_COMPARING_CLASS_NAMES"/>
    <name>Equals() compares class names</name>
    <shortMessage>This equals compares class names rather than class objects. Just compare the class objects.</shortMessage>
    <info>
<![CDATA[<p> This <code>equals</code> method checks to see if two
objects are the same class by checking to see if the names of their
classes are equal. You can have different classes with the same name
if they are loaded by different class loaders. Just check to see if
the class objects are the same.  For example</p>

<pre>
this.getClass() == o.getClass()
</pre>

<p>For more information see Bloch's <i>Effective Java</i> (second
edition) items 8 and 9.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EQ_UNUSUAL</id>
    <artifact tool="FindBugs" mnemonic="EQ_UNUSUAL"/>
    <name>Unusual equals() method</name>
    <shortMessage>This is an unusual equals() method. It might be OK but is worth checking.</shortMessage>
    <info>
<![CDATA[<p>This class doesn't do any of the patterns we recognize
for checking that the type of the argument is compatible with the type
of the <code>this</code> object. There might not be anything wrong
with this code, but it is worth reviewing. </p>

<p>For more information see Bloch's <i>Effective Java</i> (second
edition) items 8 and 9.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EQ_GETCLASS_AND_CLASS_CONSTANT</id>
    <artifact tool="FindBugs" mnemonic="EQ_GETCLASS_AND_CLASS_CONSTANT"/>
    <name>Equals() fails for subtypes</name>
    <shortMessage>This equals method will fail for subtypes. Consider making it more robust.</shortMessage>
    <info>
<![CDATA[<p>This class has an <code>equals</code> method that will be
broken if it is inherited by subclasses.  It compares a class literal
with the class of the argument, e.g., in class <code>Foo</code> it
might check if <code>Foo.class == o.getClass()</code>.  It is better
to check if <code>this.getClass() == o.getClass()</code>.</p>

<p>For more information see Bloch's <i>Effective Java</i> (second
edition) items 8 and 9.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EQ_ALWAYS_TRUE</id>
    <artifact tool="FindBugs" mnemonic="EQ_ALWAYS_TRUE"/>
    <name>Equals() always returns true</name>
    <shortMessage>This equals method always returns true. This violates the symmetric property of the equals method.</shortMessage>
    <info>
<![CDATA[<p>This class defines an equals method that always returns
true. This is imaginative, but not very smart. Plus, it means that the
equals method is not symmetric.  It is not at all clear what
semantics are intended here and this class will likely cause problems
if placed inside of a collection.</p>

<p>For more information see Bloch's <i>Effective Java</i> (second
edition) items 8 and 9.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EQ_ALWAYS_FALSE</id>
    <artifact tool="FindBugs" mnemonic="EQ_ALWAYS_FALSE"/>
    <name>Equals() always returns false</name>
    <shortMessage>This equals method always returns false. This violates the reflexive requirement of the equals method.</shortMessage>
    <info>
<![CDATA[<p>This class defines an <code>equals</code> method that
always returns false. This means that an object is not equal to
itself, and it is impossible to create useful <code>Map</code>s or
<code>Set</code>s of this class.</p>

<p>More fundamentally, it means that <code>equals</code> is not
reflexive, one of the requirements of the <code>equals</code>
method.</p>

<p>The likely intended semantics are object identity&mdash;that an
object is equal to itself.  This is the behavior inherited from
<code>java.lang.Object</code>. If you need to override an equals
inherited from a different superclass, you can use:</p>

<pre>
@Override public boolean equals(Object o) {
  return this == o;
}
</pre>

<p>For more information see Bloch's <i>Effective Java</i> (second
edition) items 8 and 9.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>MSF_MUTABLE_SERVLET_FIELD</id>
    <artifact tool="FindBugs" mnemonic="MSF_MUTABLE_SERVLET_FIELD"/>
    <name>Avoid mutable servlet fields</name>
    <shortMessage>This code contains a mutable servlet field that could cause race conditions. Remove this field or make it immutable.</shortMessage>
    <info>
<![CDATA[<p>A web server generally only creates one instance of a
servlet or JSP class (i.e., it treats the class as a singleton), and
will have multiple threads invoke methods on that instance to service
multiple simultaneous requests.  Thus, having a mutable instance field
generally creates race conditions. It is recommended that this field
be removed or made immutable.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SE_READ_RESOLVE_IS_STATIC</id>
    <artifact tool="FindBugs" mnemonic="SE_READ_RESOLVE_IS_STATIC"/>
    <name>Ignored static readResolve() method</name>
    <shortMessage>The readResolve() method must not be declared to be static. It will be ignored by the serialization mechanism.</shortMessage>
    <info>
<![CDATA[<p>In order for the <code>readResolve</code> method to be
recognized by the serialization mechanism, it must not be declared as
a <code>static</code> method.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SE_PRIVATE_READ_RESOLVE_NOT_INHERITED</id>
    <artifact tool="FindBugs" mnemonic="SE_PRIVATE_READ_RESOLVE_NOT_INHERITED"/>
    <name>Private readResolve() is not inherited</name>
    <shortMessage>private readResolve() is not inherited by subclasses.</shortMessage>
    <info>
<![CDATA[<p>This class defines a private <code>readResolve</code>
method. Since it is private, it won't be inherited by subclasses.</p>

<p>This might be intentional and OK, but should be reviewed to ensure
it is what is intended.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>RpC_REPEATED_CONDITIONAL_TEST</id>
    <artifact tool="FindBugs" mnemonic="RpC_REPEATED_CONDITIONAL_TEST"/>
    <name>Suspicious repeated conditional test</name>
    <shortMessage>This repeated conditional test is suspicious and may indicate a typo in the code.</shortMessage>
    <info>
<![CDATA[<p>The code contains a conditional test is performed twice,
one right after the other.  For example</p>

<pre>
x == 0 || x == 0
</pre>

<p>Perhaps this is a typo and the the second occurrence is intended to
be something else, such as</p>

<pre>
x == 0 || y == 0
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DMI_FUTILE_ATTEMPT_TO_CHANGE_MAXPOOL_SIZE_OF_SCHEDULED_THREAD_POOL_EXECUTOR</id>
    <artifact tool="FindBugs" mnemonic="DMI_FUTILE_ATTEMPT_TO_CHANGE_MAXPOOL_SIZE_OF_SCHEDULED_THREAD_POOL_EXECUTOR"/>
    <name>Futile attempt to change max pool size of ScheduledThreadPoolExecutor</name>
    <shortMessage>This code seems to make a futile attempt to change the max pool size of a ScheduledThreadPoolExecutor. This is probably a mistake.</shortMessage>
    <info>
<![CDATA[<p>While <code>ScheduledThreadPoolExecutor</code> inherits
from <code>ThreadPoolExecutor</code>, a few of the inherited tuning
methods are not useful for it. In particular, because it acts as a
fixed-sized pool using <code>corePoolSize</code> threads and an
unbounded queue, adjustments to <code>maximumPoolSize</code> have no
useful effect.</p>

<p>This code appears to be trying to use these useless inherited
methods.</p>

<p>For more information, please see the corresponding <a
href="http://java.sun.com/javase/6/docs/api/java/util/concurrent/ScheduledThreadPoolExecutor.html">Javadoc</a>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DMI_SCHEDULED_THREAD_POOL_EXECUTOR_WITH_ZERO_CORE_THREADS</id>
    <artifact tool="FindBugs" mnemonic="DMI_SCHEDULED_THREAD_POOL_EXECUTOR_WITH_ZERO_CORE_THREADS"/>
    <name>Avoid creation of ScheduledThreadPoolExecutor with zero core threads</name>
    <shortMessage>Creation of a ScheduledThreadPoolExecutor with zero core threads. This is probably a mistake.</shortMessage>
    <info>
<![CDATA[<p>A <code>ScheduledThreadPoolExecutor</code> with zero core
threads will never execute anything; changes to the max pool size are
ignored. Check this code carefully and fix this problem.</p>

<p>For more information, please see the corresponding <a
href="http://java.sun.com/javase/6/docs/api/java/util/concurrent/ScheduledThreadPoolExecutor.html#ScheduledThreadPoolExecutor(int)">Javadoc</a>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DMI_UNSUPPORTED_METHOD</id>
    <artifact tool="FindBugs" mnemonic="DMI_UNSUPPORTED_METHOD"/>
    <name>Call to an unsupported method</name>
    <shortMessage>Call to an unsupported method</shortMessage>
    <info>
<![CDATA[<p>All targets of this method invocation throw an
<code>UnsupportedOperationException</code>. Examine this code
carefully and consider if it is correct.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS</id>
    <artifact tool="FindBugs" mnemonic="EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS"/>
    <name>Avoid equals() check for incompatible operand</name>
    <shortMessage>This equals implementation checks to see if the operand is some particular incompatible type. This is not recommended and may create unexpected behaviors.</shortMessage>
    <info>
<![CDATA[<p>This equals method is checking to see if the argument is
some incompatible type (i.e., a class that is neither a supertype nor
subtype of the class that defines the equals method). For example, the
<code>Foo</code> class might have an equals method that looks like:

<pre>
@Override public boolean equals(Object o) {
  if (o instanceof Foo)
    return name.equals(((Foo)o).name);
  else if (o instanceof String)
    return name.equals(o);
  else return false;
</pre>

<p>This is considered bad practice, as it makes it very hard to
implement an equals method that is symmetric and transitive. Without
those properties, very unexpected behaviors are possible.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NP_PARAMETER_MUST_BE_NONNULL_BUT_MARKED_AS_NULLABLE</id>
    <artifact tool="FindBugs" mnemonic="NP_PARAMETER_MUST_BE_NONNULL_BUT_MARKED_AS_NULLABLE"/>
    <name>Parameter must be nonnull but is marked as nullable</name>
    <shortMessage>This parameter must be nonnull but is marked as nullable. Either the use or the annotation is wrong.</shortMessage>
    <info>
<![CDATA[<p>This parameter is always used in a way that requires it to
be nonnull, but the parameter is explicitly annotated as being
@Nullable. Either the use of the parameter or the annotation is
wrong.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>VA_FORMAT_STRING_BAD_CONVERSION</id>
    <artifact tool="FindBugs" mnemonic="VA_FORMAT_STRING_BAD_CONVERSION"/>
    <name>The type of a supplied argument doesn't match format specifier</name>
    <shortMessage>The type of a supplied argument doesn't match format specifier. This code will always throw an exception at runtime.</shortMessage>
    <info>
<![CDATA[<p>One of the arguments is incompatible with the
corresponding format string specifier. As a result, this will generate
a runtime exception when executed. For example,</p>

<pre>
String.format("%d", "1")
</pre>

<p>will throw an exception, since the string <code>"1"</code> is
incompatible with the format specifier <code>%d</code>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>VA_FORMAT_STRING_BAD_CONVERSION_TO_BOOLEAN</id>
    <artifact tool="FindBugs" mnemonic="VA_FORMAT_STRING_BAD_CONVERSION_TO_BOOLEAN"/>
    <name>Non-Boolean argument formatted using %b format specifier</name>
    <shortMessage>A non-Boolean argument is being formatted using %b format specifier. This is probably a typo or a bug.</shortMessage>
    <info>
<![CDATA[<p>An argument not of type <code>Boolean</code> is being
formatted with a <code>%b</code> format specifier. This won't throw an
exception; instead, it will print <code>true</code> for any nonnull
value, and <code>false</code> for null.  This feature of format
strings is strange, and may not be what you intended.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>VA_FORMAT_STRING_BAD_CONVERSION_FROM_ARRAY</id>
    <artifact tool="FindBugs" mnemonic="VA_FORMAT_STRING_BAD_CONVERSION_FROM_ARRAY"/>
    <name>Array formatted in useless way using format string</name>
    <shortMessage>Array formatted in useless way using format string</shortMessage>
    <info>
<![CDATA[<p>One of the arguments being formatted with a format string
is an array. This will be formatted using a fairly useless format,
such as <code>[I@304282</code>, which doesn't actually show the contents of the
array. This behavior is probably not desired.</p>

<p>Consider wrapping the array using <code>Arrays.asList(...)</code>
before handling it off to be formatted or using
<code>Arrays.toString(...)</code>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>VA_FORMAT_STRING_NO_PREVIOUS_ARGUMENT</id>
    <artifact tool="FindBugs" mnemonic="VA_FORMAT_STRING_NO_PREVIOUS_ARGUMENT"/>
    <name>No previous argument for format string</name>
    <shortMessage>No previous argument for format string. This code will always throw an exception at runtime.</shortMessage>
    <info>
<![CDATA[<p>The format string specifies a relative index to request
that the argument for the previous format specifier be
reused. However, there is no previous argument.  For example,</p>

<pre>
formatter.format("%&lt;s %s", "a", "b")
</pre>

<p>would throw a MissingFormatArgumentException when executed.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>VA_FORMAT_STRING_BAD_ARGUMENT</id>
    <artifact tool="FindBugs" mnemonic="VA_FORMAT_STRING_BAD_ARGUMENT"/>
    <name>Format string placeholder incompatible with passed argument</name>
    <shortMessage>This format string placeholder is incompatible with its passed argument. This code will always throw an exception at runtime.</shortMessage>
    <info>
<![CDATA[<p>The format string placeholder is incompatible with the
corresponding argument. For example,

<pre>
System.out.println("%d\n", "hello");
</pre>

<p>The <code>%d</code> placeholder requires a numeric argument, but a
string value is passed instead.  A runtime exception will occur when
this statement is executed.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>VA_FORMAT_STRING_MISSING_ARGUMENT</id>
    <artifact tool="FindBugs" mnemonic="VA_FORMAT_STRING_MISSING_ARGUMENT"/>
    <name>Too few arguments are passed for this format string</name>
    <shortMessage>This code contains a format string that is passed too few arguments. This code will always throw an exception at runtime.</shortMessage>
    <info>
<![CDATA[<p>Not enough arguments are passed to satisfy a placeholder
in the format string.  A runtime exception will occur when this
statement is executed.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>VA_FORMAT_STRING_ILLEGAL</id>
    <artifact tool="FindBugs" mnemonic="VA_FORMAT_STRING_ILLEGAL"/>
    <name>Illegal format string</name>
    <shortMessage>This code contains an illegal format string. This code will always throw an exception at runtime.</shortMessage>
    <info>
<![CDATA[<p>The format string used in this code is syntactically
invalid, and a runtime exception will occur when this statement is
executed. Examine and fix this code.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>VA_FORMAT_STRING_EXTRA_ARGUMENTS_PASSED</id>
    <artifact tool="FindBugs" mnemonic="VA_FORMAT_STRING_EXTRA_ARGUMENTS_PASSED"/>
    <name>More arguments are passed than are actually used in the format string</name>
    <shortMessage>This code passes more arguments than are actually used in the format string. This is probably a typo or a bug.</shortMessage>
    <info>
<![CDATA[<p>A format-string method with a variable number of
arguments is called, but more arguments are passed than are actually
used by the format string.  This won't cause a runtime exception, but
the code may be silently omitting information that was intended to be
included in the formatted string.  Check this code carefully.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>BIT_ADD_OF_SIGNED_BYTE</id>
    <artifact tool="FindBugs" mnemonic="BIT_ADD_OF_SIGNED_BYTE"/>
    <name>Bitwise add of signed byte value</name>
    <shortMessage>This code performs a suspicious bitwise add of signed byte value. Sign extension may cause an unexpected result to be computed.</shortMessage>
    <info>
<![CDATA[<p>Adds a byte value and a value which is known to have its 8
lower bits clear. Values loaded from a byte array are sign extended to
32 bits before any any bitwise operations are performed on the value.
Thus, if <code>b[0]</code> contains the value <code>0xff</code>, and
<code>x</code> is initially 0, then the code <code>((x &lt;&lt; 8) +
b[0])</code> will sign extend <code>0xff</code> to get
<code>0xffffffff</code>, and thus give the value
<code>0xffffffff</code> as the result.</p>

<p>In particular, the following code for packing a <code>byte</code>
array into an <code>int</code> is badly wrong:</p>

<pre>
int result = 0;
for(int i = 0; i &lt; 4; i++) {
  result = ((result &lt;&lt; 8) + b[i]);
}
</pre>

<p>However, the following idiom will work instead:</p>

<pre>
int result = 0;
for(int i = 0; i &lt; 4; i++) {
  result = ((result &lt;&lt; 8) + (b[i] &amp; 0xff));
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DMI_INVOKING_HASHCODE_ON_ARRAY</id>
    <artifact tool="FindBugs" mnemonic="DMI_INVOKING_HASHCODE_ON_ARRAY"/>
    <name>Suspicious use hashCode() method on an array</name>
    <shortMessage>This code calls a.hashCode() on an array. Did you mean to call Arrays.hashCode(a)?</shortMessage>
    <info>
<![CDATA[<p>This code invokes <code>hashCode()</code> on an array
type. Calling <code>hashCode()</code> on an array returns the same
value as <code>System.identityHashCode</code>, and ignores the
contents and length of the array. Therefore, this code is highly
suspect and may not do what the programmer intended it to.</p>

<p>If you need a hashcode that depends on the contents of an array
<code>a</code>, use <code>java.util.Arrays.hashCode(a)</code>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DMI_USING_REMOVEALL_TO_CLEAR_COLLECTION</id>
    <artifact tool="FindBugs" mnemonic="DMI_USING_REMOVEALL_TO_CLEAR_COLLECTION"/>
    <name>Avoid c.removeAll(c) to clear a collection</name>
    <shortMessage>Don't use c.removeAll(c) to clear a collection. Use c.clear() instead.</shortMessage>
    <info>
<![CDATA[<p>If you want to remove all elements from a collection
<code>c</code>, use <code>c.clear()</code> rather than
<code>c.removeAll(c)</code>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DMI_VACUOUS_SELF_COLLECTION_CALL</id>
    <artifact tool="FindBugs" mnemonic="DMI_VACUOUS_SELF_COLLECTION_CALL"/>
    <name>Vacuous call to a collection</name>
    <shortMessage>This code appears to be nonsensical. Consider removing it. It may indicate a type or a bug.</shortMessage>
    <info>
<![CDATA[<p>This call doesn't make sense. For any
<code>Collection</code> <code>c</code>, calling</p>

<pre>
c.containsAll(c)
</pre>

<p>should always be true, and</p>

<pre>
c.retainAll(c)
</pre>

<p>should have no effect.</p>

<p>This is highly suspicious code that may signpost a bug or a
typo.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DMI_COLLECTIONS_SHOULD_NOT_CONTAIN_THEMSELVES</id>
    <artifact tool="FindBugs" mnemonic="DMI_COLLECTIONS_SHOULD_NOT_CONTAIN_THEMSELVES"/>
    <name>Collections should not contain themselves</name>
    <shortMessage>Collections should not contain themselves</shortMessage>
    <info>
<![CDATA[<p>This call to a generic collection's method would only make
sense if a collection contained itself, e.g., if
<code>s.contains(s)</code> were true. This is unlikely to be true and
would cause problems if it were true (such as the computation of the
hash code of such a collection resulting in infinite recursion).  It
is likely that the wrong value is being passed as a parameter.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>TQ_EXPLICIT_UNKNOWN_SOURCE_VALUE_REACHES_NEVER_SINK</id>
    <artifact tool="FindBugs" mnemonic="TQ_EXPLICIT_UNKNOWN_SOURCE_VALUE_REACHES_NEVER_SINK"/>
    <name>Explicit annotation inconsistent with use</name>
    <shortMessage>Explicit annotation is inconsistent with use.</shortMessage>
    <info>
<![CDATA[<p>A value is used in a way that requires it to be never be a
value denoted by a type qualifier, but there is an explicit annotation
stating that it is not known where the value is prohibited from having
that type qualifier. Either the usage or the annotation is
incorrect.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>TQ_EXPLICIT_UNKNOWN_SOURCE_VALUE_REACHES_ALWAYS_SINK</id>
    <artifact tool="FindBugs" mnemonic="TQ_EXPLICIT_UNKNOWN_SOURCE_VALUE_REACHES_ALWAYS_SINK"/>
    <name>Explicit annotation inconsistent with use</name>
    <shortMessage>Explicit annotation is inconsistent with use.</shortMessage>
    <info>
<![CDATA[<p>A value is used in a way that requires it to be always be
a value denoted by a type qualifier, but there is an explicit
annotation stating that it is not known where the value is required to
have that type qualifier. Either the usage or the annotation is
incorrect.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>OBL_UNSATISFIED_OBLIGATION</id>
    <artifact tool="FindBugs" mnemonic="OBL_UNSATISFIED_OBLIGATION"/>
    <artifact tool="FindBugs" mnemonic="OS_OPEN_STREAM"/>
    <artifact tool="FindBugs" mnemonic="ODR_OPEN_DATABASE_RESOURCE"/>
    <artifact tool="FindBugs" mnemonic="OS_OPEN_STREAM_EXCEPTION_PATH"/>
    <artifact tool="PMD" mnemonic="CloseResource"/>
    <name>Method may fail to clean up stream or resource</name>
    <shortMessage>Method may fail to clean up stream or resource</shortMessage>
    <info>
<![CDATA[<p>This method may fail to clean up (close, dispose of) a
stream, database object, or other resource requiring an explicit
cleanup operation.</p>
	       
<p>In general, if a method opens a stream or other resource, the
method should use a try/finally block to ensure that the stream or
resource is cleaned up before the method returns. For example, the
code below properly closes its reader in a finally block.</p>

<pre>
try {
  final BufferedReader in = new BufferedReader(new FileReader("data.txt"));
  try {
    String str;
    while ((str = in.readLine()) != null) {
      System.out.println(str);
    }
  } finally {
    in.close();
  }
} catch (IOException e) {
  e.printStackTrace();
}
</pre>

<p>See Weimer and Necula, <i>Finding and Preventing Run-Time Error
Handling Mistakes</i>, for a description of the analysis
technique.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EmptyInitializer</id>
    <artifact tool="PMD" mnemonic="EmptyInitializer"/>
    <artifact tool="PMD" mnemonic="EmptyStaticInitializer"/>
    <name>Empty initializer</name>
    <shortMessage>It is questionable coding practice to have an empty initializer.</shortMessage>
    <info>
<![CDATA[<p>It is highly questionable to have an empty
initializer. Consider removing it from your code.</p>

<pre>
public class Foo {
  static {} // Why ?
  {} // Again, why ?
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EmptyCatchBlock</id>
    <artifact tool="PMD" mnemonic="EmptyCatchBlock"/>
    <name>Empty catch block</name>
    <shortMessage>Are you swallowing an exception which should either be acted on or
      reported?</shortMessage>
    <info>
<![CDATA[<p>An exception is caught, but nothing is done. In most
circumstances, this swallows an exception which should either be acted
on or reported.</p>

<pre>
public void doSomething() {
  try {
    FileInputStream fis = new FileInputStream("/tmp/bugger");
  } catch (IOException ioe) {
      // not good
  }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EmptyIfStmt</id>
    <artifact tool="PMD" mnemonic="EmptyIfStmt"/>
    <name>Empty if</name>
    <shortMessage>It is questionable coding practice to have an empty if statement.</shortMessage>
    <info>
<![CDATA[<p>A condition is being checked but nothing is done about it.
Consider removing the check if it doesn't have side-effects.</p>

<p>If the check has side-effects just call the check and ignore the
result.  For example, <code>if (sideEffect()) {}</code> would be
replaced with <code>sideEffect()</code>.</p>

<pre>
public class Foo {
  void bar(int x) {
    if (x == 0) {
      // empty!
    }
  }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EmptyWhileStmt</id>
    <artifact tool="PMD" mnemonic="EmptyWhileStmt"/>
    <name>Empty while</name>
    <shortMessage>It is questionable coding practice to have an empty while statement.</shortMessage>
    <info>
<![CDATA[<p>This <code>while</code> statement appears to do
nothing. If it is a timing loop, then you should use
<code>Thread.sleep()</code> for it; if it's a while loop that does a
lot in the exit expression, then consider rewriting it to make what it
is doing clearer.</p>

<pre>
public class Foo {
  void bar(int a, int b) {
    while (a == b) {
      // empty!
    }
   }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EmptyTryBlock</id>
    <artifact tool="PMD" mnemonic="EmptyTryBlock"/>
    <name>Empty try block</name>
    <shortMessage>It is questionable coding practice to have an empty try block.</shortMessage>
    <info>
<![CDATA[<p>This <code>try</code> block is empty. It should be removed
from the code.</p>

<pre>
public class Foo {
  public void bar() {
    try {
    } catch (Exception e) {
      e.printStackTrace();
    }
  }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EmptyFinallyBlock</id>
    <artifact tool="PMD" mnemonic="EmptyFinallyBlock"/>
    <name>Empty finally block</name>
    <shortMessage>It is questionable coding practice to have an empty finally block.</shortMessage>
    <info>
<![CDATA[<p>This <code>finally</code> block is empty. It should be
removed from the code.</p>

<pre>
public class Foo {
  public void bar() {
    try {
      int x=2;
    } finally {
      // empty!
    }
  }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EmptySwitchStatements</id>
    <artifact tool="PMD" mnemonic="EmptySwitchStatements"/>
    <name>Empty switch</name>
    <shortMessage>It is questionable coding practice to have an empty switch statement.</shortMessage>
    <info>
<![CDATA[<p>This <code>switch</code> statement is empty. Consider
removing it from the code.</p>

<pre>
public class Foo {
  public void bar() {
    int x = 2;
    switch (x) {
      // once there was code here
      // but it's been commented out or something
    }
  }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>JumbledIncrementer</id>
    <artifact tool="PMD" mnemonic="JumbledIncrementer"/>
    <name>Jumbled incrementer</name>
    <shortMessage>Avoid jumbled loop incrementers because it's usually a mistake.</shortMessage>
    <info>
<![CDATA[<p>Avoid jumbled loop incrementers&mdash;it's usually a
mistake, and it's confusing even if it's what's intended.</p>

<pre>
public class JumbledIncrementerRule1 {
  public void foo() {
    for (int i = 0; i < 10; i++) {
      for (int k = 0; k < 20; i++) {
        System.out.println("Hello");
      }
    }
  }
}
</pre>
]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ForLoopShouldBeWhileLoop</id>
    <artifact tool="PMD" mnemonic="ForLoopShouldBeWhileLoop"/>
    <name>For should be a while</name>
    <shortMessage>This for loop can be simplified to a while loop.</shortMessage>
    <info>
<![CDATA[
<p>This loop can be simplified to a <code>while</code> and made more concise.</p>

<pre>
public class Foo {
  void bar() {
    for (;true;) true; // No Init or Update part, may as well be: while (true)
  }
}
</pre>
]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ReturnFromFinallyBlock</id>
    <artifact tool="PMD" mnemonic="ReturnFromFinallyBlock"/>
    <name>Return from within finally block</name>
    <shortMessage>It is questionable coding practice to return from a finally block because this can discard exceptions.</shortMessage>
    <info>
<![CDATA[<p>It is questionable coding practice to return from a
finally block because this can discard exceptions.</p>

<pre>
public class Bar {
  public String foo() {
    try {
      throw new Exception( "My Exception" );
    } catch (Exception e) {
      throw e;
    } finally {
      return "A. O. K."; // Very bad.
    }
  }
}
</pre>

<p>For more information on this issue see puzzle 36 of Bloch and
Gafter's <i>Java Puzzlers</i>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UnnecessaryReturn</id>
    <artifact tool="PMD" mnemonic="UnnecessaryReturn"/>
    <name>Unnecessary return</name>
    <shortMessage>Avoid unnecessary return statements</shortMessage>
    <info>
<![CDATA[<p>It is questionable coding practice to place a return
statement where the method would simply return without it.  This
unnecessary return can be removed from your code.</p>

</pre>
public class Foo {
  public void bar() {
    int x = 42;
    return;
  }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UnconditionalIfStatement</id>
    <artifact tool="PMD" mnemonic="UnconditionalIfStatement"/>
    <name>Unconditional if</name>
    <shortMessage>Avoid if statements that are always true or always false.  Can this be removed?</shortMessage>
    <info>
<![CDATA[<p>It is questionable coding practice to have an
<code>if</code> statement that is always true or always false.  Unless
this is test code (or some other special purpose code) the
<code>if</code> can be removed.  Just remove the <code>if</code> and
keep the block if the statement was always true.  Delete both the
conditional and the block if the statement was always false.</p>

<pre>
public class Foo {
  public void close() {
    if (true) {
      // ...
    }
  }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EmptyStatementNotInLoop</id>
    <artifact tool="PMD" mnemonic="EmptyStatementNotInLoop"/>
    <name>Empty statement not in loop</name>
    <shortMessage>It is questionable coding practice to include an empty statement, i.e., a semicolon by itself.  Consider removing this empty statement.</shortMessage>
    <info>
<![CDATA[<p>It is questionable coding practice to include an empty
statement, i.e., a semicolon by itself, that is not used as the sole
body of a for loop or while loop. This could also be a double
semicolon, which is useless and should be removed.</p>

<pre>
public class MyClass {
  public void doit() {
    // this is probably not what you meant to do
    ;
    // the extra semicolon here this is not necessary
    System.out.println("look at the extra semicolon");;
  }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UnnecessaryFinalModifier</id>
    <artifact tool="PMD" mnemonic="UnnecessaryFinalModifier"/>
    <name>Unnecessary final modifier</name>
    <shortMessage>This class has the final modifier, therefore all of its methods are automatically final.</shortMessage>
    <info>
<![CDATA[<p>This class has the final modifier, therefore all of its
methods are automatically final.  Any final declarations on methods
may be removed.</p>

<pre>
public final class Foo {
   // This final modifier is not necessary, since the class is final
   // and thus, all methods are final
   private final void foo() {
   }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>CollapsibleIfStatements</id>
    <artifact tool="PMD" mnemonic="CollapsibleIfStatements"/>
    <name>Collapsible if</name>
    <shortMessage>Sometimes two if statements can be consolidated by separating their conditions with a boolean short-circuit operator.</shortMessage>
    <info>
<![CDATA[<p>Sometimes two if statements can be consolidated by
separating their conditions with a boolean short-circuit
operator. For example, the below code</p>

<pre>
if (x) {
  if (y) {
    // do stuff
  }
}
</pre>

<p>can be changed to</p>

<pre>
if (x && y) {
  // do stuff
}
</pre>

<p>When making this change ensure that the expression <code>y</code>
has no side-effects.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UselessOverridingMethod</id>
    <artifact tool="PMD" mnemonic="UselessOverridingMethod"/>
    <artifact tool="FindBugs" mnemonic="USM_USELESS_SUBCLASS_METHOD"/>
    <name>Useless overriding method</name>
    <shortMessage>This overriding method merely calls the same method defined in a superclass. It should simply inherit the method.</shortMessage>
    <info>
<![CDATA[<p>This overriding method merely calls the same method
defined in a superclass.</p>

<pre>
@Override public String foo() {
  return super.foo();  // Why bother overriding?
}
</pre>

<p>It is strongly recommended that you remove this method and simply
inherit the method from the superclass. This problem may indicate a
lack of understanding about how inheritance works in the Java
programming language.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidDecimalLiteralsInBigDecimalConstructor</id>
    <artifact tool="PMD" mnemonic="AvoidDecimalLiteralsInBigDecimalConstructor"/>
    <name>Avoid decimal literals in BigDecimal construction</name>
    <shortMessage>Use of float or double literals when construction BigDecimal instances can result in imprecision.  Use the String argument constructor instead..</shortMessage>
    <info>
<![CDATA[<p>One might assume that <code>new BigDecimal(.1)</code> is
exactly equal to .1, but it is actually equal to
.1000000000000000055511151231257827021181583404541015625.  This is the
case because .1 cannot be represented exactly as a double (or, for
that matter, as a binary fraction of any finite length). Thus, the
long value that is being passed in to the constructor is not exactly
equal to .1, appearances notwithstanding.</p>

<p>The String argument constructor, on the other hand, is perfectly
predictable: <code>new BigDecimal(".1")</code> is exactly equal to .1,
as one would expect. Therefore, it is generally recommended that the
String argument constructor be used in preference to this one.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UselessOperationOnImmutable</id>
    <artifact tool="PMD" mnemonic="UselessOperationOnImmutable"/>
    <name>Ignored operation on an immutable object</name>
    <shortMessage>An operation on an Immutable object (e.g., a BigDecimal or a BigInteger) won't change the object itself. Thus, ignoring the result is probably an error.</shortMessage>
    <info>
<![CDATA[<p>An operation on an immutable object (e.g., a
<code>BigDecimal</code> or a <code>BigInteger</code>) won't change the
object itself. The result of the operation is a new object. Therefore,
ignoring the operation result is probably a mistake.</p>

<pre>
import java.math.*;
class Test {
  void method1() {
    BigDecimal bd=new BigDecimal(10);
    bd.add(new BigDecimal(5));      // this will trigger the rule
  }
  void method2() {
    BigDecimal bd=new BigDecimal(10);
    bd = bd.add(new BigDecimal(5)); // this won't trigger the rule
  }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UnusedNullCheckInEquals</id>
    <artifact tool="PMD" mnemonic="UnusedNullCheckInEquals"/>
    <name>Unused null check before equals()</name>
    <shortMessage>After checking an object reference for null, you should invoke equals() on that object rather than passing it to another object's equals() method.</shortMessage>
    <info>
<![CDATA[<p>After checking an object reference for <code>null</code>,
you should invoke <code>equals()</code> on that object rather than
passing it to another object's <code>equals()</code> method.</p>

<pre>
public class Example {

  public String method1() { return "ok";}
  public String method2() { return null;}

  public void method(String a) {
    String b;
    /*
     * I don't know if method1() can be "null" but I know "a" is not null...
     * I'd better write a.equals(method1())
     */
    if (a != null && method1().equals(a)) { // will trigger the rule
      // do something
    }

    if (method1().equals(a) && a != null) { // won't trigger the rule
      // do something
    }

    if (a != null && method1().equals(b)) { // won't trigger the rule
      // do something
    }

    if (a != null && "LITERAL".equals(a)) { // won't trigger the rule
      // do something
    }

    if (a != null && !a.equals("go")) {     // won't trigger the rule
      a = method2();
      if (method1().equals(a)) {
        //do something
      }
    }
  }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidThreadGroup</id>
    <artifact tool="PMD" mnemonic="AvoidThreadGroup"/>
    <name>Avoid ThreadGroup</name>
    <shortMessage>It is best to avoid the use of ThreadGroup. Consider updating this code to use a util concurrent Executor.</shortMessage>
    <info>
<![CDATA[<p>It is best to avoid the use of ThreadGroup.  Although it
is intended to be used in a threaded environment it contains methods
that are not thread-safe.</p>

<pre>
public class Bar {
  void buz() {
    ThreadGroup tg = new ThreadGroup("My threadgroup");
    tg = new ThreadGroup(tg, "my thread group");
    tg = Thread.currentThread().getThreadGroup();
    tg = System.getSecurityManager().getThreadGroup();
  }
}
</pre>

<p>A better framework is provided by the util concurrent library found
in the <code>java.util.concurrent</code> package.  This library was
added to JDK 1.5.  In particular, the <code>Exceutor</code> framework
is worth considering.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>BrokenNullCheck</id>
    <artifact tool="PMD" mnemonic="BrokenNullCheck"></artifact>
    <name>Broken null check expression</name>
    <shortMessage>This null check appears to be broken since it can throw a NullPointerException. It is likely that you used || instead of &amp;&amp; or vice versa.</shortMessage>
    <info>
<![CDATA[<p>This null check appears to be broken since it can throw a
<code>NullPointerException</code>. It is likely that you used
<code>||</code> instead of <code>&amp;&amp;</code> or vice versa.</p>

<pre>
class Foo {
  String bar(String string) {
    // should be &&
    if (string != null || !string.equals(""))
      return string;
    // should be ||
    if (string == null && string.equals(""))
      return string;
  }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>BigIntegerInstantiation</id>
    <artifact tool="PMD" mnemonic="BigIntegerInstantiation"/>
    <name>Use BigInteger and BigDecimal constants</name>
    <shortMessage>This code creates an instance of BigInteger or BigDecimal for which a constant exists.  It is recommended that you use the constant instead of creating another object.</shortMessage>
    <info>
<![CDATA[<p>There is no need to create instances of already existing
<code>BigInteger</code> or <code>BigDecimal</code> objects.</p>

<pre>
// Don't do this -- use the defined constants
BigInteger bi = new BigInteger(1);
BigInteger bi2 = new BigInteger("0");
BigInteger bi3 = new BigInteger(0.0);
BigInteger bi4;
bi4 = new BigInteger(0);
bi4 = BigInteger.ZERO; // OK
</pre>

<p>Just use the predefined constants, such as
<code>BigInteger.ZERO</code>, <code>BigInteger.ONE</code>, (and for
1.5 on) <code>BigInteger.TEN</code>, <code>BigDecimal.ZERO</code>,
<code>BigDecimal.ONE</code>, and <code>BigDecimal.TEN</code>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidUsingOctalValues</id>
    <artifact tool="PMD" mnemonic="AvoidUsingOctalValues"/>
    <name>Avoid octal literals</name>
    <shortMessage>Integer literals should not start with zero. Zero means that the rest of literal will be interpreted as an octal value which might not be what you want.</shortMessage>
    <info>
<![CDATA[<p>Integer literals should not start with zero. Zero means
that the rest of literal will be interpreted as an octal value which
might not be what you want.</p>

<pre>
int i = 012;   // sets i to 10 not  12
int j = 010;   // sets j to  8 not  10
int k = i * j; // sets k to 80 not 120
</pre>

<p>If you really want the octal literal, it is recommended that it be
commented very clearly to avoid programmer confusion.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>IfStmtsMustUseBraces</id>
    <artifact tool="PMD" mnemonic="IfStmtsMustUseBraces"/>
    <artifact tool="PMD" mnemonic="IfElseStmtsMustUseBraces"/>
    <name>If must use braces</name>
    <shortMessage>Avoid if statements without curly braces.</shortMessage>
    <info>
<![CDATA[<p>This rule flags all if statements that do not use curly
braces because this has been deemed a questionable coding practice. To
fix this change</p>

<pre>
if (expression)
  statement1;
else
  statement2;
</pre>

<p>to</p>

<pre>
if (expression) {
  statement1;
} else {
  statement2;
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>WhileLoopsMustUseBraces</id>
    <artifact tool="PMD" mnemonic="WhileLoopsMustUseBraces"/>
    <name>While must use braces</name>
    <shortMessage>Avoid while loops without curly braces.</shortMessage>
    <info>
<![CDATA[<p>This rule flags all while loops that do not use curly
braces because this has been deemed a questionable coding practice. To
fix this change</p>

<pre>
while (expression)
  statement;
</pre>

<p>to</p>

<pre>
while (expression) {
  statement;
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ForLoopsMustUseBraces</id>
    <artifact tool="PMD" mnemonic="ForLoopsMustUseBraces"/>
    <name>For must use braces</name>
    <shortMessage>Avoid for loops without curly braces.</shortMessage>
    <info>
<![CDATA[<p>This rule flags all for loops that do not use curly braces
because this has been deemed a questionable coding practice. To fix
this change</p>

<pre>
for (e ; e ; e)
  statement;
</pre>

<p>to</p>

<pre>
for (e ; e ; e)
  statement;
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>CloneThrowsCloneNotSupportedException</id>
    <artifact tool="PMD" mnemonic="CloneThrowsCloneNotSupportedException"/>
    <name>Clone() method signature must include throws CloneNotSupportedException</name>
    <shortMessage>This clone method does not declare that it can throw CloneNotSupportedException.  Its signature appears to be wrong.</shortMessage>
    <info>
<![CDATA[<p>The method clone has the wrong signature, it should throw
a <code>CloneNotSupportedException</code>.  So change the code
below</p>

<pre>
public Object clone() { // will cause this finding to appear
  return super.clone();
}
</pre>

<p>to</p>

<pre>
public Object clone() throws CloneNotSupportedException {
  return super.clone();
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NPathComplexity</id>
    <artifact tool="PMD" mnemonic="NPathComplexity"/>
    <name>High NPath complexity</name>
    <shortMessage>This method has a high NPath complexity.  Can you reduce its complexity?</shortMessage>
    <info>
<![CDATA[<p>The NPath complexity of a method is the number of acyclic
execution paths through that method. A threshold of 200 is generally
considered the point where measures should be taken to reduce
complexity.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ExcessiveMethodLength</id>
    <artifact tool="PMD" mnemonic="ExcessiveMethodLength"/>
    <name>Excessive method length</name>
    <shortMessage>This method is very long. Can you make it more concise?</shortMessage>
    <info>
<![CDATA[<p>Violations of this rule usually indicate that the method
is doing too much. This may signpost a poor design. Try to reduce the
method size by creating helper methods and removing any copy/pasted
code.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ExcessiveParameterList</id>
    <artifact tool="PMD" mnemonic="ExcessiveParameterList"/>
    <name>Excessive parameter list</name>
    <shortMessage>This method takes too many parameters.  Can it be redesigned to take less?</shortMessage>
    <info>
<![CDATA[<p>Long parameter lists can indicate that a new object should
be created to wrap the numerous parameters. Basically, try to group
the parameters together.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ExcessiveClassLength</id>
    <artifact tool="PMD" mnemonic="ExcessiveClassLength"/>
    <name>Excessive class length</name>
    <shortMessage>This class is very long. Can you make it more concise?</shortMessage>
    <info>
<![CDATA[<p>Long Class files are indications that the class may be
trying to do too much. Try to break it down, and reduce the size to
something manageable.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>CyclomaticComplexity</id>
    <artifact tool="PMD" mnemonic="CyclomaticComplexity"/>
    <name>High cyclomatic complexity</name>
    <shortMessage>This method has a high cyclomatic complexity.  Can you reduce its complexity?</shortMessage>
    <info>
<![CDATA[<p>Complexity is determined by the number of decision points
in a method plus one for the method entry. The decision points are
<code>if</code>, <code>while</code>, <code>for</code>, and
<code>case</code> labels. Generally, 1-4 is low complexity, 5-7
indicates moderate complexity, 8-10 is high complexity, and 11+ is
very high complexity.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ExcessivePublicCount</id>
    <artifact tool="PMD" mnemonic="ExcessivePublicCount"/>
    <name>Excessive public count</name>
    <shortMessage>This class has too many public methods and attributes.  Can you reduce this number?</shortMessage>
    <info>
<![CDATA[<p>A large number of public methods and attributes declared
in a class can indicate the class may need to be broken up as
increased effort will be required to thoroughly test it.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>TooManyFields</id>
    <artifact tool="PMD" mnemonic="TooManyFields"/>
    <name>Too many fields</name>
    <shortMessage>This class has too many fields.  Can you reduce this number?</shortMessage>
    <info>
<![CDATA[<p>Classes that have too many fields could be redesigned to
have fewer fields, possibly through some nested object grouping of
some of the information. For example, a class with city/state/zip
fields could instead have one Address field.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NcssMethodCount</id>
    <artifact tool="PMD" mnemonic="NcssMethodCount"/>
    <name>NCSS method count</name>
    <shortMessage>This rule uses the NCSS (Non Commenting Source Statements) algorithm to determine the number of lines of code for a given method.</shortMessage>
    <info>
<![CDATA[<p>This rule uses the NCSS (Non Commenting Source Statements)
algorithm to determine the number of lines of code for a given
method. NCSS ignores comments, and counts actual statements. Using
this algorithm, lines of code that are split are counted as
one.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NcssTypeCount</id>
    <artifact tool="PMD" mnemonic="NcssTypeCount"/>
    <name>NCSS type count</name>
    <shortMessage>This rule uses the NCSS (Non Commenting Source Statements) algorithm to determine the number of lines of code for a given type.</shortMessage>
    <info>
<![CDATA[<p>This rule uses the NCSS (Non Commenting Source Statements)
algorithm to determine the number of lines of code for a given
type. NCSS ignores comments, and counts actual statements. Using this
algorithm, lines of code that are split are counted as one.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NcssConstructorCount</id>
    <artifact tool="PMD" mnemonic="NcssConstructorCount"/>
    <name>NCSS constructor count</name>
    <shortMessage>This rule uses the NCSS (Non Commenting Source Statements) algorithm to determine the number of lines of code for a given constructor.</shortMessage>
    <info>
<![CDATA[<p>This rule uses the NCSS (Non Commenting Source
Statements) algorithm to determine the number of lines of code for a
given constructor. NCSS ignores comments, and counts actual
statements. Using this algorithm, lines of code that are split are
counted as one.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UnnecessaryConstructor</id>
    <artifact tool="PMD" mnemonic="UnnecessaryConstructor"/>
    <name>Unnecessary constructor</name>
    <shortMessage>This constructor is not required to be explicitly declared. You may remove it from your code and it will be automatically generated for you.</shortMessage>
    <info>
<![CDATA[<p>This rule detects when a constructor is not necessary;
i.e., when there's only one constructor, it's public, has an empty
body, and takes no arguments.  In this case Java will generate a
default constructor for you.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NullAssignment</id>
    <artifact tool="PMD" mnemonic="NullAssignment"/>
    <name>Null assignment warning</name>
    <shortMessage>Null is being assigned to a variable which could indicate a muddled implementation.</shortMessage>
    <info>
<![CDATA[<p>Assigning a <code>null</code> to a variable (outside of
its declaration) is usually bad form. Some times, the assignment is an
indication that the programmer doesn't completely understand what is
going on in the code.</p>

<p>This sort of assignment may in rare cases be useful to encourage
garbage collection. If that's what it's being using it for, by all
means, disregard this finding.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>OnlyOneReturn</id>
    <artifact tool="PMD" mnemonic="OnlyOneReturn"/>
    <name>Only one return</name>
    <shortMessage>This method has more than one exit point or its one exit point is not the last statement in the method. This has been deemed a questionable coding practice.</shortMessage>
    <info>
<![CDATA[<p>It has been determined that each method should have only
one exit point, and that should be the last statement in the
method.</p>

<pre>
public void foo(int x) {
  if (x > 0) {
    return "hey"; // oops, multiple exit points!
  }
  return "hi";
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UnusedModifier</id>
    <artifact tool="PMD" mnemonic="UnusedModifier"/>
    <name>Superfluous method modifiers in an interface</name>
    <shortMessage>This interface has superfluous modifiers on method declarations that are implied by their context.</shortMessage>
    <info>
<![CDATA[<p>Fields in interfaces are automatically <code>public</code>
<code>static</code> <code>final</code>, and methods are
<code>public</code> <code>abstract</code>. Classes or interfaces
nested in an interface are automatically <code>public</code> and
<code>static</code> (all nested interfaces are automatically
<code>static</code>). For historical reasons, modifiers which are
implied by the context are accepted by the compiler, but are
superfluous.  Below are some examples.</p>

<pre>
public interface Foo {
  public abstract void bar();    // both abstract and public are ignored by the compiler
  public static final int X = 0; // public, static, and final all ignored
  public static class Bar {}     // public, static ignored
  public static interface Baz {} // ditto
}
public class Bar {
  public static interface Baz {} // static ignored
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AssignmentInOperand</id>
    <artifact tool="PMD" mnemonic="AssignmentInOperand"/>
    <name>Avoid assignment in operand</name>
    <shortMessage>This code makes an assignment in an operand. This has been deemed questionable coding practice because it can be complicated and hard to read.</shortMessage>
    <info>
<![CDATA[<p>Avoid assignments in operands; this can make code more
complicated and harder to read.  Consider changing the below code</p>

<pre>
int x = 2;
if ((x = getX()) == 3) {
  System.out.println("3!");
}
</pre>

<p>to</p>

<pre>
int x = getX();
if (x == 3) {
  System.out.println("3!");
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AtLeastOneConstructor</id>
    <artifact tool="PMD" mnemonic="AtLeastOneConstructor"/>
    <name>Have at least one constructor</name>
    <shortMessage>This class does not have an explicit constructor.  Consider adding one.</shortMessage>
    <info>
<![CDATA[<p>This class lacks an explicit constructor. An implicit
constructor has been generated for it by the compiler. If you consider
this to be a bad coding practice then add an explicit constructor to
this class.</p>

<pre>
public class Foo {
  // no explicit constructor!  not good!
}
</pre>
]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DontImportSun</id>
    <artifact tool="PMD" mnemonic="DontImportSun"/>
    <name>Avoid import from sun.*</name>
    <shortMessage>This class imports from the sun.* packages. This should be avoided because these packages are not portable and are likely to change.</shortMessage>
    <info>
<![CDATA[<p>Avoid importing anything from the 'sun.*' packages because
these packages are not portable and are likely to change.</p>

<pre>
import sun.misc.foo;
public class Foo {
  ...
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SuspiciousOctalEscape</id>
    <artifact tool="PMD" mnemonic="SuspiciousOctalEscape"/>
    <name>Suspicious octal escape inside a string literal</name>
    <shortMessage>This is a suspicious octal escape sequence inside a String literal. Is this what is intended?</shortMessage>
    <info>
<![CDATA[<p>A suspicious octal escape sequence was found inside a
String literal. The Java language specification (section 3.10.6) says
an octal escape sequence inside a literal String shall consist of a
backslash followed by:</p>

<p><i>OctalDigit</i> | <i>OctalDigit</i> <i>OctalDigit</i> | <i>ZeroToThree</i> <i>OctalDigit</i> <i>OctalDigit</i></p>

<p>Any octal escape sequence followed by non-octal digits can be
confusing, e.g. <code>"\038"</code> is interpreted as the octal escape
sequence <code>\03</code> followed by the literal character
<code>8</code>.</p>

<pre>
public void foo() {
  // interpreted as octal 12, followed by the character '8'
  System.out.println("suspicious: \128");
}
</pre>

<p>See <a
href="http://java.sun.com/docs/books/jls/third_edition/html/lexical.html#3.10.6">the
Java Language Specification</a> for further details.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>CallSuperInConstructor</id>
    <artifact tool="PMD" mnemonic="CallSuperInConstructor"/>
    <name>Call super in all constructors</name>
    <shortMessage>This constructor does not call super() explicitly.</shortMessage>
    <info>
<![CDATA[<p>It is a good practice to call <code>super()</code> in a
constructor. If <code>super()</code> is not called but another
constructor (such as an overloaded constructor) is called, this rule
will not report it.</p>

<pre>
public class Foo extends Bar{
  public Foo() {
    // call the constructor of Bar explicitly
    super(); // if this was missing this rule would complain
   }
   public Foo(int code) {
     this(); // no problem with this
     // do something with 'code'
   }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UnnecessaryParentheses</id>
    <artifact tool="PMD" mnemonic="UnnecessaryParentheses"/>
    <name>Unnecessary parentheses</name>
    <shortMessage>This expression is wrapped in unnecessary parentheses, making it look like a function call.</shortMessage>
    <info>
<![CDATA[<p>Sometimes expressions are wrapped in unnecessary
parentheses, making them look like a function call.  Consider removing
the unnecessary parentheses.</p>

<p>For example, consider changing</p>

<pre>
public boolean bar() {
  return (true); // Bad!
}
</pre>

<p>to</p>

<pre>
public boolean bar() {
  return true;
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SingularField</id>
    <artifact tool="PMD" mnemonic="SingularField"/>
    <name>Singular field</name>
    <shortMessage>This field is only used by one method. Can it be replaced by a local variable? </shortMessage>
    <info>
<![CDATA[<p>A field that's only used by one method could perhaps be
replaced by a local variable.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DefaultPackage</id>
    <artifact tool="PMD" mnemonic="DefaultPackage"/>/artifact>
    <name>Use explicit visibility</name>
    <shortMessage>Use explicit visibility instead of the default package private level.</shortMessage>
    <info>
<![CDATA[<p>Use explicit visibility for attributes instead of the
default package private level.  For example, change</p>

<pre>
public class Foo {
  int myInt;
  ...
}
</pre>

<p>to</p>

<pre>
public class Foo {
  private int myInt;
  ...
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>BooleanInversion</id>
    <artifact tool="PMD" mnemonic="BooleanInversion"/>
    <name>Use boolean inversion</name>
    <shortMessage>Use bitwise inversion to invert this boolean value; it's the fastest way to do this.</shortMessage>
    <info>
<![CDATA[<p>Use bitwise inversion to invert boolean values&mdash;it's
the fastest way to do this.</p>

<pre>
boolean b = true;
b = !b;    // slow
b ^= true; // fast
</pre>

<p>See <a
href="http://www.javaspecialists.co.za/archive/newsletter.do?issue=042">
Speed-kings of inverting booleans</a> by Dr. Heinz M. Kabutz for more
details.  It also may be prudent to check this result on your
particular JVM.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DataflowAnomalyAnalysis</id>
    <artifact tool="PMD" mnemonic="DataflowAnomalyAnalysis"/>
    <name>Dataflow anomaly analysis</name>
    <shortMessage>An anomaly has been detected via PMD dataflow analysis.</shortMessage>
    <info>
<![CDATA[<p>The dataflow analysis tracks local definitions,
undefinitions and references to variables on different paths on the
data flow. From those informations there can be found various
problems.</p>

<ol>

<li>UR - Anomaly: There is a reference to a variable that was not
defined before. This is a bug and leads to an error.</li>

<li>DU - Anomaly: A recently defined variable is undefined.  These
anomalies may appear in normal source text.</li>

<li>DD - Anomaly: A recently defined variable is redefined. This is
ominous but don't have to be a bug.</li>

</ol>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>CouplingBetweenObjects</id>
    <artifact tool="PMD" mnemonic="CouplingBetweenObjects"/>
    <name>Coupling between objects</name>
    <shortMessage>This class seems to have a high number of unique attributes, local variables and return types within an object. This can indicate a high degree of coupling.  Can you reduce its coupling?</shortMessage>
    <info>
<![CDATA[<p>This rule counts unique attributes, local variables and
return types within an object. A number higher than specified
threshold can indicate a high degree of coupling.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ExcessiveImports</id>
    <artifact tool="PMD" mnemonic="ExcessiveImports"></artifact>
    <name>Excessive imports</name>
    <shortMessage>This class has too many imports. Can you reduce this count?</shortMessage>
    <info>
<![CDATA[<p>A high number of imports can indicate a high degree of
coupling within an object. Rule counts the number of unique imports
and reports a violation if the count is above the defined
threshold.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LooseCoupling</id>
    <artifact tool="PMD" mnemonic="LooseCoupling"></artifact>
    <name>Loose coupling violation</name>
    <shortMessage>Avoid using implementation types (i.e., HashSet); use the interface (i.e, Set) instead.</shortMessage>
    <info>
<![CDATA[<p>Avoid using implementation types (i.e.,
<code>HashSet</code>); use the interface (i.e, <code>Set</code>)
instead.</p>

<pre>
import java.util.*;
public class Bar {
  // Use List instead
  private ArrayList list = new ArrayList();
  // Use Set instead
  public HashSet getFoo() {
    return new HashSet();
  }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UseSingleton</id>
    <artifact tool="PMD" mnemonic="UseSingleton"/>
    <name>Use singleton pattern</name>
    <shortMessage>Consider refactoring this class to be a singleton.</shortMessage>
    <info>
<![CDATA[<p>If you have a class that has nothing but static methods,
consider making it a singleton. Note that this doesn't apply to
abstract classes, since their subclasses may well include non-static
methods. Also, if you want this class to be a singleton, remember to
add a private constructor to prevent instantiation.</p>

<p>The singleton pattern in Java is typically implemented as a
variation the below.  So instead of</p>

<pre>
public final class Foo {
  public static void m1() {
    // do something
  }

  private Foo() {
    // no instances...a utility
  }
}
</pre>

<p>use</p>

<pre>
public final class Foo {
  private static final INSTANCE = new Foo();

  public static Foo getInstance() {
    return INSTANCE;
  }

  private Foo() {
    // singleton
  }

  public void m1() {
    // do something
  }
}
</pre>

<p>Clients change calls to <code>m1()</code> from
<code>Foo.m1()</code> to <code>Foo.getInstance().m1()</code>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SimplifyBooleanExpressions</id>
    <artifact tool="PMD" mnemonic="SimplifyBooleanReturns"/>
    <artifact tool="PMD" mnemonic="SimplifyBooleanExpressions"/>
    <name>Use boolean expressions directly</name>
    <shortMessage>Use boolean expressions directly to simplify your code.</shortMessage>
    <info>
<![CDATA[<p>Avoid unnecessary comparisons in boolean
expressions&mdash;this complicates simple code.</p>

<p>For example, consider changing</p>

<pre>
public class Foo {

  private int bar = 2;

  public boolean isBarEqualTo(int x) {
    if (bar == x) {
     return true;
    } else {
     return false;
    }
  }

  private boolean bar = (isFoo() == true);

  public isFoo() {
    return false;
  }
}
</pre>

<p>to</p>

<pre>
public class Foo {

  private int bar = 2;

  public boolean isBarEqualTo(int x) {
    return bar == x;
  }

  private boolean bar = isFoo();

  public isFoo() {
    return false;
  }
}</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SwitchStmtsShouldHaveDefault</id>
    <artifact tool="PMD" mnemonic="SwitchStmtsShouldHaveDefault"/>
    <name>Switch with no default</name>
    <shortMessage>This switch statement should have a default label.</shortMessage>
    <info>
<![CDATA[<p>It has been deemed questionable coding practice to not
have a <code>default</code> label for each <code>switch</code>.</p>

<pre>
int x = 2;
switch (x) {
  case 2: int j = 8; // no default?
}
</pre>
]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidDeeplyNestedIfStmts</id>
    <artifact tool="PMD" mnemonic="AvoidDeeplyNestedIfStmts"/>
    <name>Avoid deeply nested if statements</name>
    <shortMessage>This is a deeply nested if that may be hard to read. Can the level of nesting be reduced?</shortMessage>
    <info>
<![CDATA[<p>Deeply nested if statements have been deemed to be
questionable coding practice because they can be hard to read.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidReassigningParameters</id>
    <artifact tool="PMD" mnemonic="AvoidReassigningParameters"/>
    <name>Avoid reassigning parameter values</name>
    <shortMessage>This method reassigns the values of one or more of its parameters.  This is a questionable practice.</shortMessage>
    <info>
<![CDATA[<p>Reassigning values to parameters has been deemed a
questionable coding practice. Use a temporary local variable
instead.</p>

<pre>
private void foo(String bar) {
  bar = "something else";  // don't do this
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SwitchDensity</id>
    <artifact tool="PMD" mnemonic="SwitchDensity"/>
    <name>Switch density too high</name>
    <shortMessage>This switch statement has a high ratio of statements to labels. Consider moving the statements into new methods, or creating subclasses based on the switch variable.</shortMessage>
    <info>
<![CDATA[<p>A high ratio of statements to labels in a switch statement
implies that the switch statement is probably doing too much work.
Consider moving the statements into new methods, or creating
subclasses based on the switch variable (to replace the switch
statement with polymorphism).</p>

<pre>
switch (x) {
  case 1: {
    // lots of statements
    break;
  } case 2: {
    // lots of statements
    break;
  }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ConstructorCallsOverridableMethod</id>
    <artifact tool="PMD" mnemonic="ConstructorCallsOverridableMethod"/>
    <name>Constructor calls an overridable method</name>
    <shortMessage>This constructor calls, directly or indirectly, an
    overridable method.  This is considered dangerous if this class is
    subclassed.</shortMessage>
    <info>
<![CDATA[<p> Calling overridable methods during construction poses a
risk of invoking methods on an incompletely constructed object and can
be difficult to discern. It may leave the sub-class unable to
construct its superclass or forced to replicate the construction
process completely within itself, losing the ability to call
<code>super()</code>.</p>

<p>If the default constructor contains a call to an overridable
method, the subclass may be completely uninstantiable. Note that this
includes method calls throughout the control flow graph, i.e., if a
constructor <code>Foo()</code> calls a private method
<code>bar()</code> that calls a public (and thus overridable) method
<code>buz()</code>, this denotes a potential problem.</p>

<p>The code below provides an example where this finding can cause
confusing program behavior.</p>

<pre>
public class SeniorClass {
  public SeniorClass() {
    toString(); // may throw NullPointerException if overridden
  }
  public String toString() {
    return "IAmSeniorClass";
  }
}

public class JuniorClass extends SeniorClass {
  private String name;
  public JuniorClass() {
    super(); // Automatic call leads to a NullPointerException because 'name' is still null
    name = "JuniorClass";
  }
  public String toString() {
    return name.toUpperCase();
  }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AccessorClassGeneration</id>
    <artifact tool="PMD" mnemonic="AccessorClassGeneration"/>
    <name>Accessor class generation</name>
    <shortMessage>This class uses private constructors from outside of the constructor's class which can cause the generation of an accessor.</shortMessage>
    <info>
<![CDATA[<p>Instantiation by way of private constructors from outside
of the constructor's class often causes the generation of an
accessor. A factory method, or non-privatization of the constructor
can eliminate this situation. The generated class file is actually an
interface. It gives the accessing class the ability to invoke a new
hidden package scope constructor that takes the interface as a
supplementary parameter. This turns a private constructor effectively
into one with package scope, and is challenging to discern.</p>

<pre>
public class Outer {
  void method(){
    Inner ic = new Inner(); // Causes generation of an accessor class
  }
  public class Inner {
    private Inner(){}
  }
}
</pre>

<p>This could be resolved by making the constructor not be
<code>private</code> or by creating a factory method such as:</p>

<pre>
Inner getInstance() {
  return new Inner();
}
</pre>

<p>It is recommended to check if this generation still occurs on your
JDK.  If not then this finding is not an issue.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NonStaticInitializer</id>
    <artifact tool="PMD" mnemonic="NonStaticInitializer"/>
    <name>Avoid non-static initializer</name>
    <shortMessage>Do this code really need to use a non-static initializer block, it is rarely used and is confusing.</shortMessage>
    <info>
<![CDATA[<p>A non-static initializer block will be called any time a
constructor is invoked (just prior to invoking the constructor). While
this is a valid language construct, it is rarely used and is
confusing.</p>

<p>It is often possible to move the code in the initializer block into
a constructor.  Also consider using the <code>this()</code> invocation
technique to avoid copying of common constructor code.  For example:

<pre>
class Foo {

  private Foo() {
    // common code
  }

  public Foo(String s) {
    this();
    // more code
  }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DefaultLabelNotLastInSwitchStmt</id>
    <artifact tool="PMD" mnemonic="DefaultLabelNotLastInSwitchStmt"/>
    <name>Default label should be last in switch</name>
    <shortMessage>By convention, the default label should be the last label in a switch statement.</shortMessage>
    <info>
<![CDATA[<p>It is considered questionable coding practice to have the
<code>default</code> label not be last in a <code>switch</code>
statement.</p>

<pre>
switch (a) {
  case 1:
    // do something
    break;
  default:  // the default case should be last, by convention
    break;
  case 2:
    break;
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NonCaseLabelInSwitchStatement</id>
    <artifact tool="PMD" mnemonic="NonCaseLabelInSwitchStatement"/>
    <name>Non-case label in switch</name>
    <shortMessage>This code contains a non-case label (e.g. a named break/continue label) within a switch statement. This legal, but confusing.</shortMessage>
    <info>
<![CDATA[<p>A non-case label (e.g. a named break/continue label) was
present in a switch statement. This legal, but confusing. It is easy
to mix up the case labels and the non-case labels.  It is recommended
that this code be changed to avoid this confusion.</p>

<pre>
switch (a) {
  case 1:
    // do something
    break;
  mylabel: // this is legal, but confusing!
    break;
  default:
    break;
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ConfusingTernary</id>
    <artifact tool="PMD" mnemonic="ConfusingTernary"/>
    <name>Confusing negated if</name>
    <shortMessage>Avoid negation in the test of this if statement.  This can be confusing.</shortMessage>
    <info>
<![CDATA[<p>In an <code>if</code> expression with an<code>else</code>
clause, avoid negation in the test. For example, rephrase</p>

<pre>
if (x != y)
  diff();
else
  same();
</pre>

<p>as</p>

<pre>
if (x == y)
  same();
else
  diff();
</pre>

<p>Most <code>if (x != y)</code> cases without an <code>else</code>
are often return cases, so consistent use of this rule makes the code
easier to read. Also, this resolves trivial ordering problems, such as
'does the error case go first?' or 'does the common case go
first?'.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>InstantiationToGetClass</id>
    <artifact tool="PMD" mnemonic="InstantiationToGetClass"/>
    <name>Avoid instantiation to call getClass()</name>
    <shortMessage>This code instantiates an object just to call getClass() on it; use the .class public member instead.</shortMessage>
    <info>
<![CDATA[<p>Avoid instantiating an object just to call getClass() on
it; use the .class public member instead.  For example, replace</p>

<pre>
Class c = new String().getClass();
</pre>

<p>with this</p>

<pre>
Class c = String.class;
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SimpleDateFormatNeedsLocale</id>
    <artifact tool="PMD" mnemonic="SimpleDateFormatNeedsLocale"/>
    <name>Use Locale parameterized version of SimpleDateFormat constructor</name>
    <shortMessage>It is recommended that you specify a Locale when creating a new instance of SimpleDateFormat.</shortMessage>
    <info>
<![CDATA[<p>Consider specifying a Locale when creating a new instance
of SimpleDateFormat.</p>

<pre>
// Should specify Locale.US (or whatever)
private SimpleDateFormat sdf = new SimpleDateFormat("pattern");
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ImmutableField</id>
    <artifact tool="PMD" mnemonic="ImmutableField"/>
    <name>Immutable field</name>
    <shortMessage>This is a private field that never changes once it is initialized.  Consider making it a final field.</shortMessage>
    <info>
<![CDATA[<p>A private field whose value never changes once it is
initialized either in the declaration of the field or by a constructor
can be declared to be <code>final</code>. This aids in converting
existing classes to immutable classes.</p>

<pre>
public class Foo {
  private int x; // could be final
  public Foo() {
     x = 7;
  }
  public void foo() {
    int a = x + 2;
  }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidProtectedFieldInFinalClass</id>
    <artifact tool="PMD" mnemonic="AvoidProtectedFieldInFinalClass"/>
    <name>Avoid protected fields in final classes</name>
    <shortMessage>This field is declared to be protected in a final class.  Consider changing it to be private.</shortMessage>
    <info>
<![CDATA[<p>Do not use <code>protected</code> fields in
<code>final</code> classes since they cannot be subclassed. Clarify
your intent by changing these fields to use either the
<code>private</code> or package access (default) modifiers
instead.</p>

<pre>
public final class Bar {
  private int x;   // Ok
  protected int y; // 'Bar' cannot be subclassed, so should 'y' really private or package visible???
  ...
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AssignmentToNonFinalStatic</id>
    <artifact tool="PMD" mnemonic="AssignmentToNonFinalStatic"/>
    <name>Assignment to a non-final static field</name>
    <shortMessage>This assignment to a non-static field may be unsafe. Is this what was intended?</shortMessage>
    <info>
<![CDATA[<p>Identifies a possible unsafe usage of a static field.
Consider making this field immutable.  If this field is intended to be
mutable then ignore this finding.</p>

<pre>
public class StaticField {
   static int x;
   public FinalFields(int y) {
     x = y; // is this intended?
   }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>MissingStaticMethodInNonInstantiatableClass</id>
    <artifact tool="PMD" mnemonic="MissingStaticMethodInNonInstantiatableClass"/>
    <name>Non-instantiatable class</name>
    <shortMessage>This class has only private constructors and does not have any static methods of fields.  This class appears to be unusable.</shortMessage>
    <info>
<![CDATA[<p>A class that has only private constructors and does not
have any <code>static</code> methods or fields cannot be used.</p>

<pre>
/**
 * This class is unusable, since it cannot be
 * instantiated (private constructor),
 * no static method can be called, and
 * no static field can be accessed.
 */
public class Foo {
  private Foo() {}
  void foo() {}
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidSynchronizedAtMethodLevel</id>
    <artifact tool="PMD" mnemonic="AvoidSynchronizedAtMethodLevel"/>
    <name>Avoid synchronized at the method level</name>
    <shortMessage>Consider finer-grained synchronization than at the method level.</shortMessage>
    <info>
<![CDATA[<p>Method level synchronization can backfire when new code is
added to the method. Block-level synchronization helps to ensure that
only the code that needs synchronization gets it.  Block-level
synchronization can also help to improve encapsulation.</p>

<pre>
public class Foo {

  // Try to avoid this
  synchronized void foo() {
    ...
  }

  // Prefer this approach
  void bar() {
    synchronized(this) {
      ...
    }
    ...
  }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidInstanceofChecksInCatchClause</id>
    <artifact tool="PMD" mnemonic="AvoidInstanceofChecksInCatchClause"/>
    <name>Avoid instanceof checks in catch</name>
    <shortMessage>Place each caught exception in its own catch clause.  Don't use instanceof.</shortMessage>
    <info>
<![CDATA[<p>Each caught exception type should be handled in its own
catch clause. Do not use instanceof check. For example, replace</p>

<pre>
try {
  // do something
} catch (Exception ee) {
  if (ee instanceof IOException) {
    cleanup();
  }
}
</pre>

<p>with</p>

<pre>
try {
  // do something
} catch (IOException ee) {
  cleanup();
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AbstractClassWithoutAbstractMethod</id>
    <artifact tool="PMD" mnemonic="AbstractClassWithoutAbstractMethod"/>
    <name>Abstract class has no abstract methods</name>
    <shortMessage>This abstract class does not contain any abstract methods.  Is it an incomplete implementation?</shortMessage>
    <info>
<![CDATA[<p>This abstract class does not contain any abstract
methods. An abstract class suggests an incomplete implementation,
which is to be completed by subclasses implementing the abstract
methods. If the class is intended to be used as a base class only (not
to be instantiated directly) a protected constructor can be provided
prevent direct instantiation.<p>

<pre>
public abstract class Foo {
  void int method1() { ... }
  void int method2() { ... }
  // consider using abstract methods or removing
  // the abstract modifier and adding protected constructors
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SimplifyConditional</id>
    <artifact tool="PMD" mnemonic="SimplifyConditional"/>
    <name>Unnecessary null check before instanceof</name>
    <shortMessage>This code checks for null before an instanceof check. The null check can be safely removed.</shortMessage>
    <info>
<![CDATA[<p>There is no need to check for a <code>null</code> value
before an <code>instanceof</code> check.  This is because the
<code>instanceof</code> keyword returns false when given a
<code>null</code> argument.  For example, it is safe to change</p>

<pre>
if (x != null && x instanceof Bar) {
  // do something
}
</pre>

<p>to</p>

<pre>
if (x != null && x instanceof Bar) {
  // do something
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>CompareObjectsWithEquals</id>
    <artifact tool="PMD" mnemonic="CompareObjectsWithEquals"/>
    <name>Compare objects with equals() not ==</name>
    <shortMessage>Consider using equals() to compare object references. Avoid comparing them with ==.</shortMessage>
    <info>
<![CDATA[<p>It has been determined that it is a questionable code
practice to compare object references with <code>==</code>, use
<code>equals()</code> instead.  For example, change <code>a ==
b</code> to <code>a.equals(b)</code>.</p>

<p>If this practice is followed be sure that the object being
dereferenced to call <code>equals()</code> (in our example this is
<code>a</code>) is not <code>null</code>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>PositionLiteralsFirstInComparisons</id>
    <artifact tool="PMD" mnemonic="PositionLiteralsFirstInComparisons"/>
    <name>Position literals first in String comparisons</name>
    <shortMessage>Position the String literal first in this comparison. This way may throw a NullPointerException.</shortMessage>
    <info>
<![CDATA[<p>Always position literals first in String comparisons.
This ensures that if the String is <code>null</code> then the
comparison will not throw a <code>NullPointerException</code>, it'll
just return false.  For example, always use
<code>"hello".equals(s)</code> rather than
<code>s.equals("hello")</code>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UnnecessaryLocalBeforeReturn</id>
    <artifact tool="PMD" mnemonic="UnnecessaryLocalBeforeReturn"/>
    <name>Avoid unnecessary local variable before return</name>
    <shortMessage>This code appears to create an unnecessary local variable just to return it. Consider removing this local variable.</shortMessage>
    <info>
<![CDATA[<p>Avoid unnecessarily creating local variables just to
return them.</p>

<pre>
public int foo() {
  int x = doSomething();
  return x;  // instead, just 'return doSomething();'
}
</pre>]]>
  </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NonThreadSafeSingleton</id>
    <artifact tool="PMD" mnemonic="NonThreadSafeSingleton"/>
    <name>Avoid non-thread save singleton</name>
    <shortMessage>This singleton does not appear to be thread-safe. Consider making it thread-safe.</shortMessage>
    <info>
<![CDATA[<p>Non-thread-safe singletons can result in bad state
changes.  Eliminate static singletons if possible by instantiating the
object directly. Static singletons are usually not needed as only a
single instance exists anyway. Other possible fixes are to synchronize
the entire method or to use an initialize-on-demand holder class.  (do
not use the double-check idiom).  For more information see Bloch's
<i>Effective Java</i> (first edition) item 48.</p>

<p>For example, change the below code</p>

<pre>
private static Foo foo = null;

// Not thread-safe -- multiple simultaneous callers
// may see partially initialized objects
public static Foo getInstance() {
  if (foo == null)
    foo = new Foo();
  return foo;
}
</pre>

<p>to</p>

<pre>
private static final Foo INSTANCE = new Foo();

public static Foo getInstance() {
  return INSTANCE;
}
</pre>

<p>or <code>synchronize</code> the <code>getInstance()</code>
method.</p>

<p>If you are using Java 5 or above a single element <code>enum</code>
is recommended by Bloch as the best way to implement a singleton. For
example</p>

<pre>
public enum Foo {
  INSTANCE;

  // singleton methods
  public void m1() { ... }
}
</pre>

<p>would be used as <code>Foo.INSTANCE.m1()</code>.  This approach has
several advantages including built-in serialization machinery and a
guarantee against multiple instantiation.</p> ]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UncommentedEmptyMethod</id>
    <artifact tool="PMD" mnemonic="UncommentedEmptyMethod"/>
    <name>Uncommented empty method</name>
    <shortMessage>This empty method should be commented to indicate that it is intentionally empty.</shortMessage>
    <info>
<![CDATA[<p>This method does not contain any statements, but there is
no comment indicating that this lack of statements is intentional. By
explicitly commenting empty methods it is easier to distinguish
between intentional (commented) and unintentional empty
methods.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UncommentedEmptyConstructor</id>
    <artifact tool="PMD" mnemonic="UncommentedEmptyConstructor"/>
    <name>Uncommented empty constructor</name>
    <shortMessage>This empty constructor should be commented to indicate that it is intentionally empty.</shortMessage>
    <info>
<![CDATA[<p>This constructor does not contain any statements, but
there is no comment. By explicitly commenting empty constructors it is
easier to distinguish between intentional (commented) and
unintentional empty constructors.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidConstantsInterface</id>
    <artifact tool="PMD" mnemonic="AvoidConstantsInterface"/>
    <name>Avoid constants-only interface</name>
    <shortMessage>This interface only acts as a container of constants.  This is a poor usage pattern.</shortMessage>
    <info>
<![CDATA[<p>An interface should be used only to model a behavior of a
class: using an interface as a container of constants is a poor usage
pattern.</p>

<pre>
// Bad! poor use of an interface
public interface ConstantsInterface {
  public static final int CONSTANT1 = 0;
  public static final String CONSTANT2 = "1";
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>PreserveStackTrace</id>
    <artifact tool="PMD" mnemonic="PreserveStackTrace"/>
    <name>Preserve original stack trace</name>
    <shortMessage>This code throws a new exception from a catch block without passing the original exception into the new exception. This causes the true stack trace to be lost. Consider changing this code.</shortMessage>
    <info>
<![CDATA[<p>Throwing a new exception from a catch block without
passing the original exception into the new exception will cause the
true stack trace to be lost, and can make it difficult to debug
effectively.  Ensure that you pass the original exception into the
constructor of the new exception.  For example, change</p>

<pre>
try{
  Integer.parseInt("a");
} catch(Exception e){
  throw new Exception(e.getMessage());
}
</pre>

<p>to</p>

<pre>
try{
  Integer.parseInt("a");
} catch(Exception e){
  throw new Exception(e);
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UseCollectionIsEmpty</id>
    <artifact tool="PMD" mnemonic="UseCollectionIsEmpty"/>
    <name>Use isEmpty() to check if a collection is empty</name>
    <shortMessage>Use the isEmpty() method to see if a java.util.Collection is empty rather than comparing the value of size() to 0.</shortMessage>
    <info>
<![CDATA[<p>The <code>isEmpty()</code> method on
<code>java.util.Collection</code> objects is provided to see if a
collection has any elements. Comparing the value of
<code>size()</code> of the collection to 0 merely duplicates existing
behavior.  For example, change</p>

<pre>
List foo = getList();
if (foo.size() == 0) {
  // do something
}
</pre>

<p>to</p>

<pre>
List foo = getList();
if (foo.isEmpty()) {
  // do something
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>FinalizeOverloaded</id>
    <artifact tool="PMD" mnemonic="FinalizeOverloaded"/>
    <name>Avoid overloading finalize()</name>
    <shortMessage>This method overloads the finalize() method with one that has one or more parameters. It is not be called by the VM.</shortMessage>
    <info>
<![CDATA[<p>Methods named <code>finalize()</code> should not have
parameters.  It is easy to confuse such a method with a finalizer and
could lead to a bug. This method will not be called by the VM.  It is
recommended that you use another name.</p>

<pre>
public class Foo {
  // This method is confusing and might be a bug
  protected void finalize(int a) {
    ...
  }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DuplicateImports</id>
    <artifact tool="PMD" mnemonic="DuplicateImports"/>
    <artifact tool="PMD" mnemonic="ImportFromSamePackage"/>
    <name>Avoid duplicate import</name>
    <shortMessage>This compilation unit has an import that duplicates another import.  Remove the duplication.</shortMessage>
    <info>
<![CDATA[<p>It is considered bad practice for a compilation unit to
contain duplicate import statements.  For example, consider
changing</p>

<pre>
import java.util.Set;
import java.util.*;
public class Foo {
  ...
}
</pre>

<p>to</p>

<pre>
import java.util.*;
public class Foo {
  ...
}
</pre>]]>
</info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DontImportJavaLang</id>
    <artifact tool="PMD" mnemonic="DontImportJavaLang"/>
    <name>Never explicitly import from java.lang</name>
    <shortMessage>This compilation unit explicitly imports part or all of the java.lang package. This package is automatically imported.</shortMessage>
    <info>
<![CDATA[<p>Never explicitly import anything from the
<code>java.lang</code> package. Classes in this package are
automatically imported.  For example, both of the import statements
shown below are unnecessary and can be removed.</p>

<pre>
import java.lang.String;
</pre>

<pre>
import java.lang.*;
</pre>

<p>See <a
href="http://java.sun.com/docs/books/jls/third_edition/html/packages.html#7.5.5">the
Java Language Specification</a> for further details.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UnusedImports</id>
    <artifact tool="PMD" mnemonic="UnusedImports"/>
    <name>Remove unused import</name>
    <shortMessage>This import is not necessary.  Consider removing it from the compilation unit.</shortMessage>
    <info>
<![CDATA[<p>Imports that are not required by the compilation unit
create a dependency.  For example, consider the below code.</p>

<pre>
import org.apache.log4j.Logger;
public class Foo {
  public static void main(String[] args) {
    System.out.println("Hello!");
  }
}
</pre>

<p>This compilation unit will <i>not</i> compile without the Apache
Log4j Jar on its classpath despite the fact that it never uses the
imported Log4j <code>Logger</code> class.</p>

<p>Unused or unnecessary imports are considered bad coding practice
and can create unnecessary coupling between classes.</p>

<p>Many IDEs, such as Eclipse, can help you to automatically remove
unused imports from your program.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UseProperClassLoader</id>
    <artifact tool="PMD" mnemonic="UseProperClassLoader"/>
    <name>Use proper class loader</name>
    <shortMessage>Avoid getClassLoader() in J2EE. Use Thread.currentThread().getContextClassLoader() instead.</shortMessage>
    <info>
<![CDATA[<p>In J2EE <code>getClassLoader()</code> might not work as
expected. Therefore, use
<code>Thread.currentThread().getContextClassLoader()</code>
instead.</p>

<p>For example, consider changing</p>

<pre>
ClassLoader cl = Bar.class.getClassLoader();
</pre>

<p>to</p>

<pre>
ClassLoader cl = Thread.currentThread().getContextClassLoader();
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>MDBAndSessionBeanNamingConvention</id>
    <artifact tool="PMD" mnemonic="MDBAndSessionBeanNamingConvention"/>
    <name>MDB and SessionBean naming convention</name>
    <shortMessage>This class appears to be a MessageDrivenBean or a SessionBean but is not suffixed by 'Bean'.</shortMessage>
    <info>
<![CDATA[<p>The EJB Specification states that any
<code>MessageDrivenBean</code> or <code>SessionBean</code> should be
suffixed by 'Bean'. For example:</p>

<pre>
public class SomeBean implements SessionBean { ... }
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>RemoteSessionInterfaceNamingConvention</id>
    <artifact tool="PMD" mnemonic="RemoteSessionInterfaceNamingConvention"/>
    <name>Remote Home naming convention</name>
    <shortMessage>This class appears to be the Remote Home interface of a Session EJB but is not suffixed by 'Home'.</shortMessage>
    <info>
<![CDATA[<p>The <i>Remote Home</i> interface of a Session EJB should
be suffixed by 'Home'. For example:</p>

<pre>
public interface MyBeautifulHome extends javax.ejb.EJBHome { ... }
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LocalInterfaceSessionNamingConvention</id>
    <artifact tool="PMD" mnemonic="LocalInterfaceSessionNamingConvention"/>
    <name>Local naming convention</name>
    <shortMessage>This class appears to be the Local interface of a Session EJB but is not suffixed by 'Local'.</shortMessage>
    <info>
<![CDATA[<p>The <i>Local</i> Interface of a Session EJB should be
suffixed by 'Local'. For example:</p>

<pre>
public interface MyLocal extends javax.ejb.EJBLocalObject { ... }
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LocalHomeNamingConvention</id>
    <artifact tool="PMD" mnemonic="LocalHomeNamingConvention"/>
    <name>Local Home naming convention</name>
    <shortMessage>This class appears to be the Local Home interface of a Session EJB but is not suffixed by 'LocalHome'.</shortMessage>
    <info>
<![CDATA[<p>The <i>Local Home</i> interface of a Session EJB should be
suffixed by 'LocalHome'. For example:</p>

<pre>
public interface MyBeautifulLocalHome extends javax.ejb.EJBLocalHome { ... }
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>RemoteInterfaceNamingConvention</id>
    <artifact tool="PMD" mnemonic="RemoteInterfaceNamingConvention"/>
    <name>Remote naming convention</name>
    <shortMessage>The remote interface of a Session EJB should not be suffixed.</shortMessage>
    <info>
<![CDATA[<p>The <i>Remote</i> interface of a Session EJB should NOT be
suffixed. For example, use</p>

<pre>
public interface BadSuffix extends javax.ejb.EJBObject { ... }
</pre>

<p>rather than any of the following:</p>

<pre>
public interface BadSuffixSession extends javax.ejb.EJBObject { ... }

public interface BadSuffixEJB extends javax.ejb.EJBObject { ... }

public interface BadSuffixBean extends javax.ejb.EJBObject { ... }
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>BeanMembersShouldSerialize</id>
    <artifact tool="PMD" mnemonic="BeanMembersShouldSerialize"/>
    <name>Bean members should serialize</name>
    <shortMessage>This class is a bean, or is referenced by a bean directly or indirectly. Therefore, it needs to be serializable.</shortMessage>
    <info>
<![CDATA[<p>If a class is a bean, or is referenced by a bean directly
or indirectly it needs to be serializable. Member variables need to be
marked as transient, static, or have accessor methods in the
class. Marking variables as transient is the safest and easiest
modification.</p>

<p>Accessor methods should follow the Java naming conventions, i.e.,
if you have a variable <code>foo</code>, you should provide
<code>getFoo</code> and <code>setFoo</code> methods.</p>

<p>For example, consider the below code</p>

<pre>
private transient int someFoo; //good, it's transient
private static int otherFoo;   // also OK
private int moreFoo;           // OK, has proper accessors, see below
private int badFoo;            // Bad! probably should be marked transient

private void setMoreFoo(int moreFoo) {
  this.moreFoo = moreFoo;
}

private int getMoreFoo() {
  return this.moreFoo;
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>JUnitSpelling</id>
    <artifact tool="PMD" mnemonic="JUnitSpelling"/>
    <name>JUnit spelling</name>
    <shortMessage>Some JUnit framework methods are easy to misspell. Did you misspell this method's name?</shortMessage>
    <info>
<![CDATA[<p>Some JUnit framework methods are easy to misspell.  For
example, consider the below broken code.</p>

<pre>
public class Foo extends TestCase {
  public void setup() { ... }    // oops, should be setUp
  public void TearDown() { ... } // oops, should be tearDown
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>JUnitAssertionsShouldIncludeMessage</id>
    <artifact tool="PMD" mnemonic="JUnitAssertionsShouldIncludeMessage"/>
    <name>JUnit assertions should include a message</name>
    <shortMessage>Consider including a message as to what went wrong.</shortMessage>
    <info>
<![CDATA[<p>JUnit assertions should include a message, i.e., use the
three argument version of <code>assertEquals()</code>, not the two
argument version.</p>

<p>For example, consider changing</p>

<pre>
assertEquals("foo", "bar");
</pre>

<p>to</p>

<pre>
assertEquals("foo is not semantically equal to bar", "foo", "bar");
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>JUnitTestsShouldIncludeAssert</id>
    <artifact tool="PMD" mnemonic="JUnitTestsShouldIncludeAssert"/>
    <name>JUnit tests should include asserts</name>
    <shortMessage>This JUnit test case does not have an assertion. Is this intentional?</shortMessage>
    <info>
<![CDATA[<p>JUnit tests should include at least one assertion. This
makes the tests more robust, and using assert with messages provide
the developer a clearer idea of what the test does.</p>

<p>For example, consider changing</p>

<pre>
public void testSomething() {
  Bar b = findBar();
  b.work();
}
</pre>

<p>to</p>

<pre>
public void testSomething() {
  Bar b = findBar();
  assertNotNull("bar was not able to be found", b);
  b.work();
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>TestClassWithoutTestCases</id>
    <artifact tool="PMD" mnemonic="TestClassWithoutTestCases"/>
    <name>Test class without test cases</name>
    <shortMessage>Test classes end with the suffix Test. Having a non-test class with that name is not a good practice.</shortMessage>
    <info>
<![CDATA[<p>Test classes end with the suffix <code>Test</code>. Having
a non-test class with that name is not a good practice, since most
people will assume it is a test case. Test classes, for JUnit, have
test methods named <code>test</code><i>x</i>.  Where <i>x</i> is the
name of the test.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UnnecessaryBooleanAssertion</id>
    <artifact tool="PMD" mnemonic="UnnecessaryBooleanAssertion"/>
    <name>Unnecessary boolean assertion</name>
    <shortMessage>Consider removing assertTrue(true) and assertFalse(false). If you just want a test to halt, use the fail method.</shortMessage>
    <info>
<![CDATA[<p>A JUnit test assertion with a <code>boolean</code> literal
is unnecessary since it always will evaluate to the same thing. Consider
using flow control, in case of <code>assertTrue(false)</code> or
similar, or simply removing statements like
<code>assertTrue(true)</code> and <code>assertFalse(false)</code>. If
you just want a test to halt, use the <code>fail()</code>
method.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UseAssertNullInsteadOfAssertTrue</id>
    <artifact tool="PMD" mnemonic="UseAssertNullInsteadOfAssertTrue"/>
    <artifact tool="PMD" mnemonic="UseAssertSameInsteadOfAssertTrue"/>
    <artifact tool="PMD" mnemonic="UseAssertEqualsInsteadOfAssertTrue"/>
    <name>Use specific JUnit methods instead of assertTrue()</name>
    <shortMessage>Check object references using more specific JUnit methods rather than assertTrue.</shortMessage>
    <info>
<![CDATA[<p>Check object references using <code>assertNull</code>,
<code>assertNotNull</code>, <code>assertSame</code>,
<code>assertNotSame</code>, or <code>assertEquals</code> rather than
<code>assertTrue</code>. This is easier to understand.</p>

<p>For example, change</p>

<pre>
void testCode() {
  Object a = doSomething();

  assertTrue(a == null);   // Bad!
  assertTrue(a != null);   // Bad!

  assertTrue(a == b);      // Bad!
  assertTrue(a != c);      // Bad!

  assertTrue(a.equals(b)); // Bad!
}
</pre>

<p>to</p>

<pre>
void testCode() {
  Object a = doSomething();

  assertNull(a);
  assertNotNull(a);

  assertSame(a, b);
  assertNotSame(a, c);

  assertEquals(a, b);
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SimplifyBooleanAssertion</id>
    <artifact tool="PMD" mnemonic="SimplifyBooleanAssertion"/>
    <name>Simplify boolean assertion</name>
    <shortMessage>Avoid negation in an assertTrue() or assertFalse() tests.</shortMessage>
    <info>
<![CDATA[<p>Avoid negation in an <code>assertTrue</code> or
<code>assertFalse</code> test. Rephrase <code>assertTrue(!expr)</code>
as <code>assertFalse(expr)</code>.</p>

<p>For example, change</p>

<pre>
public void testX() {
  assertTrue("not empty", !r.isEmpty()); // Bad!
  assertFalse(!r.isEmpty());             // Bad!
}
</pre>

<p>to</p>

<pre>
public void testX() {
  assertFalse("not empty", r.isEmpty());
  assertTrue(r.isEmpty());
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UseCorrectExceptionLogging</id>
    <artifact tool="PMD" mnemonic="UseCorrectExceptionLogging"/>
    <name>Use informative Exception logging</name>
    <shortMessage>This code appears to lose information. Consider using the logging statement with 2 arguments: a String and a Throwable.</shortMessage>
    <info>
<![CDATA[<p>To make sure the full stacktrace is printed out, use the
logging statement with 2 arguments: a <code>String</code> and a
<code>Throwable</code>.</p>

<p>For example, consider changing</p>

<pre>
public class Main {
  private static final Log _LOG = LogFactory.getLog(Main.class);
  ...
  void bar() {
    try {
      // do something that can go wrong
    } catch(Exception e) {
      _LOG.error(e); // Bad!
    }
  }
}
</pre>

<p>to</p>

<pre>
public class Main {
  private static final Log _LOG = LogFactory.getLog(Main.class);
  ...
  void bar() {
    try {
      // do something that can go wrong
    } catch(Exception e) {
      _LOG.error(e.getMessage(), e);
    }
  }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ProperLogger</id>
    <artifact tool="PMD" mnemonic="ProperLogger"/>
    <name>Use the proper logger</name>
    <shortMessage>Consider declaring your logger to be private static final and ensure it has the correct class.</shortMessage>
    <info>
<![CDATA[<p>A logger should normally be defined to be <code>private
static final</code> and have the correct class.</p>

<p>A non-static <code>private final</code> logger is also allowed for
rare cases where loggers need to be passed around, with the
restriction that the logger needs to be passed into the
constructor.</p>

<p>For example, consider changing</p>

<pre>
public class Foo {
  protected Log LOG = LogFactory.getLog(Testclass.class);
  ...
}
</pre>

<p>to</p>

<pre>
public class Foo {
  private static final Log LOG = LogFactory.getLog(Foo.class);
  ...
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>MoreThanOneLogger</id>
    <artifact tool="PMD" mnemonic="MoreThanOneLogger"/>
    <name>Avoid more than one Logger</name>
    <shortMessage>Normally only one Logger is used in each class. Consider removing a Logger.</shortMessage>
    <info>
<![CDATA[<p>This class contains two <code>Logger</code>
references. Typically only one <code>Logger</code> is used in each
class.</p>

<p>For example, one of the below loggers should probably be
removed.</p>

<pre>
class Foo{
    private static final Logger LOG = Logger.getLogger(Foo.class.getName());
    ...
    private static final Logger LOGGER = Logger.getLogger(Foo.class.getName());
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LoggerIsNotStaticFinal</id>
    <artifact tool="PMD" mnemonic="LoggerIsNotStaticFinal"/>
    <name>Logger is not static final</name>
    <shortMessage>Consider declaring this Logger to be static and final.</shortMessage>
    <info>
<![CDATA[<p>In most cases, the <code>Logger</code> can be declared
<code>static</code> and <code>final</code>.</p>

<p>For example, consider changing</p>

<pre>
class Foo{
  private Logger log = Logger.getLogger(Foo.class.getName());
  ...
}
</pre>

<p>to</p>

<pre>
class Foo{
  private static final Logger LOG = Logger.getLogger(Foo.class.getName());
  ...
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SystemPrintln</id>
    <artifact tool="PMD" mnemonic="SystemPrintln"/>
    <name>Use of System.out or System.err println()</name>
    <shortMessage>Avoid calls to System.(out|err).print, consider using a logger.</shortMessage>
    <info>
<![CDATA[<p>Avoid print calls to <code>System.out</code> or
<code>System.err</code>, consider using a logger instead.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidPrintStackTrace</id>
    <artifact tool="PMD" mnemonic="AvoidPrintStackTrace"/>
    <name>Avoid calls to printStackTrace()</name>
    <shortMessage>Avoid calls to printStackTrace(); use a logger call instead.</shortMessage>
    <info>
<![CDATA[<p>Avoid calls to <code>printStackTrace()</code> which dumps
the trace to <code>System.out</code>, consider using a logger call
instead.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ReplaceHashtableWithMap</id>
    <artifact tool="PMD" mnemonic="ReplaceHashtableWithMap"/>
    <name>Replace Hashtable with Map</name>
    <shortMessage>Consider replacing this Hashtable with the newer java.util.Map.</shortMessage>
    <info>
<![CDATA[<p>Consider replacing this <code>Hashtable</code> with the
newer <code>java.util.Map</code>.</p>

<p>The collections framework was released with JDK 1.2 and effectively
makes types such as <code>Vector</code>, </code>Hashtable</code>, and
<code>Enumeration</code> obsolete. Avoid using these types in newer
code. In general, the performance of the new collections will be
superior because they do not synchronize each of their methods.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ReplaceEnumerationWithIterator</id>
    <artifact tool="PMD" mnemonic="ReplaceEnumerationWithIterator"/>
    <name>Replace Enumeration with Iterator</name>
    <shortMessage>Consider replacing this Enumeration with the newer java.util.Iterator.</shortMessage>
    <info>
<![CDATA[<p>Consider replacing this <code>Enumeration</code> with the
newer <code>java.util.Iterator</code>.

<p>The collections framework was released with JDK 1.2 and effectively
makes types such as <code>Vector</code>, </code>Hashtable</code>, and
<code>Enumeration</code> obsolete. Avoid using these types in newer
code. In general, the performance of the new collections will be
superior because they do not synchronize each of their methods.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>JUnit4TestShouldUseBeforeAnnotation</id>
    <artifact tool="PMD" mnemonic="JUnit4TestShouldUseBeforeAnnotation"/>
    <name>JUnit 4 tests should use @Before</name>
    <shortMessage>Use the @Before annotation in JUnit 4.</shortMessage>
    <info>
<![CDATA[<p>In JUnit 3, the <code>setUp</code> method was used to set
up all data entities required in running tests. JUnit 4 skips the
<code>setUp</code> method and executes all methods annotated with
<code>@Before</code> before running each test.</p>

<p>For example, change</p>

<pre>
public void setUp() {
  // operations to do before running each test
}
</pre>

<p>to</p>

<pre>
@Before public void setUp() {
  // operations to do before running each test
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>JUnit4TestShouldUseAfterAnnotation</id>
    <artifact tool="PMD" mnemonic="JUnit4TestShouldUseAfterAnnotation"/>
    <name>JUnit 4 tests should use @After</name>
    <shortMessage>Use the @After annotation in JUnit 4.</shortMessage>
    <info>
<![CDATA[<p>In JUnit 3, the <code>tearDown</code> method was used to
clean up all data entities required in running tests. JUnit 4 skips
the <code>tearDown</code> method and executes all methods annotated
with <code>@After</code> after running each test</p>

<p>For example, change</p>

<pre>
public void tearDown() {
  // operations to do after running each test
}
</pre>

<p>to</p>

<pre>
@After public void tearDown() {
  // operations to do after running each test
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>JUnit4TestShouldUseTestAnnotation</id>
    <artifact tool="PMD" mnemonic="JUnit4TestShouldUseTestAnnotation"/>
    <name>JUnit 4 tests should use @Test</name>
    <shortMessage>Use the @Test annotation in JUnit 4.</shortMessage>
    <info>
<![CDATA[<p>In JUnit 3, the framework executed all methods which
started with the word <code>test</code> as a unit test. In JUnit 4,
only methods annotated with the <code>@Test</code> annotation are
executed.</p>

<p>For example, change</p>

<pre>
public void testStuff() {
  // do some testing
}
</pre>

<p>to</p>

<pre>
@Test public void testStuff() {
  // do some testing
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>JUnit4SuitesShouldUseSuiteAnnotation</id>
    <artifact tool="PMD" mnemonic="JUnit4SuitesShouldUseSuiteAnnotation"/>
    <name>JUnit 4 suites should use the suite annotation</name>
    <shortMessage>Use @RunWith(Suite.class) annotation rather than a suite() method.</shortMessage>
    <info>
<![CDATA[<p>In JUnit 3, test suites are indicated by the
<code>suite()</code> method.  In JUnit 4, suites are indicated through
the <code>@RunWith(Suite.class)</code> annotation.</p>

<p>For example, in you are using JUnit 4 change</p>

<pre>
public class BadExample extends TestCase{
  public static Test suite(){
    return new Suite();
  }
}
</pre>

<p>to</p>

<pre>
@RunWith(Suite.class)
@SuiteClasses( { TestOne.class, TestTwo.class } )
public class GoodTest {
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ShortVariable</id>
    <artifact tool="PMD" mnemonic="ShortVariable"/>
    <name>Short variable name</name>
    <shortMessage>Detects when a field, local, or parameter has a very short name.</shortMessage>
    <info>
<![CDATA[<p>Detects when a field, local, or parameter has a very short
name.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LongVariable</id>
    <artifact tool="PMD" mnemonic="LongVariable"/>
    <name>Long variable name</name>
    <shortMessage>Detects when a field, formal or local variable is declared with a long name.</shortMessage>
    <info>
<![CDATA[<p>Detects when a field, formal or local variable is declared
with a long name.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ShortMethodName</id>
    <artifact tool="PMD" mnemonic="ShortMethodName"/>
    <name>Short method name</name>
    <shortMessage>Detects when very short method names are used.</shortMessage>
    <info>
<![CDATA[<p>Detects when very short method names are used.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AbstractNaming</id>
    <artifact tool="PMD" mnemonic="AbstractNaming"/>
    <name>Abstract naming</name>
    <shortMessage>Abstract classes should be named AbstractX.</shortMessage>
    <info>
<![CDATA[<p>Abstract classes should be named
<code>Abstract</code><i>x</i>. Where <i>x</i> is the class name. This
convention can help to clarify the nature of the class.]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidDollarSigns</id>
    <artifact tool="PMD" mnemonic="AvoidDollarSigns"/>
    <name>Avoid dollar signs</name>
    <shortMessage>Avoid using dollar signs in variable/method/class/interface names.</shortMessage>
    <info>
<![CDATA[<p>Avoid using dollar signs in
variable/method/class/interface names. Dollar signs are typically only
used for generated class names.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SuspiciousConstantFieldName</id>
    <artifact tool="PMD" mnemonic="SuspiciousConstantFieldName"/>
    <name>Suspicious constant field name</name>
    <shortMessage>This field name is all uppercase characters, which in Sun's Java naming conventions indicate a constant. However, the field is not final.</shortMessage>
    <info>
<![CDATA[<p>A field name of all uppercase characters, by Sun's Java
naming conventions, indicates a constant. However, this field is not
<code>final</code>. Should this field be declared to be
<code>final</code>?</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidFieldNameMatchingTypeName</id>
    <artifact tool="PMD" mnemonic="AvoidFieldNameMatchingTypeName"/>
    <name>Avoid field name matching type name</name>
    <shortMessage>This class uses a name for both a field name and a type name. This can be confusing.</shortMessage>
    <info>
<![CDATA[<p>It is somewhat confusing to have a field name matching the
declaring class name. While this is totally legal, this probably means
that type and or field names could be more precise.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidFieldNameMatchingMethodName</id>
    <artifact tool="PMD" mnemonic="AvoidFieldNameMatchingMethodName"/>
    <name>Avoid field name matching method name</name>
    <shortMessage>This class uses a name for both a field name and a method name. This can be confusing.</shortMessage>
    <info>
<![CDATA[<p>It is somewhat confusing to have a field name with the
same name as a method. While this is totally legal, having information
(field) and actions (method) with the same name is not as clear as it
could be.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NoPackage</id>
    <artifact tool="PMD" mnemonic="NoPackage"/>
    <name>No package</name>
    <shortMessage>This class or interface does not have a package definition and is within the default package. This is not recommended.</shortMessage>
    <info>
<![CDATA[<p>A class or interface that does not have a package
definition is located within the default package. Placing classes and
interfaces in the default package is not recommended.</p>

<p>Consider placing this class or interface into a package.]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>PackageCase</id>
    <artifact tool="PMD" mnemonic="PackageCase"/>
    <name>Bad package case</name>
    <shortMessage>This package definition contains upper case characters.  This violates normal package naming convention.</shortMessage>
    <info>
<![CDATA[<p>When a package definition contains upper case characters
this violates package naming conventions.</p>

<p>Consider removing the upper case characters.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>MisleadingVariableName</id>
    <artifact tool="PMD" mnemonic="MisleadingVariableName"/>
    <name>Misleading variable name</name>
    <shortMessage>This local variable name starts with 'm_'. This convention usually indicates a field and thus is confusing.</shortMessage>
    <info>
<![CDATA[<p>A a non-field has a name starting with
<code>m_</code>. This usually indicates a field and thus is
confusing.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>BooleanGetMethodName</id>
    <artifact tool="PMD" mnemonic="BooleanGetMethodName"/>
    <name>Use isX() not getX()</name>
    <shortMessage>This boolean getter method is named getX().  Consider renaming this method to isX().</shortMessage>
    <info>
<![CDATA[<p>Methods named <code>getX()</code> that return a
<code>boolean</code> may be misnamed. The convention is to name these
methods <code>isX()</code>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LocalVariableCouldBeFinal</id>
    <artifact tool="PMD" mnemonic="LocalVariableCouldBeFinal"/>
    <name>Local variable could be final</name>
    <shortMessage>This local variable assigned only once can be declared final.</shortMessage>
    <info>
<![CDATA[<p>A local variable that is assigned only once can be
declared to be <code>final</code>.]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>MethodArgumentCouldBeFinal</id>
    <artifact tool="PMD" mnemonic="MethodArgumentCouldBeFinal"/>
    <name>Method argument could be final</name>
    <shortMessage>This method argument is never assigned can be declared final.</shortMessage>
    <info>
<![CDATA[<p>A method argument that is never assigned can be declared
to be <code>final</code>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidInstantiatingObjectsInLoops</id>
    <artifact tool="PMD" mnemonic="AvoidInstantiatingObjectsInLoops"/>
    <name>Avoid instantiating objects in loops</name>
    <shortMessage>This code is instantiating new objects inside of a loop. Can this be avoided?</shortMessage>
    <info>
<![CDATA[<p>Take care when creating new objects inside of a loop as
this may create a lot of objects. Is this creation intentional?</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UseArrayListInsteadOfVector</id>
    <artifact tool="PMD" mnemonic="UseArrayListInsteadOfVector"/>
    <artifact tool="PMD" mnemonic="ReplaceVectorWithList"/>
    <name>Prefer ArrayList over Vector</name>
    <shortMessage>This code uses the old Vector collection. Consider updating this to ArrayList (or LinkedList).</shortMessage>
    <info>
<![CDATA[<p>The collections framework was released with JDK 1.2 and
effectively makes types such as <code>Vector</code>,
</code>Hashtable</code>, and <code>Enumeration</code> obsolete. Avoid
using these types in newer code. In general, the performance of the
new collections will be superior because they do not synchronize each
of their methods.</p>

<p>If you use this <code>Vector</code> in concurrent code, you can use
<code>Collections.synchronizedList</code> method to "wrap" a list or
consider one of the collections provided in the
<code>java.util.concurrent</code> package.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SimplifyStartsWith</id>
    <artifact tool="PMD" mnemonic="SimplifyStartsWith"/>
    <name>Inefficient use of startsWith()</name>
    <shortMessage>Because it passes in a String literal of length 1, this call to String.startsWith() can be rewritten using String.charAt(0) to improve performance.</shortMessage>
    <info>
<![CDATA[<p>Because this code passes in a <code>String</code> literal
of length 1, this call to <code>String.startsWith()</code> can be
rewritten using <code>String.charAt(0)</code> to save some time.</p>

<p>For example, consider changing</p>

<pre>
boolean checkIt(String x) {
  return x.startsWith("a");
}
</pre>

<p>to</p>

<pre>
boolean checkIt(String x) {
  return x.charAt(0) == 'a';
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UseArraysAsList</id>
    <artifact tool="PMD" mnemonic="UseArraysAsList"/>
    <name>Use Arrays.asList()</name>
    <shortMessage>To create a list from an array consider using Arrays.asList() rather than a loop.</shortMessage>
    <info>
<![CDATA[<p>The class <code>java.util.Arrays</code> has an
<code>asList</code> method that should be used when you want to create
a new <code>List</code> from an array of objects. It is faster than
executing a loop to copy all the elements out of the array one by
one.</p>

<p>For example, consider the below code</p>

<pre>
Integer[] intArray = new Integer[100];
Arrays.fill(intArray, Integer.valueOf(2));

// Bad! creates a copy using a loop
List&lt;Integer&gt; l1 = new ArrayList&lt;Integer&gt;(100);
for (int i = 0; i < 100; i++) {
	l1.add(intArray[i]);
}

// Changes to this list also modify the array
List&lt;Integer&gt; l2 = Arrays.asList(intArray);

// This list is a copy (just like 'l1' that was created above)
List&lt;Integer&gt; l3 = new ArrayList&lt;Integer&gt;(Arrays.asList(intArray));

l2.set(0, Integer.valueOf(10)); // sets the first element of 'intArray' and 'l2'
System.out.println(Arrays.toString(intArray));
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidArrayLoops</id>
    <artifact tool="PMD" mnemonic="AvoidArrayLoops"/>
    <name>Avoid copying arrays with a loop</name>
    <shortMessage>This code appears to use a loop to copy data between two arrays. To improve performance, consider using System.arraycopy or one of the methods provide by the Arrays utility class.</shortMessage>
    <info>
<![CDATA[<p>Instead of using a loop to copy data between two arrays
use <code>System.arraycopy</code> or one of the <code>static</code>
method declared within the <code>Arrays</code> utility class.  This
can improve the performance of your program.</p>

<p>For example, consider the below code</p>

<pre>
int[] a = new int[10];
Arrays.fill(a, 30);

// Bad! uses a loop
int[] b1 = new int[10];
for (int i = 0; i < 10; i++) {
  b1[i] = a[i];
}

// this is better
int[] b2 = new int[10];
System.arraycopy(a, 0, b2, 0, 10);

// this is also better
int[] b3 = Arrays.copyOf(a, a.length);
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UnnecessaryWrapperObjectCreation</id>
    <artifact tool="PMD" mnemonic="UnnecessaryWrapperObjectCreation"/>
    <name>Avoid unnecessary wrapper object creation</name>
    <shortMessage>This code creates a wrapper object simply to convert from a String to a primitive type or from a primitive type to a String. Use the static parse or toString methods declared on the wrapper types instead.</shortMessage>
    <info>
<![CDATA[<p>There is not need to create a wrapper object simply to
convert from a <code>String</code> to a primitive type. Use the
<code>static</code> parse methods declared on the wrapper types instead.</p>

<p>There is also no need to create a wrapper object simply to convert
from a primitive type to a <code>String</code>. Use the
<code>static</code> <code>toString</code> methods declared on the
wrapper types instead.</p>

<p>For example, consider the below code.</p>

<pre>
int i, i2;

i = Integer.valueOf(s).intValue();          // Bad! this wastes an object
i = Integer.parseInt(s);                    // this is better

i2 = Integer.valueOf(i).intValue();         // Bad! this wastes an object
i2 = i;                                     // this is better

String s3 = Integer.valueOf(i2).toString(); // Bad! this wastes an object
s3 = Integer.toString(i2);                  // this is better
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AddEmptyString</id>
    <artifact tool="PMD" mnemonic="AddEmptyString"/>
    <name>Inefficient conversion to a String</name>
    <shortMessage>This code appears to convert a type to a String using an empty string literal and concatenation. To improve performance, consider using the toString() method on each wrapper type.</shortMessage>
    <info>
<![CDATA[<p>Using an empty string literal and concatenation is an
inefficient way to convert any type to a <code>String</code>.  Consider
using the <code>static</code> <code>toString()</code> method on each
wrapper type.</p>

<p>For example, consider changing</p>

<pre>
String s = "" + 123; // Bad!
</pre>

<p>to</p>

<pre>
String s = Integer.toString(123);
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidCatchingThrowable</id>
    <artifact tool="PMD" mnemonic="AvoidCatchingThrowable"/>
    <name>Avoid catching Throwable</name>
    <shortMessage>This code catches Throwable which is dangerous because it casts too wide of a net. Consider changing this to a more specific exception type that the block is actually designed to handle.</shortMessage>
    <info>
<![CDATA[<p>Catching <code>Throwable</code> is considered dangerous
because it casts too wide of a net; it can catch things like
<code>OutOfMemoryError</code> or <code>KernelError</code> that no
program can recover from.</p>

<p>It is recommended that this catch block be made more specific about
exactly what exception it is designed to handle.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SignatureDeclareThrowsException</id>
    <artifact tool="PMD" mnemonic="SignatureDeclareThrowsException"/>
    <name>Avoid methods that throw Exception</name>
    <shortMessage>This method declares that it may throw any exception. This is overly broad. Consider making this declaration more specific.</shortMessage>
    <info>
<![CDATA[<p>It is recommended that this method be more specific about
what exceptions it may actually throw.  Declaring that a method throws
<code>Exception</code> is considered overly broad.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ExceptionAsFlowControl</id>
    <artifact tool="PMD" mnemonic="ExceptionAsFlowControl"/>
    <name>Avoid using exceptions for flow control</name>
    <shortMessage>This code appears to use exceptions as control flow. This can lead to poorly preforming GOTO-like code and, in most cases, should be avoided.</shortMessage>
    <info>
<![CDATA[<p>Using Exceptions as flow control leads to GOTO-like code
and obscures true exceptions when debugging. In addition, the
performance of such code can be half of the performance of code that
avoids this confusing technique.</p>

<p>For example, the code below has the problem identified by this finding.</p>

<pre>
void bar() {
  try {
    try {
      // do something
    } catch (Exception e) {
      throw new WrapperException(e); // this is essentially a GOTO to the WrapperException catch block
    }
  } catch (WrapperException e) {
    // do something
  }
}
</pre>

<p>Most (but not all) APIs provide ways to avoid using exceptions for
control flow.</p>

<p>For further information please see Bloch's <i>Effective Java</i>
(second edition) item 57.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidCatchingNPE</id>
    <artifact tool="PMD" mnemonic="AvoidCatchingNPE"/>
    <name>Avoid catching NullPointerException</name>
    <shortMessage>This code catches a NullPointerException. Normal code should not catch this exception. Consider removing the catch block.</shortMessage>
    <info>
<![CDATA[<p>Code should never throw <code>NullPointerException</code>
under normal circumstances. Such a catch block may hide the original
programming error, causing other more subtle errors in its wake.</p>

<p>Consider removing this catch block unless this is test code or some
other special purpose code.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidThrowingRawExceptionTypes</id>
    <artifact tool="PMD" mnemonic="AvoidThrowingRawExceptionTypes"/>
    <name>Avoid throwing raw exception types</name>
    <shortMessage>This code throws a raw exception type. Consider throwing a subclassed exception or error instead.</shortMessage>
    <info>
<![CDATA[<p>Avoid throwing base exception types. Rather than throw a
raw <code>RuntimeException</code>, <code>Throwable</code>,
<code>Exception</code>, or <code>Error</code>, use a subclassed
exception or error instead.</p>

<p>Some commonly reused exceptions are:<p>

<table>
<tr><td><code>IllegalArgumentException</code></td></tr>
<tr><td><code>IllegalStateException</code></td></tr>
<tr><td><code>NullPointerException</code></td></tr>
<tr><td><code>IndexOutOfBoundsException</code></td></tr>
<tr><td><code>ConcurrentModificationException</code></td></tr>
<tr><td><code>UnsupportedOperationException</code></td></tr>
</table>

<p>For more information please see Bloch's <i>Effective Java</i>
(second edition) item 60.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidThrowingNullPointerException</id>
    <artifact tool="PMD" mnemonic="AvoidThrowingNullPointerException"/>
    <name>Avoid throwing NullPointerException</name>
    <shortMessage>This code explicitly throws a NullPointerException. This can be confusing. Consider throwing IllegalArgumentException instead.</shortMessage>
    <info>
<![CDATA[<p>Avoid throwing a
<code>NullPointerException</code>;ndash;it's confusing because most
people will assume that the virtual machine threw it. Consider
throwing an <code>IllegalArgumentException</code> instead; this will
be clearly seen as a programmer-initiated exception.</p>

<p>For example, consider changing</p>

<pre>
public void log(String msg) {
  if (msg == null) throw new NullPointerException("msg must be non-null");
  ...
}
</pre>

<p>to</p>

<pre>
public void log(String msg) {
  if (msg == null) throw new IllegalArgumentException("msg must be non-null");
  ...
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidRethrowingException</id>
    <artifact tool="PMD" mnemonic="AvoidRethrowingException"/>
    <name>Avoid rethrowing</name>
    <shortMessage>This code contains a catch block that seems to merely rethrow a caught exception. Consider removing this catch block.</shortMessage>
    <info>
<![CDATA[<p>Catch blocks that merely rethrow a caught exception only
add to code size and runtime complexity. Consider removing this catch
block.</p>

<p>For example, consider changing</p>

<pre>
void bar() {
  try {
    // do something
  }  catch (NullPointerException e) {
    throw e;
  }
}
</pre>

<p>to</p>

<pre>
void bar() {
  // do something
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DoNotExtendJavaLangError</id>
    <artifact tool="PMD" mnemonic="DoNotExtendJavaLangError"/>
    <name>Avoid extending java.lang.Error</name>
    <shortMessage>This class extends java.lang.Error. The Error type represents system exceptions and probably should not be extended. Consider extending RuntimeException instead.</shortMessage>
    <info>
<![CDATA[<p><code>Error</code>s are system exceptions. Do not extend
them. If you are trying to declare an unchecked exception that your
program can use then consider extending <code>RuntimeException</code>
instead.</p>

<p>For example, consider changing</p>

<pre>
public class Foo extends Error {
  // Bad!
}
</pre>

<p>to</p>

<pre>
public class Foo extends RuntimeException {
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidDuplicateLiterals</id>
    <artifact tool="PMD" mnemonic="AvoidDuplicateLiterals"/>
    <name>Avoid duplicate String literals</name>
    <shortMessage>This code contains duplicate String literals. Consider declaring the String as a constant field.</shortMessage>
    <info>
<![CDATA[<p>Code containing duplicate <code>String</code> literals can usually be
improved by declaring the <code>String</code> as a constant field.</p>

<p>For example, consider changing</p>

<pre>
class Foo {
  public void bar() {
    buz("Howdy");
    buz("Howdy");
    buz("Howdy");
    buz("Howdy");
  }

  public void buz(String msg) {
    System.out.println(msg);
  }
}
</pre>

<p>to</p>

<pre>
class Foo {
  private static final String HOWDY = "Howdy";

  public void bar() {
    buz(HOWDY);
    buz(HOWDY);
    buz(HOWDY);
    buz(HOWDY);
  }

  public void buz(String msg) {
    System.out.println(msg);
  }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>InefficientStringBuffering</id>
    <artifact tool="PMD" mnemonic="InefficientStringBuffering"/>
    <name>Inefficient StringBuffer concatenation</name>
    <shortMessage>This code concatenates non-literals in a StringBuffer constructor or append(). Consider avoiding this to improve performance.</shortMessage>
    <info>
<![CDATA[<p>It is best to avoid concatenating non-literals in a
<code>StringBuffer</code> constructor or </code>append()</code>.</p>

<p>For example, consider changing</p>

<pre>
StringBuffer sb = new StringBuffer("tmp = " + System.getProperty("java.io.tmpdir"));
</pre>

<p>to</p>

<pre>
StringBuffer sb = new StringBuffer("tmp = ");
sb.append(System.getProperty("java.io.tmpdir"));
</pre>

<p>If you are using JKD 1.5 or above it is strongly recommended that
you use <code>StringBuilder</code> rather than
<code>StringBuffer</code>. In most cases the use of
<code>StringBuilder</code> will improve code performance by avoid
unnecessary synchronization.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UnnecessaryCaseChange</id>
    <artifact tool="PMD" mnemonic="UnnecessaryCaseChange"/>
    <name>Unnecessary case change for equality check</name>
    <shortMessage>This code could be made faster by using equalsIgnoreCase() rather than toUpperCase/toLowerCase().equals().</shortMessage>
    <info>
<![CDATA[<p>Using <code>String.equalsIgnoreCase()</code> is faster
than using <code>toUpperCase()</code> or <code>toLowerCase()</code>
followed by a call to <code>equals()</code>. This is because a new
<code>String</code> does not need to be created.</p>

<p>For example, consider changing</p>

<pre>
String s = ...
if (s.toUpperCase.equals("SELECT")) {
  // do something
}
if (s.toUpperCase.equalsIgnoreCase("FROM")) {
  // do something
}
</pre>

<p>to</p>

<pre>
String s = ...
if (s.equalsIgnoreCase("SELECT")) {
  // do something
}
if (s.equalsIgnoreCase("FROM")) {
  // do something
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UseStringBufferLength</id>
    <artifact tool="PMD" mnemonic="UseStringBufferLength"/>
    <name>Use StringBuffer.length()</name>
    <shortMessage>It is recommended that you use StringBuffer.length() to determine the length of a StringBuffer.</shortMessage>
    <info>
<![CDATA[<p>Use <code>StringBuffer.length()</code> to determine the
length of a StringBuffer rather than converting to a
<code>String</code> via <code>StringBuffer.toString()</code> and then
making the check.</p>

<p>For example, consider changing</p>

<pre>
StringBuffer sb = new StringBuffer();
...
if (StringBuffer.toString().equals("")) {
  // do something
}
if (StringBuffer.toString().length() == 3) {
  // do something
}
</pre>

<p>to</p>

<pre>
StringBuffer sb = new StringBuffer();
...
if (StringBuffer.length == 0) {
  // do something
}
if (StringBuffer.length() == 3) {
  // do something
}
</pre>

<p>If you are using JKD 1.5 or above it is strongly recommended that
you use <code>StringBuilder</code> rather than
<code>StringBuffer</code>. In most cases the use of
<code>StringBuilder</code> will improve code performance by avoid
unnecessary synchronization.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AppendCharacterWithChar</id>
    <artifact tool="PMD" mnemonic="AppendCharacterWithChar"/>
    <name>Avoid appending a char as a String</name>
    <shortMessage>Avoid concatenating characters as strings with StringBuffer.append calls.</shortMessage>
    <info>
<![CDATA[<p>Avoid concatenating characters as strings with calls to
the <code>StringBuffer.append</code> method.</p>

<p>For example, consider changing</p>

<pre>
StringBuffer sb = new StringBuffer();
sb.append("a"); // Bad!
</pre>

<p>to</p>

<pre>
StringBuffer sb = new StringBuffer();
sb.append('a');
</pre>

<p>If you are using JKD 1.5 or above it is strongly recommended that
you use <code>StringBuilder</code> rather than
<code>StringBuffer</code>. In most cases the use of
<code>StringBuilder</code> will improve code performance by avoid
unnecessary synchronization.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ConsecutiveLiteralAppends</id>
    <artifact tool="PMD" mnemonic="ConsecutiveLiteralAppends"/>
    <name>Consecutive String literal appends</name>
    <shortMessage>This code makes several consecutively calls to StringBuffer.append with String literals. Consider consolidating all the literals into one.</shortMessage>
    <info>
<![CDATA[<p>It is inefficient to repeatably call
<code>StringBuffer.append(String)</code> with string literals.
Consider consolidating all the literals into one call.</p>

<p>For example, consider changing</p>

<pre>
StringBuffer buf = new StringBuffer();
buf.append("Hello").append(" ").append("World"); // Bad!
</pre>

<p>to</p>

<pre>
StringBuffer buf = new StringBuffer();
buf.append("Hello World");
</pre>

<p>If you are using JKD 1.5 or above it is strongly recommended that
you use <code>StringBuilder</code> rather than
<code>StringBuffer</code>. In most cases the use of
<code>StringBuilder</code> will improve code performance by avoid
unnecessary synchronization.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UseIndexOfChar</id>
    <artifact tool="PMD" mnemonic="UseIndexOfChar"/>
    <name>Inefficient use of String.indexOf()</name>
    <shortMessage>This code can improve its performance by using String.indexOf(char) when checking for the index of a single character.</shortMessage>
    <info>
<![CDATA[<p>Use <code>String.indexOf(char)</code> rather than
<code>String.indexOf(String)</code> when checking for the index of a
single character because it executes faster.</p>

<p>For example, consider changing</p>

<pre>
if (s.indexOf("d") {  // Bad!
  // do something
}
</pre>

<p>to</p>

<pre>
if (s.indexOf('d') {
  // do something
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>InefficientEmptyStringCheck</id>
    <artifact tool="PMD" mnemonic="InefficientEmptyStringCheck"/>
    <name>Inefficient empty string check</name>
    <shortMessage>This code is an inefficient approach to check if a string is whitespace-only or empty.  Consider using the StringUtils.isBlank method from Apache Commons Lang library. </shortMessage>
    <info>
<![CDATA[<p>Using <code>String.trim().length() == 0</code> is an
inefficient way to check if a <code>String</code> is really empty
except for whitespace. This is because it creates a new String object
just to check its size.</p>

<p>One solution is to include the <a
href="http://commons.apache.org/lang/">Apache Commons Lang</a> library
in your code and use the <code>StringUtils</code> utility.  The
<code>isBlank</code> method checks if a string is whitespace, empty,
or <code>null</code>.  For example, you would change</p>

<pre>
if (s.trim().length() == 0) { // Bad!
  // do something
}
</pre>

<p>to</p>

<pre>
if (StringUtils.isBlank(s)) {
  // do something
}
</pre>

<p>If you do not want to use the Apache Commons Lang library then
consider creating a static function that loops through a string,
checking <code>Character.isWhitespace()</code> on each character and
returning false if a non-whitespace character is found.  The code
Apache uses is</p>

<pre>
public static boolean isBlank(String str) {
  int strLen;
  if (str == null || (strLen = str.length()) == 0) {
    return true;
  }
  for (int i = 0; i < strLen; i++) {
    if ((Character.isWhitespace(str.charAt(i)) == false)) {
      return false;
    }
  }
  return true;
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>InsufficientStringBufferDeclaration</id>
    <artifact tool="PMD" mnemonic="InsufficientStringBufferDeclaration"/>
    <name>Insufficient StringBuffer initial size</name>
    <shortMessage>This code fails to pre-size a StringBuffer which may cause it to resize many times.  Consider passing a larger initial capacity to the StringBuffer constructor.</shortMessage>
    <info>
<![CDATA[<p>Failing to pre-size a <code>StringBuffer</code> properly
can cause it to re-size many times. This rule checks the characters
that are actually passed into <code>StringBuffer.append()</code>
method and tries to make a best guess about the "worst case" scenario
with regard to overall size. An empty <code>StringBuffer</code>
constructor sets the initial capacity of the object to 16
characters. This default is assumed if the length of the constructor
can not be determined.</p>

<pre>
StringBuffer bad = new StringBuffer();
bad.append("This is a long string, will exceed the default 16 characters");

StringBuffer good = new StringBuffer(41);
good.append("This is a long string, which is pre-sized");
</pre>

<p>Being more accurate with your initial capacity can help to improve
your program's performance.</p>

<p>If you are using JKD 1.5 or above it is strongly recommended that
you use <code>StringBuilder</code> rather than
<code>StringBuffer</code>. In most cases the use of
<code>StringBuilder</code> will improve code performance by avoid
unnecessary synchronization.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UselessStringValueOf</id>
    <artifact tool="PMD" mnemonic="UselessStringValueOf"/>
    <name>Unnecessary String.valueOf() call</name>
    <shortMessage>This code calls String.valueOf() to append to a String. Consider just using the + operator.</shortMessage>
    <info>
<![CDATA[<p>There is no need to call <code>String.valueOf()</code> to
append to a string.  Just use <code>+</code>.</p>

<p>For example, consider changing the below code</p>

<pre>
public String convert(int i) {
  String s = "a" + String.valueOf(i); // Bad!
  return s;
}
</pre>

<p>to</p>

<pre>
public String convert(int i) {
  String s = "a" + i;
  return s;
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>StringBufferInstantiationWithChar</id>
    <artifact tool="PMD" mnemonic="StringBufferInstantiationWithChar"/>
    <name>Confusing StringBuffer instantiation with char</name>
    <shortMessage>This code instantiates a StringBuffer object with a char, e.g., StringBuffer sb = new StringBuffer('c').  However, the char will be converted into int to initialize StringBuffer size.</shortMessage>
    <info>
<![CDATA[<p>Calling the <code>StringBuffer</code> constructor with a
<code>char</code> causes the <code>char</code> to be converted to an
<code>int</code> to initialize the <code>StringBuffer</code> size.

<p>For example, if the intent is to place the character in the
<code>StringBuffer</code> then change</p>

<pre>
StringBuffer sb = new StringBuffer('c'); // Bad!
</pre>

<p>to</p>

<pre>
StringBuffer sb = new StringBuffer("c");
</pre>

<p>If you are using JKD 1.5 or above it is strongly recommended that
you use <code>StringBuilder</code> rather than
<code>StringBuffer</code>. In most cases the use of
<code>StringBuilder</code> will improve code performance by avoid
unnecessary synchronization.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ArrayIsStoredDirectly</id>
    <artifact tool="PMD" mnemonic="ArrayIsStoredDirectly"/>
    <name>Avoid storing a passed array</name>
    <shortMessage>This code takes an array as a parameter and stores it directly to a field. Consider making a defensive copy of the array.</shortMessage>
    <info>
<![CDATA[<p>This code stores an array directly to a field. This makes
this code susceptible to mutations made by code that still has a
reference to this array and its contents. Consider making a defensive
copy of the array and its contents.  this prevents future change by
outside code from effecting this class.</p>

<p>For example, consider changing</p>

<pre>
public class Foo {
  private String [] x;

  public void foo (String [] param) {
    // Bad!
    this.x = param;
  }
}
</pre>

<p>to</p>

<pre>
public class Foo {
  private String [] x;

  public void foo (String [] param) {
    this.x = Arrays.copyOf(param, param.length);
  }
}</pre>

<p>Note that in this example the contents of the array are immutable
strings. Hence, we do not need to clone the contents in this example.
In general, you will need to consider if the contents of the array
need to be cloned.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UnusedLocalVariable</id>
    <artifact tool="PMD" mnemonic="UnusedLocalVariable"/>
    <name>Unused local variable</name>
    <shortMessage>This local variable is declared but it is never read. Consider removing it.</shortMessage>
    <info>
<![CDATA[<p>This local variable is declared but it is never
read. Consider removing it from your code.</p>

<p>For example, consider changing</p>

<pre>
public void doSomething() {
  int i = 5; // unused
  System.out.println("doing something");
}
</pre>

<p>to</p>

<pre>
public void doSomething() {
  System.out.println("doing something");
}</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UnusedFormalParameter</id>
    <artifact tool="PMD" mnemonic="UnusedFormalParameter"/>
    <name>Unused parameter</name>
    <shortMessage>This code accepts a parameter then appears to never use it. Avoid passing parameters to methods or constructors and then
      not using those parameters. Consider removing the parameter.</shortMessage>
    <info>
<![CDATA[<p>Avoid passing parameters to methods or constructors and
then not using those parameters.</p>

<p>For example, consider changing<p>

<pre>
 private void bar(String howdy) {
   System.out.println("bar");
}
</pre>

<p>to</p>

<pre>
private void bar() {
   System.out.println("bar");
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidUsingHardCodedIP</id>
    <artifact tool="PMD" mnemonic="AvoidUsingHardCodedIP"/>
    <name>Avoid hardcoded IP addresses</name>
    <shortMessage>Avoid using hard-coded IP address</shortMessage>
    <info>
<![CDATA[<p>An application with hard coded IP may become impossible to
deploy in some cases. It never hurts to externalize IP
addresses.</p>

<pre>
public class Foo {
  private final String ip = "127.0.0.1"; // This is a bad idea !
  ...
}
</pre>]]>
    </info>
  </findingType>	
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>CheckResultSet</id>
    <artifact tool="PMD" mnemonic="CheckResultSet"/>
    <name>Check return values from ResultSet method calls</name>
    <shortMessage>This code appears to ignore the the return value from a call on a ResultSet method. The code should deal with this return value explicitly to handle problems.</shortMessage>
    <info>
<![CDATA[<p>Always check the return value from calling
<code>ResultSet.{next,previous,first,last}</code>.  If the return
value is false, the code should deal with it explicitly.</p>

<p>For example, the below code<p>

<pre>
// Bad! ignores what 'next()' returns
Statement stat = conn.createStatement();
ResultSet rst  = stat.executeQuery("SELECT name FROM person");
rst.next();  // what if it returns 'false'?
String firstName = rst.getString(1);
</pre>

<p>should be changed to</p>

<pre>
Statement stat = conn.createStatement();
ResultSet rst  = stat.executeQuery("SELECT name FROM person");
if (rst.next()) {
  String firstName = rst.getString(1);
} else {
  // here you deal with the error...at least log it and recover
}
</pre>]]>
    </info>
  </findingType>		
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidUsingShortType</id>
    <artifact tool="PMD" mnemonic="AvoidUsingShortType"/>
    <name>Avoid using short</name>
    <shortMessage>Avoid using the short type as it can adversely impact the performance of your code.</shortMessage>
    <info>
<![CDATA[<p>Java uses the <code>short</code> type to reduce memory
usage, not to optimize calculation. On the contrary, the JVM does not
has any arithmetic capabilities with the <code>short</code> type, so
it must convert the <code>short</code> into <code>int</code>, then do
the proper calculation and then convert int back to short. Therefore,
use of the <code>short</code> type may actually be slower than using
<code>int</code>.</p>

<pre>
public class UsingShort {
  private short doNotUseShort = 0;

  public UsingShort() {
    short shouldNotBeUsed = 1;
    doNotUseShort += shouldNotBeUsed;
  }
}
</pre>]]>
    </info>
  </findingType>	
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidUsingVolatile</id>
    <artifact tool="PMD" mnemonic="AvoidUsingVolatile"/>
    <name>Avoid using volatile fields</name>
    <shortMessage>Avoid using volatile fields.</shortMessage>
    <info>
<![CDATA[<p>The <code>volatile</code> keyword is generally used to
fine tune a concurrent Java application, and therefore, requires a
expert knowledge of the Java Memory Model.  Moreover, it is often
misused. Therefore, consider carefully if this use of the
<code>volatile</code> keyword is correct.</p>

<p>It is also recommended to consider if the use of one of the atomic
classes from util.concurrent is a better implementation
choice.  For example, the below code</p>
<pre>
public class ThrDeux {
  private volatile int counter = 1;
  private volatile String var = "Hi";
}
</pre>

<p>could be changed to</p>

<pre>
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;

public class ThrDeux {
  private final AtomicInteger counter = new AtomicInteger(1);
  private final AtomicReference&lt;String&gt; var = new AtomicReference&lt;String&gt;("Hi");
}
</pre>]]>
    </info>
  </findingType>	
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidUsingNativeCode</id>
    <artifact tool="PMD" mnemonic="AvoidUsingNativeCode"/>
    <name>Avoid using native code (JNI)</name>
    <shortMessage>Avoid using native code. Try to reimplement so that JNI is not needed.</shortMessage>
    <info>
<![CDATA[<p>The Java language allows for a wide range of
functionality, so it should be very rare to have to rely on non-Java
code, and in particular, on the Java Native Interface (JNI).  Since
the use of JNI makes an application less portable, and harder to
maintain, it is not recommended.</p>]]>
    </info>
  </findingType>	
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidAccessibilityAlteration</id>
    <artifact tool="PMD" mnemonic="AvoidAccessibilityAlteration"/>
    <name>Avoid changing class/method accessibility at runtime</name>
    <shortMessage>Avoid changing class/method accessibility at runtime.</shortMessage>
    <info>
<![CDATA[<p>Methods in <code>java.lang.reflect</code>, such as
<code>getDeclaredConstructors()</code>, <code>getDeclaredConstructor(Class[])</code> and
<code>setAccessible()</code>, allow someone to alter, at runtime, the accessibility
of fields, classes, or methods, even if they are declared to be <code>private</code>.</p>

<pre>
import java.lang.reflect.AccessibleObject;
import java.lang.reflect.Method;
import java.security.PrivilegedAction;

public class Violation {
  public void invalidCallsInMethod() throws SecurityException, NoSuchMethodException {
    // Possible call to forbidden getDeclaredConstructors
    Class[] arrayOfClass = new Class[1];
    this.getClass().getDeclaredConstructors();
    this.getClass().getDeclaredConstructor(arrayOfClass);
    Class clazz = this.getClass();
    clazz.getDeclaredConstructor(arrayOfClass);
    clazz.getDeclaredConstructors();

    // Possible call to forbidden setAccessible
    clazz.getMethod("", arrayOfClass).setAccessible(false);
    AccessibleObject.setAccessible(null, false);
    Method.setAccessible(null, false);
    Method[] methodsArray = clazz.getMethods();
    int nbMethod;
    for ( nbMethod = 0; nbMethod < methodsArray.length; nbMethod++ ) {
      methodsArray[nbMethod].setAccessible(false);
    }

    // Possible call to forbidden PrivilegedAction
    PrivilegedAction priv = (PrivilegedAction) new Object(); priv.run();
  }
}
</pre>

<p>There are legitimate specialized uses of these methods, but
observer caution that a security risk is not being introduced into
your system if their use is allowed.</p>]]>
    </info>
  </findingType>	
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ClassWithOnlyPrivateConstructorsShouldBeFinal</id>
    <artifact tool="PMD" mnemonic="ClassWithOnlyPrivateConstructorsShouldBeFinal"/>
    <name>Class with only private constructors should be final</name>
    <shortMessage>A class which only has private constructors should be declared final.</shortMessage>
    <info>
<![CDATA[<p>A class with only private constructors should be final,
unless the private constructor is called by a inner class.  The code below</p>

<pre>
public class Foo {
  private Foo() { ... }
  // no other constructors or inner classes
  ...
}
</pre>

<p>could be changed to</p>

<pre>
public final class Foo {
  private Foo() { ... }
  // no other constructors or inner classes
  ...
}
</pre>]]>
    </info>
  </findingType>	
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EmptyMethodInAbstractClassShouldBeAbstract</id>
    <artifact tool="PMD" mnemonic="EmptyMethodInAbstractClassShouldBeAbstract"/>
    <name>Empty method in abstract class should be abstract</name>
    <shortMessage>Consider if an empty method in an abstract class should be abstract.</shortMessage>
    <info>
<![CDATA[<p>An empty method in an abstract class should instead be
abstract, as developer may rely on this empty implementation, rather
than code an appropriate one.  The code below</p>

<pre>
public abstract class ShouldBeAbstract {
  public Object couldBeAbstract() {
    return null;
  }
  public void couldBeAbstractToo() {
  }
}
</pre>

<p>could be changed to</p>

<pre>
public abstract class ShouldBeAbstract {
  public abstract Object couldBeAbstract();
  public abstract void couldBeAbstractToo();
}
</pre>

<p>One exception to this rule of thumb is if the class is providing a
reasonable default behavior that is to do nothing.</p>]]>
    </info>
  </findingType>	
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>TooManyStaticImports</id>
    <artifact tool="PMD" mnemonic="TooManyStaticImports"/>
    <name>Too many static imports</name>
    <shortMessage>Too many static imports may lead to unmaintainable code.</shortMessage>
    <info>
<![CDATA[<p>If you overuse the static import feature it can make your
program unreadable and unmaintainable.  This feature pollutes the
namespace with all the imported static members.  Readers of your code
(including you, a few months after you wrote it) will not know which
class a static member comes from (Sun 1.5 Language Guide).</p>

<pre>
import static Lennon;
import static Ringo;
import static George;
import static Paul;
import static Yoko; // Too much !
</pre>]]>
    </info>
  </findingType>	
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>StaticEJBFieldShouldBeFinal</id>
    <artifact tool="PMD" mnemonic="StaticEJBFieldShouldBeFinal"/>
    <name>Static EJB fields should be final</name>
    <shortMessage>EJB's shouldn't have non-final static fields.  This can cause bugs when the container distributes the application across several JREs.</shortMessage>
    <info>
<![CDATA[<p>According to the J2EE specification (reference section
21.1.2 of the EJB 3.0 Specification), an EJB should not have any
static fields with write access. However, static read-only fields are
allowed.  This ensures proper behavior, especially when instances are
distributed by the container across several JREs.</p>]]>
    </info>
  </findingType>	
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DoNotUseThreads</id>
    <artifact tool="PMD" mnemonic="DoNotUseThreads"/>
    <name>Do not use threads in a J2EE web application</name>
    <shortMessage>To be J2EE-compliant, a web application should not use any threads.</shortMessage>
    <info>
<![CDATA[<p>The J2EE specification explicitly forbids the use of
threads within a container-based application (reference section 21.1.2
of the EJB 3.0 Specification)</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidMultipleUnaryOperators</id>
    <artifact tool="PMD" mnemonic="AvoidMultipleUnaryOperators">
    </artifact>
    <name>Avoid using multiple unary operators</name>
    <shortMessage>Avoid using multiple unary operators to make your code clearer.</shortMessage>
    <info>
<![CDATA[<p>Using multiple unary operators may be a bug.  It can also
be confusing.  Check that the usage is not a bug and consider
simplifying the expression.</p>

<pre>
// These are typo bugs, or at best needlessly complex and confusing:
int i = - -1;
int j = + - +1;
int z = ~~2;
boolean b = !!true;
boolean c = !!!true;

// These are better:
int i = 1;
int j = -1;
int z = 2;
boolean b = true;
boolean c = false;

// And these just make your brain hurt:
int i = ~-2;
int j = -~7;
</pre>]]>
    </info>
  </findingType>	
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>TooManyMethods</id>
    <artifact tool="PMD" mnemonic="TooManyMethods"/>
    <name>Avoid classes with too many methods</name>
    <shortMessage>A class with too many methods may indicate poor object-oriented design.</shortMessage>
    <info>
<![CDATA[<p>A class with too many methods is probably a good prospect
for refactoring in order to reduce its complexity and find a way to
have more fine grained objects.</p>]]>
    </info>
  </findingType>		
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AbstractClassWithoutAnyMethod</id>
    <artifact tool="PMD" mnemonic="AbstractClassWithoutAnyMethod"/>
    <name>No abstract methods in an abstract class</name>
    <shortMessage>No abstract methods in abstract class, consider other approaches to prevent instantiation.</shortMessage>
    <info>
<![CDATA[<p>If the abstract class does not provides any methods, it
may be just a data container that is not to be instantiated. In this
case, it's probably better to use a private or a protected constructor
in order to prevent instantiation than make the class misleadingly
abstract.</p>

<pre>
public abstract class Foo {
  void int method1() { ... }
  void int method2() { ... }
  // consider using abstract methods or removing
  // the abstract modifier and adding protected constructors
}
</pre>]]>
    </info>
  </findingType>				
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>TooFewBranchesForASwitchStatement</id>
    <artifact tool="PMD" mnemonic="TooFewBranchesForASwitchStatement"/>
    <name>Avoid switch statements with only a few branches</name>
    <shortMessage>Avoid switch statements with only a few branches. Use an if statement instead.</shortMessage>
    <info>
<![CDATA[<p>Switch statements are designed complex branches, and allow
branches to share treatment. Using a <code>switch</code> for only two
branches is ill advised, as switches are not as easy to understand as
<code>if</code> statements.</p>

<pre>
public void bar() {
  switch (condition) {
  case ONE:
    // do something
    break;
  default:
    // do something
    break; // not enough for a 'switch', a simple 'if' would be more appropriate
  }
}
</pre>

<p>In this case, it's most likely is a good idea to use a
<code>if</code> statement instead, at least to increase code
readability.</p>]]>
    </info>
  </findingType>					  	
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DoNotThrowExceptionInFinally</id>
    <artifact tool="PMD" mnemonic="DoNotThrowExceptionInFinally"/>
    <name>Avoid throwing exceptions in finally clauses</name>
    <shortMessage>Avoid throwing exceptions in finally clauses. It is confusing and may mask exceptions or code defects.</shortMessage>
    <info>
<![CDATA[<p>Throwing exceptions in a finally block is confusing.  It
may mask exceptions or a code defect.  Further, it may render code
cleanup unstable.</p>

<pre>
public void bar() {
  try {
    // Here do some stuff
  } catch( Exception e) {
    // Handling the issue
  } finally {
    // is this really a good idea ?
    throw new Exception();
  }
}
</pre>

<p>It is highly recommended to redesign the implementation of this
code.</p>]]>
    </info>
  </findingType>				  	
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidStringBufferField</id>
    <artifact tool="PMD" mnemonic="AvoidStringBufferField"/>
    <name>Avoid StringBuffer-typed fields</name>
    <shortMessage>Avoid keeping StringBuffer objects as a field.</shortMessage>
    <info>
<![CDATA[<p><code>StringBuffer</code> objects can grow quite a lot,
and can become a source of memory leaks (if the owning class has a
long life time).</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>IGNORE</id>
    <artifact tool="FindBugs" mnemonic="UNKNOWN"/>                   <!-- FindBugs diagnostic -->
    <artifact tool="FindBugs" mnemonic="UOE_USE_OBJECT_EQUALS"/>     <!-- Bill Pugh thinks this is bad, good enough for me -->
    <artifact tool="PMD" mnemonic="OverrideBothEqualsAndHashcode"/>  <!-- FindBugs splits this up w/ better reporting -->
    <artifact tool="PMD" mnemonic="AvoidFinalLocalVariable"/>        <!-- This is just a bad analysis -->
    <artifact tool="PMD" mnemonic="JUnitUseExpected"/>               <!-- Stange PMD analysis -->
    <name>Ignored tool artifacts</name>
    <shortMessage>Findings in this finding type can be ignored.</shortMessage>
    <info>
<![CDATA[This is special finding type that contains all tool artifacts
that Sierra ignores.  The tool artifact may be ignored if another tool
has a superior analysis or if it is a tool diagnostic report.]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
</findingTypes>
