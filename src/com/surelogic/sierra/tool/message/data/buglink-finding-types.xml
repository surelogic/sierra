<?xml version="1.0" encoding="UTF-8"?>
<findingTypes>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <!-- NOTES:                                                                        -->
  <!-- o No whitespace in "name" or "shortMessage" tags                              -->
  <!-- o Sentence case in "name" tags                                                -->
  <!-- o Sentences in "shortMessage" tags (no HTML)                                  -->
  <!-- o Use CDATA for "info" tags with HTML; do NOT indent CDATA sections           -->
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DuplicatedCode</id>
    <artifact tool="CPD" mnemonic="DuplicatedCode"/>
    <name>Suspected duplicated code</name>
    <shortMessage>Duplicated code often causes problems in long-term maintenance, due to flaws being fixed in one copy, but not the other.</shortMessage>
    <info><![CDATA[<p>This is often due to copy-and-paste programming, and it
often causes problems in long-term maintenance, due to flaws being
fixed in one copy, but not the other.</p>

<p>Consider refactoring this duplicated code into a single
method.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DMI_VACUOUS_CALL_TO_EASYMOCK_METHOD</id>
    <artifact tool="FindBugs" mnemonic="DMI_VACUOUS_CALL_TO_EASYMOCK_METHOD"/>
    <name>Useless/vacuous call to EasyMock method</name>
    <shortMessage>Useless/vacuous call to EasyMock method.</shortMessage>
    <info>
<![CDATA[<p>This call doesn't pass any objects to the EasyMock method,
so the call doesn't do anything.</p> <p>EasyMock provides Mock Objects
for interfaces in JUnit tests by generating them on the fly using
Java's proxy mechanism.  For more information please visit <a
href="http://www.easymock.org/">www.easymock.org</a>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>HE_SIGNATURE_DECLARES_HASHING_OF_UNHASHABLE_CLASS</id>
    <artifact tool="FindBugs" mnemonic="HE_SIGNATURE_DECLARES_HASHING_OF_UNHASHABLE_CLASS"/>
    <name>Signature declares use of unhashable class in hashed construct</name>
    <shortMessage>Signature declares use of unhashable class in hashed construct.</shortMessage>
    <info>
<![CDATA[<p> A method, field or class declares a generic signature
where a non-hashable class is used in context where a hashable class
is required.  A class that declares an <code>equals()</code> method
but inherits a <code>hashCode()</code> method from
<code>java.lang.Object</code> is unhashable, since it doesn't fulfill
the requirement that equal objects have equal hash codes.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>GC_UNCHECKED_TYPE_IN_GENERIC_CALL</id>
    <artifact tool="FindBugs" mnemonic="GC_UNCHECKED_TYPE_IN_GENERIC_CALL"/>
    <name>Unchecked type in generic call</name>
    <shortMessage>Unchecked type in a generic call.  This could be a type mismatch that the compiler is not able to detect.</shortMessage>
    <info>
<![CDATA[<p>This call to a generic collection method passes an
argument of compile type <code>Object</code> where a specific type
from the generic type parameters is expected.  Thus, neither the
standard Java type system nor static analysis can provide useful
information on whether the object being passed as a parameter is of an
appropriate type.</p>

<p>An example of this finding is shown in the code snippet below.</p>

<pre>
final Object o = "1";
Set&lt;Integer&gt; intSet = new HashSet&lt;Integer&gt;();
intSet.remove(o);
</pre>

<p>In this case the call to remove <code>o</code> from the set
compiles because the <code>remove()</code> method takes an argument of
type <code>Object</code> rather than of the generic type (for
backwards compatibility).  In this example the call to
<code>remove()</code> can be safely deleted.  In general, it is
recommended to examine the finding and determine if it has identified
a type mismatch that the compiler was not able to report.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SW_SWING_METHODS_INVOKED_IN_SWING_THREAD</id>
    <artifact tool="FindBugs" mnemonic="SW_SWING_METHODS_INVOKED_IN_SWING_THREAD"/>
    <name>Swing methods should be invoked in Swing thread</name>
    <shortMessage>Certain Swing methods need to be invoked in the Swing event dispatch thread.</shortMessage>
    <info>
<![CDATA[<p>(<a
href="http://java.sun.com/developer/JDCTechTips/2003/tt1208.html#1">From
JDC Tech Tips</a>): The Swing methods <code>show()</code>,
<code>setVisible()</code>, and <code>pack()</code> will create the
associated peer for the frame. With the creation of the peer, the
system creates the event dispatch thread. This makes things
problematic because the event dispatch thread could be notifying
listeners while pack and validate are still processing. This situation
could result in two threads going through the Swing component-based
GUI&mdash;it's a serious flaw that could result in deadlocks or other
related threading issues. A pack call causes components to be
realized. As they are being realized (that is, not necessarily
visible), they could trigger listener notification on the event
dispatch thread.</p>

<p>Recommendations for thread safety have changed slightly since this
article was written. It is now recommended that you use
<code>invokeLater()</code> to create the GUI on the event-dispatching
thread, rather than constructing the GUI on the main thread.  So the
below code violates this recommendation.</p>

<pre>
import javax.swing.JButton;
import javax.swing.JFrame;

public class GUI extends JFrame {

  public GUI() {
    super("GUI");
    setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
    final JButton button = new JButton("Hello, Swing!");
    add(button);
    pack();
  }

  public static void main(String[] args) {
    final GUI gui = new GUI();
    gui.setVisible(true);
 }
}
</pre>

<p>At issue is the construction of the Swing objects and the call to
<code>setVisible()</code> in the main thread.  The below code fixes
the program by moving these actions onto the event dispatch
thread using the <code>invokeLater()</code> method.</p>

<pre>
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.SwingUtilities;

public class GUI extends JFrame {

  public GUI() {
    super("GUI");
    setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
    final JButton button = new JButton("Hello, Swing!");
    add(button);
    pack();
  }

  public static void main(String[] args) {
    SwingUtilities.invokeLater(new Runnable() {
      @Override public void run() {
        final GUI gui = new GUI();
        gui.setVisible(true);
      }
    });
  }
}
</pre>
]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>IL_INFINITE_LOOP</id>
    <artifact tool="FindBugs" mnemonic="IL_INFINITE_LOOP">
    </artifact>
    <name>Caught infinite loop</name>
    <shortMessage>An apparent infinite loop that doesn't seem to have a way to terminate.</shortMessage>
    <info>
<![CDATA[<p>This loop doesn't seem to have a way to terminate (other
than by perhaps throwing an exception).</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>IL_INFINITE_RECURSIVE_LOOP</id>
    <artifact tool="FindBugs"
	      mnemonic="IL_INFINITE_RECURSIVE_LOOP">
    </artifact>
    <name>Caught infinite recursive loop</name>
    <shortMessage>An apparent infinite recursive loop that could result in a stack overflow.</shortMessage>
    <info>
<![CDATA[<p>This method unconditionally invokes itself. This would
seem to indicate an infinite recursive loop that will result in a
stack overflow.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>IL_CONTAINER_ADDED_TO_ITSELF</id>
    <artifact tool="FindBugs"
	      mnemonic="IL_CONTAINER_ADDED_TO_ITSELF">
    </artifact>
    <name>Container added to itself</name>
    <shortMessage>A container is added to itself, computing its hash code could throw a StackOverflowException.</shortMessage>
    <info>
<![CDATA[<p>A container is added to itself. As a result, computing the
hash code via <code>hashCode()</code> will throw a
StackOverflowException.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>VO_VOLATILE_REFERENCE_TO_ARRAY</id>
    <artifact tool="FindBugs"
	      mnemonic="VO_VOLATILE_REFERENCE_TO_ARRAY">
    </artifact>
    <name>Volatile reference to array</name>
    <shortMessage>A volatile reference to an array doesn't treat the array elements as volatile.  This could indicate a race condition.</shortMessage>
    <info>
<![CDATA[<p>This declares a volatile reference to an array, which
might not be what you want. With a volatile reference to an array,
reads and writes of the reference to the array are treated as
volatile, but the array elements are non-volatile. To get volatile
array elements, you will need to use one of the atomic array classes
in java.util.concurrent (provided in Java 5.0).<p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UI_INHERITANCE_UNSAFE_GETRESOURCE</id>
    <artifact tool="FindBugs"
	      mnemonic="UI_INHERITANCE_UNSAFE_GETRESOURCE"/>
    <name>Unsafe inheritance of the getResource method</name>
    <shortMessage>Usage of the getResource method may be unsafe if class is extended.</shortMessage>
    <info>
<![CDATA[<p>Calling <code>this.getClass().getResource(...)</code>
could give results other than expected if this class is extended by a
class in another package.</p>

<p>To prohibit extension of this class it can be declared to be
final.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NP_SYNC_AND_NULL_CHECK_FIELD</id>
    <artifact tool="FindBugs"
	      mnemonic="NP_SYNC_AND_NULL_CHECK_FIELD"/>
    <name>Synchronize and subsequent null check on the same field</name>
    <shortMessage>Synchronize and subsequent null check on the same field could indicate that a NullPointerException may be thrown.</shortMessage>
    <info>
<![CDATA[<p>This field is not likely to be <code>null</code> because
it is currently synchronized on. If the field is <code>null</code>
when it is synchronized then a <code>NullPointerException</code> will
be thrown and the subsequent check would be pointless.</p>

<p>This finding might indicated a muddled design or a lack of
understanding of Java semantics.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UNKNOWN</id>
    <artifact tool="FindBugs" mnemonic="UNKNOWN"/>
    <name>Unknown FindBugs bug pattern</name>
    <shortMessage>A warning was recorded for an unknown FindBugs bug pattern.</shortMessage>
    <info>
<![CDATA[<p>A warning was recorded, but FindBugs can't find the
description of this bug pattern and so can't describe it.  This should
occur only in cases of a bug in FindBugs or its configuration, or
perhaps if an analysis was generated using a plugin, but that plugin
is not currently loaded.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AM_CREATES_EMPTY_ZIP_FILE_ENTRY</id>
    <artifact tool="FindBugs"
	      mnemonic="AM_CREATES_EMPTY_ZIP_FILE_ENTRY"/>
    <name>Creates empty Zip file entry</name>
    <shortMessage>Creates an empty Zip file entry</shortMessage>
    <info>
<![CDATA[<p>The code calls <code>putNextEntry()</code>, immediately
followed by a call to <code>closeEntry()</code>.  This results in an
empty ZipFile entry. The contents of the entry should be written to
the ZipFile between the calls to <code>putNextEntry()</code> and
<code>closeEntry()</code>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AM_CREATES_EMPTY_JAR_FILE_ENTRY</id>
    <artifact tool="FindBugs"
	      mnemonic="AM_CREATES_EMPTY_JAR_FILE_ENTRY">
    </artifact>
    <name>Creates empty Jar file entry</name>
    <shortMessage>Creates an empty Jar file entry</shortMessage>
    <info>
<![CDATA[<p>The code calls <code>putNextEntry()</code>, immediately
followed by a call to <code>closeEntry()</code>.  This results in an
empty JarFile entry. The contents of the entry should be written to
the JarFile between the calls to <code>putNextEntry()</code> and
<code>closeEntry()</code>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>IMSE_DONT_CATCH_IMSE</id>
    <artifact tool="FindBugs" mnemonic="IMSE_DONT_CATCH_IMSE"/>
    <name>Avoid catching IllegalStateMonitorException</name>
    <shortMessage>Dubious code that is catching IllegalMonitorStateException may be masking a design flaw in your code.</shortMessage>
    <info>
<![CDATA[<p><code>IllegalMonitorStateException</code> is generally
only thrown in case of a design flaw in your code&mdash;calling wait
or notify on an object you do not hold a lock on.</p>

<p>It is recommended that this catch be removed from your code and the
design flaw fixed.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>FL_MATH_USING_FLOAT_PRECISION</id>
    <artifact tool="FindBugs"
	      mnemonic="FL_MATH_USING_FLOAT_PRECISION"/>
    <name>Avoid using float type for math operations</name>
    <shortMessage>Method performs math using floating point precision, consider using double precision instead.</shortMessage>
    <info>
<![CDATA[<p>The method performs math operations using floating point
precision. Floating point precision is very imprecise.  For example,
16777216.0f + 1.0f = 16777216.0f.</p>

<p>Consider using double precision math instead. To do this change
<code>float</code> type variables to <code>double</code> type
variables and avoid the <code>f</code> prefix on floating point
constants.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>CN_IDIOM</id>
    <artifact tool="FindBugs" mnemonic="CN_IDIOM"/>
    <artifact tool="PMD" mnemonic="CloneMethodMustImplementCloneable"/>
    <name>Clone method must implement Cloneable</name>
    <shortMessage>This class implements Cloneable but does not define or use clone method.</shortMessage>
    <info>
<![CDATA[<p>This class implements the <code>Cloneable</code> interface
but does not define or use the <code>clone()</code> method.  A class
that implements <code>Cloneable</code> is expected to provide a
properly functioning public <code>clone()</code> method.</p>

<p>The method <code>clone()</code> should only be implemented if the
class implements the <code>Cloneable</code> interface with the
exception of a final method that only throws
<code>CloneNotSupportedException</code>.</p>

<p>Overall it is considered bad practice to use the extralinguistic
clone mechanism (reference Bloch's <i>Effective Java</i> (second
edition) item 11).  A copy constructor is one alternative
approach.</p>

<pre>
public MyClass(MyClass o) { ... }
</pre>

<p> A copy factory is another alternative approach.</p>

<pre>
public static MyClass newInstance(MyClass o) { ... }
</pre>

<p>Either one of these alternatives is considered better practice in
modern Java programs.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>CN_IDIOM_NO_SUPER_CALL</id>
    <artifact tool="FindBugs" mnemonic="CN_IDIOM_NO_SUPER_CALL"/>
    <artifact tool="PMD" mnemonic="ProperCloneImplementation"/>
    <name>No super.clone() call in clone method</name>
    <shortMessage>This non-final class defines a clone method that does not call super.clone().</shortMessage>
    <info>
<![CDATA[<p>This non-final class defines a <code>clone()</code> method
that does not call <code>super.clone()</code>. If this class, which we
will call <code>A</code>, is extended by a subclass <code>B</code>,
and the subclass <code>B</code> calls <code>super.clone()</code>, then
it is likely that <code>B</code>'s <code>clone()</code> method will
return an object of type <code>A</code>, which violates the contract
for <code>clone()</code>.</p>

<p>If all <code>clone()</code> methods call
<code>super.clone()</code>, then they are guaranteed to use
<code>Object.clone()</code>, which always returns an object of the
correct type.</p>

<p>Overall it is considered bad practice to use the extralinguistic
clone mechanism (reference Bloch's <i>Effective Java</i> (second
edition) item 11).  A copy constructor is one alternative
approach.</p>

<pre>
public MyClass(MyClass o) { ... }
</pre>

<p> A copy factory is another alternative approach.</p>

<pre>
public static MyClass newInstance(MyClass o) { ... }
</pre>

<p>Either one of these alternatives is considered better practice in
modern Java programs.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NM_FUTURE_KEYWORD_USED_AS_IDENTIFIER</id>
    <artifact tool="FindBugs" mnemonic="NM_FUTURE_KEYWORD_USED_AS_IDENTIFIER"/>
    <name>Use of a future keyword as identifier</name>
    <shortMessage>Use of an identifier that is a keyword in later versions of Java.</shortMessage>
    <info>
<![CDATA[<p>The identifier is a word that is reserversed as a keyword
in later versions of Java, and your code will need to be changed in
order for it to compile in later versions of Java.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NM_FUTURE_KEYWORD_USED_AS_MEMBER_IDENTIFIER</id>
    <artifact tool="FindBugs" mnemonic="NM_FUTURE_KEYWORD_USED_AS_MEMBER_IDENTIFIER"/>
    <name>Use of a future keyword as a member identifier</name>
    <shortMessage>Use of an identifier that is a keyword in later versions of Java.</shortMessage>
    <info>
<![CDATA[<p>This identifier is a word that is used as a keyword in
later versions of Java. This code, and any code that references this
API, will need to be changed in order for it to compile in later
versions of Java.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DE_MIGHT_DROP</id>
    <artifact tool="FindBugs" mnemonic="DE_MIGHT_DROP"/>
    <name>Method might drop an exception</name>
    <shortMessage>Method might drop an exception.</shortMessage>
    <info>
<![CDATA[<p>This method might drop an exception that may indicate a
serious problem has occurred in the running program. In general,
exceptions should be handled or reported in some way, or they should
be thrown out of the method.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DE_MIGHT_IGNORE</id>
    <artifact tool="FindBugs" mnemonic="DE_MIGHT_IGNORE"/>
    <name>Method might ignore an exception</name>
    <shortMessage>Method might ignore an exception.</shortMessage>
    <info>
<![CDATA[<p>This method might ignore an exception that my indicate a
serious problem has occurred in the running program. In general,
exceptions should be handled or reported in some way, or they should
be thrown out of the method.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DP_DO_INSIDE_DO_PRIVILEGED</id>
    <artifact tool="FindBugs" mnemonic="DP_DO_INSIDE_DO_PRIVILEGED"/>
    <artifact tool="FindBugs" mnemonic="DP_DO_INSIDE_DO_PRIVILEDGED"/>
    <name>Method requires security permission check</name>
    <shortMessage>Method is invoked that should be only be invoked inside a doPrivileged block.</shortMessage>
    <info>
<![CDATA[<p>This code invokes a method that requires a security
permission check. If this code will be granted security permissions,
but might be invoked by code that does not have security permissions,
then the invocation needs to occur inside a <code>doPrivileged</code>
block.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED</id>
    <artifact tool="FindBugs" mnemonic="DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED"/>
    <artifact tool="FindBugs" mnemonic="DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEDGED"/>
    <name>Classloader creation requires security permission check</name>
    <shortMessage>Classloaders should only be created inside a doPrivileged block.</shortMessage>
    <info>
<![CDATA[<p>This code creates a classloader, which requires a security
manager. If this code will be granted security permissions, but might
be invoked by code that does not have security permissions, then the
classloader creation needs to occur inside a <code>doPrivileged</code>
block.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>JCIP_FIELD_ISNT_FINAL_IN_IMMUTABLE_CLASS</id>
    <artifact tool="FindBugs" mnemonic="JCIP_FIELD_ISNT_FINAL_IN_IMMUTABLE_CLASS"/>
    <name>Field isn't final in an immutable class</name>
    <shortMessage>Fields that are declared within an immutable class should be final.</shortMessage>
    <info>
<![CDATA[<p>This class is annotated with the
<code>net.jcip.annotations.Immutable</code> annotation, and the rules
for that annotation require that all fields are final.  This class is
in voilation of those rules.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DMI_THREAD_PASSED_WHERE_RUNNABLE_EXPECTED</id>
    <artifact tool="FindBugs" mnemonic="DMI_THREAD_PASSED_WHERE_RUNNABLE_EXPECTED"/>
    <name>Thread passed where Runnable is expected</name>
    <shortMessage>A Thread object has been passed as a parameter to a method where a Runnable is expected.</shortMessage>
    <info>
<![CDATA[<p>A Thread object is passed as a parameter to a method where
a Runnable is expected. This is unusual, and may indicate a logic
error or cause unexpected behavior.</p>

<p>Consider changing the type of the object to not be a Thread.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DMI_COLLECTION_OF_URLS</id>
    <artifact tool="FindBugs" mnemonic="DMI_COLLECTION_OF_URLS"/>
    <name>Avoid a collection Of URLs</name>
    <shortMessage>Maps and sets of URLs can be horrible performance hogs.</shortMessage>
    <info>
<![CDATA[ <p>This method or field is or uses a <code>Map</code> or
<code>Set</code> of URLs. Since both the equals and hashCode methods of
URL perform domain name resolution, this can result in a big
performance hit. See <a
href="http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html">http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html</a>
for more information. Consider using <code>java.net.URI</code>
instead.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DMI_BLOCKING_METHODS_ON_URL</id>
    <artifact tool="FindBugs" mnemonic="DMI_BLOCKING_METHODS_ON_URL"/>
    <name>Blocking methods on URL</name>
    <shortMessage>The equals and hashCode methods of URL are blocking.  This could result in a big performance hit.</shortMessage>
    <info>
<![CDATA[<p>The equals and hashCode method of URL perform domain name
resolution, this can result in a big performance hit. See <a
href="http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html">Michael
Scharf's Blog entry</a> on this topic for more information.</p>

<p>Consider using <code>java.net.URI</code> instead.  When using URI
objects in your code it is straightforward to convert one to a URL
object as shown in the code below.  This might be necessary to use the
object with some libraries and frameworks.</p>

<pre>
try {
  URI uri = new URI("http://www.surelogic.com");
  URL url = uri.toURL();
  assert uri.getHost().equals(url.getHost());
} catch (Exception e) {
  // handle URL and URI exceptions
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DMI_ANNOTATION_IS_NOT_VISIBLE_TO_REFLECTION</id>
    <artifact tool="FindBugs" mnemonic="DMI_ANNOTATION_IS_NOT_VISIBLE_TO_REFLECTION"/>
    <name>Annotation is not visible to reflection</name>
    <shortMessage>Can't use reflection to check for presence of annotation with default retention.</shortMessage>
    <info>
<![CDATA[<p>Unless an annotation has itself been annotated with a
<code>@Retention</code> other than the default of source-only
retention, the annotation isn't retained in the classfile and can't be
observed using reflection, i.e., using the
<code>isAnnotationPresent</code> method.</p>

<p>The standard annotation <code>@SuppressWarnings</code> is not
retained in the classfile, however <code>@Deprecated</code> is as
shown in the code below.</p>

<pre>
@Documented
@Retention(RetentionPolicy.RUNTIME)
public @interface Deprecated {}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DM_EXIT</id>
    <artifact tool="FindBugs" mnemonic="DM_EXIT"/>
    <artifact tool="PMD" mnemonic="DoNotCallSystemExit"/>
    <name>Avoid calling System.exit(...)</name>
    <shortMessage>Calling System.exit(...) may make it difficult for your code to be invoked by other code.</shortMessage>
    <info>
<![CDATA[<p>Invoking <code>System.exit(...)</code> shuts down the
entire Java virtual machine. This should only been done when it is
appropriate. Such calls make it hard or impossible for your code to be
invoked by other code. Consider throwing a
<code>RuntimeException</code> instead.</p>

<p>It is prohibited for any EJB to invoke this call and shutdown the
container (reference section 21.1.2 of the EJB 3.0
Specification).</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DM_RUN_FINALIZERS_ON_EXIT</id>
    <artifact tool="FindBugs" mnemonic="DM_RUN_FINALIZERS_ON_EXIT"/>
    <name>Avoid the dangerous runFinalizersOnExit method</name>
    <shortMessage>Calling dangerous method runFinalizersOnExit could result in erratic behavior or deadlock.</shortMessage>
    <info>
<![CDATA[<p><em>Never call System.runFinalizersOnExit or
Runtime.runFinalizersOnExit for any reason: they are among the most
dangerous methods in the Java libraries.</em> &mdash; Joshua Bloch
(reference Bloch's <i>Effective Java</i> (second edition) item 7)</p>

<p>Calling <code>runFinalizersOnExit</code> is inherently unsafe.  It
may result in finalizers being called on live objects while other
threads are concurrently manipulating those objects, resulting in
erratic behavior or deadlock.</p>

<p>Any Java program which depends upon finalizers, or a programmer who
thinks of them as similar to C++ destructors, is headed for serious
trouble. Work to avoid the use of finalizers in your code for
non-memory resources.  In Java, <code>try-finally</code> blocks should
be used for this purpose.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DM_STRING_CTOR</id>
    <artifact tool="FindBugs" mnemonic="DM_STRING_CTOR"/>
    <artifact tool="PMD" mnemonic="StringInstantiation"/>
    <artifact tool="FindBugs" mnemonic="DM_STRING_VOID_CTOR"/>
    <name>Use of inefficient String constructor</name>
    <shortMessage>Use of String constructor wastes memory and is inefficient.</shortMessage>
    <info>
<![CDATA[<p>Using the <code>java.lang.String(String)</code>
constructor wastes memory because the object so constructed will be
functionally indistinguishable from the <code>String</code> passed as
a parameter. Just use the argument <code>String</code> directly.  For
example, <code>new String("Hi")</code> is replaced with
<code>"Hi"</code> and <code>new String(s)</code> is replaced with
<code>s</code>.</p>

<p>Avoid instantiating String objects; this is usually unnecessary.</p>

<p>Creating a new <code>java.lang.String</code> object using the
no-argument constructor wastes memory because the object so created
will be functionally indistinguishable from the empty string constant
<code>""</code> Java guarantees that identical string constants will
be represented by the same <code>String</code> object. Therefore, you
should just use the empty string constant directly.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DM_STRING_TOSTRING</id>
    <artifact tool="FindBugs" mnemonic="DM_STRING_TOSTRING"/>
    <artifact tool="PMD" mnemonic="StringToString"/>
    <name>Avoid calling toString() on a String</name>
    <shortMessage>Method invokes the toString() method on a String.</shortMessage>
    <info>
<![CDATA[<p>Calling <code>String.toString()</code> is just a redundant
operation. Just use the String directly.  For example,
<code>s.toString()</code> is replaced with <code>s</code>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DM_GC</id>
    <artifact tool="FindBugs" mnemonic="DM_GC"></artifact>
    <artifact tool="PMD" mnemonic="DoNotCallGarbageCollectionExplicitly"/>
    <name>Avoid explicit garbage collection</name>
    <shortMessage>Explicit garbage collection is being invoked which is extremely dubious except in benchmarking code.</shortMessage>
    <info>
<![CDATA[<p>This code explicitly invokes garbage collection. Except
for use in benchmarking, this is very dubious.  It is recommended that
these calls be removed from your program.</p>

<p>In the past, situations where people have explicitly invoked the
garbage collector in routines such as close or finalize methods has
led to huge performance black holes. Garbage collection can be
expensive. Any situation that forces hundreds or thousands of garbage
collections will bring the machine to a crawl.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DM_BOOLEAN_CTOR</id>
    <artifact tool="FindBugs" mnemonic="DM_BOOLEAN_CTOR"/>
    <artifact tool="PMD" mnemonic="BooleanInstantiation"/>
    <name>Inefficient boolean constructor</name>
    <shortMessage>Method invokes inefficient Boolean constructor; use Boolean.valueOf(...) instead.</shortMessage>
    <info>
<![CDATA[<p>Creating new instances of <code>java.lang.Boolean</code>
wastes memory, since <code>Boolean</code> objects are immutable and
there are only two useful values of this type. Use the
<code>Boolean.valueOf()</code> method, <code>Boolean.TRUE</code> or
<code>Boolean.FALSE</code>, or autoboxing if you are using Java 1.5 or
above to create <code>Boolean</code> objects instead.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DM_NUMBER_CTOR</id>
    <artifact tool="FindBugs" mnemonic="DM_NUMBER_CTOR"/>
    <artifact tool="FindBugs" mnemonic="DM_FP_NUMBER_CTOR"/>
    <artifact tool="PMD" mnemonic="IntegerInstantiation"/>
    <artifact tool="PMD" mnemonic="ByteInstantiation"/>
    <artifact tool="PMD" mnemonic="LongInstantiation"/>
    <artifact tool="PMD" mnemonic="ShortInstantiation"/>
    <name>Inefficient number constructor</name>
    <shortMessage>
      Method invokes inefficient number constructor; use static
      valueOf instead
    </shortMessage>
    <info>
<![CDATA[<p>Using <code>new Integer(int)</code> (or any number
constructor such as <code>new Double(double)</code>) is guaranteed to
always result in a new object whereas
<code>Integer.valueOf(int)</code> allows caching of values to be done
by the compiler, class library, or JVM.  Using of cached values avoids
object allocation and the code will be faster.</p>

<p>For the integer numbers, values between -128 and 127 are guaranteed
to have corresponding cached instances and using
<code>valueOf()</code> is approximately 3.5 times faster than using
the constructor. For values outside the constant range the performance
of both styles is the same.</p>

<p>Unless the class must be compatible with JVMs predating Java 1.5,
use either autoboxing or the <code>valueOf()</code> method when
creating instances of <code>Double</code>, <code>Float</code>,
<code>Long</code>, <code>Integer</code>, <code>Short</code>,
<code>Character</code>, and <code>Byte</code>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DM_STRING_EMPTY_EQUALS</id>
    <artifact tool="FindBugs" mnemonic="DM_STRING_EMPTY_EQUALS"/>
    <name>Use length() or isEmpty() to check if a String is empty</name>
    <shortMessage>Method invokes inefficient String.equals(""); use String.length() == 0 instead.</shortMessage>
    <info>
<![CDATA[<p>An object is compared to the empty String object using the
equals() method here. Checking that the String object's length is zero
may be faster, and removes String constants from the class file.
Change <code>s.equals("")</code> or <code>"".equals(s)</code> to
<code>s.length() == 0</code></p>

<p>If you are using JDK 1.6 or above an <code>isEmpty()</code> method
was added to the String class which will directly answer the query.
Thus in the example above use <code>s.isEmpty()</code>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DM_CONVERT_CASE</id>
    <artifact tool="FindBugs" mnemonic="DM_CONVERT_CASE"/>
    <artifact tool="PMD" mnemonic="UseLocaleWithCaseConversions"/>
    <name>Use Locale parameterized versions of toUpperCase and toLowerCase methods</name>
    <shortMessage>Consider using the Locale parameterized version of the invoked method.</shortMessage>
    <info>
<![CDATA[<p>A String is being converted to upper or lowercase, using
the platform's default encoding. This may result in improper
conversions when used with international characters. Consider using
the below versions instead.</p>

<pre>
String.toUpperCase(Locale)
String.toLowerCase(Locale)
</pre>

<p>One instance where this might be an issue is conversion of local
insensitive strings. To obtain correct results for locale insensitive
strings, use <code>toUpperCase(Locale.ENGLISH)</code>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>BX_UNBOXED_AND_COERCED_FOR_TERNARY_OPERATOR</id>
    <artifact tool="FindBugs" mnemonic="BX_UNBOXED_AND_COERCED_FOR_TERNARY_OPERATOR"/>
    <name>Unboxed and coerced for ternary operator</name>
    <shortMessage>A primitive value is unboxed and coerced for use with the ternary operator.</shortMessage>
    <info>
<![CDATA[<p>A wrapped primitive value is unboxed and converted to
another primitive type as part of the evaluation of a conditional
ternary operator (the <code> b ? e1 : e2</code> operator). The
semantics of Java mandate that if <code>e1</code> and <code>e2</code>
are wrapped numeric values, the values are unboxed and
converted/coerced to their common type (e.g, if <code>e1</code> is of
type <code>Integer</code> and <code>e2</code> is of type
<code>Float</code>, then <code>e1</code> is unboxed, converted to a
floating point value, and boxed. See JLS Section 15.25.</p>

<p>This behavior can be unexpected and can be a source of subtle
bugs.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>BX_BOXING_IMMEDIATELY_UNBOXED</id>
    <artifact tool="FindBugs" mnemonic="BX_BOXING_IMMEDIATELY_UNBOXED"/>
    <name>Boxing immediately unboxed</name>
    <shortMessage>A primitive value is boxed and then immediately unboxed.</shortMessage>
    <info>
<![CDATA[<p>A primitive is boxed, and then immediately unboxed.  This
probably is due to a manual boxing in a place where an unboxed value
is required, thus forcing the compiler to immediately undue the work
of the boxing.</p>

<p>This change may improve program performance.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>BX_BOXING_IMMEDIATELY_UNBOXED_TO_PERFORM_COERCION</id>
    <artifact tool="FindBugs" mnemonic="BX_BOXING_IMMEDIATELY_UNBOXED_TO_PERFORM_COERCION"/>
    <name>Boxing immediately unboxed to perform coercion</name>
    <shortMessage>A primitive value is boxed then unboxed to perform primitive coercion.</shortMessage>
    <info>
<![CDATA[<p>A primitive boxed value constructed and then immediately
converted into a different primitive type (e.g., <code>new
Double(d).intValue()</code>). Just perform direct primitive coercion
(e.g., <code>(int) d</code>).</p>

<p>This change may improve program performance.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DM_BOXED_PRIMITIVE_TOSTRING</id>
    <artifact tool="FindBugs" mnemonic="DM_BOXED_PRIMITIVE_TOSTRING"/>
    <artifact tool="PMD" mnemonic="UnnecessaryConversionTemporary"/>
    <name>Boxed primitive used just to call toString</name>
    <shortMessage>Method allocates a boxed primitive just to call toString.</shortMessage>
    <info>
<![CDATA[<p>A boxed primitive is allocated just to call toString(). It
is more effective to just use the static form of <code>toString</code>
on each wrapper type which takes the primitive value. So,</p>

<table>
      <tr><th>Replace...</th><th>With this...</th></tr>
      <tr><td>new Integer(1).toString()</td><td>Integer.toString(1)</td></tr>
      <tr><td>new Long(1).toString()</td><td>Long.toString(1)</td></tr>
      <tr><td>new Float(1.0).toString()</td><td>Float.toString(1.0)</td></tr>
      <tr><td>new Double(1.0).toString()</td><td>Double.toString(1.0)</td></tr>
      <tr><td>new Byte(1).toString()</td><td>Byte.toString(1)</td></tr>
      <tr><td>new Short(1).toString()</td><td>Short.toString(1)</td></tr>
      <tr><td>new Boolean(true).toString()</td><td>Boolean.toString(true)</td></tr>
</table>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DM_NEW_FOR_GETCLASS</id>
    <artifact tool="FindBugs" mnemonic="DM_NEW_FOR_GETCLASS"/>
    <name>Avoid allocating an object to obtain the class object</name>
    <shortMessage>Method allocates an object, only to get the class object.  Use .class property of the class instead.</shortMessage>
    <info>
 <![CDATA[<p>This method allocates an object just to call
 <code>getClass()</code> on it, in order to retrieve the class object
 for it. It is simpler to just access the <code>.class</code> property
 of the class.</p>

<p>For example, change <code>(new Foo()).getClass()</code> to
<code>Foo.class</code>.]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DM_MONITOR_WAIT_ON_CONDITION</id>
    <artifact tool="FindBugs" mnemonic="DM_MONITOR_WAIT_ON_CONDITION"/>
    <name>Monitor wait on a util concurrent Condition object</name>
    <shortMessage>Monitor wait() called on a util concurrent Condition object, use await() instead.</shortMessage>
    <info>
<![CDATA[<p>This method calls <code>wait()</code> on a
<code>java.util.concurrent.locks.Condition</code> object.  Waiting for
a <code>Condition</code> should be done using one of the
<code>await()</code> methods defined by the <code>Condition</code>
interface.</p>

<p>This is highly confusing code that can lead to subtle concurrency
bugs.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>RV_01_TO_INT</id>
    <artifact tool="FindBugs" mnemonic="RV_01_TO_INT"></artifact>
    <name>Random value from 0 and 1 is to coerced to int</name>
    <shortMessage>A random value from 0 to 1 is coerced to the integer 0.  This is probably not the desired behavior. Consider fixing with the Random.nextInt method.</shortMessage>
    <info>
<![CDATA[<p>A random value from 0 to 1 is being coerced to the
integer value 0.  This is probably not the desired behavior.</p>

</p>You probably wanted to multiply the random value by something
before coercing it to an integer.  It is highly recommended that the
<code>nextInt</code> method (of the <code>Random</code> class) be used
for this purpose because it avoid several tricky implementation issues
(for more information see its method documentation).</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DM_NEXTINT_VIA_NEXTDOUBLE</id>
    <artifact tool="FindBugs" mnemonic="DM_NEXTINT_VIA_NEXTDOUBLE"/>
    <name>Use nextInt not nextDouble to generate a random integer</name>
    <shortMessage>Use the nextInt method of Random rather than nextDouble to generate a random integer.</shortMessage>
    <info>
<![CDATA[<p>If <code>r</code> is a <code>java.util.Random</code>
object, you can generate a random number from 0 to <code>n</code>-1
using <code>r.nextInt(n)</code> Rather than using
<code>(int)(r.nextDouble() * n)<code>.</p>

<p>It is highly recommended that the <code>nextInt</code> method be
used for this purpose because it avoid several tricky implementation
issues (for more information see its method documentation).</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE</id>
    <artifact tool="FindBugs" mnemonic="SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE"/>
    <name>Nonconstant String passed to execute may be vulnerable to SQL injection</name>
    <shortMessage>A Nonconstant string passed to execute method on an SQL statement.  This may be vulnerable to SQL injection.</shortMessage>
    <info>
<![CDATA[<p>The method invokes the execute method on an SQL statement
with a <code>String</code> that seems to be dynamically
generated. Consider using a prepared statement instead. It is more
efficient and less vulnerable to SQL injection attacks.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING</id>
    <artifact tool="FindBugs" mnemonic="SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING"/>
    <name>Prepared statement generated from nonconstant String may be vulnerable to SQL injection</name>
    <shortMessage>A prepared statement is generated from a nonconstant String.  This may be vulnerable to SQL injection.</shortMessage>
    <info>
<![CDATA[<p>The code creates an SQL prepared statement from a
nonconstant <code>String</code>. If unchecked, tainted data from a
user is used in building this <code>String</code>, SQL injection could
be used to make the prepared statement do something unexpected and
undesirable.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DM_USELESS_THREAD</id>
    <artifact tool="FindBugs" mnemonic="DM_USELESS_THREAD"/>
    <name>Useless thread</name>
    <shortMessage>A thread was created using the default empty run method.  Delete this thread.</shortMessage>
    <info>
<![CDATA[<p>This method creates a thread without specifying a run
method either by deriving from (i.e., subclassing) the
<code>Thread</code> class, or by passing a <code>Runnable</code>
object. This thread, then, does nothing but waste time.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DC_DOUBLECHECK</id>
    <artifact tool="FindBugs" mnemonic="DC_DOUBLECHECK"/>
    <artifact tool="PMD" mnemonic="DoubleCheckedLocking"/>
    <name>Double-checked locking</name>
    <shortMessage>Possible instance of double-check locking on a field.</shortMessage>
    <info>
<![CDATA[<p>This method may contain an instance of double-checked
locking. This idiom is not correct according to the semantics of the
Java memory model.</p>

<p>For more detailed information on this problem and how to correct
it, see the web page <a
href="http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html"
>http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html</a>
as well as <a
href="http://www.javaworld.com/javaworld/jw-02-2001/jw-0209-double.html"
>http://www.javaworld.com/javaworld/jw-02-2001/jw-0209-double.html</a>
.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>FI_FINALIZER_NULLS_FIELDS</id>
    <artifact tool="FindBugs" mnemonic="FI_FINALIZER_NULLS_FIELDS"/>
    <name>Finalizer nulls fields</name>
    <shortMessage>Finalizer nulls fields which does not aid garbage collection.</shortMessage>
    <info>
<![CDATA[<p>This finalizer <code>null</code>s out fields. This is
usually an error, as it does not aid garbage collection, and the
object is going to be garbage collected anyway.</p>

<p>It is recommended to try to remove all finalizers from your
program.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>FI_FINALIZER_ONLY_NULLS_FIELDS</id>
    <artifact tool="FindBugs" mnemonic="FI_FINALIZER_ONLY_NULLS_FIELDS"/>
    <name>Finalizer only nulls out fields</name>
    <shortMessage>Finalizer only nulls out fields. This finalize method should be removed.</shortMessage>
    <info>
<![CDATA[<p>This finalizer does nothing except <code>null</code> out
fields. This is completely pointless, and requires that the object be
garbage collected, finalized, and then garbage collected again. You
should just remove the finalize method.</p>

<p>It is recommended to try to remove all finalizers from your
program.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>FI_PUBLIC_SHOULD_BE_PROTECTED</id>
    <artifact tool="FindBugs" mnemonic="FI_PUBLIC_SHOULD_BE_PROTECTED"/>
    <artifact tool="PMD" mnemonic="FinalizeShouldBeProtected"/>
    <name>Finalize method should be protected</name>
    <shortMessage>Finalizer method should be declared to be protected, not public. Other classes can call public methods. Change the visibility or remove it.</shortMessage>
    <info>
<![CDATA[<p>A class's <code>finalize()</code> method should have
protected access, not public.</p>

If you override <code>finalize()</code>, make it protected. If you
make it public, other classes may call it.</p>

<p>It is recommended to try to remove all finalizers from your
program.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>FI_EMPTY</id>
    <artifact tool="FindBugs" mnemonic="FI_EMPTY"/>
    <artifact tool="PMD" mnemonic="EmptyFinalizer"/>
    <name>Empty finalizer block</name>
    <shortMessage>Empty finalizer should be removed</shortMessage>
    <info>
<![CDATA[<p>Empty <code>finalize()</code> methods are useless, so they
should be deleted.</p>

<p>It is recommended to try to remove all finalizers from your
program.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>FI_NULLIFY_SUPER</id>
    <artifact tool="FindBugs" mnemonic="FI_NULLIFY_SUPER"/>
    <name>Finalizer nullifies superclass finalizer</name>
    <shortMessage>Finalizer nullifies superclass finalizer.  Consider removing this method.</shortMessage>
    <info>
<![CDATA[<p>This empty <code>finalize()</code> method explicitly
negates the effect of any finalizer defined by its superclass. Any
finalizer actions defined for the superclass will not be
performed. Unless this is intended, delete this method.</p>

<p>It is recommended to try to remove all finalizers from your
program.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>FI_USELESS</id>
    <artifact tool="FindBugs" mnemonic="FI_USELESS"/>
    <artifact tool="PMD" mnemonic="FinalizeOnlyCallsSuperFinalize"/>
    <name>Finalize only calls super.finalize()</name>
    <shortMessage>Finalizer does nothing but call its superclass finalizer.  Consider removing this method.</shortMessage>
    <info>
<![CDATA[<p>The only thing this <code>finalize()</code> method does
is call the superclass's <code>finalize()</code> method, making it
redundant. Delete this method.</p>

<p>It is recommended to try to remove all finalizers from your
program.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>FI_MISSING_SUPER_CALL</id>
    <artifact tool="FindBugs" mnemonic="FI_MISSING_SUPER_CALL"/>
    <artifact tool="PMD" mnemonic="FinalizeDoesNotCallSuperFinalize"/>
    <name>Finalize does not call super finalize</name>
    <shortMessage>Finalizer does not call the superclass finalizer as its last operation.  Add a call to super.finalize() to this method.</shortMessage>
    <info>
<![CDATA[<p>This <code>finalize()</code> method does not make a call
to its superclass's <code>finalize()</code> method. So, any finalizer
actions defined for the superclass will not be performed.</p>

<p>To fix this problem add a call to
<code>super.finalize()</code>. Note that this method's last action
should be the call to <code>super.finalize()</code>.</p>

<p>It is recommended to try to remove all finalizers from your
program.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>FI_EXPLICIT_INVOCATION</id>
    <artifact tool="FindBugs" mnemonic="FI_EXPLICIT_INVOCATION"/>
    <artifact tool="PMD" mnemonic="AvoidCallingFinalize"/>
    <name>Avoid calling finalize() explicitly</name>
    <shortMessage>Explicit invocation of finalizer found. This is almost always a bug.</shortMessage>
    <info>
<![CDATA[<p>This method contains an explicit invocation of the
<code>finalize()</code> method on an object. Because finalizer methods
are supposed to be executed once, and only by the VM, this is a bad
idea.</p>

<p>If a connected set of objects becomes finalizable, then the VM will
invoke the <code>finalize()</code> method on all the finalizable
objects, possibly at the same time in different threads. Thus, it is a
particularly bad idea, in the <code>finalize()</code> method for a
class X, to invoke <code>finalize()</code> on objects referenced by X,
because they may already be getting finalized in a separate
thread.</p>

<p>It is recommended to try to remove all finalizers from your
program.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EQ_DONT_DEFINE_EQUALS_FOR_ENUM</id>
    <artifact tool="FindBugs" mnemonic="EQ_DONT_DEFINE_EQUALS_FOR_ENUM"/>
    <name>Don't define equals()for enum</name>
    <shortMessage>Covariant equals() method defined for enum.  This is a bad practice.</shortMessage>
    <info>
<![CDATA[<p>This class defines an enumeration, and equality on
enumerations are defined using object identity. Defining a covariant
equals method for an enumeration value is exceptionally bad practice,
since it would likely result in having two different enumeration
values that compare as equals using the covariant enum method, and as
not equal when compared normally. Don't do it.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EQ_SELF_USE_OBJECT</id>
    <artifact tool="FindBugs" mnemonic="EQ_SELF_USE_OBJECT"/>
    <artifact tool="FindBugs" mnemonic="EQ_SELF_NO_OBJECT"/>
    <artifact tool="FindBugs" mnemonic="EQ_ABSTRACT_SELF"/>
    <name>Equals defined that does not override Object.equals</name>
    <shortMessage>Covariant equals() method defined, Object.equals(Object) inherited.</shortMessage>
    <info>
<![CDATA[<p>This class defines a covariant version of the
<code>equals()</code> method, but inherits the normal
<code>equals(Object)</code> method defined in the base
<code>java.lang.Object</code> class. The class probably intended to
define a non-covariant version of <code>equals()</code> and use the
<code>@Override</code> tag if using JDK 1.5 or above as shown in the
code below.  In addition, to correctly override the
<code>equals</code> method in <code>java.lang.Object</code>, the
parameter must have the type <code>java.lang.Object</code>.</p>

<pre>
@Override public boolean equals(Object obj) {
  // implementation (don't forget to override hashCode as well!)
}
</pre>

<p>If this was not the intent of the class, then the method should be
renamed something other than <code>equals</code> to avoid
confusion.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EQ_OVERRIDING_EQUALS_NOT_SYMMETRIC</id>
    <artifact tool="FindBugs" mnemonic="EQ_OVERRIDING_EQUALS_NOT_SYMMETRIC"/>
    <name>Overriding equals not symmetric</name>
    <shortMessage>Equals method overrides equals in superclass and may not be symmetric.</shortMessage>
    <info>
<![CDATA[<p>This class defines an equals method that overrides an
equals method in a superclass. Both equals methods methods use
<code>instanceof</code> in the determination of whether two objects
are equals. This is fraught with peril, since it is important that the
equals method is symmetrical (in other words, <code>a.equals(b) ==
b.equals(a)</code>). If B is a subtype of A, and A's equals method
checks that the argument is an instanceof A, and B's equals method
checks that the argument is an instanceof B, it is quite likely that
the equivalence relation defined by these methods is not
symmetric.</p>

<p>See Bloch's <i>Effective Java</i> (second edition) item 8 for
(much) more information.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>HSC_HUGE_SHARED_STRING_CONSTANT</id>
    <artifact tool="FindBugs" mnemonic="HSC_HUGE_SHARED_STRING_CONSTANT"/>
    <name>Huge shared string constant</name>
    <shortMessage>Huge string constants are duplicated across multiple class files.</shortMessage>
    <info>
<![CDATA[<p>A large String constant is duplicated across multiple
class files. This is likely because a final field is initialized to a
String constant, and the Java language mandates that all references to
a final field from other classes be inlined into that classfile.</p>

<p>See <a
href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6447475">JDK
bug 6447475</a> for a description of an occurrence of this bug in the
JDK and how resolving it reduced the size of the JDK by 1
megabyte.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NP_ARGUMENT_MIGHT_BE_NULL</id>
    <artifact tool="FindBugs" mnemonic="NP_ARGUMENT_MIGHT_BE_NULL"/>
    <name>Argument might be null</name>
    <shortMessage>Method does not check for a null argument.</shortMessage>
    <info>
<![CDATA[<p>A parameter to this method has been identified as a value
that should always be checked to see whether or not it is
<code>null</code>, but it is being dereferenced without a preceding
null check.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT</id>
    <artifact tool="FindBugs" mnemonic="NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT"/>
    <artifact tool="FindBugs" mnemonic="NP_DOES_NOT_HANDLE_NULL"/>
    <name>Equals should handle null argument</name>
    <shortMessage>This equals() method does not check for null argument.  This contract violation should be fixed.</shortMessage>
    <info>
<![CDATA[<p>This implementation of <code>equals(Object)</code>
violates the contract defined by
<code>java.lang.Object.equals()</code> because it does not check for
<code>null</code> being passed as the argument. By the defined
contract, all <code>equals()</code> methods should return false if
passed a <code>null</code> value.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>CO_SELF_NO_OBJECT</id>
    <artifact tool="FindBugs" mnemonic="CO_SELF_NO_OBJECT"/>
    <artifact tool="FindBugs" mnemonic="CO_ABSTRACT_SELF"/>
    <name>Covariant compareTo method</name>
    <shortMessage>Covariant compareTo() method defined.</shortMessage>
    <info>
<![CDATA[<p>This class defines a covariant version of
<code>compareTo()</code>. To correctly implement (or override if an
implementation is provided by a superclass) the
<code>compareTo()</code> method in the <code>Comparable</code>
interface, the parameter of <code>compareTo()</code> must have type
<code>java.lang.Object</code>.</p>

<p>If this was not the intent of the class, then the method should be
renamed something other than <code>compareTo</code> to avoid
confusion.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>HE_USE_OF_UNHASHABLE_CLASS</id>
    <artifact tool="FindBugs" mnemonic="HE_USE_OF_UNHASHABLE_CLASS"/>
    <name>Use of unhashable class</name>
    <shortMessage>Use of class without a hashCode() method in a hashed data structure.</shortMessage>
    <info>
<![CDATA[<p>A class defines an <code>equals(Object)</code> method but
not a <code>hashCode()</code> method, and thus doesn't fulfill the
requirement that equal objects have equal hash codes. An instance of
this class is used in a hash data structure, making the need to fix
this problem of highest importance.]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>HE_HASHCODE_NO_EQUALS</id>
    <artifact tool="FindBugs" mnemonic="HE_HASHCODE_NO_EQUALS"/>
    <artifact tool="FindBugs" mnemonic="HE_HASHCODE_USE_OBJECT_EQUALS"/>
    <name>Defines hash code but inherits equals</name>
    <shortMessage>Class defines hashCode() but inherits equals().</shortMessage>
    <info>
<![CDATA[<p>This class defines a <code>hashCode()</code> method but
inherits its <code>equals()</code> method from
<code>java.lang.Object</code> (which defines equality by comparing
object references). Although this will probably satisfy the contract
that equal objects must have equal hashcodes, it is probably not what
was intended by overriding the <code>hashCode()</code>
method. Overriding <code>hashCode()</code> typically implies that the
object's identity is based on criteria more complicated than simple
reference equality.</p>

<p>If you don't think instances of this class will ever be inserted
into a HashMap/HashTable, the recommended <code>hashCode</code>
implementation to use is:</p>

<pre>
@Override public int hashCode() {
  assert false : "hashCode not designed";
  return 42; // any arbitrary constant will do
}
</pre>

<p>Note however, that some Java IDEs, such as Eclipse, will generate a
reasonable equals and hashcode for you.</p>

<p>Override both <code>public boolean Object.equals(Object
other)</code>, and <code>public int Object.hashCode()</code>, or
override neither. Even if you are inheriting a <code>hashCode</code>
method from a parent class, consider implementing
<code>hashCode</code> and explicitly delegating to your
superclass.</p>

<p>For more information on this topic please reference items 8 and 9
of Bloch's <i>Effective Java</i> (second edition).</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EQ_COMPARETO_USE_OBJECT_EQUALS</id>
    <artifact tool="FindBugs" mnemonic="EQ_COMPARETO_USE_OBJECT_EQUALS"/>
    <name>Defines compareTo() but uses Object.equals()</name>
    <shortMessage>Class defines a compareTo(...) method but uses Object.equals().</shortMessage>
    <info>
<![CDATA[<p>This class defines a <code>compareTo(...)</code> method
but inherits its <code>equals</code> method from
<code>java.lang.Object</code>. Generally, the <code>compareTo</code>
method should return zero if and only if <code>equals</code> returns
true. If this is violated, weird and unpredictable failures will occur
in classes such as <code>PriorityQueue</code>. In Java 5 the
<code>remove</code> method of <code>PriorityQueue</code> uses the
<code>compareTo</code> method, while in Java 6 it uses the
<code>equals</code> method.

<p>From the JavaDoc for the <code>compareTo</code> method in the
<code>Comparable</code> interface:</p>

<blockquote> It is strongly recommended, but not strictly required
that <code>(x.compareTo(y)==0) == (x.equals(y))</code>. Generally
speaking, any class that implements the Comparable interface and
violates this condition should clearly indicate this fact. The
recommended language is &quot;Note: this class has a natural ordering
that is inconsistent with equals.&quot;</blockquote>

<p>For more information on this topic please reference item 12 of
Bloch's <i>Effective Java</i> (second edition).</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>HE_EQUALS_NO_HASHCODE</id>
    <artifact tool="FindBugs" mnemonic="HE_EQUALS_NO_HASHCODE"/>
    <artifact tool="FindBugs" mnemonic="HE_EQUALS_USE_HASHCODE"/>
    <name>Defines equals but inherits hash code</name>
    <shortMessage>Class defines equals() but inherits hashCode().</shortMessage>
    <info>
<![CDATA[<p> This class overrides <code>equals(Object)</code>, but
does not override <code>hashCode()</code>, and inherits the
implementation of <code>hashCode()</code> from
<code>java.lang.Object</code>.  The implementation of
<code>hashCode</code> in <code>java.lang.Object</code> returns the
identity hash code, an arbitrary value assigned to the object by the
VM).  Therefore, the class is likely to violate the invariant that
equal objects must have equal hashcodes.</p>

<p>If you don't think instances of this class will ever be inserted
into a HashMap/HashTable, the recommended <code>hashCode</code>
implementation to use is:</p>

<pre>
@Override public int hashCode() {
  assert false : "hashCode not designed";
  return 42; // any arbitrary constant will do
}
</pre>

<p>Note however, that some Java IDEs, such as Eclipse, will generate a
reasonable equals and hashcode for you.</p>

<p>Override both <code>public boolean Object.equals(Object
other)</code>, and <code>public int Object.hashCode()</code>, or
override neither. Even if you are inheriting a <code>hashCode</code>
method from a parent class, consider implementing
<code>hashCode</code> and explicitly delegating to your
superclass.</p>

<p>For more information on this topic please reference items 8 and 9
of Bloch's <i>Effective Java</i> (second edition).</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>HE_INHERITS_EQUALS_USE_HASHCODE</id>
    <artifact tool="FindBugs" mnemonic="HE_INHERITS_EQUALS_USE_HASHCODE"/>
    <name>Inherits equals but uses hash code</name>
    <shortMessage>Class inherits equals() but uses Object.hashCode().</shortMessage>
    <info>
<![CDATA[<p>This class inherits <code>equals(Object)</code> from an
abstract superclass, and <code>hashCode()</code> from
<code>java.lang.Object</code> The implementation of
<code>hashCode</code> in <code>java.lang.Object</code> returns the
identity hash code, an arbitrary value assigned to the object by the
VM).  Therefore, the class is likely to violate the invariant that
equal objects must have equal hashcodes.</p>

<p>If you don't think instances of this class will ever be inserted
into a HashMap/HashTable, the recommended <code>hashCode</code>
implementation to use is:</p>

<pre>
public int hashCode() {
  assert false : &quot;hashCode not designed&quot;;
  return 42; // any arbitrary constant will do
}
</pre>

<p>Note however, that some Java IDEs, such as Eclipse, will generate a
reasonable equals and hashcode for you.</p>

<p>Override both <code>public boolean Object.equals(Object
other)</code>, and <code>public int Object.hashCode()</code>, or
override neither. Even if you are inheriting a <code>hashCode</code>
method from a parent class, consider implementing
<code>hashCode</code> and explicitly delegating to your
superclass.</p>

<p>For more information on this topic please reference items 8 and 9
of Bloch's <i>Effective Java</i> (second edition).</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ES_COMPARING_STRINGS_WITH_EQ</id>
    <artifact tool="FindBugs" mnemonic="ES_COMPARING_STRINGS_WITH_EQ"/>
    <artifact tool="FindBugs" mnemonic="ES_COMPARING_PARAMETER_STRING_WITH_EQ"/>
    <artifact tool="PMD" mnemonic="UseEqualsToCompareStrings"/>				
    <name>String comparison with == or !=</name>
    <shortMessage>Suspicious comparison of String objects using == or !=.</shortMessage>
    <info>
<![CDATA[<p>This code compares <code>java.lang.String</code> objects
for reference equality using the == or != operators. Unless both
strings are constants in a source file or have been interned using the
<code>String.intern()</code> method, the same string value may be
represented by two different String objects.  In short, only very
specialized code should use == or != operators on strings as this is
unusual and can create subtle bugs in your code.</p>

<p>This is even worse if the string is a parameter. Requiring callers
to pass only String constants or interned strings to a method is
unnecessarily fragile, and rarely leads to measurable performance
gains.</p>

<p>Consider using the <code>equals(Object)</code> method instead.  For
example, change <code>s1 == s2</code> with <code>s1.equals(s2)</code>
where you are sure that <code>s1</code> is non-null.</p>

<p>If you are comparing a constant string to any other string always
call <code>equals</code> on the constant as this avoids any possibility
of a <code>NullPointerException</code>.  For example, use
<code>"hello".equals(s1)</code> rather than
<code>s1.equals("hello")</code>.]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>IS_FIELD_NOT_GUARDED</id>
    <artifact tool="FindBugs" mnemonic="IS_FIELD_NOT_GUARDED"/>
    <name>Annotated field is not guarded</name>
    <shortMessage>Annotated field is not guarded against concurrent access.</shortMessage>
    <info>
<![CDATA[<p>This field is annotated with
<code>net.jcip.annotations.GuardedBy</code>, but can be accessed in a
way that seems to violate the annotation.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>IS2_INCONSISTENT_SYNC</id>
    <artifact tool="FindBugs" mnemonic="IS2_INCONSISTENT_SYNC"/>
    <artifact tool="FindBugs" mnemonic="IS_INCONSISTENT_SYNC"/>
    <name>Inconsistent field synchronization</name>
    <shortMessage>Inconsistent synchronization of fields.  Possible race condition detected.</shortMessage>
    <info>
<![CDATA[<p>The fields of this class appear to be accessed
inconsistently with respect to synchronization. This bug report
indicates that the bug pattern detector judged that</p>

<ol>
<li> The class contains a mix of locked and unlocked accesses,</li>
<li> At least one locked access was performed by one of the class's own methods, and</li>
<li> The number of unsynchronized field accesses (reads and writes) was no more than one third of all accesses, with writes being weighed twice as high as reads</li>
</ol>

<p>A typical bug matching this bug pattern is forgetting to
synchronize one of the methods in a class that is intended to be
thread-safe.</p>

<p>Note that there are various sources of inaccuracy in this
detector; for example, the detector cannot statically detect all
situations in which a lock is held.  Also, even when the detector is
accurate in distinguishing locked vs. unlocked accesses, the code in
question may still be correct.</p>

<p>To address this issue you must determine what the programmer
intended with respect to concurrency policy design intent and ensure
that this class faithfully implements that intent.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NN_NAKED_NOTIFY</id>
    <artifact tool="FindBugs" mnemonic="NN_NAKED_NOTIFY"/>
    <name>Naked notify</name>
    <shortMessage>Naked notify, no apparent change has been made to mutable object state.</shortMessage>
    <info>
<![CDATA[<p> A call to <code>notify()</code> or
<code>notifyAll()</code> was made without any (apparent) accompanying
modification to mutable object state. In general, calling a notify
method on a monitor is done because some condition another thread is
waiting for has become true. However, for the condition to be
meaningful, it must involve a heap object that is visible to both
threads.</p>

<p>This bug does not necessarily indicate an error, since the change
to mutable object state may have taken place in a method which then
called the method containing the notification.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>MS_EXPOSE_REP</id>
    <artifact tool="FindBugs" mnemonic="MS_EXPOSE_REP"/>
    <artifact tool="PMD" mnemonic="MethodReturnsInternalArray"/>
    <name>Exposing a mutable array</name>
    <shortMessage>Public static method may expose internal representation by returning a mutable array.</shortMessage>
    <info>
<![CDATA[<p>A public static method returns a reference to an array
that is part of the static state of the class. Any code that calls
this method can freely modify the underlying array.  If the array is
accessed by untrusted code, and unchecked changes to the mutable array
would compromise security or other important properties, you will need
to do something different.</p>

<p>One possible fix is to return a copy of the array.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EI_EXPOSE_REP</id>
    <artifact tool="FindBugs" mnemonic="EI_EXPOSE_REP"/>
    <name>Exposing a mutable object</name>
    <shortMessage>May expose internal representation by returning a reference to a mutable object.</shortMessage>
    <info>
<![CDATA[<p>Returning a reference to a mutable object value stored in
one of the object's fields exposes the internal representation of the
object. If instances are accessed by untrusted code, and unchecked
changes to the mutable object would compromise security or other
important properties, you will need to do something different.</p>

<p>Returning a new copy of the object is better approach in many
situations.</p> ]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EI_EXPOSE_REP2</id>
    <artifact tool="FindBugs" mnemonic="EI_EXPOSE_REP2"/>
    <name>Exposing a mutable object by reference</name>
    <shortMessage>May expose internal representation by incorporating a reference to a mutable object.</shortMessage>
    <info>
<![CDATA[<p>This code stores a reference to an externally mutable
object into the internal representation of the object. If instances
are accessed by untrusted code, and unchecked changes to the mutable
object would compromise security or other important properties, you
will need to do something different.</p>

<p>Storing a copy of the object is better approach in many
situations.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EI_EXPOSE_STATIC_REP2</id>
    <artifact tool="FindBugs" mnemonic="EI_EXPOSE_STATIC_REP2"/>
    <name>Exposing mutable state via a static field</name>
    <shortMessage>May expose internal static state by storing a mutable object into a static field.</shortMessage>
    <info>
<![CDATA[<p>This code stores a reference to an externally mutable
object into a static field. If unchecked changes to the mutable object
would compromise security or other important properties, you will need
to do something different.</p>

<p>Storing a copy of the object is better approach in many
situations.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>RU_INVOKE_RUN</id>
    <artifact tool="FindBugs" mnemonic="RU_INVOKE_RUN"/>
    <name>Invokes run on a thread</name>
    <shortMessage>Invokes run on a thread, it is likely that this code intended to invoke start instead.</shortMessage>
    <info>
<![CDATA[<p>This method explicitly invokes <code>run()</code> on an
object. In general, classes implement the <code>Runnable</code>
interface because they are going to have their <code>run()</code>
method invoked in a new thread, in which case
<code>Thread.start()</code> is the right method to call.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SP_SPIN_ON_FIELD</id>
    <artifact tool="FindBugs" mnemonic="SP_SPIN_ON_FIELD"/>
    <name>Spinning on a field read</name>
    <shortMessage>This method spins in a loop which reads a field.  This may be changed into an infinite loop by the compiler.</shortMessage>
    <info>
<![CDATA[<p>This method spins in a loop which reads a field.  The
compiler may legally hoist the read out of the loop, turning the code
into an infinite loop.</p>

<p>The class should be changed so it uses proper synchronization,
likely including wait and notify calls.  Also consider the use of the
classes in <code>java.util.concurrent</code> and
<code>java.util.concurrent.atomic</code>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NS_DANGEROUS_NON_SHORT_CIRCUIT</id>
    <artifact tool="FindBugs" mnemonic="NS_DANGEROUS_NON_SHORT_CIRCUIT"/>
    <name>Dangerous use of non-short-circuit logic</name>
    <shortMessage>Potentially dangerous use of non-short-circuit logic.</shortMessage>
    <info>
<![CDATA[<p>This code seems to be using non-short-circuit logic, i.e.,
<code>&</code> or <code>|</code>, rather than short-circuit logic,
i.e., <code>&&</code> or <code>||</code>. In addition, it seem
possible that, depending on the value of the left hand side, you might
not want to evaluate the right hand side (because it would have side
effects, could cause an exception or could be expensive.</p>

<p>Non-short-circuit logic causes both sides of the expression to be
evaluated even when the result can be inferred from knowing the
left-hand side. This can be less efficient and can result in errors if
the left-hand side guards cases when evaluating the right-hand side
can generate an error.</p>

<p>It is considered best practice to use short-circuit logic in most
expressions.  Document exceptions in the code with clear reasons why
the exception is required.</p>

<p>See <a
href="http://java.sun.com/docs/books/jls/third_edition/html/expressions.html#15.22.2">the
Java Language Specification</a> for further details.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NS_NON_SHORT_CIRCUIT</id>
    <artifact tool="FindBugs" mnemonic="NS_NON_SHORT_CIRCUIT"/>
    <name>Questionable use of non-short-circuit logic</name>
    <shortMessage>Questionable use of non-short-circuit logic.</shortMessage>
    <info>
<![CDATA[<p>This code seems to be using non-short-circuit logic, i.e.,
<code>&</code> or <code>|</code>, rather than short-circuit logic,
i.e., <code>&&</code> or <code>||</code>.</p>

<p>Non-short-circuit logic causes both sides of the expression to be
evaluated even when the result can be inferred from knowing the
left-hand side. This can be less efficient and can result in errors if
the left-hand side guards cases when evaluating the right-hand side
can generate an error.</p>

<p>It is considered best practice to use short-circuit logic in most
expressions.  Document exceptions in the code with clear reasons why
the exception is required.</p>

<p>See <a
href="http://java.sun.com/docs/books/jls/third_edition/html/expressions.html#15.22.2">the
Java Language Specification</a> for further details.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>TLW_TWO_LOCK_WAIT</id>
    <artifact tool="FindBugs" mnemonic="TLW_TWO_LOCK_WAIT"/>
    <name>Two lock wait</name>
    <shortMessage>Wait with two locks held.  Only one lock released by the wait.</shortMessage>
    <info>
<![CDATA[<p>Waiting on a monitor while two locks are held may cause
deadlock. Performing a wait only releases the lock on the object being
waited on, not any other locks.</p>

<p>This not necessarily a bug, but is worth examining closely
especially if there is also a warning about a two lock notify.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>TLW_TWO_LOCK_NOTIFY</id>
    <artifact tool="FindBugs" mnemonic="TLW_TWO_LOCK_NOTIFY"/>
    <name>Two lock notify</name>
    <shortMessage>Notify with two locks held.</shortMessage>
    <info>
<![CDATA[<p>The code calls <code>notify()</code> or
<code>notifyAll()</code> while two locks are held. If this
notification is intended to wake up a <code>wait()</code> that is
holding the same locks, it may deadlock, since the wait will only give
up one lock and the notify will be unable to get both locks, and thus
the notify will not succeed.</p>

<p>If there is also a warning about a two lock wait, the probably of a
bug is quite high.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UW_UNCOND_WAIT</id>
    <artifact tool="FindBugs" mnemonic="UW_UNCOND_WAIT"/>
    <name>Unconditional wait</name>
    <shortMessage>Unconditional wait could cause your code to hang</shortMessage>
    <info>
<![CDATA[<p>This method contains a call to
<code>java.lang.Object.wait()</code> which is not guarded by
conditional control flow. The code should verify that condition it
intends to wait for is not already satisfied before calling wait.  The
reason for this is that when you invoke <code>wait</code> any previous
notifications (i.e., those made in the past) will be ignored and your
program could hang.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UR_UNINIT_READ</id>
    <artifact tool="FindBugs" mnemonic="UR_UNINIT_READ"/>
    <name>Uninitialized field read</name>
    <shortMessage>Uninitialized read of a field within a constructor.</shortMessage>
    <info>
<![CDATA[<p>This constructor reads a field which has not yet been
assigned a value. This issue is often caused when the programmer
mistakenly uses the field instead of one of the constructor's
parameters.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UG_SYNC_SET_UNSYNC_GET</id>
    <artifact tool="FindBugs" mnemonic="UG_SYNC_SET_UNSYNC_GET"/>
    <name>Synchronized setter unsynchronized getter</name>
    <shortMessage>Unsynchronized get method with a corresponding synchronized set method. This may cause incorrect program behavior.</shortMessage>
    <info>
<![CDATA[<p>This class contains similarly-named get and set methods
where the set method is synchronized and the get method is not. This
may result in incorrect behavior at runtime, as callers of the get
method will not necessarily see a consistent state for the object. The
get method should be made synchronized.</p>

<p>This situation is caused because of the Java Memory Model which
requires that the program provide for reliable communication between
threads as well as for mutual exclusion.  See <a
href="http://java.sun.com/docs/books/jls/third_edition/html/memory.html#17.4">the
Java Language Specification</a> for further details.  In addition,
please reference Bloch's <i>Effective Java</i> item 66.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>IC_INIT_CIRCULARITY</id>
    <artifact tool="FindBugs" mnemonic="IC_INIT_CIRCULARITY"/>
    <name>Initialization circularity</name>
    <shortMessage>Initialization circularity between two classes should be removed.</shortMessage>
    <info>
<![CDATA[<p> A circularity was detected in the static initializers of
the two classes referenced by the bug instance. Many kinds of
unexpected behavior may arise from such circularity.  It is
recommended that this implementation be changed to avoid
circularity.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION</id>
    <artifact tool="FindBugs" mnemonic="IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION"/>
    <name>Superclass uses subclass during initialization</name>
    <shortMessage>Superclass uses subclass during initialization.</shortMessage>
    <info>
<![CDATA[<p>During the initialization of a class, the class makes an
active use of a subclass. That subclass will not yet be initialized at
the time of this use. For example, in the following code,
<code>foo</code> will be <code>null</code>.</p>

<pre>
public class CircularClassInitialization {

  static class InnerClassSingleton extends CircularClassInitialization {
    static InnerClassSingleton singleton = new InnerClassSingleton();
  }

  static CircularClassInitialization foo = InnerClassSingleton.singleton; // will be null
}
</pre>

<p>This finding probably indicates a muddled implementation or a
misunderstanding of the details of how Java instantiates
objects.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>IT_NO_SUCH_ELEMENT</id>
    <artifact tool="FindBugs" mnemonic="IT_NO_SUCH_ELEMENT"/>
    <name>Next must throw NoSuchElement</name>
    <shortMessage>The next() method implementation in this class should throw NoSuchElement exception when there are no more elements to return.</shortMessage>
    <info>
<![CDATA[<p>This class implements the <code>java.util.Iterator</code>
interface. However, its <code>next()</code> method is not capable of
throwing <code>java.util.NoSuchElementException</code>.</p>

<p>The <code>next()</code> method should be changed so it throws
<code>NoSuchElementException</code> if is called when there are no
more elements to return.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DL_SYNCHRONIZATION_ON_SHARED_CONSTANT</id>
    <artifact tool="FindBugs" mnemonic="DL_SYNCHRONIZATION_ON_SHARED_CONSTANT"/>
    <name>Synchronization on a shared constant</name>
    <shortMessage>Synchronization on a shared constant could lead to deadlock.</shortMessage>
    <info>
<![CDATA[<p>The code synchronizes on a shared primative constant, such
as an interned String.</p>

<pre>
private static String LOCK = "LOCK";
...
synchronized(LOCK) { ...}
...
</pre>

<p>Such constants an interned and shared across all other classes
loaded by the JVM. Thus, this could is locking on something that other
code might also be locking. This could result in very strange and hard
to diagnose blocking and deadlock behavior.</p>

<p>For further information please see <a
href="http://www.javalobby.org/java/forums/t96352.html">http://www.javalobby.org/java/forums/t96352.html</a>
and <a
href="http://jira.codehaus.org/browse/JETTY-352">http://jira.codehaus.org/browse/JETTY-352</a>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ESync_EMPTY_SYNC</id>
    <artifact tool="FindBugs" mnemonic="ESync_EMPTY_SYNC"/>
    <artifact tool="PMD" mnemonic="EmptySynchronizedBlock"/>
    <name>Empty synchronized block</name>
    <shortMessage>Empty synchronized block should be removed</shortMessage>
    <info>
<![CDATA[<p>The code contains an empty synchronized block:</p>

<pre>
synchronized(o) {}
</pre>

<p>Empty synchronized blocks are far more subtle and hard to use
correctly than most people recognize, and empty synchronized blocks
are almost never a better solution than less contrived solutions, for
example, use of the util concurrent library.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ML_SYNC_ON_UPDATED_FIELD</id>
    <artifact tool="FindBugs" mnemonic="ML_SYNC_ON_UPDATED_FIELD"/>
    <name>Synchronize on updated field</name>
    <shortMessage>Method synchronizes on an updated field.  This is likely to be incorrect.</shortMessage>
    <info>
<![CDATA[<p>This method synchronizes on an object references from a
mutable field. This is unlikely to have useful semantics, since
different threads may be synchronizing on different objects.</p>

<p>Multiple threads must synchronize on the same object to allow
shared data to be safely read and written.  It is therefore
recommended that all locks be final fields or <code>this</code> or a
static class (e.g., <code>MyClass.class</code>).</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>MS_OOI_PKGPROTECT</id>
    <artifact tool="FindBugs" mnemonic="MS_OOI_PKGPROTECT"/>
    <name>Field should be out of interface and package protected</name>
    <shortMessage>Field should should be moved out of an interface and made package protected to avoid malicious mutation.</shortMessage>
    <info>
<![CDATA[<p>A final static field that is defined in an interface
references a mutable object such as an array or hashtable. This
mutable object could be changed by malicious code or by accident from
another package.</p>

<p>To solve this, the field needs to be moved to a class and made
package protected to avoid this vulnerability.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>MS_FINAL_PKGPROTECT</id>
    <artifact tool="FindBugs" mnemonic="MS_FINAL_PKGPROTECT"/>
    <name>Field should be final and package protected</name>
    <shortMessage>Field should be both made both final and package protected to avoid malicious mutation.</shortMessage>
    <info>
<![CDATA[<p>A mutable static field could be changed by malicious code
or by accident from another package.</p>

<p>The field could be made package protected and/or made final to
avoid this vulnerability.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>MS_SHOULD_BE_FINAL</id>
    <artifact tool="FindBugs" mnemonic="MS_SHOULD_BE_FINAL"/>
    <name>Field should be final</name>
    <shortMessage>Field is not final but it should be to avoid malicious mutation.</shortMessage>
    <info>
<![CDATA[<p>A mutable static field could be changed by malicious code
or by accident from another package.</p>

<p>The field should be made final to avoid this vulnerability.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>MS_PKGPROTECT</id>
    <artifact tool="FindBugs" mnemonic="MS_PKGPROTECT"></artifact>
    <name>Field should be packaged protected</name>
    <shortMessage>Field should be made package protected to avoid malicious mutation.</shortMessage>
    <info>
<![CDATA[<p>A mutable static field could be changed by malicious code
or by accident.</p>

<p>The field could be made package protected to avoid this
vulnerability.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>MS_MUTABLE_HASHTABLE</id>
    <artifact tool="FindBugs" mnemonic="MS_MUTABLE_HASHTABLE"/>
    <name>Field is a mutable Hashtable</name>
    <shortMessage>Field is a mutable Hashtable that may be accessible by malicious code.</shortMessage>
    <info>
<![CDATA[<p>A final static field references a <code>Hashtable</code>
and can be accessed by malicious code or by accident from another
package. This code can freely modify the contents of the
<code>Hashtable</code>.</p>

<p>It is recommended that you consider replacing this
<code>Hashtable</code> with a <code>Map</code> implementation, such as
<code>HashMap</code>.]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>MS_MUTABLE_ARRAY</id>
    <artifact tool="FindBugs" mnemonic="MS_MUTABLE_ARRAY"/>
    <name>Field is a mutable array</name>
    <shortMessage>Field is a mutable array that may be accessible by malicious code.</shortMessage>
    <info>
<![CDATA[<p>A final static field references an array and can be
accessed by malicious code or by accident from another package. This
code can freely modify the contents of the array.</p>

<p>Consider encapsulating this field by reducing its visibility.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>MS_CANNOT_BE_FINAL</id>
    <artifact tool="FindBugs" mnemonic="MS_CANNOT_BE_FINAL"/>
    <name>Field cannot be final</name>
    <shortMessage>Field isn't final and can't be protected from malicious code.</shortMessage>
    <info>
<![CDATA[<p>A mutable static field could be changed by malicious code
or by accident from another package.  Unfortunately, the way the field
is used doesn't allow any easy fix to this problem.</p>

<p>Consider encapsulating this field by reducing its visibility.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>IA_AMBIGUOUS_INVOCATION_OF_INHERITED_OR_OUTER_METHOD</id>
    <artifact tool="FindBugs" mnemonic="IA_AMBIGUOUS_INVOCATION_OF_INHERITED_OR_OUTER_METHOD"/>
    <name>Ambiguous invocation of inherited or outer method</name>
    <shortMessage>Ambiguous invocation of either an inherited or outer method.</shortMessage>
    <info>
<![CDATA[<p>An inner class is invoking a method that could be resolved
to either a inherited method or a method defined in an outer class. By
the Java semantics, it will be resolved to invoke the inherited
method, but this may not be want you intend.</p>

<p>If you really intend to invoke the inherited method, invoke it by
invoking the method on <code>super</code>, for example, invoke
<code>super.foo(17)</code>, and thus it will be clear to other readers
of your code that you want to invoke the inherited method, not the
method in the outer class.</p>

<p>You may also want to consider renaming one or both of the methods
to avoid the confusion altogether.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NM_CLASS_NAMING_CONVENTION</id>
    <artifact tool="FindBugs" mnemonic="NM_CLASS_NAMING_CONVENTION"/>
    <artifact tool="PMD" mnemonic="ClassNamingConventions"/>
    <name>Class naming convention violation</name>
    <shortMessage>Class names should start with an upper case letter.</shortMessage>
    <info>
<![CDATA[<p>Class names should be nouns, in mixed case with the first
letter of each internal word capitalized. Try to keep your class names
simple and descriptive. Use whole words&mdash;avoid acronyms and
abbreviations.  Unless, of course, the abbreviation is much more
widely used than the long form, such as URL or HTML, it is recommended
that you use mixed case.  For example, <code>MyUrlClass</code> or
<code>HttpServlet</code>.</p>

<p>Class names should always begin with an upper case
character.</p>

<p>For further information, please reference Bloch's <i>Effective
Java</i> (second edition) item 56.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NM_METHOD_NAMING_CONVENTION</id>
    <artifact tool="FindBugs" mnemonic="NM_METHOD_NAMING_CONVENTION"/>
    <artifact tool="PMD" mnemonic="MethodNamingConventions"/>
    <name>Method naming convention violation</name>
    <shortMessage>Method names should start with an lower case letter.</shortMessage>
    <info>
<![CDATA[<p>Methods should be verbs, in mixed case with the first
letter lowercase, with the first letter of each internal word
capitalized.</p>

<p>Method names should always begin with a lower case character, and
should not contain underscores.</p>

<p>For further information, please reference Bloch's <i>Effective
Java</i> (second edition) item 56.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NM_FIELD_NAMING_CONVENTION</id>
    <artifact tool="FindBugs" mnemonic="NM_FIELD_NAMING_CONVENTION"/>
    <artifact tool="PMD" mnemonic="VariableNamingConventions"/>
    <name>Field naming convention violation</name>
    <shortMessage>Field names should start with an lower case letter.</shortMessage>
    <info>
<![CDATA[<p>Names of fields that are not final should be in mixed case
with a lowercase first letter and the first letters of subsequent
words capitalized.</p>

<p>Final variables that should be fully capitalized and non-final
variables should not include underscores.</p>

<p>For further information, please reference Bloch's <i>Effective
Java</i> (second edition) item 56.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NM_VERY_CONFUSING</id>
    <artifact tool="FindBugs" mnemonic="NM_VERY_CONFUSING"/>
    <name>Very confusing method names</name>
    <shortMessage>Very confusing method names, consider renaming one or both methods.</shortMessage>
    <info>
<![CDATA[<p>The referenced methods have names that differ only by
capitalization or the packages of their parameters. This is very
confusing because if the capitalization and parameter package names
were identical then one of the methods would override the other.</p>

<p>Consider renaming one or both methods to clarify their
differences.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NM_VERY_CONFUSING_INTENTIONAL</id>
    <artifact tool="FindBugs" mnemonic="NM_VERY_CONFUSING_INTENTIONAL"/>
    <name>Very confusing intentional method names</name>
    <shortMessage>Very confusing (but intentional) method names, consider trying to eliminate one of them.</shortMessage>
    <info>
<![CDATA[<p>The referenced methods have names that differ only by
capitalization or the packages of their parameters. This is very
confusing because if the capitalization were identical then one of the
methods would override the other.</p>

<p>From the existence of other methods, it seems that the existence of
both of these methods is intentional, but is sure is confusing. You
should try hard to eliminate one of them, unless you are forced to
have both due to frozen APIs.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NM_CONFUSING</id>
    <artifact tool="FindBugs" mnemonic="NM_CONFUSING"/>
    <name>Confusing method names</name>
    <shortMessage>Confusing method names, consider renaming one or both methods.</shortMessage>
    <info>
<![CDATA[<p>The referenced methods have names that differ only by
capitalization.</p>

<p>Consider renaming one or both methods to clarify their
differences.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NM_METHOD_CONSTRUCTOR_CONFUSION</id>
    <artifact tool="FindBugs" mnemonic="NM_METHOD_CONSTRUCTOR_CONFUSION"/>
    <name>Method vs constructor confusion</name>
    <shortMessage>Apparent method versus constructor confusion.</shortMessage>
    <info>
<![CDATA[<p>This regular method has the same name as the class it is
defined in. It is likely that this was intended to be a
constructor.</p>

<p>If it was intended to be a constructor, remove the declaration of a
void return value. If you had accidently defined this method, realized
the mistake, defined a proper constructor but can't get rid of this
method due to backwards compatibility, deprecate the method.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SuspiciousHashcodeMethodName</id>
    <artifact tool="FindBugs" mnemonic="NM_LCASE_HASHCODE"/>
    <artifact tool="PMD" mnemonic="SuspiciousHashcodeMethodName"/>
    <name>Suspicious hashcode method name</name>
    <shortMessage>Class defines hashcode(); should it be hashCode()?</shortMessage>
    <info>
<![CDATA[<p>This class defines a method called
<code>hashcode</code>. This method does not override the
<code>hashCode</code> method in <code>java.lang.Object</code>, which
is probably what was intended.</p>

<p>The method name and return type are suspiciously close to
<code>hashCode</code>, which may mean you are intending to override
the <code>hashCode</code> method.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NM_LCASE_TOSTRING</id>
    <artifact tool="FindBugs" mnemonic="NM_LCASE_TOSTRING"/>
    <name>Suspicious tostring method name</name>
    <shortMessage>Class defines tostring(); should it be toString()?</shortMessage>
    <info>
<![CDATA[<p>This class defines a method called
<code>tostring</code>. This method does not override the
<code>toString</code> method in <code>java.lang.Object</code>, which
is probably what was intended.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SuspiciousEqualsMethodName</id>
    <artifact tool="FindBugs" mnemonic="NM_BAD_EQUAL"/>
    <artifact tool="PMD" mnemonic="SuspiciousEqualsMethodName"/>
    <name>Suspicious equals method name</name>
    <shortMessage>Class defines equal(); should it be equals()?</shortMessage>
    <info>
<![CDATA[<p>This class defines a method
<code>equal(Object)</code>. This method does not override the
<code>equals(Object)</code> method in <code>java.lang.Object</code>,
which is probably what was intended.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NM_CLASS_NOT_EXCEPTION</id>
    <artifact tool="FindBugs" mnemonic="NM_CLASS_NOT_EXCEPTION"/>
    <name>Class not an exception</name>
    <shortMessage>Class is not derived from an Exception, even though it is named as such.</shortMessage>
    <info>
<![CDATA[<p>This class is not derived from another exception, but ends
with <tt>Exception</tt>. This will be confusing to users of this
class.</p>

<p>Consider renaming this class to clarify this code.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>RR_NOT_CHECKED</id>
    <artifact tool="FindBugs" mnemonic="RR_NOT_CHECKED"/>
    <name>Read return value not checked</name>
    <shortMessage>Method ignores results of one of the variants of the java.io.InputStream read method.</shortMessage>
    <info>
<![CDATA[<p>This method ignores the return value of one of the
variants of <code>java.io.InputStream.read()</code> which can return
multiple bytes. If the return value is not checked, the caller will
not be able to correctly handle the case where fewer bytes were read
than the caller requested.</p>

<p>This is a particularly insidious kind of bug, because in many
programs, reads from input streams usually do read the full amount of
data requested, causing the program to fail only sporadically.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SR_NOT_CHECKED</id>
    <artifact tool="FindBugs" mnemonic="SR_NOT_CHECKED"/>
    <name>Skip return value not checked</name>
    <shortMessage>Method ignores results of one of the variants of the java.io.InputStream skip method.</shortMessage>
    <info>
<![CDATA[<p>This method ignores the return value of
<code>java.io.InputStream.skip()</code> which can skip multiple
bytes. If the return value is not checked, the caller will not be able
to correctly handle the case where fewer bytes were skipped than the
caller requested.</p>

<p>This is a particularly insidious kind of bug, because in many
programs, skips from input streams usually do skip the full amount of
data requested, causing the program to fail only sporadically. With
Buffered streams, however, <code>skip()</code> will only skip data in
the buffer, and will routinely fail to skip the requested number of
bytes.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SE_READ_RESOLVE_MUST_RETURN_OBJECT</id>
    <artifact tool="FindBugs" mnemonic="SE_READ_RESOLVE_MUST_RETURN_OBJECT"/>
    <name>ReadResolve method must declare a return type of Object</name>
    <shortMessage>The readResolve method must be declared with a return type of Object.</shortMessage>
    <info>
<![CDATA[<p>In order for the <code>readResolve</code> method to be
recognized by the serialization mechanism it must declare a return
type of <code>java.lang.Object</code>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SE_TRANSIENT_FIELD_OF_NONSERIALIZABLE_CLASS</id>
    <artifact tool="FindBugs" mnemonic="SE_TRANSIENT_FIELD_OF_NONSERIALIZABLE_CLASS"/>
    <name>Transient field in a non-serializable class</name>
    <shortMessage>Transient field in a class that is not Serializable.</shortMessage>
    <info>
<![CDATA[<p>The field is marked as transient, but the class isn't
<code>Serializable</code>, so marking it as transient has absolutely
no effect.</p>

<p>This may be leftover marking from a previous version of the code in
which the class was transient, or it may indicate a misunderstanding
of how serialization works.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SE_TRANSIENT_FIELD_NOT_RESTORED</id>
    <artifact tool="FindBugs" mnemonic="SE_TRANSIENT_FIELD_NOT_RESTORED"/>
    <name>Suspicious transient field</name>
    <shortMessage>Transient field that isn't set by deserialization.</shortMessage>
    <info>
<![CDATA[<p>This class contains a field that is updated at multiple
places in the class, thus it seems to be part of the state of the
class. However, since the field is marked as transient and not set in
<code>readObject</code> or <code>readResolve</code>, it will contain
the default value in any deserialized instance of the class.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SE_METHOD_MUST_BE_PRIVATE</id>
    <artifact tool="FindBugs" mnemonic="SE_METHOD_MUST_BE_PRIVATE"/>
    <name>Serialization method must be private</name>
    <shortMessage>Method must be declared to be private in order for serialization to work.</shortMessage>
    <info>
<![CDATA[<p>This class implements the <code>Serializable</code>
interface, and defines a method for custom
serialization/deserialization. But since that method isn't declared
private, it will be silently ignored by the
serialization/deserialization API.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SE_NO_SUITABLE_CONSTRUCTOR_FOR_EXTERNALIZATION</id>
    <artifact tool="FindBugs" mnemonic="SE_NO_SUITABLE_CONSTRUCTOR_FOR_EXTERNALIZATION"/>
    <name>No suitable constructor for externalization</name>
    <shortMessage>Class is Externalizable but it doesn't define a void constructor so it will fail at runtime.</shortMessage>
    <info>
<![CDATA[<p>This class implements the <code>Externalizable</code>
interface, but does not define a void constructor. When
<code>Externalizable</code> objects are deserialized, they first need
to be constructed by invoking the void constructor. Because this class
does not have one, serialization and deserialization will fail at
runtime.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SE_NO_SUITABLE_CONSTRUCTOR</id>
    <artifact tool="FindBugs" mnemonic="SE_NO_SUITABLE_CONSTRUCTOR"/>
    <name>No suitable constructor for serialization</name>
    <shortMessage>Class is Serializable but its superclass doesn't define a void constructor so it will fail at runtime.</shortMessage>
    <info>
<![CDATA[<p> This class implements the <code>Serializable</code>
interface and its superclass does not. When such an object is
deserialized, the fields of the superclass need to be initialized by
invoking the void constructor of the superclass. Since the superclass
does not have one, serialization and deserialization will fail at
runtime.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SE_NO_SERIALVERSIONID</id>
    <artifact tool="FindBugs" mnemonic="SE_NO_SERIALVERSIONID"/>
    <artifact tool="PMD" mnemonic="MissingSerialVersionUID"/>
    <name>No serialVersionUID field defined for serialization</name>
    <shortMessage>Class is Serializable, but it doesn't define a serialVersionUID field.</shortMessage>
    <info>
<![CDATA[<p>This class implements the <code>Serializable</code>
interface, but does not define a <code>serialVersionUID</code>
field.</p>

<p>A change as simple as adding a reference to a <code>.class</code>
object will add synthetic fields to the class, which will
unfortunately change the implicit serialVersionUID.  For example,
adding a reference to <code>String.class</code> will generate a static
field <code>class$java$lang$String</code>.</p>

<p>Also, different source code to bytecode compilers may use different
naming conventions for synthetic variables generated for references to
class objects or inner classes.  To ensure interoperability of
<code>Serializable</code> across versions, consider adding an explicit
<code>serialVersionUID</code> field.</p>

<p>This field can be generated within some Java IDEs. For example the
below <code>serialVersionUID</code> field was generated by
Eclipse.</p>

<pre>
public final class FutureDatabaseException extends Exception {
  ...
  private static final long serialVersionUID = 6446502447505736644L;
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SE_COMPARATOR_SHOULD_BE_SERIALIZABLE</id>
    <artifact tool="FindBugs" mnemonic="SE_COMPARATOR_SHOULD_BE_SERIALIZABLE"/>
    <name>Comparator should be Serializable</name>
    <shortMessage>Comparator doesn't implement Serializable.</shortMessage>
    <info>
<![CDATA[<p>This class implements the <code>Comparator</code>
interface. You should consider whether or not it should also implement
the <code>Serializable</code> interface. If a comparator is used to
construct an ordered collection such as a <code>TreeMap</code>, then
the <code>TreeMap</code> will be serializable only if the comparator
is also serializable.</p>

<p>As most comparators have little or no state, making them
serializable is generally easy and good defensive programming.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SF_SWITCH_FALLTHROUGH</id>
    <artifact tool="FindBugs" mnemonic="SF_SWITCH_FALLTHROUGH"/>
    <artifact tool="PMD" mnemonic="MissingBreakInSwitch"/>
    <name>Switch fallthrough</name>
    <shortMessage>Switch statement found where one case falls through to the next case.  Did you forget a break or return?</shortMessage>
    <info>
<![CDATA[<p>This method contains a switch statement where one case
branch will fall through to the next case. Usually you need to end
this case with a break or return.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH</id>
    <artifact tool="FindBugs" mnemonic="SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH"/>
    <name>Dead store due to switch fallthrough</name>
    <shortMessage>Dead store due to switch statement fallthrough.  Did you forget a break or return?</shortMessage>
    <info>
<![CDATA[<p>A value stored in the previous switch case is overwritten
here due to a switch fall through. It is likely that you forgot to put
a break or return at the end of the previous case.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>WS_WRITEOBJECT_SYNC</id>
    <artifact tool="FindBugs" mnemonic="WS_WRITEOBJECT_SYNC"/>
    <name>Suspicious writeObject is the only synchronized method</name>
    <shortMessage>Suspicious that the writeObject() method is synchronized but nothing else is.</shortMessage>
    <info>
<![CDATA[<p>This class has a <code>writeObject()</code> method which
is synchronized; however, no other method of the class is
synchronized.  Check that the concurrency policy of this class is
implemented correctly.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>RS_READOBJECT_SYNC</id>
    <artifact tool="FindBugs" mnemonic="RS_READOBJECT_SYNC"/>
    <name>Suspicious synchronized readObject method</name>
    <shortMessage>Suspicious that the readObject() method is synchronized, it probably does not need to be.</shortMessage>
    <info>
<![CDATA[<p>This serializable class defines a
<code>readObject()</code> which is synchronized. By definition, an
object created by deserialization is only reachable by one thread, and
thus there is no need for <code>readObject()</code> to be
synchronized.</p>

<p>If the <code>readObject()</code> method itself is causing the
object to become visible to another thread, that is an example of very
dubious coding style.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SE_NONSTATIC_SERIALVERSIONID</id>
    <artifact tool="FindBugs" mnemonic="SE_NONSTATIC_SERIALVERSIONID"/>
    <name>Non-static serialVersionUID field</name>
    <shortMessage>The serialVersionUID field is not static, but it should be.</shortMessage>
    <info>
<![CDATA[<p>This class defines a <code>serialVersionUID</code> field
that is not static.</p>

<p>The field should be made static if it is intended to specify the
version UID for purposes of serialization. If it is not intended for
this purpose it should probably be renamed to avoid confusion.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SE_NONFINAL_SERIALVERSIONID</id>
    <artifact tool="FindBugs" mnemonic="SE_NONFINAL_SERIALVERSIONID"/>
    <name>Non-final serialVirsionUID field</name>
    <shortMessage>The serialVersionUID is not final, but it should be.</shortMessage>
    <info>
<![CDATA[<p>This class defines a <code>serialVersionUID</code> field
that is not final.</p>

<p>The field should be made final if it is intended to specify the
version UID for purposes of serialization. If it is not intended for
this purpose it should probably be renamed to avoid confusion.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SE_NONLONG_SERIALVERSIONID</id>
    <artifact tool="FindBugs" mnemonic="SE_NONLONG_SERIALVERSIONID"/>
    <name>Non-long serialVersionUID field</name>
    <shortMessage>serialVersionUID is not of type long, but it should be.</shortMessage>
    <info>
<![CDATA[<p>This class defines a <code>serialVersionUID</code> field
that is not long.</p>

<p>The field should be made long if it is intended to specify the
version UID for purposes of serialization. If it is not intended for
this purpose it should probably be renamed to avoid confusion.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SE_BAD_FIELD</id>
    <artifact tool="FindBugs" mnemonic="SE_BAD_FIELD"/>
    <name>Bad field in a serializable class</name>
    <shortMessage>Non-transient, non-serializable instance field in a serializable class.  This class could fail at runtime.</shortMessage>
    <info>
<![CDATA[<p>This <code>Serializable</code> class defines a
non-primitive instance field which is neither <code>transient</code>,
<code>Serializable</code>, or <code>java.lang.Object</code>, and does
not appear to implement the <code>Externalizable</code> interface or
the <code>readObject()</code> and <code>writeObject()</code>
methods.</p>

<p>Objects of this class will not be deserialized correctly if a
non-Serializable object is stored in this field.  Consider fixing this
implementation so that it can be statically checked.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SE_BAD_FIELD_INNER_CLASS</id>
    <artifact tool="FindBugs" mnemonic="SE_BAD_FIELD_INNER_CLASS"/>
    <name>Serializable inner class inside a non-serializable class</name>
    <shortMessage>Non-serializable class has a serializable inner class.  This class could fail at runtime.</shortMessage>
    <info>
<![CDATA[<p>This Serializable class is an inner class of a
non-serializable class. Thus, attempts to serialize it will also
attempt to serialize the instance of the outer class with which it is
associated, leading to a runtime error.</p>

<p>If possible, making the inner class a static inner class should
solve the problem. Making the outer class serializable might also
work, but that would mean serializing an instance of the inner class
would always also serialize the instance of the outer class, which is
often not what you really want.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SE_INNER_CLASS</id>
    <artifact tool="FindBugs" mnemonic="SE_INNER_CLASS"/>
    <name>Serializable inner class</name>
    <shortMessage>Serializable inner class will also serialize the associated outer instance.  Is this intended?</shortMessage>
    <info>
<![CDATA[<p>This Serializable class is an inner class. Any attempt to
serialize it will also serialize the associated outer instance. The
outer instance is serializable, so this won't fail, but it might
serialize a lot more data than intended.</p>

<p>If possible, declaring the inner class to be static might be what
you want to do to avoid this issue.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SE_BAD_FIELD_STORE</id>
    <artifact tool="FindBugs" mnemonic="SE_BAD_FIELD_STORE"/>
    <name>Non-serializable value stored into a serializable field</name>
    <shortMessage>Non-serializable value stored into instance field of a serializable class.</shortMessage>
    <info>
<![CDATA[<p>A non-serializable value is stored into a non-transient
field of a serializable class.  This may cause the class to fail at
runtime when it is serialized.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SC_START_IN_CTOR</id>
    <artifact tool="FindBugs" mnemonic="SC_START_IN_CTOR"/>
    <name>Thread start in constructor</name>
    <shortMessage>This constructor invokes Thread.start() which is highly dubious.</shortMessage>
    <info>
<![CDATA[<p>The constructor starts a thread. This is likely to be
wrong if the class is ever extended/subclassed, since the thread will
be started before the subclass constructor is started.  This practice
can also cause subtle race conditions.</p>

<p>Consider moving the thread start into a separate method, such as an
<code>init</code> method.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SS_SHOULD_BE_STATIC</id>
    <artifact tool="FindBugs" mnemonic="SS_SHOULD_BE_STATIC"/>
    <artifact tool="PMD" mnemonic="FinalFieldCouldBeStatic"/>
    <name>Should field be static</name>
    <shortMessage>This field is initialized to a compile-time static value.  Should this field be static?</shortMessage>
    <info>
<![CDATA[<p>This class contains an instance final field that is
initialized to a compile-time static value. Consider making the field
static.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UUF_UNUSED_FIELD</id>
    <artifact tool="FindBugs" mnemonic="UUF_UNUSED_FIELD"/>
    <artifact tool="PMD" mnemonic="UnusedPrivateField"/>
    <name>Unused field</name>
    <shortMessage>This field is never used.</shortMessage>
    <info>
<![CDATA[<p>This field is never used. Consider removing it from the
class.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>URF_UNREAD_FIELD</id>
    <artifact tool="FindBugs" mnemonic="URF_UNREAD_FIELD"/>
    <name>Unread field</name>
    <shortMessage>This field is never read.</shortMessage>
    <info>
<![CDATA[<p>This field is never read. Consider removing it from the
class.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>QF_QUESTIONABLE_FOR_LOOP</id>
    <artifact tool="FindBugs" mnemonic="QF_QUESTIONABLE_FOR_LOOP"/>
    <name>Questionable for loop</name>
    <shortMessage>Complicated, subtle or wrong increment in for loop.</shortMessage>
    <info>
<![CDATA[<p>Are you sure this for loop is incrementing the correct
variable? It appears that another variable is being initialized and
checked by the for loop.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UWF_NULL_FIELD</id>
    <artifact tool="FindBugs" mnemonic="UWF_NULL_FIELD"/>
    <name>Null-only field</name>
    <shortMessage>This field is always null. Check for errors or remove the field if it is useless.</shortMessage>
    <info>
<![CDATA[<p>All writes to this field are the constant value
<code>null</code>, and thus all reads of the field will return
<code>null</code>. It is highly likely that there is something muddled
about this code. Check for errors, or remove the field if it is
useless.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UWF_UNWRITTEN_FIELD</id>
    <artifact tool="FindBugs" mnemonic="UWF_UNWRITTEN_FIELD"/>
    <artifact tool="FindBugs" mnemonic="NP_UNWRITTEN_FIELD"/>
    <name>Unwritten field</name>
    <shortMessage>This field is never written to. All reads of it will return the default value. Is this intended?</shortMessage>
    <info>
<![CDATA[<p>This field is never written to. All reads of it will
return the default value. Check for errors (e.g., should this field
have been initialized?), or remove it if it is useless.</p>

<p>If this field is an object reference, i.e., not of a primitive
type, then it will be <code>null</code> and dereferencing it will
throw a <code>NullPointerException</code>.]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD</id>
    <artifact tool="FindBugs" mnemonic="ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD"/>
    <name>Write to a static from an instance method</name>
    <shortMessage>Write to a static field from an instance method. Is this intended?</shortMessage>
    <info>
<![CDATA[<p>This instance method writes to a static field.  This is
tricky to get correct if multiple instances of this class are being
manipulated, and generally bad practice.  Also check that this write
has not created a race condition.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NP_LOAD_OF_KNOWN_NULL_VALUE</id>
    <artifact tool="FindBugs" mnemonic="NP_LOAD_OF_KNOWN_NULL_VALUE"/>
    <name>Load Of Known Null Value</name>
    <shortMessage>Load of known null value</shortMessage>
    <info>
<![CDATA[<p>The variable referenced at this point is known to be
<code>null</code> due to an earlier check against
<code>null</code>. Although this is valid, it might be a mistake</p>

<p>Perhaps you intended to refer to a different variable, or perhaps
the earlier check to see if the variable is <code>null</code> should
have been a check to see if it was non-null.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NP_IMMEDIATE_DEREFERENCE_OF_READLINE</id>
    <artifact tool="FindBugs" mnemonic="NP_IMMEDIATE_DEREFERENCE_OF_READLINE"/>
    <name>Immediate dereference of readLine result</name>
    <shortMessage>This code immediately dereferences the result of a call to readLine().  This code may throw a NullPointerException.</shortMessage>
    <info>
<![CDATA[<p>The result of invoking <code>readLine()</code> is
immediately dereferenced by this code. If there are no more lines of
text to read, <code>readLine()</code> method will return
<code>null</code> and dereferencing that will throw a
<code>NullPointerException</code>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SIC_INNER_SHOULD_BE_STATIC</id>
    <artifact tool="FindBugs" mnemonic="SIC_INNER_SHOULD_BE_STATIC"/>
    <artifact tool="FindBugs" mnemonic="SIC_INNER_SHOULD_BE_STATIC_ANON"/>
    <artifact tool="FindBugs" mnemonic="SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS"/>
    <name>Inner class should be static</name>
    <shortMessage>This inner class should be declared to be static.</shortMessage>
    <info>
<![CDATA[<p>This class is an inner class, but does not use its
embedded reference to the object which created it. This reference
makes instances of the inner class larger, and may keep the reference
to the creator object alive longer than necessary.  If possible, the
class should be made static.</p>

<p>If the inner class is anonymous then it will need to be named to be
declared to be <code>static</code>.  This is because anonymous inner
classes cannot be marked as <code>static</code>.</p>

<p>If a reference to the outer object is required during construction
of the inner instance, the inner class will need to be refactored so
as to pass a reference to the outer instance to the constructor for
the inner class (after construction the outer instance reference
should no longer be needed).</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NP_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR</id>
    <artifact tool="FindBugs" mnemonic="NP_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR"/>
    <artifact tool="FindBugs" mnemonic="UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR"/>
    <name>Field not initialized in constructor</name>
    <shortMessage>This code reads a field that is not initialized in any constructor.</shortMessage>
    <info>
<![CDATA[<p>This is a read of a field is never initialized within any
constructor, and is therefore could be <code>null</code> after the
object is initialized. If this field is dereferenced it could cause a
<code>NullPointerException</code> to be thrown.</p>

<p>This might be a coding error, or else the class containing the
field is written in a way that depends upon methods being called in
some specific order (perhaps a little bit dodgy, but not necessarily
wrong).</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>WA_NOT_IN_LOOP</id>
    <artifact tool="FindBugs" mnemonic="WA_NOT_IN_LOOP"></artifact>
    <name>Wait outside loop</name>
    <shortMessage>This call to wait is not in loop. Are you sure the condition waited for is true?</shortMessage>
    <info>
<![CDATA[<p>This method contains a call to
<code>java.lang.Object.wait()</code> which is not in a loop.  If the
monitor is used for multiple conditions, the condition the caller
intended to wait for might not be the one that actually
occurred.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>WA_AWAIT_NOT_IN_LOOP</id>
    <artifact tool="FindBugs" mnemonic="WA_AWAIT_NOT_IN_LOOP"/>
    <name>Await outside loop</name>
    <shortMessage>This call to Condition.await() is not in a loop.  Are you sure the condition waited for is true?</shortMessage>
    <info>
<![CDATA[<p>This method contains a call to
<code>java.util.concurrent.Condition.await()</code> (or variants)
which is not in a loop. If the object is used for multiple conditions,
the condition the caller intended to wait for might not be the one
that actually occurred.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NO_NOTIFY_NOT_NOTIFYALL</id>
    <artifact tool="FindBugs" mnemonic="NO_NOTIFY_NOT_NOTIFYALL"/>
    <artifact tool="PMD" mnemonic="UseNotifyAllInsteadOfNotify"/>
    <name>Use notifyAll not notify</name>
    <shortMessage>Consider using notifyAll() rather than notify().</shortMessage>
    <info>
<![CDATA[<p>This method calls <code>notify()</code> rather than
<code>notifyAll()</code>. Java monitors are often used for multiple
conditions. Calling <code>notify()</code> only wakes up one thread,
meaning that the thread woken up might not be the one waiting for the
condition that the caller just satisfied.</p>

<p>The thread chosen is arbitrary (i.e., it is <i>not</i> the first
thread that waited); thus it's usually safer to call
<code>notifyAll()</code> instead.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>RV_CHECK_FOR_POSITIVE_INDEXOF</id>
    <artifact tool="FindBugs" mnemonic="RV_CHECK_FOR_POSITIVE_INDEXOF"/>
    <name>Avoid check for positive indexOf</name>
    <shortMessage>Method checks to see if result of String.indexOf is positive rather than negative.</shortMessage>
    <info>
<![CDATA[<p>The method invokes <code>String.indexOf</code> and checks
to see if the result is positive or non-positive. It is much more
typical to check to see if the result is negative or non-negative.
The reason for this is that a result of 0 indicates that the substring
occurs at the beginning of the String&mdash;not that it was not
found. The result is positive only if the substring checked for occurs
at some place other than at the beginning of the String.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>RV_DONT_JUST_NULL_CHECK_READLINE</id>
    <artifact tool="FindBugs" mnemonic="RV_DONT_JUST_NULL_CHECK_READLINE"/>
    <name>Line read by readLine ignored</name>
    <shortMessage>Method discards the result of readLine() after checking if it is non-null. Is it intended to throw away the line just read?</shortMessage>
    <info>
<![CDATA[<p>The value returned by <code>readLine()</code> is discarded
after checking to see if it is non-null. In almost all situations, if
the result is non-null, you will want to use that non-null value
because it represents the line that was read. Note that calling
<code>readLine</code> again will give you a different line.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>RV_RETURN_VALUE_IGNORED</id>
    <artifact tool="FindBugs" mnemonic="RV_RETURN_VALUE_IGNORED"/>
    <artifact tool="FindBugs" mnemonic="RV_RETURN_VALUE_IGNORED2"/>
    <name>Immutable object return value ignored</name>
    <shortMessage>This code ignores the return value of an immutable object.  Is this a mistake?</shortMessage>
    <info>
<![CDATA[<p>The return value of this method should be checked.  One
common cause of this warning is to invoke a method on an immutable
object, thinking that it updates the object. For example, in the
following code fragment,</p>

<pre>
String dateString = getHeaderField(name);
dateString.trim();
</pre>

<p>the programmer seems to be thinking that the <code>trim()</code>
method will update the String referenced by
<code>dateString</code>. But since Strings are immutable, the
<code>trim()</code> function returns a new String value, which is
being ignored here. The code should be corrected to: </p>

<pre>
String dateString = getHeaderField(name);
dateString = dateString.trim();
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NP_ALWAYS_NULL</id>
    <artifact tool="FindBugs" mnemonic="NP_ALWAYS_NULL"></artifact>
    <name>Null dereference</name>
    <shortMessage>A null pointer is dereferenced here which will throw a NullPointerException at runtime.</shortMessage>
    <info>
<![CDATA[<p>A <code>null</code> pointer is dereferenced here.  This
will lead to a <code>NullPointerException</code> being thrown when the
code is executed.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NP_STORE_INTO_NONNULL_FIELD</id>
    <artifact tool="FindBugs" mnemonic="NP_STORE_INTO_NONNULL_FIELD"/>
    <name>Store into a @NonNull field</name>
    <shortMessage>Store of a possible null value into field annotated with @NonNull.</shortMessage>
    <info>
<![CDATA[<p>A value that could be <code>null</code> is stored into a
field that has been annotated @NonNull.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NP_ALWAYS_NULL_EXCEPTION</id>
    <artifact tool="FindBugs" mnemonic="NP_ALWAYS_NULL_EXCEPTION"/>
    <artifact tool="FindBugs" mnemonic="NP_NULL_ON_SOME_PATH_EXCEPTION"/>
    <name>Null dereference on exceptional path</name>
    <shortMessage>This code has a null pointer dereference on an exceptional path.</shortMessage>
    <info>
<![CDATA[<p>A pointer which is <code>null</code> on an exception path
is dereferenced here. This will lead to a
<code>NullPointerException</code> being thrown when the code is
executed. Note that because the analysis currently does not prune
infeasible exception paths, this may be a false warning.</p>

<p>Also note that the analysis considers the default case of a
<code>switch</code> statement to be an exception path, since the
default case is often infeasible.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NP_NULL_ON_SOME_PATH</id>
    <artifact tool="FindBugs" mnemonic="NP_NULL_ON_SOME_PATH">
    </artifact>
    <name>Null dereference on some path</name>
    <shortMessage>This code may dereference a null pointer and throw a NullPointerException.</shortMessage>
    <info>
<![CDATA[<p>A reference value dereferenced here might be
<code>null</code> at runtime. This may lead to a
<code>NullPointerException</code> being thrown when the code is
executed.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE</id>
    <artifact tool="FindBugs" mnemonic="NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE"/>
    <name>Null dereference on some path from return</name>
    <shortMessage>This code may dereference a null pointer and throw a NullPointerException due to return value of a called method.</shortMessage>
    <info>
<![CDATA[<p>A reference value which is <code>null</code> on some
exception control path is dereferenced here. This may lead to a
<code>NullPointerException</code> when the code is executed.</p>

<p>The value may be <code>null</code> because it was returned from a
method which is known to return possibly-null values.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NP_NULL_PARAM_DEREF_NONVIRTUAL</id>
    <artifact tool="FindBugs" mnemonic="NP_NULL_PARAM_DEREF_NONVIRTUAL"/>
    <artifact tool="FindBugs" mnemonic="NP_NULL_PARAM_DEREF_ALL_TARGETS_DANGEROUS"/>
    <artifact tool="FindBugs" mnemonic="NP_NULL_PARAM_DEREF"/>
    <name>Null derefrence of paparamenterNull Param Deref Nonvirtual</name>
    <shortMessage>A method call passes null for an unconditionally dereferenced parameter.  This may result in a NullPointerException being thrown if this code is executed.</shortMessage>
    <info>
<![CDATA[<p>A possibly-<code>null</code> value is passed to a method
which unconditionally dereferences it. This may result in a
<code>NullPointerException</code> being thrown at runtime if this code
is executed.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NP_NONNULL_PARAM_VIOLATION</id>
    <artifact tool="FindBugs" mnemonic="NP_NONNULL_PARAM_VIOLATION"/>
    <name>NonNull parameter violation</name>
    <shortMessage>This method call passes null to a non-null parameter.</shortMessage>
    <info>
<![CDATA[<p>This method passes a <code>null</code> value as the
parameter of a method which must be non-null. Either this parameter has
been explicitly annotated as @NonNull, or the analysis has determined that
this parameter is always deferenced.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NP_NONNULL_RETURN_VIOLATION</id>
    <artifact tool="FindBugs" mnemonic="NP_NONNULL_RETURN_VIOLATION"/>
    <name>NonNull return violation</name>
    <shortMessage>This method may return null, but its return value is declared @NonNull.</shortMessage>
    <info>
<![CDATA[<p>This method may return a <code>null</code> value, but the
method (or a superclass method which it overrides) is declared to
return @NonNull.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NP_CLONE_COULD_RETURN_NULL</id>
    <artifact tool="FindBugs" mnemonic="NP_CLONE_COULD_RETURN_NULL"/>
    <name>Clone may return null</name>
    <shortMessage>This clone method may return null. This violates the contract for clone.</shortMessage>
    <info>
<![CDATA[<p>This clone method seems to return <code>null</code> in
some circumstances.  This violates the contract for clone because it
is never allowed to return a <code>null</code> value.</p>

<p>If you are convinced this path is unreachable, throw an
<code>AssertionError</code> instead of returning
<code>null</code>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NP_TOSTRING_COULD_RETURN_NULL</id>
    <artifact tool="FindBugs" mnemonic="NP_TOSTRING_COULD_RETURN_NULL"/>
    <name>ToString may return rull</name>
    <shortMessage>This toString() method may return null.  This could cause other code to break and is a bad coding practice.</shortMessage>
    <info>
<![CDATA[<p>This <code>toString()</code> method seems to return
<code>null</code> in some circumstances. A liberal reading of the
specification could be interpreted as allowing this, but it is
probably a very bad idea because it could cause other code to break.</p>

<p>It is suggested that you return the empty string or some other
appropriate string rather than <code>null</code>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NP_GUARANTEED_DEREF</id>
    <artifact tool="FindBugs" mnemonic="NP_GUARANTEED_DEREF"/>
    <name>Null dereference guaranteed on branch</name>
    <shortMessage>A null value is guaranteed to be dereferenced. This may result in a NullPointerException being thrown if this code is executed.</shortMessage>
    <info>
<![CDATA[<p>There is a statement or branch that if executed guarantees
that a value is <code>null</code> at this point, and that value that
is guaranteed to be dereferenced (except on forward paths involving
runtime exceptions). This may result in a
<code>NullPointerException</code> being thrown at runtime.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH</id>
    <artifact tool="FindBugs" mnemonic="NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH"/>
    <name>Null defeference guaranteed on exceptional path</name>
    <shortMessage>A null value is guaranteed to be dereferenced on an exception path. This may result in a NullPointerException being thrown if this code is executed.</shortMessage>
    <info>
<![CDATA[<p>There is a statement or branch on an exception path that
if executed guarantees that a value is <code>null</code> at this
point, and that value that is guaranteed to be dereferenced (except on
forward paths involving runtime exceptions). This may result in a
<code>NullPointerException</code> being thrown at runtime.</p></p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SI_INSTANCE_BEFORE_FINALS_ASSIGNED</id>
    <artifact tool="FindBugs" mnemonic="SI_INSTANCE_BEFORE_FINALS_ASSIGNED"/>
    <name>Instance constructed before static finals assigned</name>
    <shortMessage>This static initializer creates an instance before all static final fields have been assigned.  This could cause errors if the constructors expect the final static fields to have been assigned.</shortMessage>
    <info>
<![CDATA[<p>The class's static initializer creates an instance of the
class before all of the static final fields are assigned.</p>

<p>This could cause subtle behavior problems if the constructors rely
upon the final static field to have been assigned.  It is recommended
that this static initizlizer block be moved below the field
declarations to avoid this problem.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>PZLA_PREFER_ZERO_LENGTH_ARRAYS</id>
    <artifact tool="FindBugs" mnemonic="PZLA_PREFER_ZERO_LENGTH_ARRAYS"/>
    <artifact tool="PMD" mnemonic="ReturnEmptyArrayRatherThanNull"/>
    <name>Return zero length arrays instead of null</name>
    <shortMessage>Consider returning a zero length array rather than null.</shortMessage>
    <info>
<![CDATA[<p>It is nearly always a better design to return a length
zero array rather than a <code>null</code> reference to indicate that
there are no results (i.e., an empty list of results). This way, no
explicit check for null is needed by clients of the method.</p>

<p>For example, change code similar to</p>

<pre>
public String[] getArrayOfStrings() {
  // do something
  return null;
}
</pre>

<p>to</p>

<pre>
public String[] getArrayOfStrings() {
  // do something
  return new String[0];
}
</pre>

<p>This can be placed into a constant because you only need one
zero-length array for each type.</p>

<p>On the other hand, using <code>null</code> to indicate "there is no
answer to this question", then it is probably appropriate. For
example, <code>File.listFiles()</code> returns an empty list if given
a directory containing no files, and returns <code>null</code> if the
file is not a directory.</p>

<p>For more information see Bloch's <i>Effective Java</i> (second
edition) item 43.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UCF_USELESS_CONTROL_FLOW</id>
    <artifact tool="FindBugs" mnemonic="UCF_USELESS_CONTROL_FLOW"/>
    <artifact tool="FindBugs" mnemonic="UCF_USELESS_CONTROL_FLOW_NEXT_LINE"/>
    <name>Useless control flow</name>
    <shortMessage>The code appears to have useless control flow. Is this intentional or is it a mistake?</shortMessage>
    <info>
<![CDATA[<p>This method contains a useless control flow statement,
where control flow continues onto the same place regardless of whether
or not the branch is taken. For example, this can be caused by having
an empty statement block for an <code>if</code> statement</p>

<pre>
if (argv.length == 0) {
  // TODO: handle this case
}
</pre>

<p>or by inadvertently using an empty statement as the body of an
<code>if</code> statement</p>

<pre>
if (argv.length == 1);
  System.out.println("I always run, regardless of indentation" + argv[0]);
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE</id>
    <artifact tool="FindBugs" mnemonic="RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE"/>
    <artifact tool="PMD" mnemonic="MisplacedNullCheck"/>
    <name>Null check of previously dereferenced value</name>
    <shortMessage>This null check would have previously thrown a NullPointerException if the value is null. Either the check is redundant or the previous dereference is erroneous.</shortMessage>
    <info>
<![CDATA[<p>A value is checked here to see whether it is
<code>null</code>, but this value can't be <code>null</code> because
it was previously dereferenced and if it were <code>null</code> then a
<code>NullPointerException</code> would have been thrown at the
earlier dereference.</p>

<p>Essentially, this code and the previous dereference disagree as to
whether this value is allowed to be <code>null</code>. Either the
check is redundant or the previous dereference is erroneous. Clearly
some fix to the code is necessary.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE</id>
    <artifact tool="FindBugs" mnemonic="RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE"/>
    <name>Redundant null check of null value</name>
    <shortMessage>This code contains a redundant null check of a value known to be null. This check can be removed.</shortMessage>
    <info>
<![CDATA[<p>This method contains a redundant check of a known null
value against the constant null. The redundant check can be removed
from the code.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE</id>
    <artifact tool="FindBugs" mnemonic="RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE"/>
    <name>Redundant null check Of non-null value</name>
    <shortMessage>This code contains a redundant null check of a value known to be non-null. This check can be removed.</shortMessage>
    <info>
<![CDATA[<p>This method contains a redundant check of a known non-null
value against the constant null. The redundant chec can be removed
from the code.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>RCN_REDUNDANT_COMPARISON_TWO_NULL_VALUES</id>
    <artifact tool="FindBugs" mnemonic="RCN_REDUNDANT_COMPARISON_TWO_NULL_VALUES"/>
    <name>Redundant comparison of two null values</name>
    <shortMessage>This method contains a redundant comparison of two references known to both be definitely null. Fix this muddled code.</shortMessage>
    <info>
<![CDATA[<p>This method contains a redundant comparison of two
references known to both be definitely <code>null</code>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>RCN_REDUNDANT_COMPARISON_OF_NULL_AND_NONNULL_VALUE</id>
    <artifact tool="FindBugs" mnemonic="RCN_REDUNDANT_COMPARISON_OF_NULL_AND_NONNULL_VALUE"/>
    <name>Redundant comparison of a null and a non-null value</name>
    <shortMessage>This method contains a redundant comparison of a reference known to be non-null with another reference known to be null. Fix this muddled code.</shortMessage>
    <info>
<![CDATA[<p>This method contains a redundant comparison of a reference
known to be non-<code>null</code> with another reference known to be
<code>null</code>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UnreleasedLock</id>
    <artifact tool="FindBugs" mnemonic="UL_UNRELEASED_LOCK"/>
    <artifact tool="FindBugs" mnemonic="UL_UNRELEASED_LOCK_EXCEPTION_PATH"/>
    <name>Unreleased util concurrent lock</name>
    <shortMessage>This method does not release a util concurrent dynamic lock on all paths.</shortMessage>
    <info>
<![CDATA[<p>This method acquires a <code>java.util.concurrent</code>
lock, but does not release it on all paths (exceptional or
unexceptional) out of the method. In general, the correct idiom for
using a util concurrent lock is</p>

<pre>
Lock l = ...;
l.lock();
try {
  // do something
} finally {
  l.unlock();
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>RC_REF_COMPARISON</id>
    <artifact tool="FindBugs" mnemonic="RC_REF_COMPARISON"/>
    <name>Suspicious reference comparison</name>
    <shortMessage>This code contains a suspicious reference comparison. Should it be using equals() instead?</shortMessage>
    <info>
<![CDATA[<p>This method compares two reference values using the == or
!= operator, where the correct way to compare instances of this type
is generally with the <code>equals()</code> method. Examples of
classes which should generally not be compared by reference are
<code>java.lang.Integer</code>, <code>java.lang.Float</code>,
etc.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EC_UNRELATED_TYPES</id>
    <artifact tool="FindBugs" mnemonic="EC_UNRELATED_TYPES"/>
    <artifact tool="FindBugs" mnemonic="EC_UNRELATED_INTERFACES"/>
    <artifact tool="FindBugs" mnemonic="EC_UNRELATED_CLASS_AND_INTERFACE"/>
    <name>Avoid calling equals on unrelated types</name>
    <shortMessage>This code calls equals() comparing two different and unrelated types. Fix this muddled code.</shortMessage>
    <info>
<![CDATA[<p>This method calls <code>equals()</code> on two references
of different class types with no common subclasses.  Therefore, the
objects being compared are unlikely to be members of the same class at
runtime (unless some application classes were not analyzed, or dynamic
class loading can occur at runtime).</p>

<p>According to the contract of <code>equals()</code>, objects of
different classes should always compare as unequal; therefore,
according to the contract defined by
<code>java.lang.Object.equals(Object)</code>, the result of this
comparison will always be false at runtime.</p>

<p>This finding may signpost muddled code that may contain subtle
errors.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EqualComparisonToNullArgument</id>
    <artifact tool="FindBugs" mnemonic="EC_NULL_ARG"/>
    <artifact tool="PMD" mnemonic="EqualsNull"/>
    <name>Avoid calling equals with a null argument</name>
    <shortMessage>This code calls equals() with a null argument.</shortMessage>
    <info>
<![CDATA[<p>This method calls <code>equals(Object)</code>, passing a
<code>null</code> value as the argument. According to the contract of
the <code>java.lang.Object.equals(Object)</code> method, this call
should always return false.</p>
      
<p>This finding may signpost muddled code that may contain subtle
errors. Inexperienced programmers sometimes confuse comparison
concepts and use <code>equals()</code> to check for a
<code>null</code> reference.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>MWN_MISMATCHED_WAIT</id>
    <artifact tool="FindBugs" mnemonic="MWN_MISMATCHED_WAIT"/>
    <name>Mismatched wait</name>
    <shortMessage>This code calls wait() without obviously holding a lock on the object. This could throw IllegalMonitorStateException at runtime.</shortMessage>
    <info>
<![CDATA[<p>This method calls <code>Object.wait()</code> without
obviously holding a lock on the object. Calling <code>wait()</code>
without a lock held will result in an
<code>IllegalMonitorStateException</code> being thrown at
runtime.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>MWN_MISMATCHED_NOTIFY</id>
    <artifact tool="FindBugs" mnemonic="MWN_MISMATCHED_NOTIFY"/>
    <name>Mismatched notify</name>
    <shortMessage>This code calls notiry() or notifyAll() without obviously holding a lock on the object. This could throw IllegalMonitorStateException at runtime.</shortMessage>
    <info>
<![CDATA[<p>This method calls <code>Object.notify()</code> or
<code>Object.notifyAll()</code> without obviously holding a lock on
the object. Calling <code>notify()</code> or </code>notifyAll()</code>
without a lock held will result in an
<code>IllegalMonitorStateException</code> being thrown at
runtime.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SA_LOCAL_SELF_ASSIGNMENT</id>
    <artifact tool="FindBugs" mnemonic="SA_LOCAL_SELF_ASSIGNMENT"/>
    <artifact tool="FindBugs" mnemonic="SA_FIELD_SELF_ASSIGNMENT"/>
    <artifact tool="PMD" mnemonic="IdempotentOperations"/>
    <name>Self assignment</name>
    <shortMessage>This code assigns a variable or field to itself. This may indicate a logic error or a typo.</shortMessage>
    <info>
<![CDATA[<p>This method contains a self assignment of a local variable
or field. For example, the below code self assigns a local
variable.</p>

<pre>
public void foo() {
  int x = 3;
  x = x;
}
</pre>

<p>The below code self assigns a field.</p>

<pre>
int x;

public void foo() {
  x = x;
}
</pre>

<p>Such assignments are useless, and may indicate a logic error or
typo.  One common case where this highlights a logic error is when a
parameter masks a field and it appears the parameter is being assigned
to the field but, sadly, the parameter is being assigned to itself.
An example of this mistake is shown below.</p>

<pre>
int x;

public void foo(int x) {
  x = x;
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SA_LOCAL_DOUBLE_ASSIGNMENT</id>
    <artifact tool="FindBugs" mnemonic="SA_LOCAL_DOUBLE_ASSIGNMENT"/>
    <artifact tool="FindBugs" mnemonic="SA_FIELD_DOUBLE_ASSIGNMENT"/>
    <name>Double assignment</name>
    <shortMessage>This code contains a double assignment of a variable or field. This may indicate a logic error or a typo.</shortMessage>
    <info>
<![CDATA[<p> This method contains a double assignment of a local
variable or a field.  For example, the below code double assigns a
local variable.</p>

<pre>
public void foo() {
  int x, y;
  x = x = 17;
}
</pre>

<p>The below code double assigns a field.</p>

<pre>
private int x, y;

public void foo() {
  x = x = 17;
}
</pre>

 <p>Assigning to a local variable or a field twice is useless, and may
 indicate a logic error or typo.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SA_LOCAL_SELF_COMPUTATION</id>
    <artifact tool="FindBugs" mnemonic="SA_LOCAL_SELF_COMPUTATION"/>
    <artifact tool="FindBugs" mnemonic="SA_FIELD_SELF_COMPUTATION"/>
    <name>Nonsensical computation</name>
    <shortMessage>This code performs a nonsensical self computation involving a field (e.g., x &amp; x). Is this intentional?</shortMessage>
    <info>
<![CDATA[<p>This method performs a nonsensical computation of a field
or local variable with another reference to the same field or local
variable (e.g., x&amp;x or x-x). Because of the nature of the
computation, this operation doesn't seem to make sense, and may
indicate a typo or a logic error. Please double check that the
computation is intended.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SA_LOCAL_SELF_COMPARISON</id>
    <artifact tool="FindBugs" mnemonic="SA_LOCAL_SELF_COMPARISON"/>
    <artifact tool="FindBugs" mnemonic="SA_FIELD_SELF_COMPARISON"/>
    <name>Self comparison</name>
    <shortMessage>This code compares a field or local variable with itself. Is this intentional?</shortMessage>
    <info>
<![CDATA[<p>This method compares a field or local variable with
itself, and may indicate a typo or a logic error. Make sure that you
are comparing the right things.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DMI_LONG_BITS_TO_DOUBLE_INVOKED_ON_INT</id>
    <artifact tool="FindBugs" mnemonic="DMI_LONG_BITS_TO_DOUBLE_INVOKED_ON_INT"/>
    <name>Double.longBitsToDouble invoked on int</name>
    <shortMessage>This code invokes Double.longBitsToDouble int which is unlikely to give the intended result.</shortMessage>
    <info>
<![CDATA[<p>The <code>Double.longBitsToDouble</code> method is
invoked, but a 32-bit int value is passed as an argument. This
almostly certainly is not intended and is unlikely to give the
intended result due to the primitive widing conversion which will take
place.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DMI_RANDOM_USED_ONLY_ONCE</id>
    <artifact tool="FindBugs" mnemonic="DMI_RANDOM_USED_ONLY_ONCE"/>
    <name>Random used only once</name>
    <shortMessage>This code creates a Random object but only uses it once.</shortMessage>
    <info>
<![CDATA[<p>This code creates a <code>java.util.Random</code> object,
uses it to generate one random number, and then discards the
object. This produces mediocre quality random numbers and is
inefficient. If possible, rewrite the code so that the object is
created once and saved, and each time a new random number is required
invoke a method on the existing <code>Random</code> object to obtain
it.</p>

<p>If it is important that the generated random numbers not be
guessable, you <em>must</em> not create a new <code>Random</code>
instance for each random number; the values are too easily
guessable. You should strongly consider using a
<code>java.security.SecureRandom</code> instead (and avoid allocating
a new <code>SecureRandom</code> for each random number needed). </p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>RV_ABSOLUTE_VALUE_OF_RANDOM_INT</id>
    <artifact tool="FindBugs"
	      mnemonic="RV_ABSOLUTE_VALUE_OF_RANDOM_INT">
    </artifact>
    <shortMessage>
      Bad attempt to compute absolute value of signed 32-bit
      random integer
    </shortMessage>
    <info>

      &lt;p&gt; This code generates a random signed integer and
      then computes the absolute value of that random integer. If
      the number returned by the random number generator is
      &lt;code&gt;Integer.MIN_VALUE&lt;/code&gt;, then the result
      will be negative as well (since
      &lt;code&gt;Math.abs(Integer.MIN_VALUE) ==
      Integer.MIN_VALUE&lt;/code&gt;). &lt;/p&gt;

    </info>
    <name>Absolute Value Of Random Int</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>RV_ABSOLUTE_VALUE_OF_HASHCODE</id>
    <artifact tool="FindBugs"
	      mnemonic="RV_ABSOLUTE_VALUE_OF_HASHCODE">
    </artifact>
    <shortMessage>
      Bad attempt to compute absolute value of signed 32-bit
      hashcode
    </shortMessage>
    <info>

      &lt;p&gt; This code generates a hashcode and then computes
      the absolute value of that hashcode. If the hashcode is
      &lt;code&gt;Integer.MIN_VALUE&lt;/code&gt;, then the result
      will be negative as well (since
      &lt;code&gt;Math.abs(Integer.MIN_VALUE) ==
      Integer.MIN_VALUE&lt;/code&gt;). &lt;/p&gt;

    </info>
    <name>Absolute Value Of Hashcode</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>RV_REM_OF_RANDOM_INT</id>
    <artifact tool="FindBugs" mnemonic="RV_REM_OF_RANDOM_INT">
    </artifact>
    <shortMessage>
      Remainder of 32-bit signed random integer
    </shortMessage>
    <info>

      &lt;p&gt; This code generates a random signed integer and
      then computes the remainder of that value modulo another
      value. Since the random number can be negative, the result
      of the remainder operation can also be negative. Be sure
      this is intended, and strongly consider using the
      Random.nextInt(int) method instead. &lt;/p&gt;

    </info>
    <name>Rem Of Random Int</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>RV_REM_OF_HASHCODE</id>
    <artifact tool="FindBugs" mnemonic="RV_REM_OF_HASHCODE">
    </artifact>
    <shortMessage>
      Remainder of hashCode could be negative
    </shortMessage>
    <info>

      &lt;p&gt; This code computes a hashCode, and then computes
      the remainder of that value modulo another value. Since the
      hashCode can be negative, the result of the remainder
      operation can also be negative. &lt;/p&gt; &lt;p&gt;
      Assuming you want to ensure that the result of your
      computation is nonnegative, you may need to change your
      code. If you know the divisor is a power of 2, you can use a
      bitwise and operator instead (i.e., instead of using
      &lt;code&gt;x.hashCode()%n&lt;/code&gt;, use
      &lt;code&gt;x.hashCode()&amp;amp;(n-1)&lt;/code&gt;. This is
      probably faster than computing the remainder as well. If you
      don't know that the divisor is a power of 2, take the
      absolute value of the result of the remainder operation
      (i.e., use &lt;code&gt;Math.abs(x.hashCode()%n)&lt;/code&gt;
      &lt;/p&gt;

    </info>
    <name>Rem Of Hashcode</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE</id>
    <artifact tool="FindBugs"
	      mnemonic="INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE">
    </artifact>
    <shortMessage>
      Bad comparison of nonnegative value with negative constant
    </shortMessage>
    <info>

      &lt;p&gt; This code compares a value that is guaranteed to
      be non-negative with a negative constant. &lt;/p&gt;

    </info>
    <name>Bad Comparison With Nonnegative Value</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>INT_BAD_COMPARISON_WITH_SIGNED_BYTE</id>
    <artifact tool="FindBugs"
	      mnemonic="INT_BAD_COMPARISON_WITH_SIGNED_BYTE">
    </artifact>
    <shortMessage>Bad comparison of signed byte</shortMessage>
    <info>

      &lt;p&gt; Signed bytes can only have a value in the range
      -128 to 127. Comparing a signed byte with a value outside
      that range is vacuous and likely to be incorrect. To convert
      a signed byte &lt;code&gt;b&lt;/code&gt; to an unsigned
      value in the range 0..255, use &lt;code&gt;0xff &amp;
      b&lt;/code&gt; &lt;/p&gt;

    </info>
    <name>Bad Comparison With Signed Byte</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>INT_VACUOUS_COMPARISON</id>
    <artifact tool="FindBugs" mnemonic="INT_VACUOUS_COMPARISON">
    </artifact>
    <shortMessage>Vacuous comparison of integer value</shortMessage>
    <info>

      &lt;p&gt; There is an integer comparison that always returns
      the same value (e.g., x &lt;= Integer.MAX_VALUE). &lt;/p&gt;

    </info>
    <name>Vacuous Comparison</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>INT_BAD_REM_BY_1</id>
    <artifact tool="FindBugs" mnemonic="INT_BAD_REM_BY_1">
    </artifact>
    <shortMessage>Integer remainder modulo 1</shortMessage>
    <info>

      &lt;p&gt; Any expression (exp % 1) is guaranteed to always
      return zero. Did you mean (exp &amp; 1) or (exp % 2)
      instead? &lt;/p&gt;

    </info>
    <name>Bad Rem By 1</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>BIT_IOR_OF_SIGNED_BYTE</id>
    <artifact tool="FindBugs" mnemonic="BIT_IOR_OF_SIGNED_BYTE">
    </artifact>
    <shortMessage>Bitwise OR of signed byte value</shortMessage>
    <info>

      &lt;p&gt; Loads a value from a byte array and performs a
      bitwise OR with that value. Values loaded from a byte array
      are sign extended to 32 bits before any any bitwise
      operations are performed on the value. Thus, if
      &lt;code&gt;b[0]&lt;/code&gt; contains the value
      &lt;code&gt;0xff&lt;/code&gt;, and
      &lt;code&gt;x&lt;/code&gt; is initially 0, then the code
      &lt;code&gt;((x &lt;&lt; 8) | b[0])&lt;/code&gt; will sign
      extend &lt;code&gt;0xff&lt;/code&gt; to get
      &lt;code&gt;0xffffffff&lt;/code&gt;, and thus give the value
      &lt;code&gt;0xffffffff&lt;/code&gt; as the result.
      &lt;/p&gt;

      &lt;p&gt;In particular, the following code for packing a
      byte array into an int is badly wrong: &lt;/p&gt;
      &lt;code&gt; int result = 0; for(int i = 0; i &lt; 4; i++)
      result = ((result &lt;&lt; 8) | b[i]); &lt;/code&gt;

      &lt;p&gt;The following idiom will work instead: &lt;/p&gt;
      &lt;code&gt; int result = 0; for(int i = 0; i &lt; 4; i++)
      result = ((result &lt;&lt; 8) | (b[i] &amp;amps; 0xff));
      &lt;/code&gt;


    </info>
    <name>Bitwise OR Of Signed Byte</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>BIT_AND</id>
    <artifact tool="FindBugs" mnemonic="BIT_AND"></artifact>
    <shortMessage>Incompatible bit masks</shortMessage>
    <info>

      &lt;p&gt; This method compares an expression of the form (a
      &amp;amp; C) to D, which will always compare unequal due to
      the specific values of constants C and D. This may indicate
      a logic error or typo.&lt;/p&gt;

    </info>
    <name>Incompatible Bit Masks And</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>BIT_AND_ZZ</id>
    <artifact tool="FindBugs" mnemonic="BIT_AND_ZZ"></artifact>
    <shortMessage>
      Check to see if ((...) &amp; 0) == 0
    </shortMessage>
    <info>

      &lt;p&gt; This method compares an expression of the form (a
      &amp;amp; 0) to 0, which will always compare equal. This may
      indicate a logic error or typo.&lt;/p&gt;

    </info>
    <name>Incompatible Bit Masks And Zero</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>BIT_IOR</id>
    <artifact tool="FindBugs" mnemonic="BIT_IOR"></artifact>
    <shortMessage>Incompatible bit masks</shortMessage>
    <info>

      &lt;p&gt; This method compares an expression of the form (a
      | C) to D. which will always compare unequal due to the
      specific values of constants C and D. This may indicate a
      logic error or typo.&lt;/p&gt;

      &lt;p&gt; Typically, this bug occurs because the code wants
      to perform a membership test in a bit set, but uses the
      bitwise OR operator (&quot;|&quot;) instead of bitwise AND
      (&quot;&amp;amp;&quot;).&lt;/p&gt;

    </info>
    <name>Incompatible Bit Masks OR</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>IncorrectLazyInitializationOfInstance</id>
    <artifact tool="FindBugs" mnemonic="LI_LAZY_INIT_INSTANCE">
    </artifact>
    <shortMessage>
      Incorrect lazy initialization of instance field
    </shortMessage>
    <info>

      &lt;p&gt; This method contains an unsynchronized lazy
      initialization of a non-volatile field. Because the compiler
      or processor may reorder instructions, threads are not
      guaranteed to see a completely initialized object,
      &lt;em&gt;if the method can be called by multiple
      threads&lt;/em&gt;. You can make the field volatile to
      correct the problem. For more information, see the &lt;a
      href=&quot;http://www.cs.umd.edu/~pugh/java/memoryModel/&quot;&gt;Java
      Memory Model web site&lt;/a&gt;. &lt;/p&gt;

    </info>
    <name>Lazy Init Instance</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>IncorrectLazyInitializationOfStatic</id>
    <artifact tool="FindBugs" mnemonic="LI_LAZY_INIT_STATIC">
    </artifact>
    <shortMessage>
      Incorrect lazy initialization of static field
    </shortMessage>
    <info>

      &lt;p&gt; This method contains an unsynchronized lazy
      initialization of a non-volatile static field. Because the
      compiler or processor may reorder instructions, threads are
      not guaranteed to see a completely initialized object,
      &lt;em&gt;if the method can be called by multiple
      threads&lt;/em&gt;. You can make the field volatile to
      correct the problem. For more information, see the &lt;a
      href=&quot;http://www.cs.umd.edu/~pugh/java/memoryModel/&quot;&gt;Java
      Memory Model web site&lt;/a&gt;. &lt;/p&gt;

    </info>
    <name>Incorrect Lazy Initialization of Static Field</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidCallingSynchronizedOnLock</id>
    <artifact tool="FindBugs"
	      mnemonic="JLM_JSR166_LOCK_MONITORENTER">
    </artifact>
    <shortMessage>
      Synchronization performed on java.util.concurrent Lock
    </shortMessage>
    <info>

      &lt;p&gt; This method performs synchronization on an
      implementation of
      &lt;code&gt;java.util.concurrent.locks.Lock&lt;/code&gt;.
      You should use the &lt;code&gt;lock()&lt;/code&gt; and
      &lt;code&gt;unlock()&lt;/code&gt; methods instead.
      &lt;/p&gt;

    </info>
    <name>JSR166 Lock Monitor Enter</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UPM_UNCALLED_PRIVATE_METHOD</id>
    <artifact tool="FindBugs"
	      mnemonic="UPM_UNCALLED_PRIVATE_METHOD">
    </artifact>
    <shortMessage>Private method is never called</shortMessage>
    <info>

      &lt;p&gt; This private method is never called. Although it
      is possible that the method will be invoked through
      reflection, it is more likely that the method is never used,
      and should be removed. &lt;/p&gt;

    </info>
    <name>Uncalled Private Method</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UMAC_UNCALLABLE_METHOD_OF_ANONYMOUS_CLASS</id>
    <artifact tool="FindBugs"
	      mnemonic="UMAC_UNCALLABLE_METHOD_OF_ANONYMOUS_CLASS">
    </artifact>
    <shortMessage>
      Uncallable method defined in anonymous class
    </shortMessage>
    <info>

      &lt;p&gt; This anonymous class defined a method that is not
      directly invoked and does not override a method in a
      superclass. Since methods in other classes cannot directly
      invoke methods declared in an anonymous class, it seems that
      this method is uncallable. The method might simply be dead
      code, but it is also possible that the method is intended to
      override a method declared in a superclass, and due to an
      typo or other error the method does not, in fact, override
      the method it is intended to. &lt;/p&gt;

    </info>
    <name>Uncallable Method Of Anonymous Class</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ODR_OPEN_DATABASE_RESOURCE_EXCEPTION_PATH</id>
    <artifact tool="FindBugs"
	      mnemonic="ODR_OPEN_DATABASE_RESOURCE_EXCEPTION_PATH">
    </artifact>
    <shortMessage>
      Method may fail to close database resource on exception
    </shortMessage>
    <info>

      &lt;p&gt; The method creates a database resource (such as a
      database connection or row set), does not assign it to any
      fields, pass it to other methods, or return it, and does not
      appear to close the object on all exception paths out of the
      method.&amp;nbsp; Failure to close database resources on all
      paths out of a method may result in poor performance, and
      could cause the application to have problems communicating
      with the database.&lt;/p&gt;

    </info>
    <name>Open Database Resource Exception Path</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UseStringBufferForStringAppends</id>
    <artifact tool="FindBugs"
	      mnemonic="SBSC_USE_STRINGBUFFER_CONCATENATION">
    </artifact>
    <artifact tool="PMD"
	      mnemonic="UseStringBufferForStringAppends">
    </artifact>
    <shortMessage>
      Method concatenates strings using + in a loop
    </shortMessage>
    <info>

      &lt;p&gt; The method seems to be building a String using
      concatenation in a loop. In each iteration, the String is
      converted to a StringBuffer/StringBuilder, appended to, and
      converted back to a String. This can lead to a cost
      quadratic in the number of iterations, as the growing string
      is recopied in each iteration. &lt;/p&gt;

      &lt;p&gt;Better performance can be obtained by using a
      StringBuffer (or StringBuilder in Java 1.5)
      explicitly.&lt;/p&gt;

      &lt;p&gt; For example:&lt;/p&gt; &lt;pre&gt; // This is bad
      String s = &quot;&quot;; for (int i = 0; i &amp;lt;
      field.length; ++i) { s = s + field[i]; }

      // This is better StringBuffer buf = new StringBuffer(); for
      (int i = 0; i &amp;lt; field.length; ++i) {
      buf.append(field[i]); } String s = buf.toString();
      &lt;/pre&gt;

      Avoid using += for appending strings. Use StringBuffer
      instead.

    </info>
    <name>Use StringBuffer For String Appends</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ITA_INEFFICIENT_TO_ARRAY</id>
    <artifact tool="FindBugs" mnemonic="ITA_INEFFICIENT_TO_ARRAY"/>
    <artifact tool="PMD" mnemonic="ClassCastExceptionWithToArray"/>
    <artifact tool="PMD" mnemonic="OptimizableToArrayCall"/>
    <name>Questionable use of toArray</name>
    <shortMessage>Method uses toArray() with no argument or a zero-length array argument. The no argument call may result in a ClassCastException.</shortMessage>
    <info>
<![CDATA[<p>This method uses the <code>toArray()</code> method of a
collection derived class, and passes nothing or a zero-length
prototype array argument.</p>

<p>It is more efficient to use <code>myCollection.toArray(new
Foo[myCollection.size()])</code> If the array passed in is big enough
to store all of the elements of the collection, then it is populated
and returned directly. This avoids the need to create a second array
(by reflection) to return as the result.</p>

<p>If you need to get an array of a class from a
<code>Collection</code>, you should pass an array of the desired class
as the parameter of the <code>toArray</code> method. Otherwise you
will get a <code>ClassCastException</code>.</p>

<pre>
import java.util.ArrayList;
import java.util.Collection;

public class Test {
  public static void main(String[] args) {
    Collection c = new ArrayList();
    Integer obj = new Integer(1);
    c.add(obj);

    // this would trigger the rule (and throw a ClassCastException if executed)
    Integer[] a = (Integer[])c.toArray();

    // this wouldn't trigger the rule
    Integer[] b = (Integer[])c.toArray(new Integer[c.size()]);
  }
}

</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>IJU_ASSERT_METHOD_INVOKED_FROM_RUN_METHOD</id>
    <artifact tool="FindBugs"
	      mnemonic="IJU_ASSERT_METHOD_INVOKED_FROM_RUN_METHOD">
    </artifact>
    <shortMessage>
      JUnit assertion in run method will not be noticed by JUnit
    </shortMessage>
    <info>

      &lt;p&gt; A JUnit assertion is performed in a run method.
      Failed JUnit assertions just result in exceptions being
      thrown. Thus, if this exception occurs in a thread other
      than the thread that invokes the test method, the exception
      will terminate the thread but not result in the test
      failing. &lt;/p&gt;

    </info>
    <name>Assert Method Invoked From Run Method</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>IJU_SETUP_NO_SUPER</id>
    <artifact tool="FindBugs" mnemonic="IJU_SETUP_NO_SUPER">
    </artifact>
    <shortMessage>
      TestCase implements setUp but doesn't call super.setUp()
    </shortMessage>
    <info>

      &lt;p&gt; Class is a JUnit TestCase and implements the setUp
      method. The setUp method should call super.setUp(), but
      doesn't.&lt;/p&gt;

    </info>
    <name>Setup No Super</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>IJU_TEARDOWN_NO_SUPER</id>
    <artifact tool="FindBugs" mnemonic="IJU_TEARDOWN_NO_SUPER">
    </artifact>
    <shortMessage>
      TestCase implements tearDown but doesn't call
      super.tearDown()
    </shortMessage>
    <info>

      &lt;p&gt; Class is a JUnit TestCase and implements the
      tearDown method. The tearDown method should call
      super.tearDown(), but doesn't.&lt;/p&gt;

    </info>
    <name>Teardown No Super</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>IJU_SUITE_NOT_STATIC</id>
    <artifact tool="FindBugs" mnemonic="IJU_SUITE_NOT_STATIC">
    </artifact>
    <shortMessage>
      TestCase implements a non-static suite method
    </shortMessage>
    <info>

      &lt;p&gt; Class is a JUnit TestCase and implements the
      suite() method. The suite method should be declared as being
      static, but isn't.&lt;/p&gt;

    </info>
    <name>Suite Not Static</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>IJU_BAD_SUITE_METHOD</id>
    <artifact tool="FindBugs" mnemonic="IJU_BAD_SUITE_METHOD">
    </artifact>
    <shortMessage>
      TestCase declares a bad suite method
    </shortMessage>
    <info>

      &lt;p&gt; Class is a JUnit TestCase and defines a suite()
      method. However, the suite method needs to be declared as
      either &lt;pre&gt;public static junit.framework.Test
      suite()&lt;/pre&gt; or &lt;pre&gt;public static
      junit.framework.TestSuite suite()&lt;/pre&gt; &lt;/p&gt;

    </info>
    <name>Bad Suite Method</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>IJU_NO_TESTS</id>
    <artifact tool="FindBugs" mnemonic="IJU_NO_TESTS"></artifact>
    <shortMessage>TestCase has no tests</shortMessage>
    <info>

      &lt;p&gt; Class is a JUnit TestCase but has not implemented
      any test methods&lt;/p&gt;

    </info>
    <name>No Tests</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>BOA_BADLY_OVERRIDDEN_ADAPTER</id>
    <artifact tool="FindBugs"
	      mnemonic="BOA_BADLY_OVERRIDDEN_ADAPTER">
    </artifact>
    <shortMessage>
      Class overrides a method implemented in super class Adapter
      wrongly
    </shortMessage>
    <info>

      &lt;p&gt; This method overrides a method found in a parent
      class, where that class is an Adapter that implements a
      listener defined in the java.awt.event or javax.swing.event
      package. As a result, this method will not get called when
      the event occurs.&lt;/p&gt;

    </info>
    <name>Badly Overridden Adapter</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>BRSA_BAD_RESULTSET_ACCESS</id>
    <artifact tool="FindBugs"
	      mnemonic="BRSA_BAD_RESULTSET_ACCESS">
    </artifact>
    <shortMessage>
      Method attempts to access a result set field with index 0
    </shortMessage>
    <info>

      &lt;p&gt; A call to getXXX or updateXXX methods of a result
      set was made where the field index is 0. As ResultSet fields
      start at index 1, this is always a mistake.&lt;/p&gt;

    </info>
    <name>Bad Resultset Access</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SQL_BAD_RESULTSET_ACCESS</id>
    <artifact tool="FindBugs" mnemonic="SQL_BAD_RESULTSET_ACCESS">
    </artifact>
    <shortMessage>
      Method attempts to access a result set field with index 0
    </shortMessage>
    <info>

      &lt;p&gt; A call to getXXX or updateXXX methods of a result
      set was made where the field index is 0. As ResultSet fields
      start at index 1, this is always a mistake.&lt;/p&gt;

    </info>
    <name>Bad Resultset Access</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SQL_BAD_PREPARED_STATEMENT_ACCESS</id>
    <artifact tool="FindBugs"
	      mnemonic="SQL_BAD_PREPARED_STATEMENT_ACCESS">
    </artifact>
    <shortMessage>
      Method attempts to access a prepared statement parameter
      with index 0
    </shortMessage>
    <info>

      &lt;p&gt; A call to a setXXX method of a prepared statement
      was made where the parameter index is 0. As parameter
      indexes start at index 1, this is always a
      mistake.&lt;/p&gt;

    </info>
    <name>Bad Prepared Statement Access</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SIO_SUPERFLUOUS_INSTANCEOF</id>
    <artifact tool="FindBugs"
	      mnemonic="SIO_SUPERFLUOUS_INSTANCEOF">
    </artifact>
    <shortMessage>
      Unnecessary type check done using instanceof operator
    </shortMessage>
    <info>

      &lt;p&gt; Type check performed using the instanceof operator
      where it can be statically determined whether the object is
      of the type requested. &lt;/p&gt;

    </info>
    <name>Superfluous instanceof</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>BAC_BAD_APPLET_CONSTRUCTOR</id>
    <artifact tool="FindBugs"
	      mnemonic="BAC_BAD_APPLET_CONSTRUCTOR">
    </artifact>
    <shortMessage>
      Bad Applet Constructor relies on uninitialized AppletStub
    </shortMessage>
    <info>

      &lt;p&gt; This constructor calls methods in the parent
      Applet that rely on the AppletStub. Since the AppletStub
      isn't initialized until the init() method of this applet is
      called, these methods will not perform correctly. &lt;/p&gt;

    </info>
    <name>Bad Applet Constructor</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EC_ARRAY_AND_NONARRAY</id>
    <artifact tool="FindBugs" mnemonic="EC_ARRAY_AND_NONARRAY">
    </artifact>
    <shortMessage>
      equals() used to compare array and nonarray
    </shortMessage>
    <info>

      &lt;p&gt; This method invokes the .equals(Object o) to
      compare an array and a reference that doesn't seem to be an
      array. If things being compared are of different types, they
      are guaranteed to be unequal and the comparison is almost
      certainly an error. Even if they are both arrays, the equals
      method on arrays only determines of the two arrays are the
      same object. To compare the contents of the arrays, use
      java.util.Arrays.equals(Object[], Object[]). &lt;/p&gt;

    </info>
    <name>Array And Nonarray</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EC_BAD_ARRAY_COMPARE</id>
    <artifact tool="FindBugs" mnemonic="EC_BAD_ARRAY_COMPARE">
    </artifact>
    <shortMessage>
      Invocation of equals() on an array, which is equivalent to
      ==
    </shortMessage>
    <info>

      &lt;p&gt; This method invokes the .equals(Object o) method
      on an array. Since arrays do not override the equals method
      of Object, calling equals on an array is the same as
      comparing their addresses. To compare the contents of the
      arrays, use java.util.Arrays.equals(Object[], Object[]).
      &lt;/p&gt;

    </info>
    <name>Bad Array Compare</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UOE_USE_OBJECT_EQUALS</id>
    <artifact tool="FindBugs" mnemonic="UOE_USE_OBJECT_EQUALS">
    </artifact>
    <shortMessage>
      Calls to equals on a final class that doesn't override
      Object's version
    </shortMessage>
    <info>

      &lt;p&gt; This method invokes the .equals(Object o) method
      on a final class that doesn't override the equals method in
      the Object class, effectively making the equals method test
      for sameness, like ==. It is good to use the .equals method,
      but you should consider adding an .equals method in this
      class. &lt;/p&gt; &lt;p&gt;[Bill Pugh]: Sorry, but I
      strongly disagree that this should be a warning, and I think
      your code is just fine. Users of your code shouldn't care
      how you've implemented equals(), and they should never
      depend on == to compare instances, since that bypasses the
      libraries ability to control how objects are compared.
      &lt;/p&gt;

    </info>
    <name>Use Object Equals</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>STI_INTERRUPTED_ON_CURRENTTHREAD</id>
    <artifact tool="FindBugs"
	      mnemonic="STI_INTERRUPTED_ON_CURRENTTHREAD">
    </artifact>
    <shortMessage>
      Unneeded use of currentThread() call, to call interrupted()
    </shortMessage>
    <info>

      &lt;p&gt; This method invokes the Thread.currentThread()
      call, just to call the interrupted() method. As
      interrupted() is a static method, is more simple and clear
      to use Thread.interrupted(). &lt;/p&gt;

    </info>
    <name>Interrupted On Currentthread</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>STI_INTERRUPTED_ON_UNKNOWNTHREAD</id>
    <artifact tool="FindBugs"
	      mnemonic="STI_INTERRUPTED_ON_UNKNOWNTHREAD">
    </artifact>
    <shortMessage>
      Static Thread.interrupted() method invoked on thread
      instance
    </shortMessage>
    <info>

      &lt;p&gt; This method invokes the Thread.interrupted()
      method on a Thread object that appears to be a Thread object
      that is not the current thread. As the interrupted() method
      is static, the interrupted method will be called on a
      different object than the one the author intended.
      &lt;/p&gt;

    </info>
    <name>Interrupted On Unknown Thread</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN</id>
    <artifact tool="FindBugs"
	      mnemonic="IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN">
    </artifact>
    <shortMessage>
      A parameter is dead upon entry to a method but overwritten
    </shortMessage>
    <info>

      &lt;p&gt; The initial value of this parameter is ignored,
      and the parameter is overwritten here. This often indicates
      a mistaken belief that the write to the parameter will be
      conveyed back to the caller. &lt;/p&gt;

    </info>
    <name>Parameter Is Dead But Overwritten</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DLS_DEAD_LOCAL_STORE</id>
    <artifact tool="FindBugs" mnemonic="DLS_DEAD_LOCAL_STORE">
    </artifact>
    <shortMessage>Dead store to local variable</shortMessage>
    <info>

      &lt;p&gt; This instruction assigns a value to a local
      variable, but the value is not read by any subsequent
      instruction. Often, this indicates an error, because the
      value computed is never used. &lt;/p&gt; &lt;p&gt; Note that
      Sun's javac compiler often generates dead stores for final
      local variables. Because FindBugs is a bytecode-based tool,
      there is no easy way to eliminate these false positives.
      &lt;/p&gt;

    </info>
    <name>Dead Local Store</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DLS_DEAD_LOCAL_STORE_OF_NULL</id>
    <artifact tool="FindBugs"
	      mnemonic="DLS_DEAD_LOCAL_STORE_OF_NULL">
    </artifact>
    <shortMessage>
      Dead store of null to local variable
    </shortMessage>
    <info>

      &lt;p&gt;The code stores null into a local variable, and
      stored value is not read. This store may have been
      introduced in assist the garbage collector, but as of Java
      SE 6.0, this is no longer needed or useful. &lt;/p&gt;

    </info>
    <name>Dead Local Store Of Null</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>MF_METHOD_MASKS_FIELD</id>
    <artifact tool="FindBugs" mnemonic="MF_METHOD_MASKS_FIELD">
    </artifact>
    <shortMessage>
      Method defines a variable that obscures a field
    </shortMessage>
    <info>

      &lt;p&gt; This method defines a local variable with the same
      name as a field in this class or a superclass. This may
      cause the method to read an uninitialized value from the
      field, leave the field uninitialized, or both.&lt;/p&gt;

    </info>
    <name>Method Masks Field</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>MF_CLASS_MASKS_FIELD</id>
    <artifact tool="FindBugs" mnemonic="MF_CLASS_MASKS_FIELD">
    </artifact>
    <shortMessage>
      Class defines field that masks a superclass field
    </shortMessage>
    <info>

      &lt;p&gt; This class defines a field with the same name as a
      visible instance field in a superclass. This is confusing,
      and may indicate an error if methods update or access one of
      the fields when they wanted the other.&lt;/p&gt;

    </info>
    <name>Class Masks Field</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>WMI_WRONG_MAP_ITERATOR</id>
    <artifact tool="FindBugs" mnemonic="WMI_WRONG_MAP_ITERATOR">
    </artifact>
    <shortMessage>
      Inefficient use of keySet iterator instead of entrySet
      iterator
    </shortMessage>
    <info>

      &lt;p&gt; This method accesses the value of a Map entry,
      using a key that was retrieved from a keySet iterator. It is
      more efficient to use an iterator on the entrySet of the
      map, to avoid the Map.get(key) lookup.&lt;/p&gt;

    </info>
    <name>Wrong Map Iterator</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ISC_INSTANTIATE_STATIC_CLASS</id>
    <artifact tool="FindBugs"
	      mnemonic="ISC_INSTANTIATE_STATIC_CLASS">
    </artifact>
    <shortMessage>
      Needless instantiation of class that only supplies static
      methods
    </shortMessage>
    <info>

      &lt;p&gt; This class allocates an object that is based on a
      class that only supplies static methods. This object does
      not need to be created, just access the static methods
      directly using the class name as a qualifier.&lt;/p&gt;

    </info>
    <name>Instantiate Static Class</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>REC_CATCH_EXCEPTION</id>
    <artifact tool="FindBugs" mnemonic="REC_CATCH_EXCEPTION">
    </artifact>
    <shortMessage>
      Exception is caught when Exception is not thrown
    </shortMessage>
    <info>

      &lt;p&gt; This method uses a try-catch block that catches
      Exception objects, but Exception is not thrown within the
      try block, and RuntimeException is not explicitly caught. It
      is a common bug pattern to say try { ... } catch (Exception
      e) { something } as a shorthand for catching a number of
      types of exception each of whose catch blocks is identical,
      but this construct also accidentally catches
      RuntimeException as well, masking potential bugs. &lt;/p&gt;

    </info>
    <name>Catch Exception</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>FE_TEST_IF_EQUAL_TO_NOT_A_NUMBER</id>
    <artifact tool="FindBugs" mnemonic="FE_TEST_IF_EQUAL_TO_NOT_A_NUMBER"/>
    <artifact tool="PMD" mnemonic="BadComparison"/>
    <name>Doomed test for equality to NaN</name>
    <shortMessage>Doomed test for equality to NaN.  Did you mean to use Double.isNaN() or Float.isNaN()?</shortMessage>
    <info>
<![CDATA[<p>This code checks to see if a floating point value is equal
to the special <i>Not A Number</i> (NaN) value (e.g., <code>if (x ==
Double.NaN)</code>). However, because of the special semantics of
<code>NaN</code>, no value is equal to <code>Nan</code>, including
<code>NaN</code>. Thus, <code>x == Double.NaN</code> always evaluates
to false.</p>

<p>To check to see if a value contained in <code>x</code> is the
special Not A Number value, use <code>Double.isNaN(x)</code> (or
<code>Float.isNaN(x)</code> if <code>x</code> is floating point
precision).</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>FE_FLOATING_POINT_EQUALITY</id>
    <artifact tool="FindBugs"
	      mnemonic="FE_FLOATING_POINT_EQUALITY">
    </artifact>
    <shortMessage>Test for floating point equality</shortMessage>
    <info>

      &lt;p&gt; This operation compares two floating point values
      for equality. Because floating point calculations may
      involve rounding, calculated float and double values may not
      be accurate. For values that must be precise, such as
      monetary values, consider using a fixed-precision type such
      as BigDecimal. For values that need not be precise, consider
      comparing for equality within some range, for example:
      &lt;code&gt;if ( Math.abs(x - y) &amp;lt; .0000001
      )&lt;/code&gt;. See the Java Language Specification, section
      4.2.4. &lt;/p&gt;

    </info>
    <name>Floating Point Equality</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UM_UNNECESSARY_MATH</id>
    <artifact tool="FindBugs" mnemonic="UM_UNNECESSARY_MATH"/>
    <name>Unnecessary math</name>
    <shortMessage>Method calls static Math class method on a constant value.</shortMessage>
    <info>
<![CDATA[<p>This method uses a static method from <code>java.lang.Math</code> on a
constant value. This method's result in this case, can be determined
statically, and is faster and sometimes more accurate to just use the
constant. Methods detected are:</p>

<table>
  <tr><th>Method</th><th>Parameter</th></tr>
  <tr><td>abs</td><td>-any-</td></tr>
  <tr><td>acos</td><td>0.0 or 1.0</td></tr>
  <tr><td>asin</td><td>0.0 or 1.0</td></tr>
  <tr><td>atan</td> <td>0.0 or 1.0</td></tr>
  <tr><td>atan2</td><td>0.0</td></tr>
  <tr><td>cbrt</td><td>0.0 or 1.0</td></tr>
  <tr><td>ceil</td><td>-any-</td></tr>
  <tr><td>cos</td><td>0.0</td></tr>
  <tr><td>cosh</td><td>0.0</td></tr>
  <tr><td>exp</td><td>0.0 or 1.0</td></tr>
  <tr><td>expm1</td><td>0.0</td></tr>
  <tr><td>floor</td><td>-any-</td></tr>
  <tr><td>log</td><td>0.0 or 1.0</td></tr>
  <tr><td>log10</td><td>0.0 or 1.0</td></tr>
  <tr><td>rint</td><td>-any-</td></tr>
  <tr><td>round</td><td>-any-</td></tr>
  <tr><td>sin</td><td>0.0</td></tr>
  <tr><td>sinh</td><td>0.0</td></tr>
  <tr><td>sqrt</td><td>0.0 or 1.0</td></tr>
  <tr><td>tan</td><td>0.0</td></tr>
  <tr><td>tanh</td><td>0.0</td></tr>
  <tr><td>toDegrees</td><td>0.0 or 1.0</td></tr>
  <tr><td>toRadians</td><td>0.0</td></tr>
</table>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>CD_CIRCULAR_DEPENDENCY</id>
    <artifact tool="FindBugs" mnemonic="CD_CIRCULAR_DEPENDENCY"/>
    <name>Circular dependency</name>
    <shortMessage>Circular dependencies among classes detected.  This signposts a poor design or implementation.</shortMessage>
    <info>
<![CDATA[<p>This class has a circular dependency with other
classes. This makes building these classes difficult, as each is
dependent on the other to build correctly. Consider using interfaces
to break the hard dependency.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>RI_REDUNDANT_INTERFACES</id>
    <artifact tool="FindBugs" mnemonic="RI_REDUNDANT_INTERFACES">
    </artifact>
    <shortMessage>
      Class implements same interface as superclass
    </shortMessage>
    <info>

      &lt;p&gt; This class declares that it implements an
      interface that is also implemented by a superclass. This is
      redundant, once a superclass implements an interface, all
      subclasses by default also implement this interface. It may
      point out that the inheritance hierarchy has changed since
      this class was created, and consideration should be taken
      into account for the ownership of the interface's
      implementation. &lt;/p&gt;

    </info>
    <name>Redundant Interfaces</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>MTIA_SUSPECT_STRUTS_INSTANCE_FIELD</id>
    <artifact tool="FindBugs"
	      mnemonic="MTIA_SUSPECT_STRUTS_INSTANCE_FIELD">
    </artifact>
    <shortMessage>
      Class extends Struts Action class and uses instance
      variables
    </shortMessage>
    <info>

      &lt;p&gt; This class extends from a Struts Action class, and
      uses a instance member variable. Since only one instance of
      a struts Action class is created by the Struts framework,
      and used in a multithreaded way, this paradigm is highly
      discouraged and most likely problematic. Consider only using
      method local variables. &lt;/p&gt;

    </info>
    <name>Suspect Struts Instance Field</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>MTIA_SUSPECT_SERVLET_INSTANCE_FIELD</id>
    <artifact tool="FindBugs"
	      mnemonic="MTIA_SUSPECT_SERVLET_INSTANCE_FIELD">
    </artifact>
    <shortMessage>
      Class extends Servlet class and uses instance variables
    </shortMessage>
    <info>

      &lt;p&gt; This class extends from a Servlet class, and uses
      a instance member variable. Since only one instance of a
      Servlet class is created by the J2EE framework, and used in
      a multithreaded way, this paradigm is highly discouraged and
      most likely problematic. Consider only using method local
      variables. &lt;/p&gt;

    </info>
    <name>Suspect Servlet Instance Field</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>PS_PUBLIC_SEMAPHORES</id>
    <artifact tool="FindBugs" mnemonic="PS_PUBLIC_SEMAPHORES">
    </artifact>
    <shortMessage>
      Class exposes synchronization and semaphores in its public
      interface
    </shortMessage>
    <info>

      &lt;p&gt; This class uses synchronization along with wait(),
      notify() or notifyAll() on itself (the this reference).
      Client classes that use this class, may, in addition, use an
      instance of this class as a synchronizing object. Because
      two classes are using the same object for synchronization,
      Multithread correctness is suspect. You should not
      synchronize nor call semaphore methods on a public
      reference. Consider using a internal private member variable
      to control synchronization. &lt;/p&gt;

    </info>
    <name>Public Semaphores</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ICAST_INTEGER_MULTIPLY_CAST_TO_LONG</id>
    <artifact tool="FindBugs"
	      mnemonic="ICAST_INTEGER_MULTIPLY_CAST_TO_LONG">
    </artifact>
    <shortMessage>
      Result of integer multiplication cast to long
    </shortMessage>
    <info>

      &lt;p&gt; This code performs integer multiply and then
      converts the result to a long, as in: &lt;code&gt;
      &lt;pre&gt; long convertDaysToMilliseconds(int days) {
      return 1000*3600*24*days; } &lt;/pre&gt;&lt;/code&gt; If the
      multiplication is done using long arithmetic, you can avoid
      the possibility that the result will overflow. For example,
      you could fix the above code to: &lt;code&gt; &lt;pre&gt;
      long convertDaysToMilliseconds(int days) { return
      1000L*3600*24*days; } &lt;/pre&gt;&lt;/code&gt; or
      &lt;code&gt; &lt;pre&gt; static final long
      MILLISECONDS_PER_DAY = 24L*3600*1000; long
      convertDaysToMilliseconds(int days) { return days *
      MILLISECONDS_PER_DAY; } &lt;/pre&gt;&lt;/code&gt; &lt;/p&gt;


    </info>
    <name>Integer Multiply Cast To Long</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ICAST_INT_CAST_TO_FLOAT_PASSED_TO_ROUND</id>
    <artifact tool="FindBugs"
	      mnemonic="ICAST_INT_CAST_TO_FLOAT_PASSED_TO_ROUND">
    </artifact>
    <shortMessage>
      int value cast to float and then passed to Math.round
    </shortMessage>
    <info>

      &lt;p&gt; This code converts an int value to a float
      precision floating point number and then passing the result
      to the Math.round() function, which returns the int/long
      closest to the argument. This operation should always be a
      no-op, since the converting an integer to a float should
      give a number with no fractional part. It is likely that the
      operation that generated the value to be passed to
      Math.round was intended to be performed using floating point
      arithmetic. &lt;/p&gt;


    </info>
    <name>Int Cast To Float Passed To Round</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ICAST_INT_CAST_TO_DOUBLE_PASSED_TO_CEIL</id>
    <artifact tool="FindBugs"
	      mnemonic="ICAST_INT_CAST_TO_DOUBLE_PASSED_TO_CEIL">
    </artifact>
    <shortMessage>
      int value cast to double and then passed to Math.ceil
    </shortMessage>
    <info>

      &lt;p&gt; This code converts an int value to a double
      precision floating point number and then passing the result
      to the Math.ceil() function, which rounds a double to the
      next higher integer value. This operation should always be a
      no-op, since the converting an integer to a double should
      give a number with no fractional part. It is likely that the
      operation that generated the value to be passed to Math.ceil
      was intended to be performed using double precision floating
      point arithmetic. &lt;/p&gt;


    </info>
    <name>Int Cast To Double Passed To Math.ceil</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ICAST_IDIV_CAST_TO_DOUBLE</id>
    <artifact tool="FindBugs"
	      mnemonic="ICAST_IDIV_CAST_TO_DOUBLE">
    </artifact>
    <shortMessage>
      int division result cast to double or float
    </shortMessage>
    <info>

      &lt;p&gt; This code casts the result of an integer division
      operation to double or float. Doing division on integers
      truncates the result to the integer value closest to zero.
      The fact that the result was cast to double suggests that
      this precision should have been retained. What was probably
      meant was to cast one or both of the operands to double
      &lt;em&gt;before&lt;/em&gt; performing the division. Here is
      an example: &lt;/p&gt; &lt;blockquote&gt; &lt;pre&gt; int x
      = 2; int y = 5; // Wrong: yields result 0.0 double value1 =
      x / y;

      // Right: yields result 0.4 double value2 = x / (double) y;
      &lt;/pre&gt; &lt;/blockquote&gt;

    </info>
    <name>Idiv Cast To Double</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION</id>
    <artifact tool="FindBugs"
	      mnemonic="J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION">
    </artifact>
    <shortMessage>
      Store of non serializable object into HttpSession
    </shortMessage>
    <info>

      &lt;p&gt; This code seems to be storing a non-serializable
      object into an HttpSession. If this session is passivated or
      migrated, an error will result. &lt;/p&gt;

    </info>
    <name>Store Of Non Serializable Object Into Session</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DMI_NONSERIALIZABLE_OBJECT_WRITTEN</id>
    <artifact tool="FindBugs"
	      mnemonic="DMI_NONSERIALIZABLE_OBJECT_WRITTEN">
    </artifact>
    <shortMessage>
      Non serializable object written to ObjectOutput
    </shortMessage>
    <info>

      &lt;p&gt; This code seems to be passing a non-serializable
      object to the ObjectOutput.writeObject method. If the object
      is, indeed, non-serializable, an error will result.
      &lt;/p&gt;

    </info>
    <name>Nonserializable Object Written</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>VA_PRIMITIVE_ARRAY_PASSED_TO_OBJECT_VARARG</id>
    <artifact tool="FindBugs"
	      mnemonic="VA_PRIMITIVE_ARRAY_PASSED_TO_OBJECT_VARARG">
    </artifact>
    <shortMessage>
      Primitive array passed to function expecting a variable
      number of object arguments
    </shortMessage>
    <info>

      &lt;p&gt; This code passes a primitive array to a function
      that takes a variable number of object arguments. This
      creates an array of length one to hold the primitive array
      and passes it to the function. &lt;/p&gt;

    </info>
    <name>Primitive Array Passed To Object Vararg</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS</id>
    <artifact tool="FindBugs"
	      mnemonic="BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS">
    </artifact>
    <shortMessage>
      Equals method should not assume anything about the type of
      its argument
    </shortMessage>
    <info>

      &lt;p&gt; The &lt;code&gt;equals(Object o)&lt;/code&gt;
      method shouldn't make any assumptions about the type of
      &lt;code&gt;o&lt;/code&gt;. It should simply return false if
      &lt;code&gt;o&lt;/code&gt; is not the same type as
      &lt;code&gt;this&lt;/code&gt;. &lt;/p&gt;

    </info>
    <name>Equals Method Should Work For All Objects</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>BC_BAD_CAST_TO_ABSTRACT_COLLECTION</id>
    <artifact tool="FindBugs"
	      mnemonic="BC_BAD_CAST_TO_ABSTRACT_COLLECTION">
    </artifact>
    <shortMessage>
      Questionable cast to abstract collection
    </shortMessage>
    <info>

      &lt;p&gt; This code casts a Collection to an abstract
      collection (such as &lt;code&gt;List&lt;/code&gt;,
      &lt;code&gt;Set&lt;/code&gt;, or
      &lt;code&gt;Map&lt;/code&gt;). Ensure that you are
      guaranteed that the object is of the type you are casting
      to. If all you need is to be able to iterate through a
      collection, you don't need to cast it to a Set or List.
      &lt;/p&gt;

    </info>
    <name>Bad Cast To Abstract Collection</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>BC_IMPOSSIBLE_CAST_PRIMITIVE_ARRAY</id>
    <artifact tool="FindBugs"
	      mnemonic="BC_IMPOSSIBLE_CAST_PRIMITIVE_ARRAY">
    </artifact>
    <shortMessage>
      Impossible cast involving primitive array
    </shortMessage>
    <info>

      &lt;p&gt; This cast will always throw a ClassCastException.
      &lt;/p&gt;

    </info>
    <name>Impossible Cast Primitive Array</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>BC_IMPOSSIBLE_CAST</id>
    <artifact tool="FindBugs" mnemonic="BC_IMPOSSIBLE_CAST">
    </artifact>
    <shortMessage>Impossible cast</shortMessage>
    <info>

      &lt;p&gt; This cast will always throw a ClassCastException.
      &lt;/p&gt;

    </info>
    <name>Impossible Cast</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NP_NULL_INSTANCEOF</id>
    <artifact tool="FindBugs" mnemonic="NP_NULL_INSTANCEOF">
    </artifact>
    <shortMessage>
      A known null value is checked to see if it is an instance of
      a type
    </shortMessage>
    <info>

      &lt;p&gt; This instanceof test will always return false,
      since the value being checked is guaranteed to be null.
      Although this is safe, make sure it isn't an indication of
      some misunderstanding or some other logic error. &lt;/p&gt;

    </info>
    <name>Null instanceof</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>BC_NULL_INSTANCEOF</id>
    <artifact tool="FindBugs" mnemonic="BC_NULL_INSTANCEOF">
    </artifact>
    <shortMessage>
      A known null value is checked to see if it is an instance of
      a type
    </shortMessage>
    <info>

      &lt;p&gt; This instanceof test will always return false,
      since the value being checked is guaranteed to be null.
      Although this is safe, make sure it isn't an indication of
      some misunderstanding or some other logic error. &lt;/p&gt;

    </info>
    <name>Null instanceof</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>BC_IMPOSSIBLE_INSTANCEOF</id>
    <artifact tool="FindBugs" mnemonic="BC_IMPOSSIBLE_INSTANCEOF">
    </artifact>
    <shortMessage>instanceof will always return false</shortMessage>
    <info>

      &lt;p&gt; This instanceof test will always return false.
      Although this is safe, make sure it isn't an indication of
      some misunderstanding or some other logic error. &lt;/p&gt;

    </info>
    <name>Impossible instanceof</name>
  </findingType>
  <findingType>
    <id>BC_VACUOUS_INSTANCEOF</id>
    <artifact tool="FindBugs" mnemonic="BC_VACUOUS_INSTANCEOF">
    </artifact>
    <shortMessage>instanceof will always return true</shortMessage>
    <info>

      &lt;p&gt; This instanceof test will always return true.
      Although this is safe, make sure it isn't an indication of
      some misunderstanding or some other logic error. &lt;/p&gt;

    </info>
    <name>Vacuous instanceof</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>BC_UNCONFIRMED_CAST</id>
    <artifact tool="FindBugs" mnemonic="BC_UNCONFIRMED_CAST">
    </artifact>
    <shortMessage>Unchecked/unconfirmed cast</shortMessage>
    <info>

      &lt;p&gt; This cast is unchecked, and not all instances of
      the type casted from can be cast to the type it is being
      cast to. Ensure that your program logic ensures that this
      cast will not fail. &lt;/p&gt;

    </info>
    <name>Unconfirmed Cast</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>BC_BAD_CAST_TO_CONCRETE_COLLECTION</id>
    <artifact tool="FindBugs"
	      mnemonic="BC_BAD_CAST_TO_CONCRETE_COLLECTION">
    </artifact>
    <shortMessage>
      Questionable cast to concrete collection
    </shortMessage>
    <info>

      &lt;p&gt; This code casts an abstract collection (such as a
      Collection, List, or Set) to a specific concrete
      implementation (such as an ArrayList or HashSet). This might
      not be correct, and it may make your code fragile, since it
      makes it harder to switch to other concrete implementations
      at a future point. Unless you have a particular reason to do
      so, just use the abstract collection class. &lt;/p&gt;

    </info>
    <name>Bad Cast To Concrete Collection</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>RE_POSSIBLE_UNINTENDED_PATTERN</id>
    <artifact tool="FindBugs"
	      mnemonic="RE_POSSIBLE_UNINTENDED_PATTERN">
    </artifact>
    <shortMessage>
      &quot;.&quot; used for regular expression
    </shortMessage>
    <info>

      &lt;p&gt; A String function is being invoked and
      &quot;.&quot; is being passed to a parameter that takes a
      regular expression as an argument. Is this what you
      intended? For example s.replaceAll(&quot;.&quot;,
      &quot;/&quot;) will return a String in which
      &lt;em&gt;every&lt;/em&gt; character has been replaced by a
      / character. &lt;/p&gt;

    </info>
    <name>Possible Unintended Pattern</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>RE_BAD_SYNTAX_FOR_REGULAR_EXPRESSION</id>
    <artifact tool="FindBugs"
	      mnemonic="RE_BAD_SYNTAX_FOR_REGULAR_EXPRESSION">
    </artifact>
    <shortMessage>
      Invalid syntax for regular expression
    </shortMessage>
    <info>

      &lt;p&gt; The code here uses a regular expression that is
      invalid according to the syntax for regular expressions.
      This statement will throw a PatternSyntaxException when
      executed. &lt;/p&gt;

    </info>
    <name>Bad Syntax For Regular Expression</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>RE_CANT_USE_FILE_SEPARATOR_AS_REGULAR_EXPRESSION</id>
    <artifact tool="FindBugs"
	      mnemonic="RE_CANT_USE_FILE_SEPARATOR_AS_REGULAR_EXPRESSION">
    </artifact>
    <shortMessage>
      File.separator used for regular expression
    </shortMessage>
    <info>

      &lt;p&gt; The code here uses
      &lt;code&gt;File.separator&lt;/code&gt; where a regular
      expression is required. This will fail on Windows platforms,
      where the &lt;code&gt;File.separator&lt;/code&gt; is a
      backslash, which is interpreted in a regular expression as
      an escape character. Amoung other options, you can just use
      &lt;code&gt;File.separatorChar=='\\' &amp;amp;
      &quot;\\\\&quot; : File.separator&lt;/code&gt; instead of
      &lt;code&gt;File.separator&lt;/code&gt;

      &lt;/p&gt;

    </info>
    <name>Cant Use File Separator As Regular Expression</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DLS_OVERWRITTEN_INCREMENT</id>
    <artifact tool="FindBugs"
	      mnemonic="DLS_OVERWRITTEN_INCREMENT">
    </artifact>
    <shortMessage>Overwritten increment</shortMessage>
    <info>

      &lt;p&gt; The code performs an increment operation (e.g.,
      &lt;code&gt;i++&lt;/code&gt;) and then immediately
      overwrites it. For example, &lt;code&gt;i = i++&lt;/code&gt;
      immediately overwrites the incremented value with the
      original value. &lt;/p&gt;

    </info>
    <name>Overwritten Increment</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ICAST_QUESTIONABLE_UNSIGNED_RIGHT_SHIFT</id>
    <artifact tool="FindBugs"
	      mnemonic="ICAST_QUESTIONABLE_UNSIGNED_RIGHT_SHIFT">
    </artifact>
    <shortMessage>
      Unsigned right shift cast to short/byte
    </shortMessage>
    <info>

      &lt;p&gt; The code performs an unsigned right shift, whose
      result is then cast to a short or byte, which discards the
      upper bits of the result. Since the upper bits are
      discarded, there may be no difference between a signed and
      unsigned right shift (depending upon the size of the shift).
      &lt;/p&gt;

    </info>
    <name>Questionable Unsigned Right Shift</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ICAST_BAD_SHIFT_AMOUNT</id>
    <artifact tool="FindBugs" mnemonic="ICAST_BAD_SHIFT_AMOUNT">
    </artifact>
    <shortMessage>
      Integer shift by an amount not in the range 0..31
    </shortMessage>
    <info>

      &lt;p&gt; The code performs an integer shift by a constant
      amount outside the range 0..31. The effect of this is to use
      the lower 5 bits of the integer value to decide how much to
      shift by. This probably isn't want was expected, and it at
      least confusing. &lt;/p&gt;

    </info>
    <name>Bad Shift Amount</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>IM_MULTIPLYING_RESULT_OF_IREM</id>
    <artifact tool="FindBugs"
	      mnemonic="IM_MULTIPLYING_RESULT_OF_IREM">
    </artifact>
    <shortMessage>
      Integer multiply of result of integer remainder
    </shortMessage>
    <info>

      &lt;p&gt; The code multiplies the result of an integer
      remaining by an integer constant. Be sure you don't have
      your operator precedence confused. For example i % 60 * 1000
      is (i % 60) * 1000, not i % (60 * 1000). &lt;/p&gt;

    </info>
    <name>Multiplying Result Of Int Remainder</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DMI_INVOKING_TOSTRING_ON_ARRAY</id>
    <artifact tool="FindBugs"
	      mnemonic="DMI_INVOKING_TOSTRING_ON_ARRAY">
    </artifact>
    <shortMessage>Invocation of toString on an array</shortMessage>
    <info>

      &lt;p&gt; The code invokes toString on an array, which will
      generate a fairly useless result such as [C@16f0472.
      Consider using Arrays.toString to convert the array into a
      readable String that gives the contents of the array. See
      Programming Puzzlers, chapter 3, puzzle 12. &lt;/p&gt;

    </info>
    <name>Invoking toString On Array</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>IM_AVERAGE_COMPUTATION_COULD_OVERFLOW</id>
    <artifact tool="FindBugs"
	      mnemonic="IM_AVERAGE_COMPUTATION_COULD_OVERFLOW">
    </artifact>
    <shortMessage>
      Computation of average could overflow
    </shortMessage>
    <info>

      &lt;p&gt;The code computes the average of two integers using
      either division or signed right shift, and then uses the
      result as the index of an array. If the values being
      averaged are very large, this can overflow (resulting in the
      computation of a negative average). Assuming that the result
      is intended to be nonnegative, you can use an unsigned right
      shift instead. In other words, rather that using
      &lt;code&gt;(low+high)/2&lt;/code&gt;, use
      &lt;code&gt;(low+high) &amp;gt;&amp;gt;&amp;gt;
      1&lt;/code&gt; &lt;/p&gt; &lt;p&gt;This bug exists in many
      earlier implementations of binary search and merge sort.
      Martin Buchholz &lt;a
      href=&quot;http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6412541&quot;&gt;found
      and fixed it&lt;/a&gt; in the JDK libraries, and Joshua
      Bloch &lt;a
      href=&quot;http://googleresearch.blogspot.com/2006/06/extra-extra-read-all-about-it-nearly.html&quot;&gt;widely
      publicized the bug pattern&lt;/a&gt;. &lt;/p&gt;

    </info>
    <name>Average Computation Could Overflow</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>IM_BAD_CHECK_FOR_ODD</id>
    <artifact tool="FindBugs" mnemonic="IM_BAD_CHECK_FOR_ODD">
    </artifact>
    <shortMessage>
      Check for oddness that won't work for negative numbers
    </shortMessage>
    <info>

      &lt;p&gt; The code uses x % 2 == 1 to check to see if a
      value is odd, but this won't work for negative numbers
      (e.g., (-5) % 2 == -1). If this code is intending to check
      for oddness, consider using x &amp; 1 == 1, or x % 2 != 0.
      &lt;/p&gt;

    </info>
    <name>Bad Check For Odd</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DMI_HARDCODED_ABSOLUTE_FILENAME</id>
    <artifact tool="FindBugs"
	      mnemonic="DMI_HARDCODED_ABSOLUTE_FILENAME">
    </artifact>
    <shortMessage>
      Code contains a hard coded reference to an absolute pathname
    </shortMessage>
    <info>

      &lt;p&gt;This code constructs a File object using a hard
      coded to an absolute pathname (e.g., &lt;code&gt;new
      File(&quot;/home/dannyc/workspace/j2ee/src/share/com/sun/enterprise/deployment&quot;);&lt;/code&gt;
      &lt;/p&gt;

    </info>
    <name>Hardcoded Absolute Filename</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DMI_BAD_MONTH</id>
    <artifact tool="FindBugs" mnemonic="DMI_BAD_MONTH"></artifact>
    <shortMessage>Bad constant value for month</shortMessage>
    <info>

      &lt;p&gt; This code passes a constant month value outside
      the expected range of 0..11 to a method. &lt;/p&gt;

    </info>
    <name>Bad Month</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DMI_USELESS_SUBSTRING</id>
    <artifact tool="FindBugs" mnemonic="DMI_USELESS_SUBSTRING">
    </artifact>
    <shortMessage>
      Invocation of substring(0), which returns the original value
    </shortMessage>
    <info>

      &lt;p&gt; This code invokes substring(0) on a String, which
      returns the original value. &lt;/p&gt;

    </info>
    <name>Useless Substring</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DMI_CALLING_NEXT_FROM_HASNEXT</id>
    <artifact tool="FindBugs"
	      mnemonic="DMI_CALLING_NEXT_FROM_HASNEXT">
    </artifact>
    <shortMessage>hasNext method invokes next</shortMessage>
    <info>

      &lt;p&gt; The hasNext() method invokes the next() method.
      This is almost certainly wrong, since the hasNext() method
      is not supposed to change the state of the iterator, and the
      next method is supposed to change the state of the iterator.
      &lt;/p&gt;

    </info>
    <name>Calling Next From hasNext</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidCallingSleepWithLockHeld</id>
    <artifact tool="FindBugs" mnemonic="SWL_SLEEP_WITH_LOCK_HELD">
    </artifact>
    <shortMessage>
      Method calls Thread.sleep() with a lock held
    </shortMessage>
    <info>

      &lt;p&gt; This method calls Thread.sleep() with a lock held.
      This may result in very poor performance and scalability, or
      a deadlock, since other threads may be waiting to acquire
      the lock. It is a much better idea to call wait() on the
      lock, which releases the lock and allows other threads to
      run. &lt;/p&gt;

    </info>
    <name>Sleep With Lock Held</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DB_DUPLICATE_BRANCHES</id>
    <artifact tool="FindBugs" mnemonic="DB_DUPLICATE_BRANCHES">
    </artifact>
    <shortMessage>
      Method uses the same code for two branches
    </shortMessage>
    <info>

      &lt;p&gt; This method uses the same code to implement two
      branches of a conditional branch. Check to ensure that this
      isn't a coding mistake. &lt;/p&gt;

    </info>
    <name>Duplicate Branches</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DB_DUPLICATE_SWITCH_CLAUSES</id>
    <artifact tool="FindBugs"
	      mnemonic="DB_DUPLICATE_SWITCH_CLAUSES">
    </artifact>
    <shortMessage>
      Method uses the same code for two switch clauses
    </shortMessage>
    <info>

      &lt;p&gt; This method uses the same code to implement two
      clauses of a switch statement. This could be a case of
      duplicate code, but it might also indicate a coding mistake.
      &lt;/p&gt;

    </info>
    <name>Duplicate Switch Clauses</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>IMA_INEFFICIENT_MEMBER_ACCESS</id>
    <artifact tool="FindBugs"
	      mnemonic="IMA_INEFFICIENT_MEMBER_ACCESS">
    </artifact>
    <shortMessage>
      Method accesses a private member variable of owning class
    </shortMessage>
    <info>

      &lt;p&gt; This method of an inner class reads from or writes
      to a private member variable of the owning class, or calls a
      private method of the owning class. The compiler must
      generate a special method to access this private member,
      causing this to be less efficient. Relaxing the protection
      of the member variable or method will allow the compiler to
      treat this as a normal access. &lt;/p&gt;

    </info>
    <name>Inefficient Member Access</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>XFB_XML_FACTORY_BYPASS</id>
    <artifact tool="FindBugs" mnemonic="XFB_XML_FACTORY_BYPASS">
    </artifact>
    <shortMessage>
      Method directly allocates a specific implementation of xml
      interfaces
    </shortMessage>
    <info>

      &lt;p&gt; This method allocates a specific implementation of
      an xml interface. It is preferable to use the supplied
      factory classes to create these objects so that the
      implementation can be changed at runtime. See &lt;/p&gt;
      &lt;ul&gt;
      &lt;li&gt;javax.xml.parsers.DocumentBuilderFactory&lt;/li&gt;
      &lt;li&gt;javax.xml.parsers.SAXParserFactory&lt;/li&gt;
      &lt;li&gt;javax.xml.transform.TransformerFactory&lt;/li&gt;
      &lt;li&gt;org.w3c.dom.Document.create&lt;i&gt;XXXX&lt;/i&gt;&lt;/li&gt;
      &lt;/ul&gt; &lt;p&gt;for details.&lt;/p&gt;

    </info>
    <name>XML Factory Bypass</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>USM_USELESS_SUBCLASS_METHOD</id>
    <artifact tool="FindBugs"
	      mnemonic="USM_USELESS_SUBCLASS_METHOD">
    </artifact>
    <shortMessage>
      Method superfluously delegates to parent class method
    </shortMessage>
    <info>

      &lt;p&gt; This derived method merely calls the same
      superclass method passing in the exact parameters received.
      This method can be removed, as it provides no additional
      value. &lt;/p&gt;

    </info>
    <name>Useless Subclass Method</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>USM_USELESS_ABSTRACT_METHOD</id>
    <artifact tool="FindBugs"
	      mnemonic="USM_USELESS_ABSTRACT_METHOD">
    </artifact>
    <shortMessage>
      Abstract Method is already defined in implemented interface
    </shortMessage>
    <info>

      &lt;p&gt; This abstract method is already defined in an
      interface that is implemented by this abstract class. This
      method can be removed, as it provides no additional value.
      &lt;/p&gt;

    </info>
    <name>Useless Abstract Method</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>CI_CONFUSED_INHERITANCE</id>
    <artifact tool="FindBugs" mnemonic="CI_CONFUSED_INHERITANCE">
    </artifact>
    <shortMessage>
      Class is final but declares protected field
    </shortMessage>
    <info>

      &lt;p&gt; This class is declared to be final, but declares
      fields to be protected. Since the class is final, it can not
      be derived from, and the use of protected is confusing. The
      access modifier for the field should be changed to private
      or public to represent the true use for the field.
      &lt;/p&gt;

    </info>
    <name>Confused Inheritance</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>QBA_QUESTIONABLE_BOOLEAN_ASSIGNMENT</id>
    <artifact tool="FindBugs"
	      mnemonic="QBA_QUESTIONABLE_BOOLEAN_ASSIGNMENT">
    </artifact>
    <shortMessage>
      Method assigns boolean literal in boolean expression
    </shortMessage>
    <info>

      &lt;p&gt; This method assigns a literal boolean value (true
      or false) to a boolean variable inside an if or while
      expression. Most probably this was supposed to be a boolean
      comparison using ==, not an assignment using =. &lt;/p&gt;

    </info>
    <name>Questionable Boolean Assignment</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>VR_UNRESOLVABLE_REFERENCE</id>
    <artifact tool="FindBugs"
	      mnemonic="VR_UNRESOLVABLE_REFERENCE">
    </artifact>
    <shortMessage>
      Class makes reference to unresolvable class or method
    </shortMessage>
    <info>

      &lt;p&gt; This class makes a reference to a class or method
      that can not be resolved using against the libraries it is
      being analyzed with. &lt;/p&gt;

    </info>
    <name>Unresolvable Reference</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>GC_UNRELATED_TYPES</id>
    <artifact tool="FindBugs" mnemonic="GC_UNRELATED_TYPES">
    </artifact>
    <shortMessage>
      No relationship between generic parameter and method
      argument
    </shortMessage>
    <info>

      &lt;p&gt; This call to a generic container's method contains
      an argument with a different class type from that of the
      container's parameter. Therefore, it is unlikely that the
      container contains any objects with the same type as the
      method argument used here. &lt;/p&gt;

    </info>
    <name>Unrelated Types</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidStaticCalendar</id>
    <artifact tool="FindBugs"
	      mnemonic="STCAL_STATIC_CALENDAR_INSTANCE">
    </artifact>
    <shortMessage>Static Calendar</shortMessage>
    <info>

      &lt;p&gt;Even though the JavaDoc does not contain a hint
      about it, Calendars are inherently unsafe for multihtreaded
      use. Sharing a single instance across thread boundaries
      without proper synchronization will result in erratic
      behavior of the application. Under 1.4 problems seem to
      surface less often than under Java 5 where you will probably
      see random ArrayIndexOutOfBoundsExceptions or
      IndexOutOfBoundsExceptions in
      sun.util.calendar.BaseCalendar.getCalendarDateFromFixedDate().&lt;/p&gt;
      &lt;p&gt;You may also experience serialization
      problems.&lt;/p&gt; &lt;p&gt;Using an instance field is
      recommended.&lt;/p&gt; &lt;p&gt;For more information on this
      see &lt;a
      href=&quot;http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6231579&quot;&gt;Sun
      Bug #6231579&lt;/a&gt; and &lt;a
      href=&quot;http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6178997&quot;&gt;Sun
      Bug #6178997&lt;/a&gt;.&lt;/p&gt;

    </info>
    <name>Static Calendar Instance</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>CallToStaticCalendar</id>
    <artifact tool="FindBugs"
	      mnemonic="STCAL_INVOKE_ON_STATIC_CALENDAR_INSTANCE">
    </artifact>
    <shortMessage>Call to static Calendar</shortMessage>
    <info>

      &lt;p&gt;Even though the JavaDoc does not contain a hint
      about it, Calendars are inherently unsafe for multihtreaded
      use. The detector has found a call to an instance of
      Calendar that has been obtained via a static field. This
      looks suspicous.&lt;/p&gt; &lt;p&gt;For more information on
      this see &lt;a
      href=&quot;http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6231579&quot;&gt;Sun
      Bug #6231579&lt;/a&gt; and &lt;a
      href=&quot;http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6178997&quot;&gt;Sun
      Bug #6178997&lt;/a&gt;.&lt;/p&gt;

    </info>
    <name>Invoke On Static Calendar Instance</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>STCAL_STATIC_SIMPLE_DATE_FORMAT_INSTANCE</id>
    <artifact tool="FindBugs" mnemonic="STCAL_STATIC_SIMPLE_DATE_FORMAT_INSTANCE"/>
    <artifact tool="PMD" mnemonic="UnsynchronizedStaticDateFormatter"/>
    <name>Static SimpleDateFormat Instance</name>
    <shortMessage>Static SimpleDateFormat</shortMessage>
    <info>
<![CDATA[<p>As the JavaDoc states, <code>DateFormat</code> objects are
inherently unsafe for multithreaded use. Sharing a single instance
across thread boundaries without proper synchronization will result in
erratic behavior of the application.</p>

<p>You may also experience serialization problems.</p>

<p>Using an instance field is recommended.</p>

<p>For more information about this issue see <a
href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6231579">Sun
Bug #6231579</a> and <a
href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6178997">Sun
Bug #6178997</a>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>CallToStaticDateFormat</id>
    <artifact tool="FindBugs"
	      mnemonic="STCAL_INVOKE_ON_STATIC_DATE_FORMAT_INSTANCE">
    </artifact>
    <shortMessage>Call to static DateFormat</shortMessage>
    <info>

      &lt;p&gt;As the JavaDoc states, DateFormats are inherently
      unsafe for multithreaded use. The detector has found a call
      to an instance of DateFormat that has been obtained via a
      static field. This looks suspicous.&lt;/p&gt; &lt;p&gt;For
      more information on this see &lt;a
      href=&quot;http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6231579&quot;&gt;Sun
      Bug #6231579&lt;/a&gt; and &lt;a
      href=&quot;http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6178997&quot;&gt;Sun
      Bug #6178997&lt;/a&gt;.&lt;/p&gt;

    </info>
    <name>Invoke On Static Date Format Instance</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <!-- FindBugs 1.3.0 Upgrade -->
  <findingType>
    <id>DoesntOverrideEquals</id>
    <artifact tool="FindBugs"
	      mnemonic="EQ_DOESNT_OVERRIDE_EQUALS">
    </artifact>
    <shortMessage>
      Class doesn't override equals in superclass
    </shortMessage>
    <info>

      &lt;p&gt; This class extends a class that defines an equals
      method and adds fields, but doesn't define an equals method
      itself. Thus, equality on instances of this class will
      ignore the identity of the subclass and the added fields. Be
      sure this is what is intended, and that you don't need to
      override the equals method. Even if you don't need to
      override the equals method, consider overriding it anyone to
      document the fact that the equals method for the subclass
      just return the result of invoking super.equals(o).

    </info>
    <name>Doesn't Override Equals</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SameSimpleNameAsInterface</id>
    <artifact tool="FindBugs"
	      mnemonic="NM_SAME_SIMPLE_NAME_AS_INTERFACE">
    </artifact>
    <shortMessage>
      Class names shouldn't shadow simple name of implemented
      interface
    </shortMessage>
    <info>

      &lt;p&gt; This class/interface has a simple name that is
      identical to that of an implemented/extended interface,
      except that the interface is in a different package (e.g.,
      &lt;code&gt;alpha.Foo&lt;/code&gt; extends
      &lt;code&gt;beta.Foo&lt;/code&gt;). This can be
      exceptionally confusing, create lots of situations in which
      you have to look at import statements to resolve references
      and creates many opportunities to accidently define methods
      that do not override methods in their superclasses.
      &lt;/p&gt;

    </info>
    <name>Same Simple Name As Interface</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SameSimpleNameAsSuperclass</id>
    <artifact tool="FindBugs"
	      mnemonic="NM_SAME_SIMPLE_NAME_AS_SUPERCLASS">
    </artifact>
    <shortMessage>
      Class names shouldn't shadow simple name of superclass
    </shortMessage>
    <info>

      &lt;p&gt; This class has a simple name that is identical to
      that of its superclass, except that its superclass is in a
      different package (e.g., &lt;code&gt;alpha.Foo&lt;/code&gt;
      extends &lt;code&gt;beta.Foo&lt;/code&gt;). This can be
      exceptionally confusing, create lots of situations in which
      you have to look at import statements to resolve references
      and creates many opportunities to accidently define methods
      that do not override methods in their superclasses.
      &lt;/p&gt;

    </info>
    <name>Same Simple Name As Superclass</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>WrongPackage</id>
    <artifact tool="FindBugs" mnemonic="NM_WRONG_PACKAGE">
    </artifact>
    <shortMessage>
      Method doesn't override method in superclass due to wrong
      package for parameter
    </shortMessage>
    <info>

      &lt;p&gt; The method in the subclass doesn't override a
      similar method in a superclass because the type of a
      parameter doesn't exactly match the type of the
      corresponding parameter in the superclass. For example, if
      you have:&lt;/p&gt;

      &lt;blockquote&gt; &lt;pre&gt; import alpha.Foo; public
      class A { public int f(Foo x) { return 17; } } ---- import
      beta.Foo; public class B extends A { public int f(Foo x) {
      return 42; } } &lt;/pre&gt; &lt;/blockquote&gt;

      &lt;p&gt;The &lt;code&gt;f(Foo)&lt;/code&gt; method defined
      in class &lt;code&gt;B&lt;/code&gt; doesn't override the
      &lt;code&gt;f(Foo)&lt;/code&gt; method defined in class
      &lt;code&gt;A&lt;/code&gt;, because the argument types are
      &lt;code&gt;Foo&lt;/code&gt;'s from different packages.
      &lt;/p&gt;

    </info>
    <name>Wrong Package</name>
  </findingType>
   <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
 <findingType>
    <id>WrongPackageIntentional</id>
    <artifact tool="FindBugs"
	      mnemonic="NM_WRONG_PACKAGE_INTENTIONAL">
    </artifact>
    <shortMessage>
      Method doesn't override method in superclass due to wrong
      package for parameter
    </shortMessage>
    <info>

      &lt;p&gt; The method in the subclass doesn't override a
      similar method in a superclass because the type of a
      parameter doesn't exactly match the type of the
      corresponding parameter in the superclass. For example, if
      you have:&lt;/p&gt;

      &lt;blockquote&gt; &lt;pre&gt; import alpha.Foo; public
      class A { public int f(Foo x) { return 17; } } ---- import
      beta.Foo; public class B extends A { public int f(Foo x) {
      return 42; } public int f(alpha.Foo x) { return 27; } }
      &lt;/pre&gt; &lt;/blockquote&gt;

      &lt;p&gt;The &lt;code&gt;f(Foo)&lt;/code&gt; method defined
      in class &lt;code&gt;B&lt;/code&gt; doesn't override the
      &lt;code&gt;f(Foo)&lt;/code&gt; method defined in class
      &lt;code&gt;A&lt;/code&gt;, because the argument types are
      &lt;code&gt;Foo&lt;/code&gt;'s from different packages.
      &lt;/p&gt;

      &lt;p&gt;In this case, the subclass does define a method
      with a signature identical to the method in the superclass,
      so this is presumably understood. However, such methods are
      exceptionally confusing. You should strongly consider
      removing or deprecating the method with the similar but not
      identical signature. &lt;/p&gt;

    </info>
    <name>Wrong Package Intentional</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ReturnValueIgnoredBadPractice</id>
    <artifact tool="FindBugs"
	      mnemonic="RV_RETURN_VALUE_IGNORED_BAD_PRACTICE">
    </artifact>
    <shortMessage>Method ignores return value</shortMessage>
    <info>

      &lt;p&gt; This method returns a value that is not checked.
      For example, the &lt;code&gt;File.delete()&lt;/code&gt;
      method returns false if the file could not be successfully
      deleted (rather than throwing an Exception). If you don't
      check the result, you won't notice if the method invocation
      signals unexpected behavior by returning an atypical return
      value.

    </info>
    <name>Return Value Ignored Bad Practice</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ExceptionNotThrown</id>
    <artifact tool="FindBugs" mnemonic="RV_EXCEPTION_NOT_THROWN">
    </artifact>
    <shortMessage>
      Exception created and dropped rather than thrown
    </shortMessage>
    <info>

      &lt;p&gt; This code creates an exception (or error) object,
      but doesn't do anything with it. For example, something like
      &lt;/p&gt; &lt;blockquote&gt; &lt;pre&gt; if (x &lt; 0) new
      IllegalArgumentException(&quot;x must be nonnegative&quot;);
      &lt;/pre&gt; &lt;/blockquote&gt; &lt;p&gt;It was probably
      the intent of the programmer to throw the created
      exception:&lt;/p&gt; &lt;blockquote&gt; &lt;pre&gt; if (x
      &lt; 0) throw new IllegalArgumentException(&quot;x must be
      nonnegative&quot;); &lt;/pre&gt; &lt;/blockquote&gt;

    </info>
    <name>Exception Not Thrown</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UnrelatedTypesUsingPointerEquality</id>
    <artifact tool="FindBugs"
	      mnemonic="EC_UNRELATED_TYPES_USING_POINTER_EQUALITY">
    </artifact>
    <shortMessage>
      Using pointer equality to compare different types
    </shortMessage>
    <info>

      &lt;p&gt; This method uses using pointer equality to compare
      two references that seem to be of different types. The
      result of this comparison will always be false at runtime.
      &lt;/p&gt;

    </info>
    <name>Unrelated Types Using Pointer Equality</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>BitSignedCheck</id>
    <artifact tool="FindBugs" mnemonic="BIT_SIGNED_CHECK">
    </artifact>
    <shortMessage>Check for sign of bitwise operation</shortMessage>
    <info>

      &lt;p&gt; This method compares an expression such as
      &lt;pre&gt;((event.detail &amp; SWT.SELECTED) &gt;
      0)&lt;/pre&gt;. Using bit arithmetic and then comparing with
      the greater than operator can lead to unexpected results (of
      course depending on the value of SWT.SELECTED). If
      SWT.SELECTED is a negative number, this is a candidate for a
      bug. Even when SWT.SELECTED is not negative, it seems good
      practice to use '!= 0' instead of '&gt; 0'. &lt;/p&gt;
      &lt;p&gt; &lt;em&gt;Boris Bokowski&lt;/em&gt; &lt;/p&gt;

    </info>
    <name>Signed Check</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>BitSignedCheckHighBit</id>
    <artifact tool="FindBugs"
	      mnemonic="BIT_SIGNED_CHECK_HIGH_BIT">
    </artifact>
    <shortMessage>Check for sign of bitwise operation</shortMessage>
    <info>

      &lt;p&gt; This method compares an expression such as
      &lt;pre&gt;((event.detail &amp; SWT.SELECTED) &gt;
      0)&lt;/pre&gt;. Using bit arithmetic and then comparing with
      the greater than operator can lead to unexpected results (of
      course depending on the value of SWT.SELECTED). If
      SWT.SELECTED is a negative number, this is a candidate for a
      bug. Even when SWT.SELECTED is not negative, it seems good
      practice to use '!= 0' instead of '&gt; 0'. &lt;/p&gt;
      &lt;p&gt; &lt;em&gt;Boris Bokowski&lt;/em&gt; &lt;/p&gt;

    </info>
    <name>Signed Check High Bit</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LazyInitUpdateStatic</id>
    <artifact tool="FindBugs"
	      mnemonic="LI_LAZY_INIT_UPDATE_STATIC">
    </artifact>
    <shortMessage>
      Incorrect lazy initialization and update of static field
    </shortMessage>
    <info>

      &lt;p&gt; This method contains an unsynchronized lazy
      initialization of a static field. After the field is set,
      the object stored into that location is further accessed.
      The setting of the field is visible to other threads as soon
      as it is set. If the futher accesses in the method that set
      the field serve to initialize the object, then you have a
      &lt;em&gt;very serious&lt;/em&gt; multithreading bug, unless
      something else prevents any other thread from accessing the
      stored object until it is fully initialized. &lt;/p&gt;

    </info>
    <name>Lazy Init Update Static</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DeadStoreOfClassLiteral</id>
    <artifact tool="FindBugs"
	      mnemonic="DLS_DEAD_STORE_OF_CLASS_LITERAL">
    </artifact>
    <shortMessage>Dead store of class literal</shortMessage>
    <info>

      &lt;p&gt; This instruction assigns a class literal to a
      variable and then never uses it. &lt;a
      href=&quot;//java.sun.com/j2se/1.5.0/compatibility.html#literal&quot;&gt;The
      behavior of this differs in Java 1.4 and in Java
      5.&lt;/a&gt; In Java 1.4 and earlier, a reference to
      &lt;code&gt;Foo.class&lt;/code&gt; would force the static
      initializer for &lt;code&gt;Foo&lt;/code&gt; to be executed,
      if it has not been executed already. In Java 5 and later, it
      does not. &lt;/p&gt; &lt;p&gt;See Sun's &lt;a
      href=&quot;//java.sun.com/j2se/1.5.0/compatibility.html#literal&quot;&gt;article
      on Java SE compatibility&lt;/a&gt; for more details and
      examples, and suggestions on how to force class
      initialization in Java 5. &lt;/p&gt;

    </info>
    <name>Dead Store Of Class Literal</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AlwaysValueUsedWhereNeverRequired</id>
    <artifact tool="FindBugs"
	      mnemonic="TQ_ALWAYS_VALUE_USED_WHERE_NEVER_REQUIRED">
    </artifact>
    <shortMessage>
      Value annotated as carrying a type qualifier used where a
      value that must not carry that qualifier is required
    </shortMessage>
    <info>

      &lt;p&gt; A value specified as carrying a type qualifier
      annotation is consumed in a location or locations requiring
      that the value not carry that annotation. &lt;/p&gt;

      &lt;p&gt; More precisely, a value annotated with a type
      qualifier specifying when=ALWAYS is guaranteed to reach a
      use or uses where the same type qualifier specifies
      when=NEVER. &lt;/p&gt;

      &lt;p&gt; For example, say that @NonNegative is a nickname
      for the type qualifier annotation
      @Negative(when=When.NEVER). The following code will generate
      this warning because the return statement requires a
      @NonNegative value, but receives one that is marked as
      @Negative. &lt;/p&gt; &lt;blockquote&gt; &lt;pre&gt; public
      @NonNegative Integer example(@Negative Integer value) {
      return value; } &lt;/pre&gt; &lt;/blockquote&gt;

    </info>
    <name>Always Value Used Where Never Required</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NeverValueUsedWhereAlwaysRequired</id>
    <artifact tool="FindBugs"
	      mnemonic="TQ_NEVER_VALUE_USED_WHERE_ALWAYS_REQUIRED">
    </artifact>
    <shortMessage>
      Value annotated as never carrying a type qualifier used
      where value carrying that qualifier is required
    </shortMessage>
    <info>

      &lt;p&gt; A value specified as not carrying a type qualifier
      annotation is guaranteed to be consumed in a location or
      locations requiring that the value does carry that
      annotation. &lt;/p&gt;

      &lt;p&gt; More precisely, a value annotated with a type
      qualifier specifying when=NEVER is guaranteed to reach a use
      or uses where the same type qualifier specifies when=ALWAYS.
      &lt;/p&gt;

      &lt;p&gt; TODO: example &lt;/p&gt;

    </info>
    <name>Never Value Used Where Always Required</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>MaybeSourceValueReachesAlwaysSink</id>
    <artifact tool="FindBugs"
	      mnemonic="TQ_MAYBE_SOURCE_VALUE_REACHES_ALWAYS_SINK">
    </artifact>
    <shortMessage>
      Value that might not carry a type qualifier reaches a use
      requiring that type qualifier
    </shortMessage>
    <info>

      &lt;p&gt; A value that might not carry a type qualifier
      annotation reaches a use which requires that annotation.
      &lt;/p&gt;

      &lt;p&gt; For example, consider the following method:
      &lt;/p&gt; &lt;blockquote&gt; &lt;pre&gt; public @Untainted
      Object mustReturnUntainted(Object unknown) { return unknown;
      } &lt;/pre&gt; &lt;/blockquote&gt; &lt;p&gt; The
      &lt;code&gt;mustReturnUntainted&lt;/code&gt; method is
      required to return a value carrying the @Untainted
      annotation, but a value not known to carry that annotation
      is returned. &lt;/p&gt;

    </info>
    <name>Maybe Source Value Reaches Always Sink</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>MaybeSourceValueReachesNeverSink</id>
    <artifact tool="FindBugs"
	      mnemonic="TQ_MAYBE_SOURCE_VALUE_REACHES_NEVER_SINK">
    </artifact>
    <shortMessage>
      Unknown value reaches a use which forbids values carrying
      type qualifier annotation
    </shortMessage>
    <info>

      &lt;p&gt; A value which might carry a type qualifier
      annotation reaches a use which forbids values carrying that
      annotation. &lt;/p&gt;

      &lt;p&gt; TODO: example. &lt;/p&gt;

    </info>
    <name>Maybe Source Value Reaches Never Sink</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

  <!-- For FB 1.3.1 -->
  <findingType>
    <id>BooleanMethodReturnsNull</id>
    <artifact tool="FindBugs"
	      mnemonic="NP_BOOLEAN_RETURN_NULL">
    </artifact>
    <shortMessage>
      Method with Boolean return type returns explicit null
    </shortMessage>
    <info>

      &lt;p&gt; This method can be invoked as though it returned a value of type boolean, and
      the compiler will insert automatic unboxing of the Boolean value. If a null value is returned,
      this will result in a NullPointerException. &lt;/p&gt;

    </info>
    <name>Boolean-typed Method Returns Null</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AppendingToObjectOutputStream</id>
    <artifact tool="FindBugs"
	      mnemonic="IO_APPENDING_TO_OBJECT_OUTPUT_STREAM">
    </artifact>
    <shortMessage>
      Appending to an ObjectOutputStream
    </shortMessage>
    <info>

      &lt;p&gt; This code opens a file in append mode and that wraps the result in an object output stream. 
      This won't allow you to append to an existing object output stream stored in a file. If you want to be
      able to append to an object output stream, you need to keep the object output stream open. &lt;/p&gt;

      &lt;p&gt; The only situation in which opening a file in append mode and the writing an object output stream
      could work is if on reading the file you plan to open it in random access mode and seek to the byte offset
      where the append started. &lt;/p&gt;

    </info>
    <name>Appending To ObjectOutputStream</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>FormatStringArgsMismatch</id>
    <artifact tool="FindBugs"
	      mnemonic="VA_FORMAT_STRING_ARG_MISMATCH">
    </artifact>
    <shortMessage>
      Number of format-string arguments does not correspond to number of placeholders
    </shortMessage>
    <info>

      &lt;p&gt; A format-string method with a variable number of arguments is called,
      but the number of arguments passed does not match with the number of
      % placeholders in the format string.  This is probably not what the
      author intended.. &lt;/p&gt;

    </info>
    <name>Mismatch Of Number Of Args For Format String</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>InvokingToStringOnArray</id>
    <artifact tool="FindBugs"
	      mnemonic="DMI_INVOKING_TOSTRING_ON_ANONYMOUS_ARRAY">
    </artifact>
    <shortMessage>
      Invocation of toString() on an array
    </shortMessage>
    <info>

      &lt;p&gt; The code invokes toString on an array, which will generate a fairly useless result
      such as [C@16f0472. Consider using Arrays.toString to convert the array into a readable
      String that gives the contents of the array. 
      See Programming Puzzlers, chapter 3, puzzle 12. &lt;/p&gt;

    </info>
    <name>Invocation Of toString() On Array</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <!-- For FB 1.3.2 -->
  <findingType>
    <id>HttpParameterWrittenToServlet</id>
    <artifact tool="FindBugs"
	      mnemonic="XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER">
    </artifact>
    <shortMessage>
      HTTP parameter directly written to Servlet output
    </shortMessage>
    <info>

      &lt;p&gt; This code directly writes an HTTP parameter to Servlet output, which allows for a cross site scripting
      vunerability. See &lt;a href="http://en.wikipedia.org/wiki/Cross-site_scripting"&gt;http://en.wikipedia.org/wiki/Cross-site_scripting&lt;/a&gt;
      for more information. &lt;/p&gt;

    </info>
    <name>Servlet cross site scripting vulnerability</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>HttpParameterWrittenToJSP</id>
    <artifact tool="FindBugs"
	      mnemonic="XSS_REQUEST_PARAMETER_TO_JSP_WRITER">
    </artifact>
    <shortMessage>
      HTTP parameter directly written to JSP output
    </shortMessage>
    <info>

      &lt;p&gt; This code directly writes an HTTP parameter to JSP output, which allows for a cross site scripting
      vunerability. See &lt;a href="http://en.wikipedia.org/wiki/Cross-site_scripting"&gt;http://en.wikipedia.org/wiki/Cross-site_scripting&lt;/a&gt;
      for more information. &lt;/p&gt;

    </info>
    <name>JSP cross site scripting vulnerability</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EqualsDoesntOverride</id>
    <artifact tool="FindBugs"
	      mnemonic="EQ_OTHER_USE_OBJECT">
    </artifact>
    <shortMessage>
      equals() method defined that doesn't override Object.equals(Object)
    </shortMessage>
    <info>

      &lt;p&gt; This class defines an &lt;code&gt;equals()&lt;/code&gt;
      method, that doesn't override the normal &lt;code&gt;equals(Object)&lt;/code&gt; method
      defined in the base &lt;code&gt;java.lang.Object&lt;/code&gt; class.
      The class should probably define a &lt;code&gt;boolean equals(Object)&lt;/code&gt; 
      method. &lt;/p&gt;

    </info>
    <name>equals() doesn't override Object.equals(Object)</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EqualsDoesntOverrideInherited</id>
    <artifact tool="FindBugs"
	      mnemonic="EQ_OTHER_NO_OBJECT">
    </artifact>
    <shortMessage>
      equals() method defined that doesn't override inherited equals(Object)
    </shortMessage>
    <info>

      &lt;p&gt; This class defines an &lt;code&gt;equals()&lt;/code&gt;
      method, that doesn't override the normal &lt;code&gt;equals(Object)&lt;/code&gt; method
      defined in the base &lt;code&gt;java.lang.Object&lt;/code&gt; class.
      Instead, it inherits an &lt;code&gt;equals(Object)&lt;/code&gt; method from a superclass.
      The class should probably define a &lt;code&gt;boolean equals(Object)&lt;/code&gt; 
      method. &lt;/p&gt;

    </info>
    <name>equals() doesn't override inherited equals(Object)</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NP_NULL_ON_SOME_PATH_MIGHT_BE_INFEASIBLE</id>
    <artifact tool="FindBugs"
	      mnemonic="NP_NULL_ON_SOME_PATH_MIGHT_BE_INFEASIBLE">
    </artifact>
    <shortMessage>
      Possible null pointer dereference on path that might be infeasible
    </shortMessage>
    <info>

      &lt;p&gt; This class defines an &lt;code&gt;equals()&lt;/code&gt;
      method, that doesn't override the normal &lt;code&gt;equals(Object)&lt;/code&gt; method
      defined in the base &lt;code&gt;java.lang.Object&lt;/code&gt; class.
      Instead, it inherits an &lt;code&gt;equals(Object)&lt;/code&gt; method from a superclass.
      The class should probably define a &lt;code&gt;boolean equals(Object)&lt;/code&gt; 
      method. &lt;/p&gt;

    </info>
    <name>Possible null dereference on potentially infeasible path</name>
  </findingType>	
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <!-- For FB 1.3.3 -->
  <findingType>
    <id>HRS_REQUEST_PARAMETER_TO_HTTP_HEADER</id>
    <artifact tool="FindBugs"
	      mnemonic="HRS_REQUEST_PARAMETER_TO_HTTP_HEADER">
    </artifact>
    <shortMessage>
      HTTP parameter directly written to HTTP header output
    </shortMessage>
    <info>
      &lt;p&gt; This code directly writes an HTTP parameter to an HTTP header, 
      which allows for a HTTP response splitting vulnerability. 
      See &lt;a href="http://en.wikipedia.org/wiki/HTTP_response_splitting"&gt;
      http://en.wikipedia.org/wiki/HTTP_response_splitting&lt;/a&gt;
      for more information.&lt;/p&gt;
    </info>
    <name>HTTP Response splitting vulnerability</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>HRS_REQUEST_PARAMETER_TO_COOKIE</id>
    <artifact tool="FindBugs"
	      mnemonic="HRS_REQUEST_PARAMETER_TO_COOKIE">
    </artifact>
    <shortMessage>
      HTTP cookie formed from untrusted input
    </shortMessage>
    <info>
      &lt;p&gt; 
      This code constructs an HTTP Cookie using an untrusted HTTP parameter. 
      If this cookie is added to an HTTP response, 
      it will allow a HTTP response splitting vulnerability. 
      See &lt;a href="http://en.wikipedia.org/wiki/HTTP_response_splitting"&gt;
      http://en.wikipedia.org/wiki/HTTP_response_splitting&lt;/a&gt;
      for more information.
      &lt;/p&gt;
    </info>
    <name>HTTP cookie formed from untrusted input</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>CN_IMPLEMENTS_CLONE_BUT_NOT_CLONEABLE</id>
    <artifact tool="FindBugs"
	      mnemonic="CN_IMPLEMENTS_CLONE_BUT_NOT_CLONEABLE">
    </artifact>
    <shortMessage>
      Class defines clone() but doesn't implement Cloneable
    </shortMessage>
    <info>
      &lt;p&gt; 
      This class defines a clone() method but the class doesn't implement Cloneable.
      There are some situations in which this is OK (e.g., you want to control how subclasses 
      can clone themselves), but just make sure that this is what you intended.
      &lt;/p&gt;
    </info>
    <name>Class defines clone() but doesn't implement Cloneable</name>
  </findingType>	
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DMI_CONSTANT_DB_PASSWORD</id>
    <artifact tool="FindBugs"
	      mnemonic="DMI_CONSTANT_DB_PASSWORD">
    </artifact>
    <shortMessage>
      Hardcoded constant database password
    </shortMessage>
    <info>
      &lt;p&gt; 
      This code creates a database connect using a hardcoded, 
      constant password. Anyone with access to either the source code
      or the compiled code can easily learn the password.
      &lt;/p&gt;
    </info>
    <name>Hardcoded constant database password</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DMI_EMPTY_DB_PASSWORD</id>
    <artifact tool="FindBugs"
	      mnemonic="DMI_EMPTY_DB_PASSWORD">
    </artifact>
    <shortMessage>
      Empty database password
    </shortMessage>
    <info>
      &lt;p&gt; 
      This code creates a database connect using a blank or empty password. 
      This indicates that the database is not protected by a password. 
      &lt;/p&gt;
    </info>
    <name>Empty database password</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DL_SYNCHRONIZATION_ON_BOOLEAN</id>
    <artifact tool="FindBugs"
	      mnemonic="DL_SYNCHRONIZATION_ON_BOOLEAN">
    </artifact>
    <shortMessage>
      Synchronization on Boolean could lead to deadlock
    </shortMessage>
    <info>
      &lt;p&gt; The code synchronizes on a boxed primitive constant, such as an Boolean.
      &lt;pre&gt;
      private static Boolean inited = Boolean.FALSE;
      ...
      synchronized(inited) { 
      if (!inited) {
      init();
      inited = BOOLEAN.TRUE;
      }
      }
      ...
      &lt;/pre&gt;
      &lt;/p&gt;
      &lt;p&gt; Since there normally exist only two Boolean objects, 
      this code could be synchronizing on the same object as other, unrelated code, 
      leading to unresponsiveness and possible deadlock &lt;/p&gt;			
    </info>
    <name>Synchronization on Boolean could lead to deadlock</name>
  </findingType>	
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DL_SYNCHRONIZATION_ON_BOXED_PRIMITIVE</id>
    <artifact tool="FindBugs"
	      mnemonic="DL_SYNCHRONIZATION_ON_BOXED_PRIMITIVE">
    </artifact>
    <shortMessage>
      Synchronization on boxed primitive value could lead to deadlock
    </shortMessage>
    <info>
      &lt;p&gt;
      The code synchronizes on a boxed primitive constant, such as an Integer.
      &lt;pre&gt;
      private static Integer count = 0;
      ...
      synchronized(count) { 
      count++;
      }
      ...
      &lt;/pre&gt;
      &lt;/p&gt;
      &lt;p&gt;Since Integer objects can be cached and shared,
      this code could be synchronizing on the same object as other, unrelated code, leading to unresponsiveness
      and possible deadlock 
      &lt;/p&gt;
    </info>
    <name>Synchronization on boxed primitive value could lead to deadlock</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DL_SYNCHRONIZATION_ON_UNSHARED_BOXED_PRIMITIVE</id>
    <artifact tool="FindBugs"
	      mnemonic="DL_SYNCHRONIZATION_ON_UNSHARED_BOXED_PRIMITIVE">
    </artifact>
    <shortMessage>
      Synchronization on boxed primitive values
    </shortMessage>
    <info>
      &lt;p&gt; 
      The code synchronizes on an apparently unshared boxed primitive, 
      such as an Integer.
      &lt;pre&gt;
      private static final Integer fileLock = new Integer(1);
      ...
      synchronized(fileLock) { 
      .. do something ..
      }
      ...
      &lt;/pre&gt;
      &lt;/p&gt;
      &lt;p&gt;It would be much better, in this code, to redeclare fileLock as
      &lt;pre&gt;
      private static final Object fileLock = new Object();
      &lt;/pre&gt;
      The existing code might be OK, but it is confusing and a 
      future refactoring, such as the "Remove Boxing" refactoring in IntelliJ,
      might replace this with the use of an intern'd Integer object shared 
      throughout the JVM, leading to very confusing behavior and potential deadlock.
      &lt;/p&gt;
    </info>
    <name>Synchronization on boxed primitive values</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>WL_USING_GETCLASS_RATHER_THAN_CLASS_LITERAL</id>
    <artifact tool="FindBugs"
	      mnemonic="WL_USING_GETCLASS_RATHER_THAN_CLASS_LITERAL">
    </artifact>
    <shortMessage>
      Synchronization on getClass rather than class literal
    </shortMessage>
    <info>
      &lt;p&gt; 
      This instance method synchronizes on &lt;code&gt;this.getClass()&lt;/code&gt;. 
      If this class is subclassed,
      subclasses will synchronize on the class object for the subclass, 
      which isn't likely what was intended.
      For example, consider this code from &lt;code&gt;java.awt.Label&lt;/code&gt;:
      &lt;pre&gt;
      private static final String base = "label";
      private static int nameCounter = 0;
      String constructComponentName() {
      synchronized (getClass()) {
      return base + nameCounter++;
      }
      }
      &lt;/pre&gt;&lt;/p&gt;
      &lt;p&gt;Subclasses of &lt;code&gt;Label&lt;/code&gt; won't synchronize on the same subclass, 
      giving rise to a data race.
      Instead, this code should be synchronizing on &lt;code&gt;Label.class&lt;/code&gt;
      &lt;pre&gt;
      private static final String base = "label";
      private static int nameCounter = 0;
      String constructComponentName() {
      synchronized (Label.class) {
      return base + nameCounter++;
      }
      }
      &lt;/pre&gt;&lt;/p&gt;
      &lt;p&gt;Bug pattern contributed by Jason Mehrens
      &lt;/p&gt;
    </info>
    <name>Synchronization on getClass rather than class literal</name>
  </findingType>	
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ML_SYNC_ON_FIELD_TO_GUARD_CHANGING_THAT_FIELD</id>
    <artifact tool="FindBugs"
	      mnemonic="ML_SYNC_ON_FIELD_TO_GUARD_CHANGING_THAT_FIELD">
    </artifact>
    <shortMessage>
      Synchronization on field in futile attempt to guard that field
    </shortMessage>
    <info>
      &lt;p&gt; 
      This method synchronizes on a field in what appears to be an attempt
      to guard against simultaneous updates to that field. But guarding a field
      gets a lock on the referenced object, not on the field. This may not 
      provide the mutual exclusion you need, and other threads might 
      be obtaining locks on the referenced objects (for other purposes). An example
      of this pattern would be:

      &lt;p&gt;&lt;pre&gt;
      private Long myNtfSeqNbrCounter = new Long(0);
      private Long getNotificationSequenceNumber() {
      Long result = null;
      synchronized(myNtfSeqNbrCounter) {
      result = new Long(myNtfSeqNbrCounter.longValue() + 1);
      myNtfSeqNbrCounter = new Long(result.longValue());
      }
      return result;
      }
      &lt;/pre&gt;
      &lt;/p&gt;
    </info>
    <name>Synchronization on field in futile attempt to guard that field</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DLS_DEAD_LOCAL_STORE_IN_RETURN</id>
    <artifact tool="FindBugs"
	      mnemonic="DLS_DEAD_LOCAL_STORE_IN_RETURN">
    </artifact>
    <shortMessage>
      Useless assignment in return statement
    </shortMessage>
    <info>
      &lt;p&gt; 
      This statement assigns to a local variable in a return statement. 
      This assignment has no lasting effect. 
      Please verify that this statement does the right thing.
      &lt;/p&gt;
    </info>
    <name>Useless assignment in return statement</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <!-- For FB 1.3.4 -->
  <findingType>
    <id>XSS_REQUEST_PARAMETER_TO_SEND_ERROR</id>
    <artifact tool="FindBugs"
	      mnemonic="XSS_REQUEST_PARAMETER_TO_SEND_ERROR">
    </artifact>
    <shortMessage>
      Servlet reflected cross site scripting vulnerability
    </shortMessage>
    <info>
      &lt;p&gt; 
      This code directly writes an HTTP parameter to a Server error page 
      (using HttpServletResponse.sendError). Echoing this untrusted input allows
      for a reflected cross site scripting vulnerability. 
      See &lt;a href="http://en.wikipedia.org/wiki/Cross-site_scripting"&gt;
      http://en.wikipedia.org/wiki/Cross-site_scripting&lt;/a&gt;
      for more information.&lt;/p&gt;
      &lt;p&gt;FindBugs looks only for the most blatent, obvious cases of cross site scripting.
    </info>
    <name>Servlet reflected cross site scripting vulnerability</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SKIPPED_CLASS_TOO_BIG</id>
    <artifact tool="FindBugs"
	      mnemonic="SKIPPED_CLASS_TOO_BIG">
    </artifact>
    <shortMessage>
      Class too big for analysis
    </shortMessage>
    <info>
      &lt;p&gt; 
      This class is bigger than can be effectively handled, and was not fully analyzed for errors.
      &lt;/p&gt;
    </info>
    <name>Class too big for analysis</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EQ_COMPARING_CLASS_NAMES</id>
    <artifact tool="FindBugs"
	      mnemonic="EQ_COMPARING_CLASS_NAMES">
    </artifact>
    <shortMessage>
      equals() compares class names rather than class objects
    </shortMessage>
    <info>
      &lt;p&gt; 
      This method checks to see if two objects are the same class by checking to see if the names
      of their classes are equal. You can have different classes with the same name if they are loaded by
      different class loaders. Just check to see if the class objects are the same.
      &lt;/p&gt;
    </info>
    <name>Comparing Class Names</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EQ_UNUSUAL</id>
    <artifact tool="FindBugs"
	      mnemonic="EQ_UNUSUAL">
    </artifact>
    <shortMessage>
      Unusual equals() method
    </shortMessage>
    <info>
      &lt;p&gt; 
      This class doesn't do any of the patterns we recognize for checking that the type of the argument 
      is compatible with the type of the &lt;code&gt;this&lt;/code&gt; object. There might not be anything wrong with
      this code, but it is worth reviewing
      &lt;/p&gt;
    </info>
    <name>Unusual equals() method</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EQ_GETCLASS_AND_CLASS_CONSTANT</id>
    <artifact tool="FindBugs"
	      mnemonic="EQ_GETCLASS_AND_CLASS_CONSTANT">
    </artifact>
    <shortMessage>
      equals() method fails for subtypes
    </shortMessage>
    <info>
      &lt;p&gt; 
      This class has an equals method that will be broken if it is inherited by subclasses.
      It compares a class literal with the class of the argument (e.g., in class &lt;code&gt;Foo&lt;/code&gt;
      it might check if &lt;code&gt;Foo.class == o.getClass()&lt;/code&gt;).
      It is better to check  if  &lt;code&gt;this.getClass() == o.getClass()&lt;/code&gt;.
      &lt;/p&gt;
    </info>
    <name>equals() fails for subtypes</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EQ_ALWAYS_TRUE</id>
    <artifact tool="FindBugs"
	      mnemonic="EQ_ALWAYS_TRUE">
    </artifact>
    <shortMessage>
      equals() method always returns true
    </shortMessage>
    <info>
      &lt;p&gt; 
      This class defines an equals method that always returns true. This is imaginative, but not very smart.
      Plus, it means that the equals method is not symmetric.
      &lt;/p&gt;
    </info>
    <name>equals() always returns true</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EQ_ALWAYS_FALSE</id>
    <artifact tool="FindBugs"
	      mnemonic="EQ_ALWAYS_FALSE">
    </artifact>
    <shortMessage>
      equals() method always returns false
    </shortMessage>
    <info>
      &lt;p&gt; 
      This class defines an equals method that always returns false. 
      This means that an object is not equal to itself, and it is impossible to 
      create useful Maps or Sets of this class. More fundamentally, it means
      that equals() is not reflexive, one of the requirements of the equals method.&lt;/p&gt;
      &lt;p&gt;The likely intended semantics are object identity: that an object is equal to itself. 
      This is the behavior inherited from class &lt;code&gt;Object&lt;/code&gt;. If you need to override an 
      equals inherited from a different superclass, you can use:
      &lt;pre&gt;
      public boolean equals(Object o) { return this == o; }
      &lt;/pre&gt;
      &lt;/p&gt;
    </info>
    <name>equals() always returns false</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>MSF_MUTABLE_SERVLET_FIELD</id>
    <artifact tool="FindBugs"
	      mnemonic="MSF_MUTABLE_SERVLET_FIELD">
    </artifact>
    <shortMessage>
      Mutable servlet field
    </shortMessage>
    <info>
      &lt;p&gt; 
      A web server generally only creates one instance of servlet or jsp class (i.e., treats
      the class as a Singleton), and will have multiple threads invoke methods on that instance to
      service multiple simultaneous requests.
      Thus, having a mutable instance field generally creates race conditions.
      &lt;/p&gt;
    </info>
    <name>Mutable servlet field</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SE_READ_RESOLVE_IS_STATIC</id>
    <artifact tool="FindBugs"
	      mnemonic="SE_READ_RESOLVE_IS_STATIC">
    </artifact>
    <shortMessage>
      readResolve() must not be declared as a static method.
    </shortMessage>
    <info>
      &lt;p&gt; 
      In order for the readResolve method to be recognized by the serialization
      mechanism, it must not be declared as a static method.
      &lt;/p&gt;
    </info>
    <name>Static readResolve() method</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SE_PRIVATE_READ_RESOLVE_NOT_INHERITED</id>
    <artifact tool="FindBugs"
	      mnemonic="SE_PRIVATE_READ_RESOLVE_NOT_INHERITED">
    </artifact>
    <shortMessage>
      private readResolve() not inherited by subclasses
    </shortMessage>
    <info>
      &lt;p&gt; 
      This class defines a private readResolve method. Since it is private, 
      it won't be inherited by subclasses.  This might be intentional and OK, 
      but should be reviewed to ensure it is what is intended.
      &lt;/p&gt;
    </info>
    <name>Private readResolve() not inherited</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>RpC_REPEATED_CONDITIONAL_TEST</id>
    <artifact tool="FindBugs"	mnemonic="RpC_REPEATED_CONDITIONAL_TEST"/>
    <shortMessage>Repeated conditional tests</shortMessage>
    <info>
      <![CDATA[

<p>The code contains a conditional test is performed twice, one right after the other
(e.g., <code>x == 0 || x == 0</code>). Perhaps the second occurrence is intended to be something else
(e.g., <code>x == 0 || y == 0</code>). 
</p>

]]>
    </info>
    <name>Repeated conditional tests</name>
  </findingType>
  <findingType>
    <id>DMI_FUTILE_ATTEMPT_TO_CHANGE_MAXPOOL_SIZE_OF_SCHEDULED_THREAD_POOL_EXECUTOR</id>
    <artifact tool="FindBugs"	mnemonic="DMI_FUTILE_ATTEMPT_TO_CHANGE_MAXPOOL_SIZE_OF_SCHEDULED_THREAD_POOL_EXECUTOR"/>
    <shortMessage>Futile attempt to change max pool size of ScheduledThreadPoolExecutor</shortMessage>
    <info>
      <![CDATA[
	       
	       <p>(<a href="http://java.sun.com/javase/6/docs/api/java/util/concurrent/ScheduledThreadPoolExecutor.html">Javadoc</a>)
	       While ScheduledThreadPoolExecutor inherits from ThreadPoolExecutor, a few of the inherited tuning methods are not useful for it. In particular, because it acts as a fixed-sized pool using corePoolSize threads and an unbounded queue, adjustments to maximumPoolSize have no useful effect.
	       </p>


      ]]>
    </info>
    <name>Futile attempt to change max pool size of ScheduledThreadPoolExecutor</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DMI_SCHEDULED_THREAD_POOL_EXECUTOR_WITH_ZERO_CORE_THREADS</id>
    <artifact tool="FindBugs"	mnemonic="DMI_SCHEDULED_THREAD_POOL_EXECUTOR_WITH_ZERO_CORE_THREADS"/>
    <shortMessage>Creation of ScheduledThreadPoolExecutor with zero core threads</shortMessage>
    <info>
      <![CDATA[
	       
	       <p>(<a href="http://java.sun.com/javase/6/docs/api/java/util/concurrent/ScheduledThreadPoolExecutor.html#ScheduledThreadPoolExecutor(int)">Javadoc</a>)
	       A ScheduledThreadPoolExecutor with zero core threads will never execute anything; changes to the max pool size are ignored.
	       </p>


      ]]>
    </info>
    <name>Creation of ScheduledThreadPoolExecutor with zero core threads</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DMI_UNSUPPORTED_METHOD</id>
    <artifact tool="FindBugs"	mnemonic="DMI_UNSUPPORTED_METHOD"/>
    <shortMessage>Call to unsupported method</shortMessage>
    <info>
      <![CDATA[
	       
	       <p>All targets of this method invocation throw an UnsupportedOperationException.
	       </p>


      ]]>
    </info>
    <name>Call to unsupported method</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NP_DEREFERENCE_OF_READLINE_VALUE</id>
    <artifact tool="FindBugs"	mnemonic="NP_DEREFERENCE_OF_READLINE_VALUE"/>
    <shortMessage>Dereference of the result of readLine() without nullcheck</shortMessage>
    <info>
      <![CDATA[

<p> The result of invoking readLine() is dereferenced without checking to see if the result is null. If there are no more lines of text
to read, readLine() will return null and dereferencing that will generate a null pointer exception.
</p>

      ]]>
    </info>
    <name>Dereference of the result of readLine() without nullcheck</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS</id>
    <artifact tool="FindBugs"	mnemonic="EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS"/>
    <shortMessage>Equals checks for noncompatible operand</shortMessage>
    <info>
      <![CDATA[

<p> This equals method is checking to see if the argument is some incompatible type
(i.e., a class that is neither a supertype nor subtype of the class that defines
the equals method). For example, the Foo class might have an equals method
that looks like:

<p><code><pre>
public boolean equals(Object o) {
if (o instanceof Foo)
return name.equals(((Foo)o).name);
else if (o instanceof String)
return name.equals(o);
else return false;
</pre></code></p>

<p>This is considered bad practice, as it makes it very hard to implement an equals method that
is symmetric and transitive. Without those properties, very unexpected behavoirs are possible.
</p>

      ]]>
    </info>
    <name>Equals checks for noncompatible operand</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NP_PARAMETER_MUST_BE_NONNULL_BUT_MARKED_AS_NULLABLE</id>
    <artifact tool="FindBugs"	mnemonic="NP_PARAMETER_MUST_BE_NONNULL_BUT_MARKED_AS_NULLABLE"/>
    <shortMessage>Parameter must be nonnull but is marked as nullable</shortMessage>
    <info>
      <![CDATA[

<p> This parameter is always used in a way that requires it to be nonnull,
but the parameter is explicitly annotated as being Nullable. Either the use
of the parameter or the annotation is wrong.
</p>

      ]]>
    </info>
    <name>Parameter must be nonnull but is marked as nullable</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>VA_FORMAT_STRING_BAD_CONVERSION</id>
    <artifact tool="FindBugs"	mnemonic="VA_FORMAT_STRING_BAD_CONVERSION"/>
    <shortMessage>The type of a supplied argument doesn't match format specifier</shortMessage>
    <info>
      <![CDATA[

<p>
One of the arguments is uncompatible with the corresponding format string specifier.
As a result, this will generate a runtime exception when executed.
For example, <code>String.format("%d", "1")</code> will generate an exception, since
the String "1" is incompatible with the format specifier %d.
</p>

      ]]>
    </info>
    <name>The type of a supplied argument doesn't match format specifier</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>VA_FORMAT_STRING_BAD_CONVERSION_TO_BOOLEAN</id>
    <artifact tool="FindBugs"	mnemonic="VA_FORMAT_STRING_BAD_CONVERSION_TO_BOOLEAN"/>
    <shortMessage>Non-Boolean argument formatted using %b format specifier</shortMessage>
    <info>
      <![CDATA[

<p>
An argument not of type Boolean is being formatted with a %b format specifier. This won't throw an
exception; instead, it will print true for any nonnull value, and false for null.
This feature of format strings is strange, and may not be what you intended.
</p>

      ]]>
    </info>
    <name>Non-Boolean argument formatted using %b format specifier</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>VA_FORMAT_STRING_BAD_CONVERSION_FROM_ARRAY</id>
    <artifact tool="FindBugs"	mnemonic="VA_FORMAT_STRING_BAD_CONVERSION_FROM_ARRAY"/>
    <shortMessage>Array formatted in useless way using format string</shortMessage>
    <info>
      <![CDATA[

<p>
One of the arguments being formatted with a format string is an array. This will be formatted
using a fairly useless format, such as [I@304282, which doesn't actually show the contents
of the array.
Consider wrapping the array using <code>Arrays.asList(...)</code> before handling it off to a formatted.
</p>

      ]]>
    </info>
    <name>Array formatted in useless way using format string</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>VA_FORMAT_STRING_NO_PREVIOUS_ARGUMENT</id>
    <artifact tool="FindBugs"	mnemonic="VA_FORMAT_STRING_NO_PREVIOUS_ARGUMENT"/>
    <shortMessage>No previous argument for format string</shortMessage>
    <info>
      <![CDATA[

<p>
The format string specifies a relative index to request that the argument for the previous format specifier
be reused. However, there is no previous argument.
For example, 
</p>
<p><code>formatter.format("%&lt;s %s", "a", "b")</code>
</p>
<p>would throw a MissingFormatArgumentException when executed.
</p>

      ]]>
    </info>
    <name>No previous argument for format string</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>VA_FORMAT_STRING_BAD_ARGUMENT</id>
    <artifact tool="FindBugs"	mnemonic="VA_FORMAT_STRING_BAD_ARGUMENT"/>
    <shortMessage>Format string placeholder incompatible with passed argument</shortMessage>
    <info>
      <![CDATA[

<p>
The format string placeholder is incompatible with the corresponding
argument. For example,
<code>
System.out.println("%d\n", "hello");
</code>
<p>The %d placeholder requires a numeric argument, but a string value is
passed instead. 
A runtime exception will occur when 
this statement is executed.
</p>

      ]]>
    </info>
    <name>Format string placeholder incompatible with passed argument</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>VA_FORMAT_STRING_MISSING_ARGUMENT</id>
    <artifact tool="FindBugs"	mnemonic="VA_FORMAT_STRING_MISSING_ARGUMENT"/>
    <shortMessage>Format string references missing argument</shortMessage>
    <info>
      <![CDATA[

<p>
Not enough arguments are passed to satisfy a placeholder in the format string.
A runtime exception will occur when 
this statement is executed.
</p>

      ]]>
    </info>
    <name>Format string references missing argument</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>VA_FORMAT_STRING_ILLEGAL</id>
    <artifact tool="FindBugs"	mnemonic="VA_FORMAT_STRING_ILLEGAL"/>
    <shortMessage>Illegal format string</shortMessage>
    <info>
      <![CDATA[

<p>
The format string is syntactically invalid, 
and a runtime exception will occur when 
this statement is executed.
</p>

      ]]>
    </info>
    <name>Illegal format string</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>VA_FORMAT_STRING_EXTRA_ARGUMENTS_PASSED</id>
    <artifact tool="FindBugs"	mnemonic="VA_FORMAT_STRING_EXTRA_ARGUMENTS_PASSED"/>
    <shortMessage>More arguments are passed that are actually used in the format string</shortMessage>
    <info>
      <![CDATA[

<p>
A format-string method with a variable number of arguments is called,
but more arguments are passed than are actually used by the format string.
This won't cause a runtime exception, but the code may be silently omitting 
information that was intended to be included in the formatted string.
</p>

      ]]>
    </info>
    <name>More arguments are passed that are actually used in the format string</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>BIT_ADD_OF_SIGNED_BYTE</id>
    <artifact tool="FindBugs"	mnemonic="BIT_ADD_OF_SIGNED_BYTE"/>
    <shortMessage>Bitwise add of signed byte value</shortMessage>
    <info>
      <![CDATA[

<p> Adds a byte value and a value which is known to the 8 lower bits clear.
Values loaded from a byte array are sign extended to 32 bits
before any any bitwise operations are performed on the value.
Thus, if <code>b[0]</code> contains the value <code>0xff</code>, and
<code>x</code> is initially 0, then the code 
<code>((x &lt;&lt; 8) + b[0])</code>  will sign extend <code>0xff</code>
to get <code>0xffffffff</code>, and thus give the value
<code>0xffffffff</code> as the result.
</p>

<p>In particular, the following code for packing a byte array into an int is badly wrong: </p>
<pre>
int result = 0;
for(int i = 0; i &lt; 4; i++) 
result = ((result &lt;&lt; 8) + b[i]);
</pre>

<p>The following idiom will work instead: </p>
<pre>
int result = 0;
for(int i = 0; i &lt; 4; i++) 
result = ((result &lt;&lt; 8) + (b[i] &amp; 0xff));
</pre>


      ]]>
    </info>
    <name>Bitwise add of signed byte value</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DMI_INVOKING_HASHCODE_ON_ARRAY</id>
    <artifact tool="FindBugs"	mnemonic="DMI_INVOKING_HASHCODE_ON_ARRAY"/>
    <shortMessage>Invocation of hashCode on an array</shortMessage>
    <info>
      <![CDATA[

<p>
The code invokes hashCode on an array. Calling hashCode on
an array returns the same value as System.identityHashCode, and ingores
the contents and length of the array. If you need a hashCode that
depends on the contents of an array <code>a</code>, 
use <code>java.util.Arrays.hashCode(a)</code>.

</p>

      ]]>
    </info>
    <name>Invocation of hashCode on an array</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DMI_USING_REMOVEALL_TO_CLEAR_COLLECTION</id>
    <artifact tool="FindBugs"	mnemonic="DMI_USING_REMOVEALL_TO_CLEAR_COLLECTION"/>
    <shortMessage>Don't use removeAll to clear a collection</shortMessage>
    <info>
      <![CDATA[
	       
	       <p> If you want to remove all elements from a collection <code>c</code>, use <code>c.clear</code>,
	       not <code>c.removeAll(c)</code>.
	       </p>
	       
      ]]>
    </info>
    <name>Don't use removeAll to clear a collection</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DMI_VACUOUS_SELF_COLLECTION_CALL</id>
    <artifact tool="FindBugs"	mnemonic="DMI_VACUOUS_SELF_COLLECTION_CALL"/>
    <shortMessage>Vacuous call to collections</shortMessage>
    <info>
      <![CDATA[
	       
	       <p> This call doesn't make sense. For any collection <code>c</code>, calling <code>c.containsAll(c)</code> should
	       always be true, and <code>c.retainAll(c)</code> should have no effect.
	       </p>
	       
      ]]>
    </info>
    <name>Vacuous call to collections</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DMI_COLLECTIONS_SHOULD_NOT_CONTAIN_THEMSELVES</id>
    <artifact tool="FindBugs"	mnemonic="DMI_COLLECTIONS_SHOULD_NOT_CONTAIN_THEMSELVES"/>
    <shortMessage>Collections should not contain themselves</shortMessage>
    <info>
      <![CDATA[
	       
	       <p> This call to a generic collection's method would only make sense if a collection contained 
	       itself (e.g., if <code>s.contains(s)</code> were true). This is unlikely to be true and would cause
	       problems if it were true (such as the computation of the hash code resulting in infinite recursion).
	       It is likely that the wrong value is being passed as a parameter.
	       </p>
	       
      ]]>
    </info>
    <name>Collections should not contain themselves</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>TQ_EXPLICIT_UNKNOWN_SOURCE_VALUE_REACHES_NEVER_SINK</id>
    <artifact tool="FindBugs"	mnemonic="TQ_EXPLICIT_UNKNOWN_SOURCE_VALUE_REACHES_NEVER_SINK"/>
    <shortMessage>Explicit annotation inconsistent with use</shortMessage>
    <info>
      <![CDATA[
	       
	       <p>
	       A value is used in a way that requires it to be never be a value denoted by a type qualifier, but
	       there is an explicit annotation stating that it is not known where the value is prohibited from having that type qualifier.
	       Either the usage or the annotation is incorrect.
	       </p>
	       
      ]]>
    </info>
    <name>Explicit annotation inconsistent with use</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>TQ_EXPLICIT_UNKNOWN_SOURCE_VALUE_REACHES_ALWAYS_SINK</id>
    <artifact tool="FindBugs"	mnemonic="TQ_EXPLICIT_UNKNOWN_SOURCE_VALUE_REACHES_ALWAYS_SINK"/>
    <shortMessage>Explicit annotation inconsistent with use</shortMessage>
    <info>
      <![CDATA[
	       
	       <p>
	       A value is used in a way that requires it to be always be a value denoted by a type qualifier, but
	       there is an explicit annotation stating that it is not known where the value is required to have that type qualifier.
	       Either the usage or the annotation is incorrect.
	       </p>
	       
      ]]>
    </info>
    <name>Explicit annotation inconsistent with use</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>OBL_UNSATISFIED_OBLIGATION</id>
    <artifact tool="FindBugs" mnemonic="OBL_UNSATISFIED_OBLIGATION"/>
    <artifact tool="FindBugs" mnemonic="OS_OPEN_STREAM"/>
    <artifact tool="FindBugs" mnemonic="ODR_OPEN_DATABASE_RESOURCE"/>
    <artifact tool="FindBugs" mnemonic="OS_OPEN_STREAM_EXCEPTION_PATH"/>
    <artifact tool="PMD" mnemonic="CloseResource"/>
    <name>Method may fail to clean up stream or resource</name>
    <shortMessage>Method may fail to clean up stream or resource</shortMessage>
    <info>
<![CDATA[<p>This method may fail to clean up (close, dispose of) a
stream, database object, or other resource requiring an explicit
cleanup operation.</p>
	       
<p>In general, if a method opens a stream or other resource, the
method should use a try/finally block to ensure that the stream or
resource is cleaned up before the method returns. For example, the
code below properly closes its reader in a finally block.</p>

<pre>
try {
  final BufferedReader in = new BufferedReader(new FileReader("data.txt"));
  try {
    String str;
    while ((str = in.readLine()) != null) {
      System.out.println(str);
    }
  } finally {
    in.close();
  }
} catch (IOException e) {
  e.printStackTrace();
}
</pre>

<p>See Weimer and Necula, <i>Finding and Preventing Run-Time Error
Handling Mistakes</i>, for a description of the analysis
technique.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>JSure</id>
    <artifact tool="JSure" mnemonic="JSure"/>
    <name>JSure issue</name>
    <shortMessage>
      A JSure issue.
    </shortMessage>
    <info>
<![CDATA[<p>A JSure issue.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ColorSecondPass_inferredColor</id> 
    <artifact tool="JSure" mnemonic="ColorSecondPass_inferredColor"/>
    <name>Inferred color</name>
    <shortMessage>An inferred color.</shortMessage>
    <info>
<![CDATA[<p>An inferred color.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ColorSecondPass_inheritedColor</id> 
    <artifact tool="JSure" mnemonic="ColorSecondPass_inheritedColor"/>
    <name>Inherited Color</name>
    <shortMessage>An inherited color.</shortMessage>
    <info>
<![CDATA[<p>An inherited color.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ColorSecondPass_inheritedTransparent</id> 
    <artifact tool="JSure" mnemonic="ColorSecondPass_inheritedTransparent"/>
    <name>Inherited as transparent</name>
    <shortMessage>A color has been inherited as transparent.</shortMessage>
    <info>
<![CDATA[<p>A color has been inherited as transparent.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ColorSecondPass_colorContextDrop</id>
    <artifact tool="JSure" mnemonic="ColorSecondPass_colorContextDrop"/>
    <name>@ColorContext</name>
    <shortMessage>Establishes a constraint on the colors of threads that may execute the
    annotated method.</shortMessage>
    <info>
<![CDATA[<p>Establishes a constraint on the colors of threads that may
execute the annotated method. At analysis time the <i>Thread
Coloring</i> analysis will enforce the constraint that the calling
thread must always have a set of associated color bindings that
satisfy the boolean expression.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ThreadEffectsAnalysis_noThreadsDrop</id> 
    <artifact tool="JSure" mnemonic="ThreadEffectsAnalysis_noThreadsDrop"/>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
    <name>No Threads Started</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ThreadEffectsAnalysis_threadEffectDrop</id> 
    <artifact tool="JSure" mnemonic="ThreadEffectsAnalysis_threadEffectDrop"/>
    <name>Illegal Thread Effects</name>
    <shortMessage>TBD</shortMessage>
    <info>TBD</info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ThreadEffectsAnalysis_callPromiseDrop</id> 
    <artifact tool="JSure" mnemonic="ThreadEffectsAnalysis_callPromiseDrop"/>
    <name>Call will not start threads</name>
    <shortMessage>This method call will not start any threads.</shortMessage>
    <info>
<![CDATA[<p>This method call will not start any threads.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ThreadEffectsAnalysis_callNotPromiseDrop</id> 
    <artifact tool="JSure" mnemonic="ThreadEffectsAnalysis_callNotPromiseDrop"/>
    <name>Call may start threads</name>
    <shortMessage>This method call may (or may not) start any threads.</shortMessage>
    <info>
<![CDATA[<p>This method call may (or may not) start any threads.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LockAnalysis_ds_SynchronizedConstructorAssured</id>
    <artifact tool="JSure" mnemonic="LockAnalysis_ds_SynchronizedConstructorAssured"/>
    <name>Single-threaded constructor assured</name>
    <shortMessage>This constructor has been assured to act in a single thread while it executes.</shortMessage>
    <info>
<![CDATA[<p>This constructor has been assured to act in a single
thread while it executes.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LockAnalysis_ds_SynchronizedConstructorNotAssured</id>
    <artifact tool="JSure" mnemonic="LockAnalysis_ds_SynchronizedConstructorNotAssured"/>
    <name>Single-threaded constructor not assured</name>
    <shortMessage>This constructor has not been assured to act in a single thread while it executes.</shortMessage>
    <info>
<![CDATA[<p>This constructor has <i>not</i> been assured to act in a
single thread while it executes.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LockAnalysis_ds_AggregationNeeded</id> 
    <artifact tool="JSure" mnemonic="LockAnalysis_ds_AggregationNeeded"/>
    <name>Object aggregation needed</name>
    <shortMessage>Object aggregation needed.</shortMessage>
    <info>
<![CDATA[<p>Object aggregation needed.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LockAnalysis_ds_AggregationNeeded2</id> 
    <artifact tool="JSure" mnemonic="LockAnalysis_ds_AggregationNeeded2"/>
    <name>Receiver aggregation needed</name>
    <shortMessage>Receiver aggregation needed.</shortMessage>
    <info>
<![CDATA[<p>Receiver aggregation needed.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LockAnalysis_ds_FieldAccessAssured</id> 
    <artifact tool="JSure" mnemonic="LockAnalysis_ds_FieldAccessAssured"/>
    <name>Field access assured</name>
    <shortMessage>Field access is assured.</shortMessage>
    <info>
<![CDATA[<p>Field access is assured.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LockAnalysis_ds_FieldAccessAssuredAlternative</id>
    <artifact tool="JSure" mnemonic="LockAnalysis_ds_FieldAccessAssuredAlternative"/>
    <name>Field access assured</name>
    <shortMessage>Field access is assured.</shortMessage>
    <info>
<![CDATA[<p>Field access is assured.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LockAnalysis_ds_FieldAccessNotAssured</id> 
    <artifact tool="JSure" mnemonic="LockAnalysis_ds_FieldAccessNotAssured"/>
    <name>Field access not assured</name>
    <shortMessage>Field access is not assured.</shortMessage>
    <info>
<![CDATA[<p>Field access is not assured.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LockAnalysis_ds_FieldAccessNotResolvable</id> 
    <artifact tool="JSure" mnemonic="LockAnalysis_ds_FieldAccessNotResolvable"/>
    <name>Unresolvable field access</name>
    <shortMessage>Unresolvable field access.</shortMessage>
    <info>
<![CDATA[<p>Unresolvable field access.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LockAnalysis_ds_PreconditionsAssured</id> 
    <artifact tool="JSure" mnemonic="LockAnalysis_ds_PreconditionsAssured"/>
    <name>Lock precondition assured</name>
    <shortMessage>Lock precondition is assured.</shortMessage>
    <info>
<![CDATA[<p>Lock precondition is assured.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LockAnalysis_ds_PreconditionsAssuredAlternative</id>
    <artifact tool="JSure" mnemonic="LockAnalysis_ds_PreconditionsAssuredAlternative"/>
    <name>Lock precondition assured</name>
    <shortMessage>Lock precondition is assured.</shortMessage>
    <info>
<![CDATA[<p>Lock precondition is assured.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LockAnalysis_ds_PreconditionsNotAssured</id> 
    <artifact tool="JSure" mnemonic="LockAnalysis_ds_PreconditionsNotAssured"/>
    <name>Lock precondition not assured</name>
    <shortMessage>Lock precondition is not assured.</shortMessage>
    <info>
<![CDATA[<p>Lock precondition is not assured.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LockAnalysis_ds_PreconditionNotResolvable</id> 
    <artifact tool="JSure" mnemonic="LockAnalysis_ds_PreconditionNotResolvable"/>
    <name>Unresolvable lock precondition</name>
    <shortMessage>Unresolvable lock precondition.</shortMessage>
    <info>
<![CDATA[<p>Unresolvable lock precondition.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LockAnalysis_ds_IndirectFieldAccessAssured</id> 
    <artifact tool="JSure" mnemonic="LockAnalysis_ds_IndirectFieldAccessAssured"/>
    <name>Indirect field access assured</name>
    <shortMessage>Indirect field access is assured.</shortMessage>
    <info>
<![CDATA[<p>Indirect field access is assured.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LockAnalysis_ds_IndirectFieldAccessAssuredAlternative</id>
    <artifact tool="JSure" mnemonic="LockAnalysis_ds_IndirectFieldAccessAssuredAlternative"/>
    <name>Indirect field access assured</name>
    <shortMessage>Indirect field access is assured.</shortMessage>
    <info>
<![CDATA[<p>Indirect field access is assured.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LockAnalysis_ds_IndirectFieldAccessNotAssured</id>
    <artifact tool="JSure" mnemonic="LockAnalysis_ds_IndirectFieldAccessNotAssured"/>
    <name>Indirect field access not assured</name>
    <shortMessage>Indirect field access is not assured.</shortMessage>
    <info>
<![CDATA[<p>Indirect field access is not assured.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LockAnalysis_ds_ReturnAssured</id> 
    <artifact tool="JSure" mnemonic="LockAnalysis_ds_ReturnAssured"/>
    <name>Return statement assured</name>
    <shortMessage>Return statement is assured.</shortMessage>
    <info>
<![CDATA[<p>Return statement is assured.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LockAnalysis_ds_ReturnNotAssured</id> 
    <artifact tool="JSure" mnemonic="LockAnalysis_ds_ReturnNotAssured"/>
    <name>Return statement not assured</name>
    <shortMessage>Return statement is not assured.</shortMessage>
    <info>
<![CDATA[<p>Return statement is not assured.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LockAnalysis_ds_SynchronizedMethodWarningDetails</id>
    <artifact tool="JSure" mnemonic="LockAnalysis_ds_SynchronizedMethodWarningDetails"/>
    <name>Unidentified Lock: this</name>
    <shortMessage>Unidentified Lock: this.</shortMessage>
    <info>
<![CDATA[<p>Unidentified Lock: <code>this</code></p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LockAnalysis_ds_SynchronizedStaticMethodWarningDetails</id>
    <artifact tool="JSure" mnemonic="LockAnalysis_ds_SynchronizedStaticMethodWarningDetails"/>
    <name>Unidentified lock: class</name>
    <shortMessage>Unidentified lock: class.</shortMessage>
    <info>
<![CDATA[<p>Unidentified lock: <code>class</code>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LockAnalysis_ds_SynchronizationUnused</id> 
    <artifact tool="JSure" mnemonic="LockAnalysis_ds_SynchronizationUnused"/>
    <name>Unused locks</name>
    <shortMessage>Unused locks.</shortMessage>
    <info>
<![CDATA[<p>Unused locks.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LockAnalysis_ds_NonfinalExpression</id> 
    <artifact tool="JSure" mnemonic="LockAnalysis_ds_NonfinalExpression"/>
    <name>Non-final lock expression</name>
    <shortMessage>This is a non-final lock expression.</shortMessage>
    <info>
<![CDATA[<p>This is a non-final lock expression.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LockAnalysis_ds_UnidentifiableLock</id> 
    <artifact tool="JSure" mnemonic="LockAnalysis_ds_UnidentifiableLock"/>
    <name>Unidentified lock</name>
    <shortMessage>This lock is unidentified.</shortMessage>
    <info>
<![CDATA[<p>This lock is unidentified.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LockAnalysis_ds_RedundantSynchronized</id> 
    <artifact tool="JSure" mnemonic="LockAnalysis_ds_RedundantSynchronized"/>
    <name>Redundant synchronization</name>
    <shortMessage>Redundant synchronization detected.</shortMessage>
    <info>
<![CDATA[<p>Redundant synchronization detected.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LockAnalysis_ds_SyncedJUCLock</id> 
    <artifact tool="JSure" mnemonic="LockAnalysis_ds_SyncedJUCLock"/>
    <name>Native synchronization an JUC Lock</name>
    <shortMessage>Native synchronization an JUC Lock.</shortMessage>
    <info>
<![CDATA[<p>Native synchronization an JUC Lock.  This is probably a mistake.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LockAnalysis_ds_MasqueradingCall</id> 
    <artifact tool="JSure" mnemonic="LockAnalysis_ds_MasqueradingCall"/>
    <name>Masquerading JUC Lock call</name>
    <shortMessage>Masquerading JUC Lock call.</shortMessage>
    <info>
<![CDATA[<p>Masquerading JUC Lock call.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LockAnalysis_ds_MasqueradingCall2</id> 
    <artifact tool="JSure" mnemonic="LockAnalysis_ds_MasqueradingCall2"/>
    <name>Masquerading JUC ReadWriteLock call</name>
    <shortMessage>Masquerading JUC ReadWriteLock call.</shortMessage>
    <info>
<![CDATA[<p>Masquerading JUC ReadWriteLock call.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LockAnalysis_ds_JUCLockFields</id> 
    <artifact tool="JSure" mnemonic="LockAnalysis_ds_JUCLockFields"/>
    <name>Fields declared as JUC locks</name>
    <shortMessage>Fields declared as JUC locks.</shortMessage>
    <info>
<![CDATA[<p>Fields declared as JUC locks.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LockAnalysis_ds_DeclaredJUCLockField</id> 
    <artifact tool="JSure" mnemonic="LockAnalysis_ds_DeclaredJUCLockField"/>
    <name>Field declared as a JUC Lock</name>
    <shortMessage>Field declared as a JUC Lock.</shortMessage>
    <info>
<![CDATA[<p>Field declared as a JUC Lock.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UniquenessAssurance_uniquenessContraints1</id> 
    <artifact tool="JSure"  mnemonic="UniquenessAssurance_uniquenessContraints1"/>
    <name>Uniqueness assured</name>
    <shortMessage>Uniqueness is assured.</shortMessage>
    <info>
<![CDATA[<p>Uniqueness is assured.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UniquenessAssurance_uniquenessContraints2</id> 
    <artifact tool="JSure" mnemonic="UniquenessAssurance_uniquenessContraints2"/>
    <name>Uniqueness not assured</name>
    <shortMessage>Uniqueness is not assured.</shortMessage>
    <info>
<![CDATA[<p>Uniqueness is not assured.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UniquenessAssurance_uniqueReturnDrop</id> 
    <artifact tool="JSure" mnemonic="UniquenessAssurance_uniqueReturnDrop"/>
    <name>Unique return value</name>
    <shortMessage>Unique return value.</shortMessage>
    <info>
<![CDATA[<p>Unique return value.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UniquenessAssurance_borrowedParametersDrop</id> 
    <artifact tool="JSure" mnemonic="UniquenessAssurance_borrowedParametersDrop"/>
    <name>Borrowed parameters</name>
    <shortMessage>Borrowed method parameters.</shortMessage>
    <info>
<![CDATA[<p>Borrowed method parameters.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UniquenessAssurance_uniqueParametersDrop</id> 
    <artifact tool="JSure" mnemonic="UniquenessAssurance_uniqueParametersDrop"/>
    <name>Unique parameters</name>
    <shortMessage>Unique method parameters.</shortMessage>
    <info>
<![CDATA[<p>Unique method parameters.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UniquenessAssurance_effectOfCallDrop</id> 
    <artifact tool="JSure" mnemonic="UniquenessAssurance_effectOfCallDrop"/>
    <name>Method call effects</name>
    <shortMessage>Method call effects.</shortMessage>
    <info>
<![CDATA[<p>Method call effects.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UniquenessAssurance_dependencyDrop</id> 
    <artifact tool="JSure" mnemonic="UniquenessAssurance_dependencyDrop"/>
    <name>Conservative uniqueness dependency</name>
    <shortMessage>Conservative uniqueness dependency.</shortMessage>
    <info>
<![CDATA[<p>Conservative uniqueness dependency.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UniquenessAssurance_error</id> 
    <artifact tool="JSure" mnemonic="UniquenessAssurance_error"/>
    <name>Uniqueness error</name>
    <shortMessage>Uniqueness error.</shortMessage>
    <info>
<![CDATA[<p>Uniqueness error.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UniquenessAssurance</id> 
    <artifact tool="JSure" mnemonic="UniquenessAssurance"/>
    <name>Uniqueness assurance</name>
    <shortMessage>Uniqueness assurance.</shortMessage>
    <info>
<![CDATA[<p>Uniqueness assurance.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>BorrowedPromiseDrop</id> 
    <artifact tool="JSure" mnemonic="BorrowedPromiseDrop"/>
    <name>@Borrowed</name>
    <shortMessage>Indicates that the parameter or receiver, in the case of an annotated method/constructor, does not receive any new aliases during execution of the method.</shortMessage>
    <info>
<![CDATA[<p>Indicates that the parameter or receiver, in the case of
an annotated method/constructor, does not receive any new aliases
during execution of the method.  That is, <tt>@Unique</tt> values can
be safely passed to the parameter or receiver with the guarantee that
they will still be unique when the method returns.</p>

<p>It is an error to use this annotation on a method whose return type
is primitive. It is an error to use this annotation on a parameter
whose type is primitive.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UniquePromiseDrop</id> 
    <artifact tool="JSure" mnemonic="UniquePromiseDrop"/>
    <name>@Unique</name>
    <shortMessage>Indicates that the parameter, receiver, return value, or field is unique.</shortMessage>
    <info>
<![CDATA[<p>Indicates that the parameter, receiver, return value, or
field is unique.</p>

<p>It is an error to annotate a method return value if the return type
is primitive. It is an error to annotate a parameter if the
parameter's type is primitive.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AggregatePromiseDrop</id> 
    <artifact tool="JSure" mnemonic="AggregatePromiseDrop"/>
    <name>@Aggregate</name>
    <shortMessage>Declares that regions of the object referenced by this field are to be mapped or "aggregated" into regions of the object that contains the field.</shortMessage>
    <info>
<![CDATA[<p>Declares that regions of the object referenced by this
field are to be mapped or "aggregated" into regions of the object that
contains the field.</p>

<p>It is an error if the field is not also annotated with
<tt>@Unique</tt>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>StartsPromiseDrop</id> 
    <artifact tool="JSure" mnemonic="StartsPromiseDrop"/>
    <name>@Starts</name>
    <shortMessage>Indicates what threads, if any, are started, i.e., by Thread.start(), during the execution of the method or constructor.</shortMessage>
    <info>
<![CDATA[<p>Indicates what threads, if any, are started, i.e., by
<tt>Thread.start()</tt>, during the execution of the method or
constructor. Presently this annotation has only one legal form,
<tt>@Starts("nothing")</tt>, that indicates that the
method/constructor does not cause any threads to be started.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>RegionEffectsPromiseDrop</id> 
    <artifact tool="JSure" mnemonic="RegionEffectsPromiseDrop"/>
    <name>@RegionEffects</name>
    <shortMessage>Declares the regions that may be read or written during execution of this method or constructor.</shortMessage>
    <info>
<![CDATA[<p>Declares the regions that may be read or written during
execution of this method or constructor. Because writing implies the
ability to read, regions that may be both read and written by the
method only need to be declared in writes clause of the annotation.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>InRegionPromiseDrop</id> 
    <artifact tool="JSure" mnemonic="InRegionPromiseDrop"/>
    <name>@InRegion</name>
    <shortMessage>Indicates that the annotated field is mapped into the named abstract region.</shortMessage>
    <info>
<![CDATA[<p>Indicates that the annotated field is mapped into the
named abstract region.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>RegionModel</id> 
    <artifact tool="JSure" mnemonic="RegionModel"/>
    <name>@Region</name>
    <shortMessage>Declares a new abstract region of state for the annotated class.</shortMessage>
    <info>
<![CDATA[<p>Declares a new abstract region of state for the annotated
class.  To declare more than one region for a class use the
<tt>@Regions</tt> annotation.  It is an error for a class to have both
a <tt>@Regions</tt> and a <tt>@Region</tt> annotation.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LockModel</id> 
    <artifact tool="JSure" mnemonic="LockModel"/>
    <shortMessage>Declare a new region lock in the annotated class.</shortMessage>
    <info>
<![CDATA[<p>Declare a new region lock in the annotated class.  Creates
a new named lock that associates a particular lock object with a
region of the class. The region may only be accessed when the lock is
held.</p>

<p>To declare more than one lock for a class use the
<tt>@RegionLocks</tt> annotation.  It is an error for a class to have
both a <tt>@RegionLocks</tt> and a <tt>@RegionLock</tt>
annotation.</p>

<p>The named lock is a Java object If the object's type
implements<tt>java.util.concurrent.locks.Lock</tt> then the lock
object must be used according to the protocol of the <tt>@Lock</tt>
interface.  Otherwise, the object must be used as a Java intrinsic
lock, i.e., with <tt>synchronized</tt> blocks.</p>]]>
    </info>
    <name>@RegionLock</name>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>RequiresLockPromiseDrop</id> 
    <artifact tool="JSure" mnemonic="RequiresLockPromiseDrop"/>
    <name>@RequiresLock</name>
    <shortMessage>Declares that the method/constructor assumes that the caller holds the named locks.</shortMessage>
    <info>
<![CDATA[<p>Declares that the method/constructor assumes that the
caller holds the named locks.  Analysis of the method/constructor
proceeds as if the named locks were held; call sites of the method are
scrutinized to determine if the precondition is satisfied.</p>

<p>The list of locks is allowed to be empty, in which case it means
that the method/constructor does not require any locks to be held by
the caller.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SelfProtectedPromiseDrop</id> 
    <artifact tool="JSure" mnemonic="SelfProtectedPromiseDrop"/>
    <name>@SelfProtected</name>
    <shortMessage>Marker annotation that indicates that the annotated type protects itself.</shortMessage>
    <info>
<![CDATA[<p>Marker annotation that indicates that the annotated type
protects itself. That is, it is safe to call any two methods from the
class simultaneously from different threads.  This annotation does not
imply anything about how the class is implemented.  Of course, it also
does not imply that a sequence of calls to methods of this class are
atomic.  It is a the responsibility of the caller to insure that such
call sequences execute atomically.  <i>This annotation is not
checked</i>; rather it is used to quiet warnings that would otherwise
be raised when accessing an object through a field protected by a
lock.</p>]]>
</info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SingleThreadedPromiseDrop</id> 
    <artifact tool="JSure" mnemonic="SingleThreadedPromiseDrop"/>
    <name>@SingleThreaded</name>
    <shortMessage>Marker annotation that indicates that the object created by the constructor is only operated on by the thread that invoked the constructor.</shortMessage>
    <info>
<![CDATA[<p>Marker annotation that indicates that the object created
by the constructor is only operated on by the thread that invoked the
constructor.  This knowledge allows fields of the newly create object
to be accessed without the normally required locking within the body
of the constructor.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>TransparentPromiseDrop</id> 
    <artifact tool="JSure" mnemonic="TransparentPromiseDrop"/>
    <name>@Transparent</name>
    <shortMessage>Indicates that the annotated method may be called from any thread color context.</shortMessage>
    <info>
<![CDATA[<p>Indicates that the annotated method may be called from any
thread color context. Semantically equivalent to <tt>@Color
true</tt>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>PromisePromiseDrop</id> 
    <artifact tool="JSure" mnemonic="PromisePromiseDrop"/>
    <name>Scoped promise</name>
    <shortMessage>A scoped promise.</shortMessage>
    <info>
<![CDATA[<p>A scoped promise</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LockAnalysis_ds_OnBehalfOfConstructor</id> 
    <artifact tool="JSure" mnemonic="LockAnalysis_ds_OnBehalfOfConstructor"/>
    <name>Analyzed initializers</name>
    <shortMessage>Analyzed initializers.</shortMessage>
    <info>
<![CDATA[<p>Analyzed initializers.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LockAnalysis_ds_FieldDeclaration</id> 
    <artifact tool="JSure" mnemonic="LockAnalysis_ds_FieldDeclaration"/>
    <name>Field declaration</name>
    <shortMessage>Field declaration.</shortMessage>
    <info>
<![CDATA[<p>Field declaration.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LockAnalysis_ds_HeldLock</id> 
    <artifact tool="JSure" mnemonic="LockAnalysis_ds_HeldLock"/>
    <name>Intrinsic lock held</name>
    <shortMessage>Intrinsic lock held.</shortMessage>
    <info>
<![CDATA[<p>Intrinsic lock held.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LockAnalysis_ds_HeldJUCLock</id> 
    <artifact tool="JSure" mnemonic="LockAnalysis_ds_HeldJUCLock"/>
    <name>JUC lock held</name>
    <shortMessage>JUC lock held.</shortMessage>
    <info>
<![CDATA[<p>JUC lock held.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LockAnalysis_ds_PoisonedLockCall</id> 
    <artifact tool="JSure" mnemonic="LockAnalysis_ds_PoisonedLockCall"/>
    <name>Inconsistent matching locks</name>
    <shortMessage>Inconsistent matching locks.</shortMessage>
    <info>
<![CDATA[<p>Inconsistent matching locks.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LockAnalysis_ds_NoMatchingUnlocks</id> 
    <artifact tool="JSure" mnemonic="LockAnalysis_ds_NoMatchingUnlocks"/>
    <name>No matching unlocks</name>
    <shortMessage>No matching unlocks.</shortMessage>
    <info>
<![CDATA[<p>No matching unlocks.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LockAnalysis_ds_MatchingUnlock</id> 
    <artifact tool="JSure" mnemonic="LockAnalysis_ds_MatchingUnlock"/>
    <name>Matching unlock</name>
    <shortMessage>Matching unlock.</shortMessage>
    <info>
<![CDATA[<p>Matching unlock.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LockAnalysis_ds_PoisonedUnlockCall</id> 
    <artifact tool="JSure" mnemonic="LockAnalysis_ds_PoisonedUnlockCall"/>
    <name>Inconsistent matching unlocks</name>
    <shortMessage>Inconsistent matching unlocks.</shortMessage>
    <info>
<![CDATA[<p>Inconsistent matching unlocks.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LockAnalysis_ds_NoMatchingLocks</id> 
    <artifact tool="JSure" mnemonic="LockAnalysis_ds_NoMatchingLocks"/>
    <name>No matching locks</name>
    <shortMessage>No matching locks.</shortMessage>
    <info>
<![CDATA[<p>No matching locks.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LockAnalysis_ds_MatchingLock</id> 
    <artifact tool="JSure" mnemonic="LockAnalysis_ds_MatchingLock"/>
    <name>Matching lock</name>
    <shortMessage>Matching lock.</shortMessage>
    <info>
<![CDATA[<p>Matching lock.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LockAnalysis_ds_AggregationEvidence</id> 
    <artifact tool="JSure" mnemonic="LockAnalysis_ds_AggregationEvidence"/>
    <name>Aggregation evidence</name>
    <shortMessage>Aggregation evidence.</shortMessage>
    <info>
<![CDATA[<p>Aggregation evidence.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EffectAssurance_msgUnaccountedFor</id> 
    <artifact tool="JSure" mnemonic="EffectAssurance_msgUnaccountedFor"/>
    <name>Unaccounted region effects</name>
    <shortMessage>Unaccounted region effects.</shortMessage>
    <info>
<![CDATA[<p>Unaccounted region effects.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EffectAssurance_msgCheckedBy</id> 
    <artifact tool="JSure" mnemonic="EffectAssurance_msgCheckedBy"/>
    <name>Checked region effects</name>
    <shortMessage>Checked region effects.</shortMessage>
    <info>
<![CDATA[<p>Checked region effects.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EffectAssurance_msgEmptyEffects</id> 
    <artifact tool="JSure"
	      mnemonic="EffectAssurance_msgEmptyEffects"/>
    <name>Empty region effects</name>
    <shortMessage>Empty region effects.</shortMessage>
    <info>
<![CDATA[<p>Empty region effects.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EffectAssurance_msgContructorRule</id> 
    <artifact tool="JSure" mnemonic="EffectAssurance_msgContructorRule"/>
    <name>Region effects checked by constructor</name>
    <shortMessage>Region effects checked by constructor.</shortMessage>
    <info>
<![CDATA[<p>Region effects checked by constructor</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EmptyInitializer</id>
    <artifact tool="PMD" mnemonic="EmptyInitializer"/>
    <artifact tool="PMD" mnemonic="EmptyStaticInitializer"/>
    <name>Empty initializer</name>
    <shortMessage>It is questionable coding practice to have an empty initializer.</shortMessage>
    <info>
<![CDATA[<p>It is highly questionable to have an empty
initializer. Consider removing it from your code.</p>

<pre>
public class Foo {
  static {} // Why ?
  {} // Again, why ?
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EmptyCatchBlock</id>
    <artifact tool="PMD" mnemonic="EmptyCatchBlock"/>
    <name>Empty catch block</name>
    <shortMessage>Are you swallowing an exception which should either be acted on or
      reported?</shortMessage>
    <info>
<![CDATA[<p>An exception is caught, but nothing is done. In most
circumstances, this swallows an exception which should either be acted
on or reported.</p>

<pre>
public void doSomething() {
  try {
    FileInputStream fis = new FileInputStream("/tmp/bugger");
  } catch (IOException ioe) {
      // not good
  }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EmptyIfStmt</id>
    <artifact tool="PMD" mnemonic="EmptyIfStmt"/>
    <name>Empty if</name>
    <shortMessage>It is questionable coding practice to have an empty if statement.</shortMessage>
    <info>
<![CDATA[<p>A condition is being checked but nothing is done about it.
Consider removing the check if it doesn't have side-effects.</p>

<p>If the check has side-effects just call the check and ignore the
result.  For example, <code>if (sideEffect()) {}</code> would be
replaced with <code>sideEffect()</code>.</p>

<pre>
public class Foo {
  void bar(int x) {
    if (x == 0) {
      // empty!
    }
  }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EmptyWhileStmt</id>
    <artifact tool="PMD" mnemonic="EmptyWhileStmt"/>
    <name>Empty while</name>
    <shortMessage>It is questionable coding practice to have an empty while statement.</shortMessage>
    <info>
<![CDATA[<p>This <code>while</code> statement appears to do
nothing. If it is a timing loop, then you should use
<code>Thread.sleep()</code> for it; if it's a while loop that does a
lot in the exit expression, then consider rewriting it to make what it
is doing clearer.</p>

<pre>
public class Foo {
  void bar(int a, int b) {
    while (a == b) {
      // empty!
    }
   }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EmptyTryBlock</id>
    <artifact tool="PMD" mnemonic="EmptyTryBlock"/>
    <name>Empty try block</name>
    <shortMessage>It is questionable coding practice to have an empty try block.</shortMessage>
    <info>
<![CDATA[<p>This <code>try</code> block is empty. It should be removed
from the code.</p>

<pre>
public class Foo {
  public void bar() {
    try {
    } catch (Exception e) {
      e.printStackTrace();
    }
  }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EmptyFinallyBlock</id>
    <artifact tool="PMD" mnemonic="EmptyFinallyBlock"/>
    <name>Empty finally block</name>
    <shortMessage>It is questionable coding practice to have an empty finally block.</shortMessage>
    <info>
<![CDATA[<p>This <code>finally</code> block is empty. It should be
removed from the code.</p>

<pre>
public class Foo {
  public void bar() {
    try {
      int x=2;
    } finally {
      // empty!
    }
  }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EmptySwitchStatements</id>
    <artifact tool="PMD" mnemonic="EmptySwitchStatements"/>
    <name>Empty switch</name>
    <shortMessage>It is questionable coding practice to have an empty switch statement.</shortMessage>
    <info>
<![CDATA[[<p>This <code>switch</code> statement is empty. Consider
removing it from the code.</p>

<pre>
public class Foo {
  public void bar() {
    int x = 2;
    switch (x) {
      // once there was code here
      // but it's been commented out or something
    }
  }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>JumbledIncrementer</id>
    <artifact tool="PMD" mnemonic="JumbledIncrementer"/>
    <name>Jumbled incrementer</name>
    <shortMessage>Avoid jumbled loop incrementers because it's usually a mistake.</shortMessage>
    <info>
<![CDATA[<p>Avoid jumbled loop incrementers&mdash;it's usually a
mistake, and it's confusing even if it's what's intended.</p>

<pre>
public class JumbledIncrementerRule1 {
  public void foo() {
    for (int i = 0; i < 10; i++) {
      for (int k = 0; k < 20; i++) {
        System.out.println("Hello");
      }
    }
  }
}
</pre>
]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ForLoopShouldBeWhileLoop</id>
    <artifact tool="PMD" mnemonic="ForLoopShouldBeWhileLoop"/>
    <name>For should be while</name>
    <shortMessage>This for loop can be simplified to a while loop.</shortMessage>
    <info>
<![CDATA[
<p>This loop can be simplified to a <code>while</code> and made more concise.</p>

<pre>
public class Foo {
  void bar() {
    for (;true;) true; // No Init or Update part, may as well be: while (true)
  }
}
</pre>
]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ReturnFromFinallyBlock</id>
    <artifact tool="PMD" mnemonic="ReturnFromFinallyBlock"/>
    <name>Return from within finally block</name>
    <shortMessage>It is questionable coding practice to return from a finally block because this can discard exceptions.</shortMessage>
    <info>
<![CDATA[<p>It is questionable coding practice to return from a
finally block because this can discard exceptions.</p>

<pre>
public class Bar {
  public String foo() {
    try {
      throw new Exception( "My Exception" );
    } catch (Exception e) {
      throw e;
    } finally {
      return "A. O. K."; // Very bad.
    }
  }
}
</pre>

<p>For more information on this issue see puzzle 36 of Bloch and
Gafter's <i>Java Puzzlers</i>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UnnecessaryReturn</id>
    <artifact tool="PMD" mnemonic="UnnecessaryReturn"/>
    <name>Unnecessary Return</name>
    <shortMessage>Avoid unnecessary return statements</shortMessage>
    <info>
<![CDATA[<p>It is questionable coding practice to place a return
statement where the method would simply return without it.  This
unnecessary return can be removed from your code.</p>

</pre>
public class Foo {
  public void bar() {
    int x = 42;
    return;
  }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UnconditionalIfStatement</id>
    <artifact tool="PMD" mnemonic="UnconditionalIfStatement"/>
    <name>Unconditional if</name>
    <shortMessage>Avoid if statements that are always true or always false.  Can this be removed?</shortMessage>
    <info>
<![CDATA[<p>It is questionable coding practice to have an
<code>if</code> statement that is always true or always false.  Unless
this is test code (or some other special purpose code) the
<code>if</code> can be removed.  Just remove the <code>if</code> and
keep the block if the statement was always true.  Delete both the
conditional and the block if the statement was always false.</p>

<pre>
public class Foo {
  public void close() {
    if (true) {
      // ...
    }
  }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EmptyStatementNotInLoop</id>
    <artifact tool="PMD" mnemonic="EmptyStatementNotInLoop"/>
    <name>Empty statement not in loop</name>
    <shortMessage>It is questionable coding practice to include an empty statement, i.e., a semicolon by itself.  Consider removing this empty statement.</shortMessage>
    <info>
<![CDATA[<p>It is questionable coding practice to include an empty
statement, i.e., a semicolon by itself, that is not used as the sole
body of a for loop or while loop. This could also be a double
semicolon, which is useless and should be removed.</p>

<pre>
public class MyClass {
  public void doit() {
    // this is probably not what you meant to do
    ;
    // the extra semicolon here this is not necessary
    System.out.println("look at the extra semicolon");;
  }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UnnecessaryFinalModifier</id>
    <artifact tool="PMD" mnemonic="UnnecessaryFinalModifier"/>
    <name>Unnecessary final modifier</name>
    <shortMessage>This class has the final modifier, therefore all of its methods are automatically final.</shortMessage>
    <info>
<![CDATA[<p>This class has the final modifier, therefore all of its
methods are automatically final.  Any final declarations on methods
may be removed.</p>

<pre>
public final class Foo {
   // This final modifier is not necessary, since the class is final
   // and thus, all methods are final
   private final void foo() {
   }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>CollapsibleIfStatements</id>
    <artifact tool="PMD" mnemonic="CollapsibleIfStatements"/>
    <name>Collapsible if</name>
    <shortMessage>Sometimes two if statements can be consolidated by separating their conditions with a boolean short-circuit operator.</shortMessage>
    <info>
<![CDATA[<p>Sometimes two if statements can be consolidated by
separating their conditions with a boolean short-circuit
operator. For example, the below code</p>

<pre>
if (x) {
  if (y) {
    // do stuff
  }
}
</pre>

<p>can be changed to</p>

<pre>
if (x && y) {
  // do stuff
}
</pre>

<p>When making this change ensure that the expression <code>y</code>
has no side-effects.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UselessOverridingMethod</id>
    <artifact tool="PMD" mnemonic="UselessOverridingMethod"/>
    <name>Useless overriding method</name>
    <shortMessage>This overriding method merely calls the same method defined in a superclass. It should simply inherit the method.</shortMessage>
    <info>
<![CDATA[<p>This overriding method merely calls the same method
defined in a superclass.</p>

<pre>
@Override public String foo() {
  return super.foo();  //Why bother overriding?
}
</pre>

<p>It is strongly recommended that you remove this method and simply
inherit the method from the superclass.  This problem may indicate a
lack of understanding about how inheritance works in the Java
programming language.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidDecimalLiteralsInBigDecimalConstructor</id>
    <artifact tool="PMD" mnemonic="AvoidDecimalLiteralsInBigDecimalConstructor"/>
    <name>Avoid decimal literals in BigDecimal construction</name>
    <shortMessage>Use of float or double literals when construction BigDecimal instances can result in imprecision.  Use the String argument constructor instead..</shortMessage>
    <info>
<![CDATA[<p>One might assume that <code>new BigDecimal(.1)</code> is
exactly equal to .1, but it is actually equal to
.1000000000000000055511151231257827021181583404541015625.  This is the
case because .1 cannot be represented exactly as a double (or, for
that matter, as a binary fraction of any finite length). Thus, the
long value that is being passed in to the constructor is not exactly
equal to .1, appearances notwithstanding.</p>

<p>The String argument constructor, on the other hand, is perfectly
predictable: <code>new BigDecimal(".1")</code> is exactly equal to .1,
as one would expect. Therefore, it is generally recommended that the
String argument constructor be used in preference to this one.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UselessOperationOnImmutable</id>
    <artifact tool="PMD" mnemonic="UselessOperationOnImmutable"/>
    <name>Ignored operation on an immutable object</name>
    <shortMessage>An operation on an Immutable object (e.g., a BigDecimal or a BigInteger) won't change the object itself. Thus, ignoring the result is probably an error.</shortMessage>
    <info>
<![CDATA[<p>An operation on an immutable object (e.g., a
<code>BigDecimal</code> or a <code>BigInteger</code>) won't change the
object itself. The result of the operation is a new object. Therefore,
ignoring the operation result is probably a mistake.</p>

<pre>
import java.math.*;
class Test {
  void method1() {
    BigDecimal bd=new BigDecimal(10);
    bd.add(new BigDecimal(5));      // this will trigger the rule
  }
  void method2() {
    BigDecimal bd=new BigDecimal(10);
    bd = bd.add(new BigDecimal(5)); // this won't trigger the rule
  }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UnusedNullCheckInEquals</id>
    <artifact tool="PMD" mnemonic="UnusedNullCheckInEquals"/>
    <name>Unused null check in equals</name>
    <shortMessage>After checking an object reference for null, you should invoke equals() on that object rather than passing it to another object's equals() method.</shortMessage>
    <info>
<![CDATA[<p>After checking an object reference for <code>null</code>,
you should invoke <code>equals()</code> on that object rather than
passing it to another object's <code>equals()</code> method.</p>

<pre>
public class Example {

  public String method1() { return "ok";}
  public String method2() { return null;}

  public void method(String a) {
    String b;
    /*
     * I don't know if method1() can be "null" but I know "a" is not null...
     * I'd better write a.equals(method1())
     */
    if (a != null && method1().equals(a)) { // will trigger the rule
      // do something
    }

    if (method1().equals(a) && a != null) { // won't trigger the rule
      // do something
    }

    if (a != null && method1().equals(b)) { // won't trigger the rule
      // do something
    }

    if (a != null && "LITERAL".equals(a)) { // won't trigger the rule
      // do something
    }

    if (a != null && !a.equals("go")) {     // won't trigger the rule
      a = method2();
      if (method1().equals(a)) {
        //do something
      }
    }
  }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidThreadGroup</id>
    <artifact tool="PMD" mnemonic="AvoidThreadGroup"/>
    <name>Avoid ThreadGroup</name>
    <shortMessage>It is best to avoid the use of ThreadGroup. Consider updating this code to use a util concurrent Executor.</shortMessage>
    <info>
<![CDATA[<p>It is best to avoid the use of ThreadGroup.  Although it
is intended to be used in a threaded environment it contains methods
that are not thread-safe.</p>

<pre>
public class Bar {
  void buz() {
    ThreadGroup tg = new ThreadGroup("My threadgroup");
    tg = new ThreadGroup(tg, "my thread group");
    tg = Thread.currentThread().getThreadGroup();
    tg = System.getSecurityManager().getThreadGroup();
  }
}
</pre>

<p>A better framework is provied by the util concurrent library found
in the <code>java.util.concurrent</code> package.  This library was
added to JDK 1.5.  In particular, the <code>Exceutor</code> framework
is worth considering.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>BrokenNullCheck</id>
    <artifact tool="PMD" mnemonic="BrokenNullCheck"></artifact>
    <name>Broken null check expression</name>
    <shortMessage>This null check appears to be broken since it can throw a NullPointerException. It is likely that you used || instead of &amp;&amp; or vice versa.</shortMessage>
    <info>
<![CDATA[<p>This null check appears to be broken since it can throw a
<code>NullPointerException</code>. It is likely that you used
<code>||</code> instead of <code>&amp;&amp;</code> or vice versa.</p>

<pre>
class Foo {
  String bar(String string) {
    // should be &&
    if (string != null || !string.equals(""))
      return string;
    // should be ||
    if (string == null && string.equals(""))
      return string;
  }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>BigIntegerInstantiation</id>
    <artifact tool="PMD" mnemonic="BigIntegerInstantiation"/>
    <name>Use BigInteger and BigDecimal constants</name>
    <shortMessage>This code creates an instance of BigInteger or BigDecimal for which a constant exists.  It is recommended that you use the constant instead of creating another object.</shortMessage>
    <info>
<![CDATA[<p>There is no need to create instances of already existing
<code>BigInteger</code> or <code>BigDecimal</code> objects.</p>

<pre>
// Don't do this -- use the defined constants
BigInteger bi = new BigInteger(1);
BigInteger bi2 = new BigInteger("0");
BigInteger bi3 = new BigInteger(0.0);
BigInteger bi4;
bi4 = new BigInteger(0);
bi4 = BigInteger.ZERO; // OK
</pre>

<p>Just use the predefined constants, such as
<code>BigInteger.ZERO</code>, <code>BigInteger.ONE</code>, (and for
1.5 on) <code>BigInteger.TEN</code>, <code>BigDecimal.ZERO</code>,
<code>BigDecimal.ONE</code>, and <code>BigDecimal.TEN</code>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidUsingOctalValues</id>
    <artifact tool="PMD" mnemonic="AvoidUsingOctalValues"/>
    <name>Avoid octal literals</name>
    <shortMessage>Integer literals should not start with zero. Zero means that the rest of literal will be interpreted as an octal value which might not be what you want.</shortMessage>
    <info>
<![CDATA[<p>Integer literals should not start with zero. Zero means
that the rest of literal will be interpreted as an octal value which
might not be what you want.</p>

<pre>
int i = 012;   // sets i to 10 not  12
int j = 010;   // sets j to  8 not  10
int k = i * j; // sets k to 80 not 120
</pre>

<p>If you really want the octal literal, it is recommended that it be
commented very clearly to avoid programmer confusion.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>IfStmtsMustUseBraces</id>
    <artifact tool="PMD" mnemonic="IfStmtsMustUseBraces"/>
    <artifact tool="PMD" mnemonic="IfElseStmtsMustUseBraces"/>
    <name>If must use braces</name>
    <shortMessage>Avoid if statements without curly braces.</shortMessage>
    <info>
<![CDATA[<p>This rule flags all if statements that do not use curly
braces because this has been deemed a questionable coding practice. To
fix this change</p>

<pre>
if (expression)
  statement1;
else
  statement2;
</pre>

<p>to</p>

<pre>
if (expression) {
  statement1;
} else {
  statement2;
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>WhileLoopsMustUseBraces</id>
    <artifact tool="PMD" mnemonic="WhileLoopsMustUseBraces"/>
    <name>While must use braces</name>
    <shortMessage>Avoid while loops without curly braces.</shortMessage>
    <info>
<![CDATA[<p>This rule flags all while loops that do not use curly
braces because this has been deemed a questionable coding practice. To
fix this change</p>

<pre>
while (expression)
  statement;
</pre>

<p>to</p>

<pre>
while (expression) {
  statement;
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ForLoopsMustUseBraces</id>
    <artifact tool="PMD" mnemonic="ForLoopsMustUseBraces"/>
    <name>For must use braces</name>
    <shortMessage>Avoid for loops without curly braces.</shortMessage>
    <info>
<![CDATA[<p>This rule flags all for loops that do not use curly braces
because this has been deemed a questionable coding practice. To fix
this change</p>

<pre>
for (e ; e ; e)
  statement;
</pre>

<p>to</p>

<pre>
for (e ; e ; e)
  statement;
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>CloneThrowsCloneNotSupportedException</id>
    <artifact tool="PMD" mnemonic="CloneThrowsCloneNotSupportedException"/>
    <name>Clone method signature must include throws CloneNotSupportedException</name>
    <shortMessage>This clone method does not declare that it can throw CloneNotSupportedException.  Its signature appears to be wrong.</shortMessage>
    <info>
<![CDATA[<p>The method clone has the wrong signature, it should throw
a <code>CloneNotSupportedException</code>.  So change the code
below</p>

<pre>
public Object clone() { // will cause this finding to appear
  return super.clone();
}
</pre>

<p>to</p>

<pre>
public Object clone() throws CloneNotSupportedException {
  return super.clone();
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NPathComplexity</id>
    <artifact tool="PMD" mnemonic="NPathComplexity"/>
    <name>High NPath complexity</name>
    <shortMessage>This method has a high NPath complexity.  Can you reduce its complexity?</shortMessage>
    <info>
<![CDATA[<p>The NPath complexity of a method is the number of acyclic
execution paths through that method. A threshold of 200 is generally
considered the point where measures should be taken to reduce
complexity.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ExcessiveMethodLength</id>
    <artifact tool="PMD" mnemonic="ExcessiveMethodLength"/>
    <name>Excessive method length</name>
    <shortMessage>This method is very long. Can you make it more concise?</shortMessage>
    <info>
<![CDATA[<p>Violations of this rule usually indicate that the method
is doing too much. This may signpost a poor design. Try to reduce the
method size by creating helper methods and removing any copy/pasted
code.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ExcessiveParameterList</id>
    <artifact tool="PMD" mnemonic="ExcessiveParameterList"/>
    <name>Excessive parameter list</name>
    <shortMessage>This method takes too many parameters.  Can it be redesigned to take less?</shortMessage>
    <info>
<![CDATA[<p>Long parameter lists can indicate that a new object should
be created to wrap the numerous parameters. Basically, try to group
the parameters together.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ExcessiveClassLength</id>
    <artifact tool="PMD" mnemonic="ExcessiveClassLength"/>
    <name>Excessive class length</name>
    <shortMessage>This class is very long. Can you make it more concise?</shortMessage>
    <info>
<![CDATA[<p>Long Class files are indications that the class may be
trying to do too much. Try to break it down, and reduce the size to
something manageable.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>CyclomaticComplexity</id>
    <artifact tool="PMD" mnemonic="CyclomaticComplexity"/>
    <name>High cyclomatic complexity</name>
    <shortMessage>This method has a high cyclomatic complexity.  Can you reduce its complexity?</shortMessage>
    <info>
<![CDATA[<p>Complexity is determined by the number of decision points
in a method plus one for the method entry. The decision points are
<code>if</code>, <code>while</code>, <code>for</code>, and
<code>case</code> labels. Generally, 1-4 is low complexity, 5-7
indicates moderate complexity, 8-10 is high complexity, and 11+ is
very high complexity.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ExcessivePublicCount</id>
    <artifact tool="PMD" mnemonic="ExcessivePublicCount"/>
    <name>Excessive public count</name>
    <shortMessage>This class has too many public methods and attributes.  Can you reduce this number?</shortMessage>
    <info>
<![CDATA[<p>A large number of public methods and attributes declared
in a class can indicate the class may need to be broken up as
increased effort will be required to thoroughly test it.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>TooManyFields</id>
    <artifact tool="PMD" mnemonic="TooManyFields"/>
    <name>Too many fields</name>
    <shortMessage>This class has too many fields.  Can you reduce this number?</shortMessage>
    <info>
<![CDATA[<p>Classes that have too many fields could be redesigned to
have fewer fields, possibly through some nested object grouping of
some of the information. For example, a class with city/state/zip
fields could instead have one Address field.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NcssMethodCount</id>
    <artifact tool="PMD" mnemonic="NcssMethodCount"/>
    <name>NCSS method count</name>
    <shortMessage>This rule uses the NCSS (Non Commenting Source Statements) algorithm to determine the number of lines of code for a given method.</shortMessage>
    <info>
<![CDATA[<p>This rule uses the NCSS (Non Commenting Source Statements)
algorithm to determine the number of lines of code for a given
method. NCSS ignores comments, and counts actual statements. Using
this algorithm, lines of code that are split are counted as
one.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NcssTypeCount</id>
    <artifact tool="PMD" mnemonic="NcssTypeCount"/>
    <name>NCSS type count</name>
    <shortMessage>This rule uses the NCSS (Non Commenting Source Statements) algorithm to determine the number of lines of code for a given type.</shortMessage>
    <info>
<![CDATA[<p>This rule uses the NCSS (Non Commenting Source Statements)
algorithm to determine the number of lines of code for a given
type. NCSS ignores comments, and counts actual statements. Using this
algorithm, lines of code that are split are counted as one.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NcssConstructorCount</id>
    <artifact tool="PMD" mnemonic="NcssConstructorCount"/>
    <name>NCSS constructor count</name>
    <shortMessage>This rule uses the NCSS (Non Commenting Source Statements) algorithm to determine the number of lines of code for a given constructor.</shortMessage>
    <info>
<![CDATA[<p>This rule uses the NCSS (Non Commenting Source
Statements) algorithm to determine the number of lines of code for a
given constructor. NCSS ignores comments, and counts actual
statements. Using this algorithm, lines of code that are split are
counted as one.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UnnecessaryConstructor</id>
    <artifact tool="PMD" mnemonic="UnnecessaryConstructor"/>
    <name>Unnecessary constructor</name>
    <shortMessage>This constructor is not required to be explicitly declared. You may remove it from your code and it will be automatically generated for you.</shortMessage>
    <info>
<![CDATA[<p>This rule detects when a constructor is not necessary;
i.e., when there's only one constructor, it's public, has an empty
body, and takes no arguments.  In this case Java will generate a
default constructor for you.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NullAssignment</id>
    <artifact tool="PMD" mnemonic="NullAssignment"/>
    <name>Null assignment warning</name>
    <shortMessage>Null is being assigned to a variable which could indicate a muddled implementation.</shortMessage>
    <info>
<![CDATA[<p>Assigning a <code>null</code> to a variable (outside of
its declaration) is usually bad form. Some times, the assignment is an
indication that the programmer doesn't completely understand what is
going on in the code.</p>

<p>This sort of assignment may in rare cases be useful to encourage
garbage collection. If that's what it's being using it for, by all
means, disregard this finding.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>OnlyOneReturn</id>
    <artifact tool="PMD" mnemonic="OnlyOneReturn"/>
    <name>Only one return</name>
    <shortMessage>This method has more than one exit point or its one exit point is not the last statement in the method. This has been deemed a questionable coding practice.</shortMessage>
    <info>
<![CDATA[<p>It has been determined that each method should have only
one exit point, and that should be the last statement in the
method.</p>

<pre>
public void foo(int x) {
  if (x > 0) {
    return "hey"; // oops, multiple exit points!
  }
  return "hi";
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UnusedModifier</id>
    <artifact tool="PMD" mnemonic="UnusedModifier"/>
    <name>Superfluous method modifiers in an interface</name>
    <shortMessage>This interface has superfluous modifiers on method declarations that are implied by their context.</shortMessage>
    <info>
<![CDATA[<p>Fields in interfaces are automatically <code>public</code>
<code>static</code> <code>final</code>, and methods are
<code>public</code> <code>abstract</code>. Classes or interfaces
nested in an interface are automatically <code>public</code> and
<code>static</code> (all nested interfaces are automatically
<code>static</code>). For historical reasons, modifiers which are
implied by the context are accepted by the compiler, but are
superfluous.  Below are some examples.</p>

<pre>
public interface Foo {
  public abstract void bar();    // both abstract and public are ignored by the compiler
  public static final int X = 0; // public, static, and final all ignored
  public static class Bar {}     // public, static ignored
  public static interface Baz {} // ditto
}
public class Bar {
  public static interface Baz {} // static ignored
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AssignmentInOperand</id>
    <artifact tool="PMD" mnemonic="AssignmentInOperand"/>
    <name>Avoid assignment in operand</name>
    <shortMessage>This code makes an assignment in an operand. This has been deemed questionable coding practice because it can be complicated and hard to read.</shortMessage>
    <info>
<![CDATA[<p>Avoid assignments in operands; this can make code more
complicated and harder to read.  Consider changing the below code</p>

<pre>
int x = 2;
if ((x = getX()) == 3) {
  System.out.println("3!");
}
</pre>

<p>to</p>

<pre>
int x = getX();
if (x == 3) {
  System.out.println("3!");
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AtLeastOneConstructor</id>
    <artifact tool="PMD" mnemonic="AtLeastOneConstructor"/>
    <name>Have at least one constructor</name>
    <shortMessage>This class does not have an explicit constructor.  Consider adding one.</shortMessage>
    <info>
<![CDATA[<p>This class lacks an explicit constructor. An implicit
constructor has been generated for it by the compiler. If you consider
this to be a bad coding practice then add an explicit constructor to
this class.</p>

<pre>
public class Foo {
  // no explicit constructor!  not good!
}
</pre>
]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DontImportSun</id>
    <artifact tool="PMD" mnemonic="DontImportSun"/>
    <name>Avoid import from sun.*</name>
    <shortMessage>This class imports from the sun.* packages. This should be avoided because these packages are not portable and are likely to change.</shortMessage>
    <info>
<![CDATA[<p>Avoid importing anything from the 'sun.*' packages because
these packages are not portable and are likely to change.</p>

<pre>
import sun.misc.foo;
public class Foo {
  ...
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SuspiciousOctalEscape</id>
    <artifact tool="PMD" mnemonic="SuspiciousOctalEscape"/>
    <name>Suspicious octal escape inside a string literal</name>
    <shortMessage>This is a suspicious octal escape sequence inside a String literal. Is this what is intended?</shortMessage>
    <info>
<![CDATA[<p>A suspicious octal escape sequence was found inside a
String literal. The Java language specification (section 3.10.6) says
an octal escape sequence inside a literal String shall consist of a
backslash followed by:</p>

<p><i>OctalDigit</i> | <i>OctalDigit</i> <i>OctalDigit</i> | <i>ZeroToThree</i> <i>OctalDigit</i> <i>OctalDigit</i></p>

<p>Any octal escape sequence followed by non-octal digits can be
confusing, e.g. <code>"\038"</code> is interpreted as the octal escape
sequence <code>\03</code> followed by the literal character
<code>8</code>.</p>

<pre>
public void foo() {
  // interpreted as octal 12, followed by the character '8'
  System.out.println("suspicious: \128");
}
</pre>

<p>See <a
href="http://java.sun.com/docs/books/jls/third_edition/html/lexical.html#3.10.6">the
Java Language Specification</a> for further details.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>CallSuperInConstructor</id>
    <artifact tool="PMD" mnemonic="CallSuperInConstructor"/>
    <name>Call super in all constructors</name>
    <shortMessage>This constructor does not call super() explicitly.</shortMessage>
    <info>
<![CDATA[<p>It is a good practice to call <code>super()</code> in a
constructor. If <code>super()</code> is not called but another
constructor (such as an overloaded constructor) is called, this rule
will not report it.</p>

<pre>
public class Foo extends Bar{
  public Foo() {
    // call the constructor of Bar explicitly
    super(); // if this was missing this rule would complain
   }
   public Foo(int code) {
     this(); // no problem with this
     // do something with 'code'
   }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UnnecessaryParentheses</id>
    <artifact tool="PMD" mnemonic="UnnecessaryParentheses"/>
    <name>Unnecessary parentheses</name>
    <shortMessage>This expression is wrapped in unnecessary parentheses, making it look like a function call.</shortMessage>
    <info>
<![CDATA[<p>Sometimes expressions are wrapped in unnecessary
parentheses, making them look like a function call.  Consider removing
the unnecessary parentheses.</p>

<pre>
public boolean bar() {
  return (true); // bad
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SingularField</id>
    <artifact tool="PMD" mnemonic="SingularField"/>
    <name>Singular field</name>
    <shortMessage>This field is only used by one method. Can it be replaced by a local variable? </shortMessage>
    <info>
<![CDATA[<p>A field that's only used by one method could perhaps be
replaced by a local variable.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DefaultPackage</id>
    <artifact tool="PMD" mnemonic="DefaultPackage"/>/artifact>
    <name>Use explicit visibility</name>
    <shortMessage>Use explicit visibility instead of the default package private level.</shortMessage>
    <info>
<![CDATA[<p>Use explicit visibility for attributes instead of the
default package private level.  For example, change</p>

<pre>
public class Foo {
  int myInt;
  ...
}
</pre>

<p>to</p>

<pre>
public class Foo {
  private int myInt;
  ...
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>BooleanInversion</id>
    <artifact tool="PMD" mnemonic="BooleanInversion"/>
    <name>Use boolean inversion</name>
    <shortMessage>Use bitwise inversion to invert this boolean value; it's the fastest way to do this.</shortMessage>
    <info>
<![CDATA[<p>Use bitwise inversion to invert boolean values&mdash;it's
the fastest way to do this.</p>

<pre>
boolean b = true;
b = !b;    // slow
b ^= true; // fast
</pre>

<p>See <a
href="http://www.javaspecialists.co.za/archive/newsletter.do?issue=042">
Speed-kings of inverting booleans</a> by Dr. Heinz M. Kabutz for more
details.  It also may be prudent to check this result on your
particular JVM.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DataflowAnomalyAnalysis</id>
    <artifact tool="PMD" mnemonic="DataflowAnomalyAnalysis"/>
    <name>Dataflow anomaly analysis</name>
    <shortMessage>An anomaly has been detected via PMD dataflow analysis.</shortMessage>
    <info>
<![CDATA[<p>The dataflow analysis tracks local definitions,
undefinitions and references to variables on different paths on the
data flow. From those informations there can be found various
problems.</p>

<ol>

<li>UR - Anomaly: There is a reference to a variable that was not
defined before. This is a bug and leads to an error.</li>

<li>DU - Anomaly: A recently defined variable is undefined.  These
anomalies may appear in normal source text.</li>

<li>DD - Anomaly: A recently defined variable is redefined. This is
ominous but don't have to be a bug.</li>

</ol>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>CouplingBetweenObjects</id>
    <artifact tool="PMD" mnemonic="CouplingBetweenObjects"/>
    <name>Coupling between objects</name>
    <shortMessage>This class seems to have a high number of unique attributes, local variables and return types within an object. This can indicate a high degree of coupling.  Can you reduce its coupling?</shortMessage>
    <info>
<![CDATA[<p>This rule counts unique attributes, local variables and
return types within an object. A number higher than specified
threshold can indicate a high degree of coupling.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ExcessiveImports</id>
    <artifact tool="PMD" mnemonic="ExcessiveImports"></artifact>
    <name>Excessive imports</name>
    <shortMessage>This class has too many imports. Can you reduce this count?</shortMessage>
    <info>
<![CDATA[<p>A high number of imports can indicate a high degree of
coupling within an object. Rule counts the number of unique imports
and reports a violation if the count is above the defined
threshold.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LooseCoupling</id>
    <artifact tool="PMD" mnemonic="LooseCoupling"></artifact>
    <name>Loose coupling violation</name>
    <shortMessage>Avoid using implementation types (i.e., HashSet); use the interface (i.e, Set) instead.</shortMessage>
    <info>
<![CDATA[<p>Avoid using implementation types (i.e.,
<code>HashSet</code>); use the interface (i.e, <code>Set</code>)
instead.</p>

<pre>
import java.util.*;
public class Bar {
  // Use List instead
  private ArrayList list = new ArrayList();
  // Use Set instead
  public HashSet getFoo() {
    return new HashSet();
  }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UseSingleton</id>
    <artifact tool="PMD" mnemonic="UseSingleton"/>
    <name>Use singleton pattern</name>
    <shortMessage>Consider refactoring this class to be a singleton.</shortMessage>
    <info>
<![CDATA[<p>If you have a class that has nothing but static methods,
consider making it a singleton. Note that this doesn't apply to
abstract classes, since their subclasses may well include non-static
methods. Also, if you want this class to be a singleton, remember to
add a private constructor to prevent instantiation.</p>

<p>The singleton pattern in Java is typically implemented as a
variation the below.  So instead of</p>

<pre>
public final class Foo {
  public static void m1() {
    // do something
  }

  private Foo() {
    // no instances...a utility
  }
}
</pre>

<p>use</p>

<pre>
public final class Foo {
  private static final INSTANCE = new Foo();

  public static Foo getInstance() {
    return INSTANCE;
  }

  private Foo() {
    // singleton
  }

  public void m1() {
    // do something
  }
}
</pre>

<p>Clients change calls to <code>m1()</code> from
<code>Foo.m1()</code> to <code>Foo.getInstance().m1()</code>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SimplifyBooleanExpressions</id>
    <artifact tool="PMD" mnemonic="SimplifyBooleanReturns"/>
    <artifact tool="PMD" mnemonic="SimplifyBooleanExpressions"/>
    <name>Use boolean expressions directly</name>
    <shortMessage>Use boolean expressions directly to simplify your code.</shortMessage>
    <info>
<![CDATA[<p>Avoid unnecessary comparisons in boolean
expressions&mdash;this complicates simple code</p>

<pre>
public class Foo {

  private int bar = 2;

  public boolean isBarEqualsTo(int x) {
    // this bit of code
    if (bar == x) {
     return true;
    } else {
     return false;
    }
    // can be simplified to 'return bar == x;'
  }

  // can be simplified to 'private boolean bar = isFoo();'
  private boolean bar = (isFoo() == true);

  public isFoo() {
    return false;
  }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SwitchStmtsShouldHaveDefault</id>
    <artifact tool="PMD" mnemonic="SwitchStmtsShouldHaveDefault"/>
    <name>Switch with no default</name>
    <shortMessage>This switch statement should have a default label.</shortMessage>
    <info>
<![CDATA[<p>It has been deemed questionable coding practice to not
have a <code>default</code> lable for each <code>switch</code>.</p>

<pre>
int x = 2;
switch (x) {
  case 2: int j = 8; // no default?
}
</pre>
]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidDeeplyNestedIfStmts</id>
    <artifact tool="PMD" mnemonic="AvoidDeeplyNestedIfStmts"/>
    <name>Avoid deeply nested if statements</name>
    <shortMessage>This is a deeply nested if that may be hard to read. Can the level of nesting be reduced?</shortMessage>
    <info>
<![CDATA[<p>Deeply nested if statments have been deemed to be
questional coding practice because they can be hard to read.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidReassigningParameters</id>
    <artifact tool="PMD" mnemonic="AvoidReassigningParameters"/>
    <name>Avoid reassigning parameter values</name>
    <shortMessage>This method reassigns the values of one or more of its parameters.  This is a questionable practice.</shortMessage>
    <info>
<![CDATA[<p>Reassigning values to parameters has been deemed a
questionable coding practice. Use a temporary local variable
instead.</p>

<pre>
private void foo(String bar) {
  bar = "something else";  // don't do this
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SwitchDensity</id>
    <artifact tool="PMD" mnemonic="SwitchDensity"/>
    <name>Switch density too high</name>
    <shortMessage>This switch statement has a high ratio of statements to labels. Consider moving the statements into new methods, or creating subclasses based on the switch variable.</shortMessage>
    <info>
<![CDATA[<p>A high ratio of statements to labels in a switch statement
implies that the switch statement is probably doing too much work.
Consider moving the statements into new methods, or creating
subclasses based on the switch variable (to replace the switch
statement with polymorphism).</p>

<pre>
switch (x) {
  case 1: {
    // lots of statements
    break;
  } case 2: {
    // lots of statements
    break;
  }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ConstructorCallsOverridableMethod</id>
    <artifact tool="PMD" mnemonic="ConstructorCallsOverridableMethod"/>
    <name>Constructor calls an overridable method</name>
    <shortMessage>This constructor calls, directly or indirectly, an
    overridable method.  This is considered dangerous if this class is
    subclassed.</shortMessage>
    <info>
<![CDATA[<p> Calling overridable methods during construction poses a
risk of invoking methods on an incompletely constructed object and can
be difficult to discern. It may leave the sub-class unable to
construct its superclass or forced to replicate the construction
process completely within itself, losing the ability to call
<code>super()</code>.</p>

<p>If the default constructor contains a call to an overridable
method, the subclass may be completely uninstantiable. Note that this
includes method calls throughout the control flow graph, i.e., if a
constructor <code>Foo()</code> calls a private method
<code>bar()</code> that calls a public (and thus overridable) method
<code>buz()</code>, this denotes a potential problem.</p>

<p>The code below provides an example where this finding can cause
confusing program behavior.</p>

<pre>
public class SeniorClass {
  public SeniorClass() {
    toString(); // may throw NullPointerException if overridden
  }
  public String toString() {
    return "IAmSeniorClass";
  }
}

public class JuniorClass extends SeniorClass {
  private String name;
  public JuniorClass() {
    super(); // Automatic call leads to a NullPointerException because 'name' is still null
    name = "JuniorClass";
  }
  public String toString() {
    return name.toUpperCase();
  }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AccessorClassGeneration</id>
    <artifact tool="PMD" mnemonic="AccessorClassGeneration"/>
    <name>Accessor class generation</name>
    <shortMessage>This class uses private constructors from outside of the constructor's class which can cause the generation of an accessor.</shortMessage>
    <info>
<![CDATA[<p>Instantiation by way of private constructors from outside
of the constructor's class often causes the generation of an
accessor. A factory method, or non-privatization of the constructor
can eliminate this situation. The generated class file is actually an
interface. It gives the accessing class the ability to invoke a new
hidden package scope constructor that takes the interface as a
supplementary parameter. This turns a private constructor effectively
into one with package scope, and is challenging to discern.</p>

<pre>
public class Outer {
  void method(){
    Inner ic = new Inner(); // Causes generation of an accessor class
  }
  public class Inner {
    private Inner(){}
  }
}
</pre>

<p>This could be resolved by making the constructor not be
<code>private</code> or by creating a factory method such as:</p>

<pre>
Inner getInstance() {
  return new Inner();
}
</pre>

<p>It is recommended to check if this generation still occurs on your
JDK.  If not then this finding is not an issue.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NonStaticInitializer</id>
    <artifact tool="PMD" mnemonic="NonStaticInitializer"/>
    <name>Avoid non-static initializer</name>
    <shortMessage>Do this code really need to use a non-static initializer block, it is rarely used and is confusing.</shortMessage>
    <info>
<![CDATA[<p>A non-static initializer block will be called any time a
constructor is invoked (just prior to invoking the constructor). While
this is a valid language construct, it is rarely used and is
confusing.</p>

<p>It is often possible to move the code in the initializer block into
a constructor.  Also consider using the <code>this()</code> invocation
technique to avoid copying of common constructor code.  For example:

<pre>
class Foo {

  private Foo() {
    // common code
  }

  public Foo(String s) {
    this();
    // more code
  }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DefaultLabelNotLastInSwitchStmt</id>
    <artifact tool="PMD" mnemonic="DefaultLabelNotLastInSwitchStmt"/>
    <name>Default label should be last in switch</name>
    <shortMessage>By convention, the default label should be the last label in a switch statement.</shortMessage>
    <info>
<![CDATA[<p>It is considered questionable coding practice to have the
<code>default</code> label not be last in a <code>switch</code>
statement.</p>

<pre>
switch (a) {
  case 1:
    // do something
    break;
  default:  // the default case should be last, by convention
    break;
  case 2:
    break;
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NonCaseLabelInSwitchStatement</id>
    <artifact tool="PMD" mnemonic="NonCaseLabelInSwitchStatement"/>
    <name>Non-case label in switch</name>
    <shortMessage>This code contains a non-case label (e.g. a named break/continue label) within a switch statement. This legal, but confusing.</shortMessage>
    <info>
<![CDATA[<p>A non-case label (e.g. a named break/continue label) was
present in a switch statement. This legal, but confusing. It is easy
to mix up the case labels and the non-case labels.  It is recommened
that this code be changed to avoid this confusion.</p>

<pre>
switch (a) {
  case 1:
    // do something
    break;
  mylabel: // this is legal, but confusing!
    break;
  default:
    break;
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ConfusingTernary</id>
    <artifact tool="PMD" mnemonic="ConfusingTernary"/>
    <name>Confusing negated if</name>
    <shortMessage>Avoid negation in the test of this if statement.  This can be confusing.</shortMessage>
    <info>
<![CDATA[<p>In an <code>if</code> expression with an<code>else</code>
clause, avoid negation in the test. For example, rephrase</p>

<pre>
if (x != y)
  diff();
else
same();
</pre>

<p>as</p>

<pre>
if (x == y)
  same();
else
  diff();
</pre>

<p>Most <code>if (x != y)</code> cases without an <code>else</code>
are often return cases, so consistent use of this rule makes the code
easier to read. Also, this resolves trivial ordering problems, such as
'does the error case go first?' or 'does the common case go
first?'.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>InstantiationToGetClass</id>
    <artifact tool="PMD" mnemonic="InstantiationToGetClass"/>
    <name>Avoid instantiation just to get class</name>
    <shortMessage>This code instantiates an object just to call getClass() on it; use the .class public member instead.</shortMessage>
    <info>
<![CDATA[<p>Avoid instantiating an object just to call getClass() on
it; use the .class public member instead.  For example, replace</p>

<pre>
Class c = new String().getClass();
</pre>

<p>with this</p>

<pre>
Class c = String.class;
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>IdempotentOperations</id>
    <artifact tool="PMD" mnemonic="IdempotentOperations"/>
    <name>Avoid idempotent operations</name>
    <shortMessage>This code appears to have no effect.  Remove it or change it to do what is intended.</shortMessage>
    <info>
<![CDATA[<p>Avoid idempotent operations because they are have no
effect and can make the code confusing.</p>

<pre>
int x = 2;
x = x;   // no effect
x = x++; // no effect
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SimpleDateFormatNeedsLocale</id>
    <artifact tool="PMD" mnemonic="SimpleDateFormatNeedsLocale"/>
    <name>Use Locale parameterized version of SimpleDateFormat constructor</name>
    <shortMessage>It is recommended that you specify a Locale when creating a new instance of SimpleDateFormat.</shortMessage>
    <info>
<![CDATA[<p>Consider specifying a Locale when creating a new instance
of SimpleDateFormat.</p>

<pre>
// Should specify Locale.US (or whatever)
private SimpleDateFormat sdf = new SimpleDateFormat("pattern");
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ImmutableField</id>
    <artifact tool="PMD" mnemonic="ImmutableField"/>
    <name>Immutable field</name>
    <shortMessage>This is a private field that never changes once it is initialized.  Consider making it a final field.</shortMessage>
    <info>
<![CDATA[<p>A private field whose value never changes once it is
initialized either in the declaration of the field or by a constructor
can be declared to be <code>final</code>. This aids in converting
existing classes to immutable classes.</p>

<pre>
public class Foo {
  private int x; // could be final
  public Foo() {
     x = 7;
  }
  public void foo() {
    int a = x + 2;
  }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidProtectedFieldInFinalClass</id>
    <artifact tool="PMD" mnemonic="AvoidProtectedFieldInFinalClass"/>
    <name>Avoid protected fields in final classes</name>
    <shortMessage>This field is declared to be protected in a final class.  Consider changing it to be private.</shortMessage>
    <info>
<![CDATA[<p>Do not use <code>protected</code> fields in
<code>final</code> classes since they cannot be subclassed. Clarify
your intent by changing these fields to use either the
<code>private</code> or package access (default) modifiers
instead.</p>

<pre>
public final class Bar {
  private int x;   // Ok
  protected int y; // 'Bar' cannot be subclassed, so should 'y' really private or package visible???
  ...
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AssignmentToNonFinalStatic</id>
    <artifact tool="PMD" mnemonic="AssignmentToNonFinalStatic"/>
    <name>Assignment to a non-final static field</name>
    <shortMessage>This assignment to a non-static field may be unsafe. Is this what was intended?</shortMessage>
    <info>
<![CDATA[<p>Identifies a possible unsafe usage of a static field.
Consider making this field immutable.  If this field is intended to be
mutable then ignore this finding.</p>

<pre>
public class StaticField {
   static int x;
   public FinalFields(int y) {
     x = y; // is this intended?
   }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>MissingStaticMethodInNonInstantiatableClass</id>
    <artifact tool="PMD" mnemonic="MissingStaticMethodInNonInstantiatableClass"/>
    <name>Non-instantiatable class</name>
    <shortMessage>This class has only private constructors and does not have any static methods of fields.  This class appears to be unusable.</shortMessage>
    <info>
<![CDATA[<p>A class that has only private constructors and does not
have any <code>static</code> methods or fields cannot be used.</p>

<pre>
/**
 * This class is unusable, since it cannot be
 * instantiated (private constructor),
 * no static method can be called, and
 * no static field can be accessed.
 */
public class Foo {
  private Foo() {}
  void foo() {}
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidSynchronizedAtMethodLevel</id>
    <artifact tool="PMD" mnemonic="AvoidSynchronizedAtMethodLevel"/>
    <name>Avoid synchronized at the method level</name>
    <shortMessage>Consider finer-grained synchronization than at the method level.</shortMessage>
    <info>
<![CDATA[<p>Method level synchronization can backfire when new code is
added to the method. Block-level synchronization helps to ensure that
only the code that needs synchronization gets it.  Block-level
synchronization can also help to improve enscapulation.</p>

<pre>
public class Foo {

  // Try to avoid this
  synchronized void foo() {
    ...
  }

  // Prefer this approach
  void bar() {
    synchronized(this) {
      ...
    }
    ...
  }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidInstanceofChecksInCatchClause</id>
    <artifact tool="PMD" mnemonic="AvoidInstanceofChecksInCatchClause"/>
    <name>Avoid instanceof checks in catch</name>
    <shortMessage>Place each caught exception in its own catch clause.  Don't use instanceof.</shortMessage>
    <info>
<![CDATA[<p>Each caught exception typ should be handled in its own
catch clause. Do not use instanceof check. For example, replace</p>

<pre>
try {
  // do something
} catch (Exception ee) {
  if (ee instanceof IOException) {
    cleanup();
  }
}
</pre>

<p>with</p>

<pre>
try {
  // do something
} catch (IOException ee) {
  cleanup();
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AbstractClassWithoutAbstractMethod</id>
    <artifact tool="PMD" mnemonic="AbstractClassWithoutAbstractMethod"/>
    <name>Abstract class has no abstract methods</name>
    <shortMessage>This abstract class does not contain any abstract methods.  Is it an incomplete implementation?</shortMessage>
    <info>
<![CDATA[<p>This abstract class does not contain any abstract
methods. An abstract class suggests an incomplete implementation,
which is to be completed by subclasses implementing the abstract
methods. If the class is intended to be used as a base class only (not
to be instantiated direcly) a protected constructor can be provided
prevent direct instantiation.<p>

<pre>
public abstract class Foo {
  void int method1() { ... }
  void int method2() { ... }
  // consider using abstract methods or removing
  // the abstract modifier and adding protected constructors
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SimplifyConditional</id>
    <artifact tool="PMD" mnemonic="SimplifyConditional"/>
    <name>Unnecessary null check before instanceof</name>
    <shortMessage>This code checks for null before an instanceof check. The null check can be safely removed.</shortMessage>
    <info>
<![CDATA[<p>There is no need to check for a <code>null</code> value
before an <code>instanceof</code> check.  This is because the
<code>instanceof</code> keyword returns false when given a
<code>null</code> argument.  For example, it is safe to change</p>

<pre>
if (x != null && x instanceof Bar) {
  // do something
}
</pre>

<p>to</p>

<pre>
if (x != null && x instanceof Bar) {
  // do something
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>CompareObjectsWithEquals</id>
    <artifact tool="PMD" mnemonic="CompareObjectsWithEquals"/>
    <name>Compare objects with equals not ==</name>
    <shortMessage>Consider using equals() to compare object references. Avoid comparing them with ==.</shortMessage>
    <info>
<![CDATA[<p>It has been determined that it is a questionable code
practice to compare object references with <code>==<code>, use
<code>equals()</code> instead.  For example, change <code>a ==
b</code> to <code>a.equals(b)</code>.</p>

<p>If this practice is followed be sure that the object being
dereferenced to call <code>equals()</code> (in our example this is
<code>a</code>) is not <code>null</code>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>PositionLiteralsFirstInComparisons</id>
    <artifact tool="PMD" mnemonic="PositionLiteralsFirstInComparisons"/>
    <name>Position literals first in String comparisons</name>
    <shortMessage>Position the String literal first in this comparison. This way may throw a NullPointerException.</shortMessage>
    <info>
<![CDATA[<p>Always position literals first in String comparisons.
This ensures that if the String is <code>null</code> then the
comparison will not throw a <code>NullPointerException</code>, it'll
just return false.  For example, always use
<code>"hello".equals(s)</code> rather than
<code>s.equals("hello")</code>.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UnnecessaryLocalBeforeReturn</id>
    <artifact tool="PMD" mnemonic="UnnecessaryLocalBeforeReturn"/>
    <name>Avoid unnecessary local before return</name>
    <shortMessage>This code appears to create an unnecessary local variable just to return it. Consider removing this local variable.</shortMessage>
    <info>
<![CDATA[<p>Avoid unnecessarily creating local variables just to
return them.</p>

<pre>
public int foo() {
  int x = doSomething();
  return x;  // instead, just 'return doSomething();'
}
</pre>]]>
  </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NonThreadSafeSingleton</id>
    <artifact tool="PMD" mnemonic="NonThreadSafeSingleton"/>
    <name>Avoid non-thread save singleton</name>
    <shortMessage>This singleton does not appear to be thread-safe. Consider making it thread-safe.</shortMessage>
    <info>
<![CDATA[<p>Non-thread-safe singletons can result in bad state
changes.  Eliminate static singletons if possible by instantiating the
object directly. Static singletons are usually not needed as only a
single instance exists anyway. Other possible fixes are to synchronize
the entire method or to use an initialize-on-demand holder class.  (do
not use the double-check idiom).  For more information see Bloch's
<i>Effective Java</i> (first edition) item 48.</p>

<p>For example, change the below code</p>

<pre>
private static Foo foo = null;

// Not thread-safe -- multiple simultaneous callers
// may see partially initialized objects
public static Foo getInstance() {
  if (foo == null)
    foo = new Foo();
  return foo;
}
</pre>

<p>to</p>

<pre>
private static final Foo INSTANCE = new Foo();

public static Foo getInstance() {
  return INSTANCE;
}
</pre>

<p>or <code>synchronize</code> the <code>getInstance()</code>
method.</p>

<p>If you are using Java 5 or above a single element <code>enum</code>
is recommended by Bloch as the best way to implement a singleton. For
example</p>

<pre>
public enum Foo {
  INSTANCE;

  // singleton methods
  public void m1() { ... }
}
</pre>

<p>would be used as <code>Foo.INSTANCE.m1()</code>.  This approach has
several advantages including built-in serialization machinery and a
guarantee against multiple instantiation.</p> ]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UncommentedEmptyMethod</id>
    <artifact tool="PMD" mnemonic="UncommentedEmptyMethod"/>
    <name>Uncommented empty method</name>
    <shortMessage>This empty method should be commented to indicate that it is intentionally empty.</shortMessage>
    <info>
<![CDATA[<p>This method does not contain any statements, but there is
no comment indicating that this lack of statements is intential. By
explicitly commenting empty methods it is easier to distinguish
between intentional (commented) and unintentional empty
methods.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UncommentedEmptyConstructor</id>
    <artifact tool="PMD" mnemonic="UncommentedEmptyConstructor"/>
    <name>Uncommented empty constructor</name>
    <shortMessage>This empty constructor should be commented to indicate that it is intentially empty.</shortMessage>
    <info>
<![CDATA[<p>This constructor does not contain any statements, but
there is no comment. By explicitly commenting empty constructors it is
easier to distinguish between intentional (commented) and
unintentional empty constructors.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidConstantsInterface</id>
    <artifact tool="PMD" mnemonic="AvoidConstantsInterface"/>
    <name>Avoid constants-only interface</name>
    <shortMessage>This interface only acts as a container of constants.  This is a poor usage pattern.</shortMessage>
    <info>
<![CDATA[<p>An interface should be used only to model a behaviour of a
class: using an interface as a container of constants is a poor usage
pattern.</p>

<pre>
// Bad! poor use of an interface
public interface ConstantsInterface {
  public static final int CONSTANT1 = 0;
  public static final String CONSTANT2 = "1";
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>PreserveStackTrace</id>
    <artifact tool="PMD" mnemonic="PreserveStackTrace"/>
    <name>Preserve Stack Trace</name>
    <shortMessage>This code throws a new exception from a catch block without passing the original exception into the new exception. This causes the true stack trace to be lost. Consider changing this code.</shortMessage>
    <info>
<![CDATA[<p>Throwing a new exception from a catch block without
passing the original exception into the new exception will cause the
true stack trace to be lost, and can make it difficult to debug
effectively.  Ensure that you pass the original exception into the
constructor of the new exception.  For example, change</p>

<pre>
try{
  Integer.parseInt("a");
} catch(Exception e){
  throw new Exception(e.getMessage());
}
</pre>

<p>to</p>

<pre>
try{
  Integer.parseInt("a");
} catch(Exception e){
  throw new Exception(e);
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UseCollectionIsEmpty</id>
    <artifact tool="PMD" mnemonic="UseCollectionIsEmpty"/>
    <name>Use isEmpty to check if a collection is empty</name>
    <shortMessage>Use the isEmpty() method to see if a java.util.Collection is empty rather than comparing the value of size() to 0.</shortMessage>
    <info>
<![CDATA[<p>The <code>isEmpty()</code> method on
<code>java.util.Collection</code> objects is provided to see if a
collection has any elements. Comparing the value of
<code>size()</code> of the collection to 0 merely duplicates existing
behavior.  For example, change</p>

<pre>
List foo = getList();
if (foo.size() == 0) {
  // do something
}
</pre>

<p>to</p>

<pre>
List foo = getList();
if (foo.isEmpty()) {
  // do something
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>FinalizeOverloaded</id>
    <artifact tool="PMD" mnemonic="FinalizeOverloaded"/>
    <name>Avoid overloading finalize</name>
    <shortMessage>This method overloads the finalize() method with one that has one or more paramenters. It is not be called by the VM.</shortMessage>
    <info>
<![CDATA[<p>Methods named <code>finalize()</code> should not have
parameters.  It is easy to confuse such a method with a finalizer and
could lead to a bug. This method will not be called by the VM.  It is
recommended that you use another name.</p>

<pre>
public class Foo {
  // This method is confusing and might be a bug
  protected void finalize(int a) {
    ...
  }
}
</pre>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DuplicateImports</id>
    <artifact tool="PMD" mnemonic="DuplicateImports"/>
    <artifact tool="PMD" mnemonic="ImportFromSamePackage"/>
    <name>Avoid duplicate import</name>
    <shortMessage>This compilation unit has an import that duplicates another import.  Remove the duplication.</shortMessage>
    <info>
<![CDATA[<p>It is considered bad practice for a compilation unit to
contain duplicate import statements.  For example, consider
changing</p>

<pre>
import java.util.Set;
import java.util.*;
public class Foo {
  ...
}
</pre>

<p>to</p>

<pre>
import java.util.*;
public class Foo {
  ...
}
</pre>]]>
</info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DontImportJavaLang</id>
    <artifact tool="PMD" mnemonic="DontImportJavaLang"/>
    <name>Never explicitly import from java.lang</name>
    <shortMessage>This compilation unit explicitly imports part or all of the java.lang package. This package is automatically imported.</shortMessage>
    <info>
<![CDATA[<p>Never explicitly import anything from the
<code>java.lang</code> package. Classes in this package are
automatically imported.  For example, both of the import statements
shown below are unnecessary and can be removed.</p>

<pre>
import java.lang.String;
</pre>

<pre>
import java.lang.*;
</pre>

<p>See <a
href="http://java.sun.com/docs/books/jls/third_edition/html/packages.html#7.5.5">the
Java Language Specification</a> for further details.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UnusedImports</id>
    <artifact tool="PMD" mnemonic="UnusedImports"/>
    <name>Remove unused import</name>
    <shortMessage>This import is not necessary.  Consider removing it from the compilation unit.</shortMessage>
    <info>
<![CDATA[<p>Imports that are not required by the compilation unit
create a dependency.  For example, consider the below code.</p>

<pre>
import org.apache.log4j.Logger;
public class Foo {
  public static void main(String[] args) {
    System.out.println("Hello!");
  }
}
</pre>

<p>This compilation unit will <i>not</i> compile without the Apache
Log4j Jar on its classpath despite the fact that it never uses the
imported Log4j <code>Logger</code> class.</p>

<p>Unused or unnecessary imports are considered bad coding practice
and can create unnecessary coupling between classes.</p>

<p>Many IDEs, such as Eclipse, can help you to automatically remove
unused imports from your program.</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UseProperClassLoader</id>
    <artifact tool="PMD" mnemonic="UseProperClassLoader"/>
    <name>Use Proper Class Loader</name>
    <shortMessage>
      In J2EE getClassLoader() might not work as expected. Use
      Thread.currentThread().getContextClassLoader() instead.
    </shortMessage>
    <info>
      In J2EE getClassLoader() might not work as expected. Use
      Thread.currentThread().getContextClassLoader() instead.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>MDBAndSessionBeanNamingConvention</id>
    <artifact tool="PMD" mnemonic="MDBAndSessionBeanNamingConvention"/>
    <name>MDB And Session Bean Naming Convention</name>
    <shortMessage>
      The EJB Specification state that any MessageDrivenBean or
      SessionBean should be suffixed by Bean.
    </shortMessage>
    <info>
      The EJB Specification state that any MessageDrivenBean or
      SessionBean should be suffixed by Bean.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>RemoteSessionInterfaceNamingConvention</id>
    <artifact tool="PMD" mnemonic="RemoteSessionInterfaceNamingConvention"/>
    <name>Remote Session Interface Naming Convention</name>
    <shortMessage>
      Remote Home interface of a Session EJB should be suffixed by
      'Home'.
    </shortMessage>
    <info>
      Remote Home interface of a Session EJB should be suffixed by
      'Home'.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LocalInterfaceSessionNamingConvention</id>
    <artifact tool="PMD" mnemonic="LocalInterfaceSessionNamingConvention"/>
    <name>Local Interface Session Naming Convention</name>
    <shortMessage>
      The Local Interface of a Session EJB should be suffixed by
      'Local'.
    </shortMessage>
    <info>
      The Local Interface of a Session EJB should be suffixed by
      'Local'.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LocalHomeNamingConvention</id>
    <artifact tool="PMD" mnemonic="LocalHomeNamingConvention"/>
    <name>Local Home Naming Convention</name>
    <shortMessage>
      The Local Home interface of a Session EJB should be suffixed
      by 'LocalHome'.
    </shortMessage>
    <info>
      The Local Home interface of a Session EJB should be suffixed
      by 'LocalHome'.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>RemoteInterfaceNamingConvention</id>
    <artifact tool="PMD" mnemonic="RemoteInterfaceNamingConvention"/>
    <name>Remote Interface Naming Convention</name>
    <shortMessage>
      Remote Interface of a Session EJB should NOT be suffixed.
    </shortMessage>
    <info>
      Remote Interface of a Session EJB should NOT be suffixed.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>BeanMembersShouldSerialize</id>
    <artifact tool="PMD" mnemonic="BeanMembersShouldSerialize"/>
    <name>Bean Members Should Serialize</name>
    <shortMessage>
      If a class is a bean, or is referenced by a bean directly or
      indirectly it needs to be serializable. Member variables
      need to be marked as transient, static, or have accessor
      methods in the class. Marking variables as transient is the
      safest and easiest modification. Accessor methods should
      follow the Java naming conventions, i.e.if you have a
      variable foo, you should provide getFoo and setFoo methods.
    </shortMessage>
    <info>
      If a class is a bean, or is referenced by a bean directly or
      indirectly it needs to be serializable. Member variables
      need to be marked as transient, static, or have accessor
      methods in the class. Marking variables as transient is the
      safest and easiest modification. Accessor methods should
      follow the Java naming conventions, i.e.if you have a
      variable foo, you should provide getFoo and setFoo methods.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>JUnitStaticSuite</id>
    <artifact tool="PMD" mnemonic="JUnitStaticSuite"/>
    <name>JUnit Static Suite</name>
    <shortMessage>
      The suite() method in a JUnit test needs to be both public
      and static.
    </shortMessage>
    <info>
      The suite() method in a JUnit test needs to be both public
      and static.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>JUnitSpelling</id>
    <artifact tool="PMD" mnemonic="JUnitSpelling"/>
    <name>JUnit Spelling</name>
    <shortMessage>
      Some JUnit framework methods are easy to misspell.
    </shortMessage>
    <info>Some JUnit framework methods are easy to misspell.</info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>JUnitAssertionsShouldIncludeMessage</id>
    <artifact tool="PMD" mnemonic="JUnitAssertionsShouldIncludeMessage"/>
    <name>JUnit Assertions Should Include Message</name>
    <shortMessage>
      JUnit assertions should include a message - i.e., use the
      three argument version of assertEquals(), not the two
      argument version.
    </shortMessage>
    <info>
      JUnit assertions should include a message - i.e., use the
      three argument version of assertEquals(), not the two
      argument version.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>JUnitTestsShouldIncludeAssert</id>
    <artifact tool="PMD" mnemonic="JUnitTestsShouldIncludeAssert"/>
    <name>JUnit Tests Should Include Assert</name>
    <shortMessage>
      JUnit tests should include at least one assertion. This
      makes the tests more robust, and using assert with messages
      provide the developer a clearer idea of what the test does.
    </shortMessage>
    <info>
      JUnit tests should include at least one assertion. This
      makes the tests more robust, and using assert with messages
      provide the developer a clearer idea of what the test does.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>TestClassWithoutTestCases</id>
    <artifact tool="PMD" mnemonic="TestClassWithoutTestCases"/>
    <name>Test Class Without Test Cases</name>
    <shortMessage>
      Test classes end with the suffix Test. Having a non-test
      class with that name is not a good practice, since most
      people will assume it is a test case. Test classes have test
      methods named testXXX.
    </shortMessage>
    <info>
      Test classes end with the suffix Test. Having a non-test
      class with that name is not a good practice, since most
      people will assume it is a test case. Test classes have test
      methods named testXXX.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UnnecessaryBooleanAssertion</id>
    <artifact tool="PMD" mnemonic="UnnecessaryBooleanAssertion"/>
    <name>Unnecessary Boolean Assertion</name>
    <shortMessage>
      A JUnit test assertion with a boolean literal is unnecessary
      since it always will eval to the same thing. Consider using
      flow control (in case of assertTrue(false) or similar) or
      simply removing statements like assertTrue(true) and
      assertFalse(false). If you just want a test to halt, use the
      fail method.
    </shortMessage>
    <info>
      A JUnit test assertion with a boolean literal is unnecessary
      since it always will eval to the same thing. Consider using
      flow control (in case of assertTrue(false) or similar) or
      simply removing statements like assertTrue(true) and
      assertFalse(false). If you just want a test to halt, use the
      fail method.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UseAssertEqualsInsteadOfAssertTrue</id>
    <artifact tool="PMD" mnemonic="UseAssertEqualsInsteadOfAssertTrue"/>
    <name>Use Assert Equals Instead Of Assert True</name>
    <shortMessage>
      This rule detects JUnit assertions in object equality. These
      assertions should be made by more specific methods, like
      assertEquals.
    </shortMessage>
    <info>
      This rule detects JUnit assertions in object equality. These
      assertions should be made by more specific methods, like
      assertEquals.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UseAssertSameInsteadOfAssertTrue</id>
    <artifact tool="PMD" mnemonic="UseAssertSameInsteadOfAssertTrue"/>
    <name>Use Assert Same Instead Of Assert True</name>
    <shortMessage>
      This rule detects JUnit assertions in object references
      equality. These assertions should be made by more specific
      methods, like assertSame, assertNotSame.
    </shortMessage>
    <info>
      This rule detects JUnit assertions in object references
      equality. These assertions should be made by more specific
      methods, like assertSame, assertNotSame.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UseAssertNullInsteadOfAssertTrue</id>
    <artifact tool="PMD" mnemonic="UseAssertNullInsteadOfAssertTrue"/>
    <name>Use Assert Null Instead Of Assert True</name>
    <shortMessage>
      This rule detects JUnit assertions in object references
      equality. These assertions should be made by more specific
      methods, like assertNull, assertNotNull.
    </shortMessage>
    <info>
      This rule detects JUnit assertions in object references
      equality. These assertions should be made by more specific
      methods, like assertNull, assertNotNull.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SimplifyBooleanAssertion</id>
    <artifact tool="PMD" mnemonic="SimplifyBooleanAssertion"/>
    <name>Simplify Boolean Assertion</name>
    <shortMessage>
      Avoid negation in an assertTrue or assertFalse test. For
      example, rephrase: assertTrue(!expr); as: assertFalse(expr);
    </shortMessage>
    <info>
      Avoid negation in an assertTrue or assertFalse test. For
      example, rephrase: assertTrue(!expr); as: assertFalse(expr);
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UseCorrectExceptionLogging</id>
    <artifact tool="PMD" mnemonic="UseCorrectExceptionLogging"/>
    <name>Use Correct Exception Logging</name>
    <shortMessage>
      To make sure the full stacktrace is printed out, use the
      logging statement with 2 arguments: a String and a
      Throwable.
    </shortMessage>
    <info>
      To make sure the full stacktrace is printed out, use the
      logging statement with 2 arguments: a String and a
      Throwable.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ProperLogger</id>
    <artifact tool="PMD" mnemonic="ProperLogger"/>
    <name>Proper Logger</name>
    <shortMessage>
      A logger should normally be defined private static final and
      have the correct class. Private final Log log; is also
      allowed for rare cases where loggers need to be passed
      around, with the restriction that the logger needs to be
      passed into the constructor.
    </shortMessage>
    <info>
      A logger should normally be defined private static final and
      have the correct class. Private final Log log; is also
      allowed for rare cases where loggers need to be passed
      around, with the restriction that the logger needs to be
      passed into the constructor.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>MoreThanOneLogger</id>
    <artifact tool="PMD" mnemonic="MoreThanOneLogger"/>
    <name>More Than One Logger</name>
    <shortMessage>
      Normally only one logger is used in each class.
    </shortMessage>
    <info>Normally only one logger is used in each class.</info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LoggerIsNotStaticFinal</id>
    <artifact tool="PMD" mnemonic="LoggerIsNotStaticFinal"/>
    <name>Logger Is Not Static Final</name>
    <shortMessage>
      In most cases, the Logger can be declared static and final.
    </shortMessage>
    <info>
      In most cases, the Logger can be declared static and final.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SystemPrintln</id>
    <artifact tool="PMD" mnemonic="SystemPrintln"/>
    <name>Use of System Println</name>
    <shortMessage>
      System.(out|err).print is used, consider using a logger.
    </shortMessage>
    <info>
      System.(out|err).print is used, consider using a logger.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidPrintStackTrace</id>
    <artifact tool="PMD" mnemonic="AvoidPrintStackTrace"/>
    <name>Avoid Print Stack Trace</name>
    <shortMessage>
      Avoid printStackTrace(); use a logger call instead.
    </shortMessage>
    <info>Avoid printStackTrace(); use a logger call instead.</info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ReplaceVectorWithList</id>
    <artifact tool="PMD" mnemonic="ReplaceVectorWithList"/>
    <name>Replace Vector With List</name>
    <shortMessage>
      Consider replacing Vector usages with the newer
      java.util.ArrayList if expensive threadsafe operation is not
      required.
    </shortMessage>
    <info>
      Consider replacing Vector usages with the newer
      java.util.ArrayList if expensive threadsafe operation is not
      required.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ReplaceHashtableWithMap</id>
    <artifact tool="PMD" mnemonic="ReplaceHashtableWithMap"/>
    <name>Replace Hashtable With Map</name>
    <shortMessage>
      Consider replacing this Hashtable with the newer
      java.util.Map
    </shortMessage>
    <info>
      Consider replacing this Hashtable with the newer
      java.util.Map
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ReplaceEnumerationWithIterator</id>
    <artifact tool="PMD" mnemonic="ReplaceEnumerationWithIterator"/>
    <name>Replace Enumeration With Iterator</name>
    <shortMessage>
      Consider replacing this Enumeration with the newer
      java.util.Iterator
    </shortMessage>
    <info>
      Consider replacing this Enumeration with the newer
      java.util.Iterator
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidEnumAsIdentifier</id>
    <artifact tool="PMD" mnemonic="AvoidEnumAsIdentifier"/>
    <name>Avoid Enum As Identifier</name>
    <shortMessage>
      Finds all places where 'enum' is used as an identifier.
    </shortMessage>
    <info>
      Finds all places where 'enum' is used as an identifier.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidAssertAsIdentifier</id>
    <artifact tool="PMD" mnemonic="AvoidAssertAsIdentifier"/>
    <name>Avoid Assert As Identifier</name>
    <shortMessage>
      Finds all places where 'assert' is used as an identifier.
    </shortMessage>
    <info>
      Finds all places where 'assert' is used as an identifier.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>JUnit4TestShouldUseBeforeAnnotation</id>
    <artifact tool="PMD" mnemonic="JUnit4TestShouldUseBeforeAnnotation"/>
    <name>JUnit4Test Should Use Before Annotation</name>
    <shortMessage>
      In JUnit 3, the setUp method was used to set up all data
      entities required in running tests. JUnit 4 skips the setUp
      method and executes all methods annotated with @Before
      before all tests
    </shortMessage>
    <info>
      In JUnit 3, the setUp method was used to set up all data
      entities required in running tests. JUnit 4 skips the setUp
      method and executes all methods annotated with @Before
      before all tests
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>JUnit4TestShouldUseAfterAnnotation</id>
    <artifact tool="PMD" mnemonic="JUnit4TestShouldUseAfterAnnotation"/>
    <name>JUnit4Test Should Use After Annotation</name>
    <shortMessage>
      In JUnit 3, the tearDown method was used to clean up all
      data entities required in running tests. JUnit 4 skips the
      tearDown method and executes all methods annotated with
      @After after running each test
    </shortMessage>
    <info>
      In JUnit 3, the tearDown method was used to clean up all
      data entities required in running tests. JUnit 4 skips the
      tearDown method and executes all methods annotated with
      @After after running each test
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>JUnit4TestShouldUseTestAnnotation</id>
    <artifact tool="PMD" mnemonic="JUnit4TestShouldUseTestAnnotation"/>
    <name>JUnit4Test Should Use Test Annotation</name>
    <shortMessage>
      In JUnit 3, the framework executed all methods which started
      with the word test as a unit test. In JUnit 4, only methods
      annotated with the @Test annotation are executed.
    </shortMessage>
    <info>
      In JUnit 3, the framework executed all methods which started
      with the word test as a unit test. In JUnit 4, only methods
      annotated with the @Test annotation are executed.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>JUnit4SuitesShouldUseSuiteAnnotation</id>
    <artifact tool="PMD" mnemonic="JUnit4SuitesShouldUseSuiteAnnotation"/>
    <name>JUnit4Suites Should Use Suite Annotation</name>
    <shortMessage>
      In JUnit 3, test suites are indicated by the suite() method.
      In JUnit 4, suites are indicated through the
      @RunWith(Suite.class) annotation.
    </shortMessage>
    <info>
      In JUnit 3, test suites are indicated by the suite() method.
      In JUnit 4, suites are indicated through the
      @RunWith(Suite.class) annotation.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>JUnitUseExpected</id>
    <artifact tool="PMD" mnemonic="JUnitUseExpected"/>
    <name>JUnit Use Expected</name>
    <shortMessage>TODO</shortMessage>
    <info>TODO</info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ShortVariable</id>
    <artifact tool="PMD" mnemonic="ShortVariable"/>
    <name>Short Variable</name>
    <shortMessage>
      Detects when a field, local, or parameter has a very short
      name.
    </shortMessage>
    <info>
      Detects when a field, local, or parameter has a very short
      name.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LongVariable</id>
    <artifact tool="PMD" mnemonic="LongVariable"/>
    <name>Long Variable</name>
    <shortMessage>
      Detects when a field, formal or local variable is declared
      with a long name.
    </shortMessage>
    <info>
      Detects when a field, formal or local variable is declared
      with a long name.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ShortMethodName</id>
    <artifact tool="PMD" mnemonic="ShortMethodName"/>
    <name>Short Method Name</name>
    <shortMessage>
      Detects when very short method names are used.
    </shortMessage>
    <info>Detects when very short method names are used.</info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AbstractNaming</id>
    <artifact tool="PMD" mnemonic="AbstractNaming"/>
    <name>Abstract Naming</name>
    <shortMessage>
      Abstract classes should be named 'AbstractXXX'.
    </shortMessage>
    <info>Abstract classes should be named 'AbstractXXX'.</info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidDollarSigns</id>
    <artifact tool="PMD" mnemonic="AvoidDollarSigns"/>
    <name>Avoid Dollar Signs</name>
    <shortMessage>
      Avoid using dollar signs in variable/method/class/interface
      names.
    </shortMessage>
    <info>
      Avoid using dollar signs in variable/method/class/interface
      names.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>MethodWithSameNameAsEnclosingClass</id>
    <artifact tool="PMD" mnemonic="MethodWithSameNameAsEnclosingClass"/>
    <name>Method With Same Name As Enclosing Class</name>
    <shortMessage>
      Non-constructor methods should not have the same name as the
      enclosing class.
    </shortMessage>
    <info>
      Non-constructor methods should not have the same name as the
      enclosing class.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SuspiciousConstantFieldName</id>
    <artifact tool="PMD" mnemonic="SuspiciousConstantFieldName"/>
    <name>Suspicious Constant Field Name</name>
    <shortMessage>
      A field name is all in uppercase characters, which in Sun's
      Java naming conventions indicate a constant. However, the
      field is not final.
    </shortMessage>
    <info>
      A field name is all in uppercase characters, which in Sun's
      Java naming conventions indicate a constant. However, the
      field is not final.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidFieldNameMatchingTypeName</id>
    <artifact tool="PMD" mnemonic="AvoidFieldNameMatchingTypeName"/>
    <name>Avoid Field Name Matching Type Name</name>
    <shortMessage>
      It is somewhat confusing to have a field name matching the
      declaring class name. This probably means that type and or
      field names could be more precise.
    </shortMessage>
    <info>
      It is somewhat confusing to have a field name matching the
      declaring class name. This probably means that type and or
      field names could be more precise.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidFieldNameMatchingMethodName</id>
    <artifact tool="PMD" mnemonic="AvoidFieldNameMatchingMethodName"/>
    <name>Avoid Field Name Matching Method Name</name>
    <shortMessage>
      It is somewhat confusing to have a field name with the same
      name as a method. While this is totally legal, having
      information (field) and actions (method) is not clear
      naming.
    </shortMessage>
    <info>
      It is somewhat confusing to have a field name with the same
      name as a method. While this is totally legal, having
      information (field) and actions (method) is not clear
      naming.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>NoPackage</id>
    <artifact tool="PMD" mnemonic="NoPackage"/>
    <name>No Package</name>
    <shortMessage>
      Detects when a class or interface does not have a package
      definition.
    </shortMessage>
    <info>
      Detects when a class or interface does not have a package
      definition.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>PackageCase</id>
    <artifact tool="PMD" mnemonic="PackageCase"/>
    <name>Package Case</name>
    <shortMessage>
      Detects when a package definition contains upper case
      characters.
    </shortMessage>
    <info>
      Detects when a package definition contains upper case
      characters.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>MisleadingVariableName</id>
    <artifact tool="PMD" mnemonic="MisleadingVariableName"/>
    <name>Misleading Variable Name</name>
    <shortMessage>
      Detects when a non-field has a name starting with 'm_'. This
      usually indicates a field and thus is confusing.
    </shortMessage>
    <info>
      Detects when a non-field has a name starting with 'm_'. This
      usually indicates a field and thus is confusing.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>BooleanGetMethodName</id>
    <artifact tool="PMD" mnemonic="BooleanGetMethodName"/>
    <name>Boolean Get Method Name</name>
    <shortMessage>
      Looks for methods named 'getX()' with 'boolean' as the
      return type. The convention is to name these methods
      'isX()'.
    </shortMessage>
    <info>
      Looks for methods named 'getX()' with 'boolean' as the
      return type. The convention is to name these methods
      'isX()'.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>LocalVariableCouldBeFinal</id>
    <artifact tool="PMD" mnemonic="LocalVariableCouldBeFinal"/>
    <name>Local Variable Could Be Final</name>
    <shortMessage>
      A local variable assigned only once can be declared final.
    </shortMessage>
    <info>
      A local variable assigned only once can be declared final.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>MethodArgumentCouldBeFinal</id>
    <artifact tool="PMD" mnemonic="MethodArgumentCouldBeFinal"/>
    <name>Method Argument Could Be Final</name>
    <shortMessage>
      A method argument that is never assigned can be declared
      final.
    </shortMessage>
    <info>
      A method argument that is never assigned can be declared
      final.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidInstantiatingObjectsInLoops</id>
    <artifact tool="PMD" mnemonic="AvoidInstantiatingObjectsInLoops"/>
    <name>Avoid Instantiating Objects In Loops</name>
    <shortMessage>
      Detects when a new object is created inside a loop
    </shortMessage>
    <info>Detects when a new object is created inside a loop</info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UseArrayListInsteadOfVector</id>
    <artifact tool="PMD" mnemonic="UseArrayListInsteadOfVector"/>
    <name>Use Array List Instead Of Vector</name>
    <shortMessage>
      ArrayList is a much better Collection implementation than
      Vector.
    </shortMessage>
    <info>
      ArrayList is a much better Collection implementation than
      Vector.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SimplifyStartsWith</id>
    <artifact tool="PMD" mnemonic="SimplifyStartsWith"/>
    <name>Simplify Starts With</name>
    <shortMessage>
      Since it passes in a literal of length 1, this call to
      String.startsWith can be rewritten using String.charAt(0) to
      save some time.
    </shortMessage>
    <info>
      Since it passes in a literal of length 1, this call to
      String.startsWith can be rewritten using String.charAt(0) to
      save some time.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UseArraysAsList</id>
    <artifact tool="PMD" mnemonic="UseArraysAsList"/>
    <name>Use Arrays As List</name>
    <shortMessage>
      The class java.util.Arrays has a &quot;asList&quot; method
      that should be use when you want to create a new List from
      an array of objects. It is faster than executing a loop to
      cpy all the elements of the array one by one
    </shortMessage>
    <info>
      The class java.util.Arrays has a &quot;asList&quot; method
      that should be use when you want to create a new List from
      an array of objects. It is faster than executing a loop to
      cpy all the elements of the array one by one
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidArrayLoops</id>
    <artifact tool="PMD" mnemonic="AvoidArrayLoops"/>
    <name>Avoid Array Loops</name>
    <shortMessage>
      Instead of copying data between two arrays, use
      System.arraycopy method
    </shortMessage>
    <info>
      Instead of copying data between two arrays, use
      System.arraycopy method
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UnnecessaryWrapperObjectCreation</id>
    <artifact tool="PMD" mnemonic="UnnecessaryWrapperObjectCreation"/>
    <name>Unnecessary Wrapper Object Creation</name>
    <shortMessage>
      Parsing method should be called directy instead.
    </shortMessage>
    <info>Parsing method should be called directy instead.</info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AddEmptyString</id>
    <artifact tool="PMD" mnemonic="AddEmptyString"/>
    <name>Add Empty String</name>
    <shortMessage>
      Finds empty string literals which are being added. This is
      an inefficient way to convert any type to a String.
    </shortMessage>
    <info>
      Finds empty string literals which are being added. This is
      an inefficient way to convert any type to a String.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidCatchingThrowable</id>
    <artifact tool="PMD" mnemonic="AvoidCatchingThrowable"/>
    <name>Avoid Catching Throwable</name>
    <shortMessage>
      This is dangerous because it casts too wide a net; it can
      catch things like OutOfMemoryError.
    </shortMessage>
    <info>
      This is dangerous because it casts too wide a net; it can
      catch things like OutOfMemoryError.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>SignatureDeclareThrowsException</id>
    <artifact tool="PMD" mnemonic="SignatureDeclareThrowsException"/>
    <name>Signature Declare Throws Exception</name>
    <shortMessage>
      It is unclear which exceptions that can be thrown from the
      methods. It might be difficult to document and understand
      the vague interfaces. Use either a class derived from
      RuntimeException or a checked exception.
    </shortMessage>
    <info>
      It is unclear which exceptions that can be thrown from the
      methods. It might be difficult to document and understand
      the vague interfaces. Use either a class derived from
      RuntimeException or a checked exception.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ExceptionAsFlowControl</id>
    <artifact tool="PMD" mnemonic="ExceptionAsFlowControl"/>
    <name>Exception As Flow Control</name>
    <shortMessage>
      Using Exceptions as flow control leads to GOTOish code and
      obscures true exceptions when debugging.
    </shortMessage>
    <info>
      Using Exceptions as flow control leads to GOTOish code and
      obscures true exceptions when debugging.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidCatchingNPE</id>
    <artifact tool="PMD" mnemonic="AvoidCatchingNPE"/>
    <name>Avoid Catching NullPointerException</name>
    <shortMessage>
      Code should never throw NPE under normal circumstances. A
      catch block may hide the original error, causing other more
      subtle errors in its wake.
    </shortMessage>
    <info>
      Code should never throw NPE under normal circumstances. A
      catch block may hide the original error, causing other more
      subtle errors in its wake.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidThrowingRawExceptionTypes</id>
    <artifact tool="PMD" mnemonic="AvoidThrowingRawExceptionTypes"/>
    <name>Avoid Throwing Raw Exception Types</name>
    <shortMessage>
      Avoid throwing certain exception types. Rather than throw a
      raw RuntimeException, Throwable, Exception, or Error, use a
      subclassed exception or error instead.
    </shortMessage>
    <info>
      Avoid throwing certain exception types. Rather than throw a
      raw RuntimeException, Throwable, Exception, or Error, use a
      subclassed exception or error instead.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidThrowingNullPointerException</id>
    <artifact tool="PMD" mnemonic="AvoidThrowingNullPointerException"/>
    <name>Avoid Throwing NullPointerException</name>
    <shortMessage>
      Avoid throwing a NullPointerException - it's confusing
      because most people will assume that the virtual machine
      threw it. Consider using an IllegalArgumentException
      instead; this will be clearly seen as a programmer-initiated
      exception.
    </shortMessage>
    <info>
      Avoid throwing a NullPointerException - it's confusing
      because most people will assume that the virtual machine
      threw it. Consider using an IllegalArgumentException
      instead; this will be clearly seen as a programmer-initiated
      exception.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidRethrowingException</id>
    <artifact tool="PMD" mnemonic="AvoidRethrowingException"/>
    <name>Avoid Rethrowing Exception</name>
    <shortMessage>
      Catch blocks that merely rethrow a caught exception only add
      to code size and runtime complexity.
    </shortMessage>
    <info>
      Catch blocks that merely rethrow a caught exception only add
      to code size and runtime complexity.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DoNotExtendJavaLangError</id>
    <artifact tool="PMD" mnemonic="DoNotExtendJavaLangError"/>
    <name>Do Not Extend java.lang.Error</name>
    <shortMessage>
      Errors are system exceptions. Do not extend them.
    </shortMessage>
    <info>Errors are system exceptions. Do not extend them.</info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidDuplicateLiterals</id>
    <artifact tool="PMD" mnemonic="AvoidDuplicateLiterals"/>
    <name>Avoid Duplicate Literals</name>
    <shortMessage>
      Code containing duplicate String literals can usually be
      improved by declaring the String as a constant field.
    </shortMessage>
    <info>
      Code containing duplicate String literals can usually be
      improved by declaring the String as a constant field.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>InefficientStringBuffering</id>
    <artifact tool="PMD" mnemonic="InefficientStringBuffering"/>
    <name>Inefficient String Buffering</name>
    <shortMessage>
      Avoid concatenating non literals in a StringBuffer
      constructor or append().
    </shortMessage>
    <info>
      Avoid concatenating non literals in a StringBuffer
      constructor or append().
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UnnecessaryCaseChange</id>
    <artifact tool="PMD" mnemonic="UnnecessaryCaseChange"/>
    <name>Unnecessary Case Change</name>
    <shortMessage>
      Using equalsIgnoreCase() is faster than using
      toUpperCase/toLowerCase().equals()
    </shortMessage>
    <info>
      Using equalsIgnoreCase() is faster than using
      toUpperCase/toLowerCase().equals()
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UseStringBufferLength</id>
    <artifact tool="PMD" mnemonic="UseStringBufferLength"/>
    <name>Use String Buffer Length</name>
    <shortMessage>
      Use StringBuffer.length() to determine StringBuffer length
      rather than using
      StringBuffer.toString().equals(&quot;&quot;) or
      StringBuffer.toString().length() ==.
    </shortMessage>
    <info>
      Use StringBuffer.length() to determine StringBuffer length
      rather than using
      StringBuffer.toString().equals(&quot;&quot;) or
      StringBuffer.toString().length() ==.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AppendCharacterWithChar</id>
    <artifact tool="PMD" mnemonic="AppendCharacterWithChar"/>
    <name>Append Character With Char</name>
    <shortMessage>
      Avoid concatenating characters as strings in
      StringBuffer.append.
    </shortMessage>
    <info>
      Avoid concatenating characters as strings in
      StringBuffer.append.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ConsecutiveLiteralAppends</id>
    <artifact tool="PMD" mnemonic="ConsecutiveLiteralAppends"/>
    <name>Consecutive Literal Appends</name>
    <shortMessage>
      Consecutively calling StringBuffer.append with String
      literals
    </shortMessage>
    <info>
      Consecutively calling StringBuffer.append with String
      literals
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UseIndexOfChar</id>
    <artifact tool="PMD" mnemonic="UseIndexOfChar"/>
    <name>Use Index Of Char</name>
    <shortMessage>
      Use String.indexOf(char) when checking for the index of a
      single character; it executes faster.
    </shortMessage>
    <info>
      Use String.indexOf(char) when checking for the index of a
      single character; it executes faster.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>InefficientEmptyStringCheck</id>
    <artifact tool="PMD" mnemonic="InefficientEmptyStringCheck"/>
    <name>Inefficient Empty String Check</name>
    <shortMessage>
      String.trim().length() is an inefficient way to check if a
      String is really empty, as it creates a new String object
      just to check its size. Consider creating a static function
      that loops through a string, checking
      Character.isWhitespace() on each character and returning
      false if a non-whitespace character is found.
    </shortMessage>
    <info>
      String.trim().length() is an inefficient way to check if a
      String is really empty, as it creates a new String object
      just to check its size. Consider creating a static function
      that loops through a string, checking
      Character.isWhitespace() on each character and returning
      false if a non-whitespace character is found.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>InsufficientStringBufferDeclaration</id>
    <artifact tool="PMD" mnemonic="InsufficientStringBufferDeclaration"/>
    <name>Insufficient String Buffer Declaration</name>
    <shortMessage>
      Failing to pre-size a StringBuffer properly could cause it
      to re-size many times during runtime. This rule checks the
      characters that are actually passed into
      StringBuffer.append(), but represents a best guess
      &quot;worst case&quot; scenario. An empty StringBuffer
      constructor initializes the object to 16 characters. This
      default is assumed if the length of the constructor can not
      be determined.
    </shortMessage>
    <info>
      Failing to pre-size a StringBuffer properly could cause it
      to re-size many times during runtime. This rule checks the
      characters that are actually passed into
      StringBuffer.append(), but represents a best guess
      &quot;worst case&quot; scenario. An empty StringBuffer
      constructor initializes the object to 16 characters. This
      default is assumed if the length of the constructor can not
      be determined.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UselessStringValueOf</id>
    <artifact tool="PMD" mnemonic="UselessStringValueOf"/>
    <name>Useless String.valueOf</name>
    <shortMessage>
      No need to call String.valueOf to append to a string; just
      use the valueOf() argument directly.
    </shortMessage>
    <info>
      No need to call String.valueOf to append to a string; just
      use the valueOf() argument directly.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>StringBufferInstantiationWithChar</id>
    <artifact tool="PMD" mnemonic="StringBufferInstantiationWithChar"/>
    <name>String Buffer Instantiation With Char</name>
    <shortMessage>
      StringBuffer sb = new StringBuffer('c'); The char will be
      converted into int to intialize StringBuffer size.
    </shortMessage>
    <info>
      StringBuffer sb = new StringBuffer('c'); The char will be
      converted into int to intialize StringBuffer size.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ArrayIsStoredDirectly</id>
    <artifact tool="PMD" mnemonic="ArrayIsStoredDirectly"/>
    <name>Array Is Stored Directly</name>
    <shortMessage>
      Constructors and methods receiving arrays should clone
      objects and store the copy. This prevents that future
      changes from the user affect the internal functionality.
    </shortMessage>
    <info>
      Constructors and methods receiving arrays should clone
      objects and store the copy. This prevents that future
      changes from the user affect the internal functionality.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UnusedLocalVariable</id>
    <artifact tool="PMD" mnemonic="UnusedLocalVariable"/>
    <name>Unused Local Variable</name>
    <shortMessage>
      Detects when a local variable is declared and/or assigned,
      but not used.
    </shortMessage>
    <info>
      Detects when a local variable is declared and/or assigned,
      but not used.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UnusedPrivateMethod</id>
    <artifact tool="PMD" mnemonic="UnusedPrivateMethod"/>
    <name>Unused Private Method</name>
    <shortMessage>
      Unused Private Method detects when a private method is
      declared but is unused.
    </shortMessage>
    <info>
      Unused Private Method detects when a private method is
      declared but is unused.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>UnusedFormalParameter</id>
    <artifact tool="PMD" mnemonic="UnusedFormalParameter"/>
    <name>Unused Formal Parameter</name>
    <shortMessage>
      Avoid passing parameters to methods or constructors and then
      not using those parameters.
    </shortMessage>
    <info>
      Avoid passing parameters to methods or constructors and then
      not using those parameters.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>OverrideBothEqualsAndHashcode</id>
    <artifact tool="PMD" mnemonic="OverrideBothEqualsAndHashcode"/>
    <name>Override Both Equals And Hashcode</name>
    <shortMessage>
      Override both public boolean Object.equals(Object other),
      and public int Object.hashCode(), or override neither. Even
      if you are inheriting a hashCode() from a parent class,
      consider implementing hashCode and explicitly delegating to
      your superclass.
    </shortMessage>
    <info>
      Override both public boolean Object.equals(Object other),
      and public int Object.hashCode(), or override neither. Even
      if you are inheriting a hashCode() from a parent class,
      consider implementing hashCode and explicitly delegating to
      your superclass.
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidUsingHardCodedIP</id>
    <artifact tool="PMD" mnemonic="AvoidUsingHardCodedIP"/>
    <name>Avoid Using Hardcoded IP Addresses</name>
    <shortMessage>Avoid using hard-coded IP address</shortMessage>
    <info>

      &lt;p&gt; An application with hard coded IP may become impossible to deploy in some cases. 
      It never hurts to externalize IP addresses. &lt;/p&gt;
      
      &lt;p&gt; . &lt;/p&gt;

    </info>
  </findingType>	
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>CheckResultSet</id>
    <artifact tool="PMD" mnemonic="CheckResultSet"/>
    <name>Check Return Values from ResultSet Methods</name>
    <shortMessage>Check the return values from methods on ResultSet</shortMessage>
    <info> &lt;p&gt; Always check the return value from calling 
    ResultSet.{next,previous,first,last}.  If the return value is 'false', 
    the developer should deal with it. &lt;/p&gt;
    </info>
  </findingType>		
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidFinalLocalVariable</id>
    <artifact tool="PMD" mnemonic="AvoidFinalLocalVariable"/>
    <name>Avoid Final Local Variables</name>
    <shortMessage>
      Avoid using final local variables 
    </shortMessage>
    <info>

      &lt;p&gt; Instead, use fields. &lt;/p&gt;

    </info>
  </findingType>	
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidUsingShortType</id>
    <artifact tool="PMD" mnemonic="AvoidUsingShortType"/>
    <name>Avoid using short type</name>
    <shortMessage>
      Avoid using the "short" type
    </shortMessage>
    <info>
<![CDATA[<p>Java uses the <code>short</code> type to reduce memory
usage, not to optimize calculation. On the contrary, the JVM does not
has any arithmetic capabilities with the <code>short</code> type, so
it must convert the <code>short</code> into <code>int</code>, then do
the proper calculation and then convert int back to short. Therefore,
use of the <code>short</code> type may actually be slower than using
<code>int</code>.</p>

<pre>
public class UsingShort {
  private short doNotUseShort = 0;

  public UsingShort() {
    short shouldNotBeUsed = 1;
    doNotUseShort += shouldNotBeUsed;
  }
}
</pre>]]>
    </info>
  </findingType>	
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidUsingVolatile</id>
    <artifact tool="PMD" mnemonic="AvoidUsingVolatile"/>
    <name>Avoid using volatile fields</name>
    <shortMessage>Avoid using volatile fields.</shortMessage>
    <info>
<![CDATA[<p>The <code>volatile</code> keyword is generally used to
fine tune a concurrent Java application, and therefore, requires a
expert knowledge of the Java Memory Model.  Moreover, it is often
misused. Therefore, consider carefully if this use of the
<code>volatile</code> keyword is correct.</p>

<p>It is also recommended to consider if the use of one of the atomic
classes from util.concurrent is a better implementation
choice.  For example, the below code</p>
<pre>
public class ThrDeux {
  private volatile int counter = 1;
  private volatile String var = "Hi";
}
</pre>

<p>could be changed to</p>

<pre>
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;

public class ThrDeux {
  private final AtomicInteger counter = new AtomicInteger(1);
  private final AtomicReference<String> var = new AtomicReference<String>("Hi");
}
</pre>]]>
    </info>
  </findingType>	
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidUsingNativeCode</id>
    <artifact tool="PMD" mnemonic="AvoidUsingNativeCode"/>
    <name>Avoid using native code (JNI)</name>
    <shortMessage>Avoid using native code. Try to reimplement so that JNI is not needed.</shortMessage>
    <info>
<![CDATA[<p>The Java language allows for a wide range of
functionality, so it should be very rare to have to rely on non-Java
code, and in particular, on the Java Native Interface (JNI).  Since
the use of JNI makes an application less portable, and harder to
maintain, it is not recommended.</p>]]>
    </info>
  </findingType>	
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidAccessibilityAlteration</id>
    <artifact tool="PMD" mnemonic="AvoidAccessibilityAlteration"/>
    <name>Avoid changing class/method accessibility at runtime</name>
    <shortMessage>Avoid changing class/method accessibility at runtime.</shortMessage>
    <info>
<![CDATA[<p>Methods in <code>java.lang.reflect</code>, such as
<code>getDeclaredConstructors()</code>, <code>getDeclaredConstructor(Class[])</code> and
<code>setAccessible()</code>, allow someone to alter, at runtime, the accessibility
of fields, classes, or methods, even if they are declared to be <code>private</code>.</p>

<pre>
import java.lang.reflect.AccessibleObject;
import java.lang.reflect.Method;
import java.security.PrivilegedAction;

public class Violation {
  public void invalidCallsInMethod() throws SecurityException, NoSuchMethodException {
    // Possible call to forbidden getDeclaredConstructors
    Class[] arrayOfClass = new Class[1];
    this.getClass().getDeclaredConstructors();
    this.getClass().getDeclaredConstructor(arrayOfClass);
    Class clazz = this.getClass();
    clazz.getDeclaredConstructor(arrayOfClass);
    clazz.getDeclaredConstructors();

    // Possible call to forbidden setAccessible
    clazz.getMethod("", arrayOfClass).setAccessible(false);
    AccessibleObject.setAccessible(null, false);
    Method.setAccessible(null, false);
    Method[] methodsArray = clazz.getMethods();
    int nbMethod;
    for ( nbMethod = 0; nbMethod < methodsArray.length; nbMethod++ ) {
      methodsArray[nbMethod].setAccessible(false);
    }

    // Possible call to forbidden PrivilegedAction
    PrivilegedAction priv = (PrivilegedAction) new Object(); priv.run();
  }
}
</pre>

<p>There are legitimate specialized uses of these methods, but
observer caution that a security risk is not being introduced into
your system if their use is allowed.</p>]]>
    </info>
  </findingType>	
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>ClassWithOnlyPrivateConstructorsShouldBeFinal</id>
    <artifact tool="PMD" mnemonic="ClassWithOnlyPrivateConstructorsShouldBeFinal"/>
    <name>Class with only private constructors should be final</name>
    <shortMessage>A class which only has private constructors should be declared final.</shortMessage>
    <info>
<![CDATA[<p>A class with only private constructors should be final,
unless the private constructor is called by a inner class.  The code below</p>

<pre>
public class Foo {
  private Foo() { ... }
  // no other constructors or inner classes
  ...
}
</pre>

<p>could be changed to</p>

<pre>
public final class Foo {
  private Foo() { ... }
  // no other constructors or inner classes
  ...
}
</pre>]]>
    </info>
  </findingType>	
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>EmptyMethodInAbstractClassShouldBeAbstract</id>
    <artifact tool="PMD"
	      mnemonic="EmptyMethodInAbstractClassShouldBeAbstract">
    </artifact>
    <name>Empty method in abstract class should be abstract</name>
    <shortMessage>Consider if an empty method in an abstract class should be abstract.</shortMessage>
    <info>
<![CDATA[<p>An empty method in an abstract class should instead be
abstract, as developer may rely on this empty implementation, rather
than code an appropriate one.  The code below</p>

<pre>
public abstract class ShouldBeAbstract {
  public Object couldBeAbstract() {
    return null;
  }
  public void couldBeAbstractToo() {
  }
}
</pre>

<p>could be changed to</p>

<pre>
public abstract class ShouldBeAbstract {
  public abstract Object couldBeAbstract();
  public abstract void couldBeAbstractToo();
}
</pre>

<p>One exception to this rule of thumb is if the class is providing a
reasonable default behavior that is to do nothing.</p>]]>
    </info>
  </findingType>	
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>TooManyStaticImports</id>
    <artifact tool="PMD" mnemonic="TooManyStaticImports"/>
    <name>Too many static imports</name>
    <shortMessage>Too many static imports may lead to unmaintainable code.</shortMessage>
    <info>
<![CDATA[<p>If you overuse the static import feature it can make your
program unreadable and unmaintainable.  This feature pollutes the
namespace with all the imported static members.  Readers of your code
(including you, a few months after you wrote it) will not know which
class a static member comes from (Sun 1.5 Language Guide).</p>

<pre>
import static Lennon;
import static Ringo;
import static George;
import static Paul;
import static Yoko; // Too much !
</pre>]]>
    </info>
  </findingType>	
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>StaticEJBFieldShouldBeFinal</id>
    <artifact tool="PMD" mnemonic="StaticEJBFieldShouldBeFinal"/>
    <name>Static EJB fields should be final</name>
    <shortMessage>EJB's shouldn't have non-final static fields.  This can cause bugs when the container distributes the application across several JREs.</shortMessage>
    <info>
<![CDATA[<p>According to the J2EE specification (reference section
21.1.2 of the EJB 3.0 Specification), an EJB should not have any
static fields with write access. However, static read-only fields are
allowed.  This ensures proper behavior, especially when instances are
distributed by the container across several JREs.</p>]]>
    </info>
  </findingType>	
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DoNotUseThreads</id>
    <artifact tool="PMD" mnemonic="DoNotUseThreads"/>
    <name>Do not use threads in a J2EE web application</name>
    <shortMessage>To be J2EE-compliant, a web application should not use any threads.</shortMessage>
    <info>
<![CDATA[<p>The J2EE specification explicitly forbids the use of
threads within a container-based application (reference section 21.1.2
of the EJB 3.0 Specification)</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidMultipleUnaryOperators</id>
    <artifact tool="PMD" mnemonic="AvoidMultipleUnaryOperators">
    </artifact>
    <name>Avoid using multiple unary operators</name>
    <shortMessage>Avoid using multiple unary operators to make your code clearer.</shortMessage>
    <info>
<![CDATA[<p>Using multiple unary operators may be a bug.  It can also
be confusing.  Check that the usage is not a bug and consider
simplifying the expression.</p>

<pre>
// These are typo bugs, or at best needlessly complex and confusing:
int i = - -1;
int j = + - +1;
int z = ~~2;
boolean b = !!true;
boolean c = !!!true;

// These are better:
int i = 1;
int j = -1;
int z = 2;
boolean b = true;
boolean c = false;

// And these just make your brain hurt:
int i = ~-2;
int j = -~7;
</pre>]]>
    </info>
  </findingType>	
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>TooManyMethods</id>
    <artifact tool="PMD" mnemonic="TooManyMethods"/>
    <name>Avoid classes with too many methods</name>
    <shortMessage>A class with too many methods may indicate poor object-oriented design.</shortMessage>
    <info>
<![CDATA[<p>A class with too many methods is probably a good prospect
for refactoring in order to reduce its complexity and find a way to
have more fine grained objects.</p>]]>
    </info>
  </findingType>		
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AbstractClassWithoutAnyMethod</id>
    <artifact tool="PMD" mnemonic="AbstractClassWithoutAnyMethod"/>
    <name>No abstract methods in an abstract class</name>
    <shortMessage>No abstract methods in abstract class, consider other approaches to prevent instantiation.</shortMessage>
    <info>
<![CDATA[<p>If the abstract class does not provides any methods, it
may be just a data container that is not to be instantiated. In this
case, it's probably better to use a private or a protected constructor
in order to prevent instantiation than make the class misleadingly
abstract.</p>

<pre>
public abstract class Foo {
  void int method1() { ... }
  void int method2() { ... }
  // consider using abstract methods or removing
  // the abstract modifier and adding protected constructors
}
</pre>]]>
    </info>
  </findingType>				
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>TooFewBranchesForASwitchStatement</id>
    <artifact tool="PMD" mnemonic="TooFewBranchesForASwitchStatement"/>
    <name>Avoid switch statements with only a few branches</name>
    <shortMessage>Avoid switch statements with only a few branches. Use an if statement instead.</shortMessage>
    <info>
<![CDATA[<p>Switch statements are designed complex branches, and allow
branches to share treatment. Using a <code>switch</code> for only two
branches is ill advised, as switches are not as easy to understand as
<code>if</code> statements.</p>

<pre>
public void bar() {
  switch (condition) {
  case ONE:
    // do something
    break;
  default:
    // do something
    break; // not enough for a 'switch', a simple 'if' would be more appropriate
  }
}
</pre>

<p>In this case, it's most likely is a good idea to use a
<code>if</code> statement instead, at least to increase code
readability.</p>]]>
    </info>
  </findingType>					  	
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>DoNotThrowExceptionInFinally</id>
    <artifact tool="PMD" mnemonic="DoNotThrowExceptionInFinally"/>
    <name>Avoid throwing exceptions in finally clauses</name>
    <shortMessage>Avoid throwing exceptions in finally clauses. It is confusing and may mask exceptions or code defects.</shortMessage>
    <info>
<![CDATA[<p>Throwing exceptions in a finally block is confusing.  It
may mask exceptions or a code defect.  Further, it may render code
cleanup unstable.</p>

<pre>
public void bar() {
  try {
    // Here do some stuff
  } catch( Exception e) {
    // Handling the issue
  } finally {
    // is this really a good idea ?
    throw new Exception();
  }
}
</pre>

<p>It is highly recommended to redesign the implementation of this
code.</p>]]>
    </info>
  </findingType>				  	
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
  <findingType>
    <id>AvoidStringBufferField</id>
    <artifact tool="PMD" mnemonic="AvoidStringBufferField"/>
    <name>Avoid StringBuffer-typed fields</name>
    <shortMessage>Avoid keeping StringBuffer objects as a field.</shortMessage>
    <info>
<![CDATA[<p><code>StringBuffer</code> objects can grow quite a lot,
and can become a source of memory leaks (if the owning class has a
long life time).</p>]]>
    </info>
  </findingType>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
</findingTypes>
